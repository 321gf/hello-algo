{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Hello Algo <p>Data Structures and Algorithms Crash Course with Animated Illustrations and Off-the-Shelf Code</p> <p> </p> <p>        Dive In           Clone Repo           Get PDF    </p> <p> </p> <p>The English edition is brewing...</p> <p>Feel free to engage in Chinese-to-English translation and pull request review! For guidelines, please see #914.</p> Endorsements <p>Quote</p> <p>\"An easy-to-understand book on data structures and algorithms, which guides readers to learn by minds-on and hands-on. Strongly recommended for algorithm beginners!\"</p> <p>\u2014\u2014 Junhui Deng, Professor of Computer Science, Tsinghua University</p> <p>Quote</p> <p>\"If I had 'Hello Algo' when I was learning data structures and algorithms, it would have been 10 times easier!\"</p> <p>\u2014\u2014 Mu Li, Senior Principal Scientist, Amazon</p> Animated illustrations <p>Easy to understandSmooth learning curve</p> <p>\"A picture is worth a thousand words.\"</p> Off-the-Shelf Code <p>Multi programming languagesRun with one click</p> <p>\"Talk is cheap. Show me the code.\"</p> Learning Together <p>Discussion and questions welcomeReaders progress together</p> <p>\"Chase the wind and moon, never stopping\"</p> <p>\"Beyond the plains, there are spring mountains\"</p>  Preface  <p>Two years ago, I shared the \"Sword Offer\" series of problem solutions on LeetCode, which received much love and support from many students. During my interactions with readers, the most common question I encountered was \"How to get started with algorithms.\" Gradually, I developed a deep interest in this question.</p> <p>Blindly solving problems seems to be the most popular method, being simple, direct, and effective. However, problem-solving is like playing a \"Minesweeper\" game, where students with strong self-learning abilities can successfully clear the mines one by one, but those with insufficient foundations may end up bruised from explosions, retreating step by step in frustration. Thoroughly reading textbooks is also common, but for students aiming for job applications, the energy consumed by graduation, resume submissions, and preparing for written tests and interviews makes tackling thick books a daunting challenge.</p> <p>If you are facing similar troubles, then you are lucky to have found this book. This book is my answer to this question, not necessarily the best solution, but at least an active attempt. Although this book won't directly land you an Offer, it will guide you through the \"knowledge map\" of data structures and algorithms, help you understand the shape, size, and distribution of different \"mines,\" and equip you with various \"demining methods.\" With these skills, I believe you can more comfortably solve problems and read literature, gradually building a complete knowledge system.</p> <p>I deeply agree with Professor Feynman's saying: \"Knowledge isn't free. You have to pay attention.\" In this sense, this book is not entirely \"free.\" To not disappoint the precious \"attention\" you pay to this book, I will do my utmost, investing the greatest \"attention\" to complete the creation of this book.</p>  Author  <p>Yudong Jin(Krahets), Senior Algorithm Engineer in a top tech company, Master's degree from Shanghai Jiao Tong University. The highest-read blogger across the entire LeetCode, his published \"Illustration of Algorithm Data Structures\" has been subscribed to by over 300k.</p>  Contribution  <p>This book is continuously improved with the joint efforts of many contributors from the open-source community. Thanks to each writer who invested their time and energy, listed in the order generated by GitHub:</p> <p> </p> <p>The code review work for this book was completed by codingonion, Gonglja, gvenusleo, hpstory, justin\u2010tse, krahets, night-cruise, nuomi1, and Reanon (listed in alphabetical order). Thanks to them for their time and effort, ensuring the standardization and uniformity of the code in various languages.</p> <sub>codingonion</sub><sub>Rust, Zig</sub> <sub>Gonglja</sub><sub>C, C++</sub> <sub>gvenusleo</sub><sub>Dart</sub> <sub>hpstory</sub><sub>C#</sub> <sub>justin-tse</sub><sub>JS, TS</sub> <sub>krahets</sub><sub>Java, Python</sub> <sub>night-cruise</sub><sub>Rust</sub> <sub>nuomi1</sub><sub>Swift</sub> <sub>Reanon</sub><sub>Go, C</sub>"},{"location":"chapter_array_and_linkedlist/","title":"Chapter 4. \u00a0 Arrays and Linked Lists","text":"<p>Abstract</p> <p>The world of data structures is like a solid brick wall.</p> <p>The bricks of an array are neatly arranged, each closely connected to the next. In contrast, the bricks of a linked list are scattered, with vines of connections freely weaving through the gaps between bricks.</p>"},{"location":"chapter_array_and_linkedlist/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>4.1 \u00a0 Array</li> <li>4.2 \u00a0 Linked List</li> <li>4.3 \u00a0 List</li> <li>4.4 \u00a0 Memory and Cache</li> <li>4.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/","title":"4.1 \u00a0 Arrays","text":"<p>The \"array\" is a linear data structure that stores elements of the same type in contiguous memory locations. We refer to the position of an element in the array as its \"index\". The following image illustrates the main terminology and concepts of an array.</p> <p></p> <p> Figure 4-1 \u00a0 Array Definition and Storage Method </p>"},{"location":"chapter_array_and_linkedlist/array/#411-common-operations-on-arrays","title":"4.1.1 \u00a0 Common Operations on Arrays","text":""},{"location":"chapter_array_and_linkedlist/array/#1-initializing-arrays","title":"1. \u00a0 Initializing Arrays","text":"<p>There are two ways to initialize arrays depending on the requirements: without initial values and with given initial values. In cases where initial values are not specified, most programming languages will initialize the array elements to \\(0\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code># Initialize array\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> array.cpp<pre><code>/* Initialize array */\n// Stored on stack\nint arr[5];\nint nums[5] = { 1, 3, 2, 5, 4 };\n// Stored on heap (manual memory release needed)\nint* arr1 = new int[5];\nint* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n</code></pre> array.java<pre><code>/* Initialize array */\nint[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\nint[] nums = { 1, 3, 2, 5, 4 };\n</code></pre> array.cs<pre><code>/* Initialize array */\nint[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]\nint[] nums = [1, 3, 2, 5, 4];\n</code></pre> array.go<pre><code>/* Initialize array */\nvar arr [5]int\n// In Go, specifying the length ([5]int) denotes an array, while not specifying it ([]int) denotes a slice.\n// Since Go's arrays are designed to have compile-time fixed length, only constants can be used to specify the length.\n// For convenience in implementing the extend() method, the Slice will be considered as an Array here.\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> array.swift<pre><code>/* Initialize array */\nlet arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\nlet nums = [1, 3, 2, 5, 4]\n</code></pre> array.js<pre><code>/* Initialize array */\nvar arr = new Array(5).fill(0);\nvar nums = [1, 3, 2, 5, 4];\n</code></pre> array.ts<pre><code>/* Initialize array */\nlet arr: number[] = new Array(5).fill(0);\nlet nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> array.dart<pre><code>/* Initialize array */\nList&lt;int&gt; arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> array.rs<pre><code>/* Initialize array */\nlet arr: Vec&lt;i32&gt; = vec![0; 5]; // [0, 0, 0, 0, 0]\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> array.c<pre><code>/* Initialize array */\nint arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\nint nums[5] = { 1, 3, 2, 5, 4 };\n</code></pre> array.zig<pre><code>// Initialize array\nvar arr = [_]i32{0} ** 5; // { 0, 0, 0, 0, 0 }\nvar nums = [_]i32{ 1, 3, 2, 5, 4 };\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#2-accessing-elements","title":"2. \u00a0 Accessing Elements","text":"<p>Elements in an array are stored in contiguous memory locations, which makes it easy to compute the memory address of any element. Given the memory address of the array (the address of the first element) and the index of an element, we can calculate the memory address of that element using the formula shown in the following image, allowing direct access to the element.</p> <p></p> <p> Figure 4-2 \u00a0 Memory Address Calculation for Array Elements </p> <p>As observed in the above image, the index of the first element of an array is \\(0\\), which may seem counterintuitive since counting starts from \\(1\\). However, from the perspective of the address calculation formula, an index is essentially an offset from the memory address. The offset for the first element's address is \\(0\\), making its index \\(0\\) logical.</p> <p>Accessing elements in an array is highly efficient, allowing us to randomly access any element in \\(O(1)\\) time.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def random_access(nums: list[int]) -&gt; int:\n    \"\"\"\u968f\u673a\u8bbf\u95ee\u5143\u7d20\"\"\"\n    # \u5728\u533a\u95f4 [0, len(nums)-1] \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    random_index = random.randint(0, len(nums) - 1)\n    # \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    random_num = nums[random_index]\n    return random_num\n</code></pre> array.cpp<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int *nums, int size) {\n    // \u5728\u533a\u95f4 [0, size) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = rand() % size;\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.java<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int[] nums) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = ThreadLocalRandom.current().nextInt(0, nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.cs<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint RandomAccess(int[] nums) {\n    Random random = new();\n    // \u5728\u533a\u95f4 [0, nums.Length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = random.Next(nums.Length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.go<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunc randomAccess(nums []int) (randomNum int) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    randomIndex := rand.Intn(len(nums))\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    randomNum = nums[randomIndex]\n    return\n}\n</code></pre> array.swift<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunc randomAccess(nums: [Int]) -&gt; Int {\n    // \u5728\u533a\u95f4 [0, nums.count) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    let randomIndex = nums.indices.randomElement()!\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    let randomNum = nums[randomIndex]\n    return randomNum\n}\n</code></pre> array.js<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunction randomAccess(nums) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    const random_index = Math.floor(Math.random() * nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.ts<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunction randomAccess(nums: number[]): number {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    const random_index = Math.floor(Math.random() * nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.dart<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(List&lt;int&gt; nums) {\n  // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n  int randomIndex = Random().nextInt(nums.length);\n  // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n  int randomNum = nums[randomIndex];\n  return randomNum;\n}\n</code></pre> array.rs<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfn random_access(nums: &amp;[i32]) -&gt; i32 {\n    // \u5728\u533a\u95f4 [0, nums.len()) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    let random_index = rand::thread_rng().gen_range(0..nums.len());\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    let random_num = nums[random_index];\n    random_num\n}\n</code></pre> array.c<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int *nums, int size) {\n    // \u5728\u533a\u95f4 [0, size) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = rand() % size;\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.zig<pre><code>// \u968f\u673a\u8bbf\u95ee\u5143\u7d20\nfn randomAccess(nums: []i32) i32 {\n    // \u5728\u533a\u95f4 [0, nums.len) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6574\u6570\n    var randomIndex = std.crypto.random.intRangeLessThan(usize, 0, nums.len);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    var randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#3-inserting-elements","title":"3. \u00a0 Inserting Elements","text":"<p>As shown in the image below, to insert an element in the middle of an array, all elements following the insertion point must be moved one position back to make room for the new element.</p> <p></p> <p> Figure 4-3 \u00a0 Array Element Insertion Example </p> <p>It's important to note that since the length of an array is fixed, inserting an element will inevitably lead to the loss of the last element in the array. We will discuss solutions to this problem in the \"List\" chapter.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def insert(nums: list[int], num: int, index: int):\n    \"\"\"\u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num\"\"\"\n    # \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in range(len(nums) - 1, index, -1):\n        nums[i] = nums[i - 1]\n    # \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n</code></pre> array.cpp<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int *nums, int size, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.java<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int[] nums, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.cs<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid Insert(int[] nums, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = nums.Length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.go<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunc insert(nums []int, num int, index int) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i := len(nums) - 1; i &gt; index; i-- {\n        nums[i] = nums[i-1]\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n}\n</code></pre> array.swift<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunc insert(nums: inout [Int], num: Int, index: Int) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in nums.indices.dropFirst(index).reversed() {\n        nums[i] = nums[i - 1]\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n}\n</code></pre> array.js<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunction insert(nums, num, index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.ts<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunction insert(nums: number[], num: number, index: number): void {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.dart<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 _num */\nvoid insert(List&lt;int&gt; nums, int _num, int index) {\n  // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n  for (var i = nums.length - 1; i &gt; index; i--) {\n    nums[i] = nums[i - 1];\n  }\n  // \u5c06 _num \u8d4b\u7ed9 index \u5904\u5143\u7d20\n  nums[index] = _num;\n}\n</code></pre> array.rs<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfn insert(nums: &amp;mut Vec&lt;i32&gt;, num: i32, index: usize) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in (index + 1..nums.len()).rev() {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.c<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int *nums, int size, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.zig<pre><code>// \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num\nfn insert(nums: []i32, num: i32, index: usize) void {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    var i = nums.len - 1;\n    while (i &gt; index) : (i -= 1) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#4-deleting-elements","title":"4. \u00a0 Deleting Elements","text":"<p>Similarly, as illustrated below, to delete an element at index \\(i\\), all elements following index \\(i\\) must be moved forward by one position.</p> <p></p> <p> Figure 4-4 \u00a0 Array Element Deletion Example </p> <p>Note that after deletion, the last element becomes \"meaningless\", so we do not need to specifically modify it.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def remove(nums: list[int], index: int):\n    \"\"\"\u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20\"\"\"\n    # \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in range(index, len(nums) - 1):\n        nums[i] = nums[i + 1]\n</code></pre> array.cpp<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(int *nums, int size, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.java<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(int[] nums, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.cs<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid Remove(int[] nums, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; nums.Length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.go<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunc remove(nums []int, index int) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i := index; i &lt; len(nums)-1; i++ {\n        nums[i] = nums[i+1]\n    }\n}\n</code></pre> array.swift<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunc remove(nums: inout [Int], index: Int) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in nums.indices.dropFirst(index).dropLast() {\n        nums[i] = nums[i + 1]\n    }\n}\n</code></pre> array.js<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunction remove(nums, index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.ts<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunction remove(nums: number[], index: number): void {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.dart<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(List&lt;int&gt; nums, int index) {\n  // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n  for (var i = index; i &lt; nums.length - 1; i++) {\n    nums[i] = nums[i + 1];\n  }\n}\n</code></pre> array.rs<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfn remove(nums: &amp;mut Vec&lt;i32&gt;, index: usize) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in index..nums.len() - 1 {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.c<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nvoid removeItem(int *nums, int size, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.zig<pre><code>// \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20\nfn remove(nums: []i32, index: usize) void {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    var i = index;\n    while (i &lt; nums.len - 1) : (i += 1) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> <p>Overall, the insertion and deletion operations in arrays have the following disadvantages:</p> <ul> <li>High Time Complexity: Both insertion and deletion in an array have an average time complexity of \\(O(n)\\), where \\(n\\) is the length of the array.</li> <li>Loss of Elements: Due to the fixed length of arrays, elements that exceed the array's capacity are lost during insertion.</li> <li>Waste of Memory: We can initialize a longer array and use only the front part, allowing the \"lost\" end elements during insertion to be \"meaningless\", but this leads to some wasted memory space.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#5-traversing-arrays","title":"5. \u00a0 Traversing Arrays","text":"<p>In most programming languages, we can traverse an array either by indices or by directly iterating over each element:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def traverse(nums: list[int]):\n    \"\"\"\u904d\u5386\u6570\u7ec4\"\"\"\n    count = 0\n    # \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in range(len(nums)):\n        count += nums[i]\n    # \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums:\n        count += num\n    # \u540c\u65f6\u904d\u5386\u6570\u636e\u7d22\u5f15\u548c\u5143\u7d20\n    for i, num in enumerate(nums):\n        count += nums[i]\n        count += num\n</code></pre> array.cpp<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.java<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int[] nums) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (int num : nums) {\n        count += num;\n    }\n}\n</code></pre> array.cs<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid Traverse(int[] nums) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; nums.Length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    foreach (int num in nums) {\n        count += num;\n    }\n}\n</code></pre> array.go<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunc traverse(nums []int) {\n    count := 0\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i := 0; i &lt; len(nums); i++ {\n        count += nums[i]\n    }\n    count = 0\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for _, num := range nums {\n        count += num\n    }\n    // \u540c\u65f6\u904d\u5386\u6570\u636e\u7d22\u5f15\u548c\u5143\u7d20\n    for i, num := range nums {\n        count += nums[i]\n        count += num\n    }\n}\n</code></pre> array.swift<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunc traverse(nums: [Int]) {\n    var count = 0\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in nums.indices {\n        count += nums[i]\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums {\n        count += num\n    }\n}\n</code></pre> array.js<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunction traverse(nums) {\n    let count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.ts<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunction traverse(nums: number[]): void {\n    let count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.dart<pre><code>/* \u904d\u5386\u6570\u7ec4\u5143\u7d20 */\nvoid traverse(List&lt;int&gt; nums) {\n  int count = 0;\n  // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n  for (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n  }\n  // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n  for (int _num in nums) {\n    count += _num;\n  }\n  // \u901a\u8fc7 forEach \u65b9\u6cd5\u904d\u5386\u6570\u7ec4\n  nums.forEach((_num) {\n    count += _num;\n  });\n}\n</code></pre> array.rs<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfn traverse(nums: &amp;[i32]) {\n    let mut _count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in 0..nums.len() {\n        _count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums {\n        _count += num;\n    }\n}\n</code></pre> array.c<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.zig<pre><code>// \u904d\u5386\u6570\u7ec4\nfn traverse(nums: []i32) void {\n    var count: i32 = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    var i: i32 = 0;\n    while (i &lt; nums.len) : (i += 1) {\n        count += nums[i];\n    }\n    count = 0;\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (nums) |num| {\n        count += num;\n    }\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#6-finding-elements","title":"6. \u00a0 Finding Elements","text":"<p>To find a specific element in an array, we need to iterate through it, checking each element to see if it matches.</p> <p>Since arrays are linear data structures, this operation is known as \"linear search\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def find(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20\"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1\n</code></pre> array.cpp<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.java<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.cs<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint Find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.go<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunc find(nums []int, target int) (index int) {\n    index = -1\n    for i := 0; i &lt; len(nums); i++ {\n        if nums[i] == target {\n            index = i\n            break\n        }\n    }\n    return\n}\n</code></pre> array.swift<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunc find(nums: [Int], target: Int) -&gt; Int {\n    for i in nums.indices {\n        if nums[i] == target {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> array.js<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunction find(nums, target) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) return i;\n    }\n    return -1;\n}\n</code></pre> array.ts<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunction find(nums: number[], target: number): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> array.dart<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(List&lt;int&gt; nums, int target) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    if (nums[i] == target) return i;\n  }\n  return -1;\n}\n</code></pre> array.rs<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfn find(nums: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        if nums[i] == target {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> array.c<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.zig<pre><code>// \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20\nfn find(nums: []i32, target: i32) i32 {\n    for (nums, 0..) |num, i| {\n        if (num == target) return @intCast(i);\n    }\n    return -1;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#7-expanding-arrays","title":"7. \u00a0 Expanding Arrays","text":"<p>In complex system environments, it's challenging to ensure that the memory space following an array is available, making it unsafe to extend the array's capacity. Therefore, in most programming languages, the length of an array is immutable.</p> <p>To expand an array, we need to create a larger array and then copy the elements from the original array. This operation has a time complexity of \\(O(n)\\) and can be time-consuming for large arrays. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig array.py<pre><code>def extend(nums: list[int], enlarge: int) -&gt; list[int]:\n    \"\"\"\u6269\u5c55\u6570\u7ec4\u957f\u5ea6\"\"\"\n    # \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    res = [0] * (len(nums) + enlarge)\n    # \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i in range(len(nums)):\n        res[i] = nums[i]\n    # \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n</code></pre> array.cpp<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint *extend(int *nums, int size, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int *res = new int[size + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // \u91ca\u653e\u5185\u5b58\n    delete[] nums;\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.java<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint[] extend(int[] nums, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int[] res = new int[nums.length + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.cs<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint[] Extend(int[] nums, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int[] res = new int[nums.Length + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; nums.Length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.go<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfunc extend(nums []int, enlarge int) []int {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    res := make([]int, len(nums)+enlarge)\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i, num := range nums {\n        res[i] = num\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n}\n</code></pre> array.swift<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfunc extend(nums: [Int], enlarge: Int) -&gt; [Int] {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    var res = Array(repeating: 0, count: nums.count + enlarge)\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i in nums.indices {\n        res[i] = nums[i]\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n}\n</code></pre> array.js<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\n// \u8bf7\u6ce8\u610f\uff0cJavaScript \u7684 Array \u662f\u52a8\u6001\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u6269\u5c55\n// \u4e3a\u4e86\u65b9\u4fbf\u5b66\u4e60\uff0c\u672c\u51fd\u6570\u5c06 Array \u770b\u4f5c\u957f\u5ea6\u4e0d\u53ef\u53d8\u7684\u6570\u7ec4\nfunction extend(nums, enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    const res = new Array(nums.length + enlarge).fill(0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.ts<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\n// \u8bf7\u6ce8\u610f\uff0cTypeScript \u7684 Array \u662f\u52a8\u6001\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u6269\u5c55\n// \u4e3a\u4e86\u65b9\u4fbf\u5b66\u4e60\uff0c\u672c\u51fd\u6570\u5c06 Array \u770b\u4f5c\u957f\u5ea6\u4e0d\u53ef\u53d8\u7684\u6570\u7ec4\nfunction extend(nums: number[], enlarge: number): number[] {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    const res = new Array(nums.length + enlarge).fill(0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.dart<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nList&lt;int&gt; extend(List&lt;int&gt; nums, int enlarge) {\n  // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n  List&lt;int&gt; res = List.filled(nums.length + enlarge, 0);\n  // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n  for (var i = 0; i &lt; nums.length; i++) {\n    res[i] = nums[i];\n  }\n  // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n  return res;\n}\n</code></pre> array.rs<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfn extend(nums: Vec&lt;i32&gt;, enlarge: usize) -&gt; Vec&lt;i32&gt; {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    let mut res: Vec&lt;i32&gt; = vec![0; nums.len() + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\n    for i in 0..nums.len() {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    res\n}\n</code></pre> array.c<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint *extend(int *nums, int size, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int *res = (int *)malloc(sizeof(int) * (size + enlarge));\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // \u521d\u59cb\u5316\u6269\u5c55\u540e\u7684\u7a7a\u95f4\n    for (int i = size; i &lt; size + enlarge; i++) {\n        res[i] = 0;\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.zig<pre><code>// \u6269\u5c55\u6570\u7ec4\u957f\u5ea6\nfn extend(mem_allocator: std.mem.Allocator, nums: []i32, enlarge: usize) ![]i32 {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    var res = try mem_allocator.alloc(i32, nums.len + enlarge);\n    @memset(res, 0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    std.mem.copy(i32, res, nums);\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#412-advantages-and-limitations-of-arrays","title":"4.1.2 \u00a0 Advantages and Limitations of Arrays","text":"<p>Arrays are stored in contiguous memory spaces and consist of elements of the same type. This approach includes a wealth of prior information that the system can use to optimize the operation efficiency of the data structure.</p> <ul> <li>High Space Efficiency: Arrays allocate a contiguous block of memory for data, eliminating the need for additional structural overhead.</li> <li>Support for Random Access: Arrays allow \\(O(1)\\) time access to any element.</li> <li>Cache Locality: When accessing array elements, the computer not only loads them but also caches the surrounding data, leveraging high-speed cache to improve the speed of subsequent operations.</li> </ul> <p>However, continuous space storage is a double-edged sword, with the following limitations:</p> <ul> <li>Low Efficiency in Insertion and Deletion: When there are many elements in an array, insertion and deletion operations require moving a large number of elements.</li> <li>Fixed Length: The length of an array is fixed after initialization. Expanding an array requires copying all data to a new array, which is costly.</li> <li>Space Wastage: If the allocated size of an array exceeds the actual need, the extra space is wasted.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#413-typical-applications-of-arrays","title":"4.1.3 \u00a0 Typical Applications of Arrays","text":"<p>Arrays are a fundamental and common data structure, frequently used in various algorithms and in implementing complex data structures.</p> <ul> <li>Random Access: If we want to randomly sample some data, we can use an array for storage and generate a random sequence to implement random sampling based on indices.</li> <li>Sorting and Searching: Arrays are the most commonly used data structure for sorting and searching algorithms. Quick sort, merge sort, binary search, etc., are primarily conducted on arrays.</li> <li>Lookup Tables: Arrays can be used as lookup tables for fast element or relationship retrieval. For instance, if we want to implement a mapping from characters to ASCII codes, we can use the ASCII code value of a character as the index, with the corresponding element stored in the corresponding position in the array.</li> <li>Machine Learning: Arrays are extensively used in neural networks for linear algebra operations between vectors, matrices, and tensors. Arrays are the most commonly used data structure in neural network programming.</li> <li>Data Structure Implementation: Arrays can be used to implement stacks, queues, hash tables, heaps, graphs, etc. For example, the adjacency matrix representation of a graph is essentially a two-dimensional array.</li> </ul>"},{"location":"chapter_array_and_linkedlist/linked_list/","title":"4.2 \u00a0 Linked Lists","text":"<p>Memory space is a common resource for all programs. In a complex system environment, free memory space can be scattered throughout memory. We know that the memory space for storing an array must be contiguous, and when the array is very large, it may not be possible to provide such a large contiguous space. This is where the flexibility advantage of linked lists becomes apparent.</p> <p>A \"linked list\" is a linear data structure where each element is a node object, and the nodes are connected via \"references\". A reference records the memory address of the next node, allowing access to the next node from the current one.</p> <p>The design of a linked list allows its nodes to be scattered throughout memory, with no need for contiguous memory addresses.</p> <p></p> <p> Figure 4-5 \u00a0 Linked List Definition and Storage Method </p> <p>Observing the image above, the fundamental unit of a linked list is the \"node\" object. Each node contains two pieces of data: the \"value\" of the node and the \"reference\" to the next node.</p> <ul> <li>The first node of a linked list is known as the \"head node\", and the last one is called the \"tail node\".</li> <li>The tail node points to \"null\", which is represented as <code>null</code> in Java, <code>nullptr</code> in C++, and <code>None</code> in Python.</li> <li>In languages that support pointers, like C, C++, Go, and Rust, the aforementioned \"reference\" should be replaced with a \"pointer\".</li> </ul> <p>As shown in the following code, a linked list node <code>ListNode</code>, apart from containing a value, also needs to store a reference (pointer). Therefore, a linked list consumes more memory space than an array for the same amount of data.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>class ListNode:\n    \"\"\"Linked List Node Class\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val               # Node value\n        self.next: ListNode | None = None # Reference to the next node\n</code></pre> <pre><code>/* Linked List Node Structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the next node\n    ListNode(int x) : val(x), next(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Linked List Node Class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Linked List Node Class */\nclass ListNode(int x) {  // Constructor\n    int val = x;         // Node value\n    ListNode? next;      // Reference to the next node\n}\n</code></pre> <pre><code>/* Linked List Node Structure */\ntype ListNode struct {\n    Val  int       // Node value\n    Next *ListNode // Pointer to the next node\n}\n\n// NewListNode Constructor, creates a new linked list\nfunc NewListNode(val int) *ListNode {\n    return &amp;ListNode{\n        Val:  val,\n        Next: nil,\n    }\n}\n</code></pre> <pre><code>/* Linked List Node Class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the next node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Linked List Node Class */\nclass ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);       // Node value\n        this.next = (next === undefined ? null : next); // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* Linked List Node Class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = val === undefined ? 0 : val;        // Node value\n        this.next = next === undefined ? null : next;  // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* \u94fe\u8868\u8282\u70b9\u7c7b */\nclass ListNode {\n  int val; // Node value\n  ListNode? next; // Reference to the next node\n  ListNode(this.val, [this.next]); // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n/* Linked List Node Class */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to the next node\n}\n</code></pre> <pre><code>/* Linked List Node Structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the next node\n} ListNode;\n\n/* Constructor */\nListNode *newListNode(int val) {\n    ListNode *node;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    return node;\n}\n</code></pre> <pre><code>// Linked List Node Class\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Node value\n        next: ?*Self = null, // Pointer to the next node\n\n        // Constructor\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n        }\n    };\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#421-common-operations-on-linked-lists","title":"4.2.1 \u00a0 Common Operations on Linked Lists","text":""},{"location":"chapter_array_and_linkedlist/linked_list/#1-initializing-a-linked-list","title":"1. \u00a0 Initializing a Linked List","text":"<p>Building a linked list involves two steps: initializing each node object and then establishing the references between nodes. Once initialized, we can access all nodes sequentially from the head node via the <code>next</code> reference.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig linked_list.py<pre><code># Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4\n# Initialize each node\nn0 = ListNode(1)\nn1 = ListNode(3)\nn2 = ListNode(2)\nn3 = ListNode(5)\nn4 = ListNode(4)\n# Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.cpp<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = new ListNode(1);\nListNode* n1 = new ListNode(3);\nListNode* n2 = new ListNode(2);\nListNode* n3 = new ListNode(5);\nListNode* n4 = new ListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.java<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new ListNode(1);\nListNode n1 = new ListNode(3);\nListNode n2 = new ListNode(2);\nListNode n3 = new ListNode(5);\nListNode n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.cs<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new(1);\nListNode n1 = new(3);\nListNode n2 = new(2);\nListNode n3 = new(5);\nListNode n4 = new(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.go<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nn0 := NewListNode(1)\nn1 := NewListNode(3)\nn2 := NewListNode(2)\nn3 := NewListNode(5)\nn4 := NewListNode(4)\n// Build references between nodes\nn0.Next = n1\nn1.Next = n2\nn2.Next = n3\nn3.Next = n4\n</code></pre> linked_list.swift<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = ListNode(x: 1)\nlet n1 = ListNode(x: 3)\nlet n2 = ListNode(x: 2)\nlet n3 = ListNode(x: 5)\nlet n4 = ListNode(x: 4)\n// Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.js<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.ts<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.dart<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = ListNode(1);\nListNode n1 = ListNode(3);\nListNode n2 = ListNode(2);\nListNode n3 = ListNode(5);\nListNode n4 = ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.rs<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = Rc::new(RefCell::new(ListNode { val: 1, next: None }));\nlet n1 = Rc::new(RefCell::new(ListNode { val: 3, next: None }));\nlet n2 = Rc::new(RefCell::new(ListNode { val: 2, next: None }));\nlet n3 = Rc::new(RefCell::new(ListNode { val: 5, next: None }));\nlet n4 = Rc::new(RefCell::new(ListNode { val: 4, next: None }));\n\n// Build references between nodes\nn0.borrow_mut().next = Some(n1.clone());\nn1.borrow_mut().next = Some(n2.clone());\nn2.borrow_mut().next = Some(n3.clone());\nn3.borrow_mut().next = Some(n4.clone());\n</code></pre> linked_list.c<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = newListNode(1);\nListNode* n1 = newListNode(3);\nListNode* n2 = newListNode(2);\nListNode* n3 = newListNode(5);\nListNode* n4 = newListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.zig<pre><code>// Initialize linked list\n// Initialize each node\nvar n0 = inc.ListNode(i32){.val = 1};\nvar n1 = inc.ListNode(i32){.val = 3};\nvar n2 = inc.ListNode(i32){.val = 2};\nvar n3 = inc.ListNode(i32){.val = 5};\nvar n4 = inc.ListNode(i32){.val = 4};\n// Build references between nodes\nn0.next = &amp;n1;\nn1.next = &amp;n2;\nn2.next = &amp;n3;\nn3.next = &amp;n4;\n</code></pre> <p>An array is a single variable, such as the array <code>nums</code> containing elements <code>nums[0]</code>, <code>nums[1]</code>, etc., while a linked list is composed of multiple independent node objects. We usually refer to the linked list by its head node, as in the linked list <code>n0</code> in the above code.</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#2-inserting-a-node","title":"2. \u00a0 Inserting a Node","text":"<p>Inserting a node in a linked list is very easy. As shown in the image below, suppose we want to insert a new node <code>P</code> between two adjacent nodes <code>n0</code> and <code>n1</code>. This requires changing only two node references (pointers), with a time complexity of \\(O(1)\\).</p> <p>In contrast, the time complexity of inserting an element in an array is \\(O(n)\\), which is less efficient with large data volumes.</p> <p></p> <p> Figure 4-6 \u00a0 Linked List Node Insertion Example </p> PythonC++JavaC#GoSwiftJSTSDartRustCZig linked_list.py<pre><code>def insert(n0: ListNode, P: ListNode):\n    \"\"\"\u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P\"\"\"\n    n1 = n0.next\n    P.next = n1\n    n0.next = P\n</code></pre> linked_list.cpp<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.java<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode n0, ListNode P) {\n    ListNode n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid Insert(ListNode n0, ListNode P) {\n    ListNode? n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.go<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunc insertNode(n0 *ListNode, P *ListNode) {\n    n1 := n0.Next\n    P.Next = n1\n    n0.Next = P\n}\n</code></pre> linked_list.swift<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunc insert(n0: ListNode, P: ListNode) {\n    let n1 = n0.next\n    P.next = n1\n    n0.next = P\n}\n</code></pre> linked_list.js<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunction insert(n0, P) {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunction insert(n0: ListNode, P: ListNode): void {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode n0, ListNode P) {\n  ListNode? n1 = n0.next;\n  P.next = n1;\n  n0.next = P;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\n#[allow(non_snake_case)]\npub fn insert&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, P: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    let n1 =  n0.borrow_mut().next.take();\n    P.borrow_mut().next = n1;\n    n0.borrow_mut().next = Some(P);\n}\n</code></pre> linked_list.c<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.zig<pre><code>// \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P\nfn insert(n0: ?*inc.ListNode(i32), P: ?*inc.ListNode(i32)) void {\n    var n1 = n0.?.next;\n    P.?.next = n1;\n    n0.?.next = P;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#3-deleting-a-node","title":"3. \u00a0 Deleting a Node","text":"<p>As shown below, deleting a node in a linked list is also very convenient, requiring only the change of one node's reference (pointer).</p> <p>Note that although node <code>P</code> still points to <code>n1</code> after the deletion operation is completed, it is no longer accessible when traversing the list, meaning <code>P</code> is no longer part of the list.</p> <p></p> <p> Figure 4-7 \u00a0 Linked List Node Deletion </p> PythonC++JavaC#GoSwiftJSTSDartRustCZig linked_list.py<pre><code>def remove(n0: ListNode):\n    \"\"\"\u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9\"\"\"\n    if not n0.next:\n        return\n    # n0 -&gt; P -&gt; n1\n    P = n0.next\n    n1 = P.next\n    n0.next = n1\n</code></pre> linked_list.cpp<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode *n0) {\n    if (n0-&gt;next == nullptr)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // \u91ca\u653e\u5185\u5b58\n    delete P;\n}\n</code></pre> linked_list.java<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid Remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode? n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.go<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunc removeItem(n0 *ListNode) {\n    if n0.Next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    P := n0.Next\n    n1 := P.Next\n    n0.Next = n1\n}\n</code></pre> linked_list.swift<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunc remove(n0: ListNode) {\n    if n0.next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    let P = n0.next\n    let n1 = P?.next\n    n0.next = n1\n    P?.next = nil\n}\n</code></pre> linked_list.js<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunction remove(n0) {\n    if (!n0.next) return;\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunction remove(n0: ListNode): void {\n    if (!n0.next) {\n        return;\n    }\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode n0) {\n  if (n0.next == null) return;\n  // n0 -&gt; P -&gt; n1\n  ListNode P = n0.next!;\n  ListNode? n1 = P.next;\n  n0.next = n1;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\n#[allow(non_snake_case)]\npub fn remove&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    if n0.borrow().next.is_none() {return};\n    // n0 -&gt; P -&gt; n1\n    let P = n0.borrow_mut().next.take();\n    if let Some(node) = P {\n        let n1 = node.borrow_mut().next.take();\n        n0.borrow_mut().next = n1;\n    }\n}\n</code></pre> linked_list.c<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nvoid removeItem(ListNode *n0) {\n    if (!n0-&gt;next)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // \u91ca\u653e\u5185\u5b58\n    free(P);\n}\n</code></pre> linked_list.zig<pre><code>// \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9\nfn remove(n0: ?*inc.ListNode(i32)) void {\n    if (n0.?.next == null) return;\n    // n0 -&gt; P -&gt; n1\n    var P = n0.?.next;\n    var n1 = P.?.next;\n    n0.?.next = n1;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#4-accessing-nodes","title":"4. \u00a0 Accessing Nodes","text":"<p>Accessing nodes in a linked list is less efficient. As mentioned earlier, any element in an array can be accessed in \\(O(1)\\) time. However, in a linked list, the program needs to start from the head node and traverse each node sequentially until it finds the target node. That is, accessing the \\(i\\)-th node of a linked list requires \\(i - 1\\) iterations, with a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig linked_list.py<pre><code>def access(head: ListNode, index: int) -&gt; ListNode | None:\n    \"\"\"\u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9\"\"\"\n    for _ in range(index):\n        if not head:\n            return None\n        head = head.next\n    return head\n</code></pre> linked_list.cpp<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == nullptr)\n            return nullptr;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.java<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode access(ListNode head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.cs<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode? Access(ListNode? head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.go<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunc access(head *ListNode, index int) *ListNode {\n    for i := 0; i &lt; index; i++ {\n        if head == nil {\n            return nil\n        }\n        head = head.Next\n    }\n    return head\n}\n</code></pre> linked_list.swift<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunc access(head: ListNode, index: Int) -&gt; ListNode? {\n    var head: ListNode? = head\n    for _ in 0 ..&lt; index {\n        if head == nil {\n            return nil\n        }\n        head = head?.next\n    }\n    return head\n}\n</code></pre> linked_list.js<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunction access(head, index) {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.ts<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunction access(head: ListNode | null, index: number): ListNode | null {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.dart<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode? access(ListNode? head, int index) {\n  for (var i = 0; i &lt; index; i++) {\n    if (head == null) return null;\n    head = head.next;\n  }\n  return head;\n}\n</code></pre> linked_list.rs<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\npub fn access&lt;T&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, index: i32) -&gt; Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt; {\n    if index &lt;= 0 {return head};\n    if let Some(node) = &amp;head.borrow_mut().next {\n        return access(node.clone(), index - 1);\n    }\n    return head;\n}\n</code></pre> linked_list.c<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == NULL)\n            return NULL;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.zig<pre><code>// \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9\nfn access(node: ?*inc.ListNode(i32), index: i32) ?*inc.ListNode(i32) {\n    var head = node;\n    var i: i32 = 0;\n    while (i &lt; index) : (i += 1) {\n        head = head.?.next;\n        if (head == null) return null;\n    }\n    return head;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#5-finding-nodes","title":"5. \u00a0 Finding Nodes","text":"<p>Traverse the linked list to find a node with a value equal to <code>target</code>, and output the index of that node in the linked list. This process also falls under linear search. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig linked_list.py<pre><code>def find(head: ListNode, target: int) -&gt; int:\n    \"\"\"\u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9\"\"\"\n    index = 0\n    while head:\n        if head.val == target:\n            return index\n        head = head.next\n        index += 1\n    return -1\n</code></pre> linked_list.cpp<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head != nullptr) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.java<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint Find(ListNode? head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.go<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunc findNode(head *ListNode, target int) int {\n    index := 0\n    for head != nil {\n        if head.Val == target {\n            return index\n        }\n        head = head.Next\n        index++\n    }\n    return -1\n}\n</code></pre> linked_list.swift<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunc find(head: ListNode, target: Int) -&gt; Int {\n    var head: ListNode? = head\n    var index = 0\n    while head != nil {\n        if head?.val == target {\n            return index\n        }\n        head = head?.next\n        index += 1\n    }\n    return -1\n}\n</code></pre> linked_list.js<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunction find(head, target) {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunction find(head: ListNode | null, target: number): number {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode? head, int target) {\n  int index = 0;\n  while (head != null) {\n    if (head.val == target) {\n      return index;\n    }\n    head = head.next;\n    index++;\n  }\n  return -1;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\npub fn find&lt;T: PartialEq&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, target: T, index: i32) -&gt; i32 {\n    if head.borrow().val == target {return index};\n    if let Some(node) = &amp;head.borrow_mut().next {\n        return find(node.clone(), target, index + 1);\n    }\n    return -1;\n}\n</code></pre> linked_list.c<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.zig<pre><code>// \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9\nfn find(node: ?*inc.ListNode(i32), target: i32) i32 {\n    var head = node;\n    var index: i32 = 0;\n    while (head != null) {\n        if (head.?.val == target) return index;\n        head = head.?.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#422-arrays-vs-linked-lists","title":"4.2.2 \u00a0 Arrays vs. Linked Lists","text":"<p>The following table summarizes the characteristics of arrays and linked lists and compares their operational efficiencies. Since they employ two opposite storage strategies, their properties and operational efficiencies also show contrasting features.</p> <p> Table 4-1 \u00a0 Efficiency Comparison of Arrays and Linked Lists </p> Arrays Linked Lists Storage Contiguous Memory Space Dispersed Memory Space Capacity Expansion Fixed Length Flexible Expansion Memory Efficiency Less Memory per Element, Potential Space Wastage More Memory per Element Accessing Elements \\(O(1)\\) \\(O(n)\\) Adding Elements \\(O(n)\\) \\(O(1)\\) Deleting Elements \\(O(n)\\) \\(O(1)\\)"},{"location":"chapter_array_and_linkedlist/linked_list/#423-common-types-of-linked-lists","title":"4.2.3 \u00a0 Common Types of Linked Lists","text":"<p>As shown in the following image, there are three common types of linked lists.</p> <ul> <li>Singly Linked List: This is the regular linked list introduced earlier. The nodes of a singly linked list contain the value and a reference to the next node. The first node is called the head node, and the last node, pointing to null (<code>None</code>), is the tail node.</li> <li>Circular Linked List: If the tail node of a singly linked list points back to the head node (forming a loop), it becomes a circular linked list. In a circular linked list, any node can be considered the head node.</li> <li>Doubly Linked List: Compared to a singly linked list, a doubly linked list stores references in two directions. Its nodes contain references to both the next (successor) and the previous (predecessor) nodes. Doubly linked lists are more flexible as they allow traversal in both directions but require more memory space.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>class ListNode:\n    \"\"\"Bidirectional linked list node class\"\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.next: ListNode | None = None  # Reference to the successor node\n        self.prev: ListNode | None = None  # Reference to a predecessor node\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the successor node\n    ListNode *prev;  // Pointer to the predecessor node\n    ListNode(int x) : val(x), next(nullptr), prev(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode(int x) {  // Constructor\n    int val = x;    // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n}\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\ntype DoublyListNode struct {\n    Val  int             // Node value\n    Next *DoublyListNode // Pointer to the successor node\n    Prev *DoublyListNode // Pointer to the predecessor node\n}\n\n// NewDoublyListNode initialization\nfunc NewDoublyListNode(val int) *DoublyListNode {\n    return &amp;DoublyListNode{\n        Val:  val,\n        Next: nil,\n        Prev: nil,\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the next node\n    var prev: ListNode? // Reference to the predecessor node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    constructor(val, next, prev) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    prev: ListNode | null;\n    constructor(val?: number, next?: ListNode | null, prev?: ListNode | null) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n    ListNode(this.val, [this.next, this.prev]);  // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Bidirectional linked list node type */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to successor node\n    prev: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to predecessor node\n}\n\n/* Constructors */\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode {\n            val,\n            next: None,\n            prev: None,\n        }\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the successor node\n    struct ListNode *prev; // Pointer to the predecessor node\n} ListNode;\n\n/* Constructors */\nListNode *newListNode(int val) {\n    ListNode *node, *next;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    node-&gt;prev = NULL;\n    return node;\n}\n</code></pre> <pre><code>// Bidirectional linked list node class\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Node value\n        next: ?*Self = null, // Pointer to the successor node\n        prev: ?*Self = null, // Pointer to the predecessor node\n\n        // Constructor\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n            self.prev = null;\n        }\n    };\n}\n</code></pre> <p></p> <p> Figure 4-8 \u00a0 Common Types of Linked Lists </p>"},{"location":"chapter_array_and_linkedlist/linked_list/#424-typical-applications-of-linked-lists","title":"4.2.4 \u00a0 Typical Applications of Linked Lists","text":"<p>Singly linked lists are commonly used to implement stacks, queues, hash tables, and graphs.</p> <ul> <li>Stacks and Queues: When insertion and deletion operations are performed at one end of the linked list, it exhibits last-in-first-out characteristics, corresponding to a stack. When insertion is at one end and deletion is at the other, it shows first-in-first-out characteristics, corresponding to a queue.</li> <li>Hash Tables: Chaining is one of the mainstream solutions to hash collisions, where all colliding elements are placed in a linked list.</li> <li>Graphs: Adjacency lists are a common way to represent graphs, where each vertex is associated with a linked list. Each element in the list represents other vertices connected to that vertex.</li> </ul> <p>Doubly linked lists are commonly used in scenarios that require quick access to the previous and next elements.</p> <ul> <li>Advanced Data Structures: For example, in red-black trees and B-trees, we need to access a node's parent, which can be achieved by storing a reference to the parent node in each node, similar to a doubly linked list.</li> <li>Browser History: In web browsers, when a user clicks the forward or backward button, the browser needs to know the previously and next visited web pages. The properties of a doubly linked list make this operation simple.</li> <li>LRU Algorithm: In Least Recently Used (LRU) cache eviction algorithms, we need to quickly find the least recently used data and support rapid addition and deletion of nodes. Here, using a doubly linked list is very appropriate.</li> </ul> <p>Circular linked lists are commonly used in scenarios requiring periodic operations, such as resource scheduling in operating systems.</p> <ul> <li>Round-Robin Scheduling Algorithm: In operating systems, the round-robin scheduling algorithm is a common CPU scheduling algorithm that cycles through a group of processes. Each process is assigned a time slice, and when it expires, the CPU switches to the next process. This circular operation can be implemented using a circular linked list.</li> <li>Data Buffers: Circular linked lists may also be used in some data buffer implementations. For instance, in audio and video players, the data stream might be divided into multiple buffer blocks placed in a circular linked list to achieve seamless playback.</li> </ul>"},{"location":"chapter_array_and_linkedlist/list/","title":"4.3 \u00a0 List","text":"<p>A \"list\" is an abstract data structure concept, representing an ordered collection of elements. It supports operations like element access, modification, addition, deletion, and traversal, without requiring users to consider capacity limitations. Lists can be implemented based on linked lists or arrays.</p> <ul> <li>A linked list naturally functions as a list, supporting operations for adding, deleting, searching, and modifying elements, and can dynamically adjust its size.</li> <li>Arrays also support these operations, but due to their fixed length, they can be considered as a list with a length limit.</li> </ul> <p>When using arrays to implement lists, the fixed length property reduces the practicality of the list. This is because we often cannot determine in advance how much data needs to be stored, making it difficult to choose an appropriate list length. If the length is too small, it may not meet the requirements; if too large, it may waste memory space.</p> <p>To solve this problem, we can use a \"dynamic array\" to implement lists. It inherits the advantages of arrays and can dynamically expand during program execution.</p> <p>In fact, many programming languages' standard libraries implement lists using dynamic arrays, such as Python's <code>list</code>, Java's <code>ArrayList</code>, C++'s <code>vector</code>, and C#'s <code>List</code>. In the following discussion, we will consider \"list\" and \"dynamic array\" as synonymous concepts.</p>"},{"location":"chapter_array_and_linkedlist/list/#431-common-list-operations","title":"4.3.1 \u00a0 Common List Operations","text":""},{"location":"chapter_array_and_linkedlist/list/#1-initializing-a-list","title":"1. \u00a0 Initializing a List","text":"<p>We typically use two methods of initialization: \"without initial values\" and \"with initial values\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Initialize list\n# Without initial values\nnums1: list[int] = []\n# With initial values\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> list.cpp<pre><code>/* Initialize list */\n// Note, in C++ the vector is the equivalent of nums described here\n// Without initial values\nvector&lt;int&gt; nums1;\n// With initial values\nvector&lt;int&gt; nums = { 1, 3, 2, 5, 4 };\n</code></pre> list.java<pre><code>/* Initialize list */\n// Without initial values\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();\n// With initial values (note the element type should be the wrapper class Integer[] for int[])\nInteger[] numbers = new Integer[] { 1, 3, 2, 5, 4 };\nList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(Arrays.asList(numbers));\n</code></pre> list.cs<pre><code>/* Initialize list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nint[] numbers = [1, 3, 2, 5, 4];\nList&lt;int&gt; nums = [.. numbers];\n</code></pre> list_test.go<pre><code>/* Initialize list */\n// Without initial values\nnums1 := []int{}\n// With initial values\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> list.swift<pre><code>/* Initialize list */\n// Without initial values\nlet nums1: [Int] = []\n// With initial values\nvar nums = [1, 3, 2, 5, 4]\n</code></pre> list.js<pre><code>/* Initialize list */\n// Without initial values\nconst nums1 = [];\n// With initial values\nconst nums = [1, 3, 2, 5, 4];\n</code></pre> list.ts<pre><code>/* Initialize list */\n// Without initial values\nconst nums1: number[] = [];\n// With initial values\nconst nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> list.dart<pre><code>/* Initialize list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> list.rs<pre><code>/* Initialize list */\n// Without initial values\nlet nums1: Vec&lt;i32&gt; = Vec::new();\n// With initial values\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Initialize list\nvar nums = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums.deinit();\ntry nums.appendSlice(&amp;[_]i32{ 1, 3, 2, 5, 4 });\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#2-accessing-elements","title":"2. \u00a0 Accessing Elements","text":"<p>Lists are essentially arrays, so accessing and updating elements can be done in \\(O(1)\\) time, which is very efficient.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Access elements\nnum: int = nums[1]  # Access the element at index 1\n\n# Update elements\nnums[1] = 0    # Update the element at index 1 to 0\n</code></pre> list.cpp<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.java<pre><code>/* Access elements */\nint num = nums.get(1);  // Access the element at index 1\n\n/* Update elements */\nnums.set(1, 0);  // Update the element at index 1 to 0\n</code></pre> list.cs<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list_test.go<pre><code>/* Access elements */\nnum := nums[1]  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0     // Update the element at index 1 to 0\n</code></pre> list.swift<pre><code>/* Access elements */\nlet num = nums[1] // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0 // Update the element at index 1 to 0\n</code></pre> list.js<pre><code>/* Access elements */\nconst num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.ts<pre><code>/* Access elements */\nconst num: number = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.dart<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.rs<pre><code>/* Access elements */\nlet num: i32 = nums[1];  // Access the element at index 1\n/* Update elements */\nnums[1] = 0;             // Update the element at index 1 to 0\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Access elements\nvar num = nums.items[1]; // Access the element at index 1\n\n// Update elements\nnums.items[1] = 0; // Update the element at index 1 to 0  \n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#3-inserting-and-deleting-elements","title":"3. \u00a0 Inserting and Deleting Elements","text":"<p>Compared to arrays, lists can freely add and remove elements. Adding elements at the end of the list has a time complexity of \\(O(1)\\), but the efficiency of inserting and deleting elements is still the same as in arrays, with a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Clear list\nnums.clear()\n\n# Append elements at the end\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n# Insert element in the middle\nnums.insert(3, 6)  # Insert number 6 at index 3\n\n# Remove elements\nnums.pop(3)        # Remove the element at index 3\n</code></pre> list.cpp<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.push_back(1);\nnums.push_back(3);\nnums.push_back(2);\nnums.push_back(5);\nnums.push_back(4);\n\n/* Insert element in the middle */\nnums.insert(nums.begin() + 3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.erase(nums.begin() + 3);      // Remove the element at index 3\n</code></pre> list.java<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert element in the middle */\nnums.add(3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(3);  // Remove the element at index 3\n</code></pre> list.cs<pre><code>/* Clear list */\nnums.Clear();\n\n/* Append elements at the end */\nnums.Add(1);\nnums.Add(3);\nnums.Add(2);\nnums.Add(5);\nnums.Add(4);\n\n/* Insert element in the middle */\nnums.Insert(3, 6);\n\n/* Remove elements */\nnums.RemoveAt(3);\n</code></pre> list_test.go<pre><code>/* Clear list */\nnums = nil\n\n/* Append elements at the end */\nnums = append(nums, 1)\nnums = append(nums, 3)\nnums = append(nums, 2)\nnums = append(nums, 5)\nnums = append(nums, 4)\n\n/* Insert element in the middle */\nnums = append(nums[:3], append([]int{6}, nums[3:]...)...) // Insert number 6 at index 3\n\n/* Remove elements */\nnums = append(nums[:3], nums[4:]...) // Remove the element at index 3\n</code></pre> list.swift<pre><code>/* Clear list */\nnums.removeAll()\n\n/* Append elements at the end */\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n/* Insert element in the middle */\nnums.insert(6, at: 3) // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(at: 3) // Remove the element at index 3\n</code></pre> list.js<pre><code>/* Clear list */\nnums.length = 0;\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.splice(3, 0, 6);\n\n/* Remove elements */\nnums.splice(3, 1);\n</code></pre> list.ts<pre><code>/* Clear list */\nnums.length = 0;\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.splice(3, 0, 6);\n\n/* Remove elements */\nnums.splice(3, 1);\n</code></pre> list.dart<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert element in the middle */\nnums.insert(3, 6); // Insert number 6 at index 3\n\n/* Remove elements */\nnums.removeAt(3); // Remove the element at index 3\n</code></pre> list.rs<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.insert(3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(3);    // Remove the element at index 3\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Clear list\nnums.clearRetainingCapacity();\n\n// Append elements at the end\ntry nums.append(1);\ntry nums.append(3);\ntry nums.append(2);\ntry nums.append(5);\ntry nums.append(4);\n\n// Insert element in the middle\ntry nums.insert(3, 6); // Insert number 6 at index 3\n\n// Remove elements\n_ = nums.orderedRemove(3); // Remove the element at index 3\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#4-traversing-the-list","title":"4. \u00a0 Traversing the List","text":"<p>Like arrays, lists can be traversed based on index, or by directly iterating over each element.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Iterate through the list by index\ncount = 0\nfor i in range(len(nums)):\n    count += nums[i]\n\n# Iterate directly through list elements\nfor num in nums:\n    count += num\n</code></pre> list.cpp<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.java<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums.get(i);\n}\n\n/* Iterate directly through list elements */\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.cs<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.Count; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nforeach (int num in nums) {\n    count += num;\n}\n</code></pre> list_test.go<pre><code>/* Iterate through the list by index */\ncount := 0\nfor i := 0; i &lt; len(nums); i++ {\n    count += nums[i]\n}\n\n/* Iterate directly through list elements */\ncount = 0\nfor _, num := range nums {\n    count += num\n}\n</code></pre> list.swift<pre><code>/* Iterate through the list by index */\nvar count = 0\nfor i in nums.indices {\n    count += nums[i]\n}\n\n/* Iterate directly through list elements */\ncount = 0\nfor num in nums {\n    count += num\n}\n</code></pre> list.js<pre><code>/* Iterate through the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.ts<pre><code>/* Iterate through the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.dart<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (var num in nums) {\n    count += num;\n}\n</code></pre> list.rs<pre><code>// Iterate through the list by index\nlet mut _count = 0;\nfor i in 0..nums.len() {\n    _count += nums[i];\n}\n\n// Iterate directly through list elements\n_count = 0;\nfor num in &amp;nums {\n    _count += num;\n}\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Iterate through the list by index\nvar count: i32 = 0;\nvar i: i32 = 0;\nwhile (i &lt; nums.items.len) : (i += 1) {\n    count += nums[i];\n}\n\n// Iterate directly through list elements\ncount = 0;\nfor (nums.items) |num| {\n    count += num;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#5-concatenating-lists","title":"5. \u00a0 Concatenating Lists","text":"<p>Given a new list <code>nums1</code>, we can append it to the end of the original list.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Concatenate two lists\nnums1: list[int] = [6, 8, 7, 10, 9]\nnums += nums1  # Concatenate nums1 to the end of nums\n</code></pre> list.cpp<pre><code>/* Concatenate two lists */\nvector&lt;int&gt; nums1 = { 6, 8, 7, 10, 9 };\n// Concatenate nums1 to the end of nums\nnums.insert(nums.end(), nums1.begin(), nums1.end());\n</code></pre> list.java<pre><code>/* Concatenate two lists */\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));\nnums.addAll(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.cs<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.AddRange(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list_test.go<pre><code>/* Concatenate two lists */\nnums1 := []int{6, 8, 7, 10, 9}\nnums = append(nums, nums1...)  // Concatenate nums1 to the end of nums\n</code></pre> list.swift<pre><code>/* Concatenate two lists */\nlet nums1 = [6, 8, 7, 10, 9]\nnums.append(contentsOf: nums1) // Concatenate nums1 to the end of nums\n</code></pre> list.js<pre><code>/* Concatenate two lists */\nconst nums1 = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.ts<pre><code>/* Concatenate two lists */\nconst nums1: number[] = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.dart<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.addAll(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.rs<pre><code>/* Concatenate two lists */\nlet nums1: Vec&lt;i32&gt; = vec![6, 8, 7, 10, 9];\nnums.extend(nums1);\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Concatenate two lists\nvar nums1 = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums1.deinit();\ntry nums1.appendSlice(&amp;[_]i32{ 6, 8, 7, 10, 9 });\ntry nums.insertSlice(nums.items.len, nums1.items); // Concatenate nums1 to the end of nums\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#6-sorting-the-list","title":"6. \u00a0 Sorting the List","text":"<p>After sorting the list, we can use algorithms often tested in array-related algorithm problems, such as \"binary search\" and \"two-pointer\" algorithms.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig list.py<pre><code># Sort the list\nnums.sort()  # After sorting, the list elements are in ascending order\n</code></pre> list.cpp<pre><code>/* Sort the list */\nsort(nums.begin(), nums.end());  // After sorting, the list elements are in ascending order\n</code></pre> list.java<pre><code>/* Sort the list */\nCollections.sort(nums);  // After sorting, the list elements are in ascending order\n</code></pre> list.cs<pre><code>/* Sort the list */\nnums.Sort(); // After sorting, the list elements are in ascending order\n</code></pre> list_test.go<pre><code>/* Sort the list */\nsort.Ints(nums)  // After sorting, the list elements are in ascending order\n</code></pre> list.swift<pre><code>/* Sort the list */\nnums.sort() // After sorting, the list elements are in ascending order\n</code></pre> list.js<pre><code>/* Sort the list */  \nnums.sort((a, b) =&gt; a - b);  // After sorting, the list elements are in ascending order\n</code></pre> list.ts<pre><code>/* Sort the list */\nnums.sort((a, b) =&gt; a - b);  // After sorting, the list elements are in ascending order\n</code></pre> list.dart<pre><code>/* Sort the list */\nnums.sort(); // After sorting, the list elements are in ascending order\n</code></pre> list.rs<pre><code>/* Sort the list */\nnums.sort(); // After sorting, the list elements are in ascending order\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.zig<pre><code>// Sort the list\nstd.sort.sort(i32, nums.items, {}, comptime std.sort.asc(i32));\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#432-list-implementation","title":"4.3.2 \u00a0 List Implementation","text":"<p>Many programming languages have built-in lists, such as Java, C++, Python, etc. Their implementations are quite complex, with very meticulous settings for parameters such as initial capacity and expansion multiplier. Interested readers can refer to the source code for learning.</p> <p>To deepen the understanding of how lists work, let's try implementing a simple version of a list, focusing on three key designs.</p> <ul> <li>Initial Capacity: Choose a reasonable initial capacity for the array. In this example, we choose 10 as the initial capacity.</li> <li>Size Recording: Declare a variable <code>size</code> to record the current number of elements in the list, updating in real-time with element insertion and deletion. With this variable, we can locate the end of the list and determine whether expansion is needed.</li> <li>Expansion Mechanism: If the list's capacity is full when inserting an element, expansion is necessary. First, create a larger array based on the expansion multiplier, then move all elements of the current array to the new array. In this example, we define that each time the array will expand to twice its previous size.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCZig my_list.py<pre><code>class MyList:\n    \"\"\"\u5217\u8868\u7c7b\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._capacity: int = 10  # \u5217\u8868\u5bb9\u91cf\n        self._arr: list[int] = [0] * self._capacity  # \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        self._size: int = 0  # \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        self._extend_ratio: int = 2  # \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\"\"\"\n        return self._size\n\n    def capacity(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u5217\u8868\u5bb9\u91cf\"\"\"\n        return self._capacity\n\n    def get(self, index: int) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u5143\u7d20\"\"\"\n        # \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        return self._arr[index]\n\n    def set(self, num: int, index: int):\n        \"\"\"\u66f4\u65b0\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        self._arr[index] = num\n\n    def add(self, num: int):\n        \"\"\"\u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\"\"\"\n        # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size() == self.capacity():\n            self.extend_capacity()\n        self._arr[self._size] = num\n        self._size += 1\n\n    def insert(self, num: int, index: int):\n        \"\"\"\u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self._size == self.capacity():\n            self.extend_capacity()\n        # \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in range(self._size - 1, index - 1, -1):\n            self._arr[j + 1] = self._arr[j]\n        self._arr[index] = num\n        # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self._size += 1\n\n    def remove(self, index: int) -&gt; int:\n        \"\"\"\u5220\u9664\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        num = self._arr[index]\n        # \u7d22\u5f15 i \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in range(index, self._size - 1):\n            self._arr[j] = self._arr[j + 1]\n        # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self._size -= 1\n        # \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num\n\n    def extend_capacity(self):\n        \"\"\"\u5217\u8868\u6269\u5bb9\"\"\"\n        # \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 _extend_ratio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        self._arr = self._arr + [0] * self.capacity() * (self._extend_ratio - 1)\n        # \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        self._capacity = len(self._arr)\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u6709\u6548\u957f\u5ea6\u7684\u5217\u8868\"\"\"\n        return self._arr[: self._size]\n</code></pre> my_list.cpp<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n  private:\n    int *arr;             // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    int arrCapacity = 10; // \u5217\u8868\u5bb9\u91cf\n    int arrSize = 0;      // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    int extendRatio = 2;   // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* \u6790\u6784\u65b9\u6cd5 */\n    ~MyList() {\n        delete[] arr;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    int size() {\n        return arrSize;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    int capacity() {\n        return arrCapacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    int get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    void add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size() == capacity())\n            extendCapacity();\n        arr[size()] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size() == capacity())\n            extendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = size() - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    int remove(int index) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u7d22\u5f15 i \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; size() - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    void extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\n        int newCapacity = capacity() * extendRatio;\n        int *tmp = arr;\n        arr = new int[newCapacity];\n        // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        for (int i = 0; i &lt; size(); i++) {\n            arr[i] = tmp[i];\n        }\n        // \u91ca\u653e\u5185\u5b58\n        delete[] tmp;\n        arrCapacity = newCapacity;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a Vector \u7528\u4e8e\u6253\u5370 */\n    vector&lt;int&gt; toVector() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        vector&lt;int&gt; vec(size());\n        for (int i = 0; i &lt; size(); i++) {\n            vec[i] = arr[i];\n        }\n        return vec;\n    }\n};\n</code></pre> my_list.java<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private int[] arr; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private int capacity = 10; // \u5217\u8868\u5bb9\u91cf\n    private int size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private int extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public MyList() {\n        arr = new int[capacity];\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09 */\n    public int size() {\n        return size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public int capacity() {\n        return capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public int get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public void add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity();\n        arr[size] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = size - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public int remove(int index) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; size - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public void extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        arr = Arrays.copyOf(arr, capacity() * extendRatio);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        capacity = arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public int[] toArray() {\n        int size = size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] arr = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            arr[i] = get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.cs<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private int[] arr;           // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private int arrCapacity = 10;    // \u5217\u8868\u5bb9\u91cf\n    private int arrSize = 0;         // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private readonly int extendRatio = 2;  // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    public int Size() {\n        return arrSize;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public int Capacity() {\n        return arrCapacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public int Get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public void Set(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public void Add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        arr[arrSize] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public void Insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = arrSize - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public int Remove(int index) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; arrSize - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public void ExtendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a arrCapacity * extendRatio \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        Array.Resize(ref arr, arrCapacity * extendRatio);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        arrCapacity = arr.Length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public int[] ToArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] arr = new int[arrSize];\n        for (int i = 0; i &lt; arrSize; i++) {\n            arr[i] = Get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.go<pre><code>/* \u5217\u8868\u7c7b */\ntype myList struct {\n    arrCapacity int\n    arr         []int\n    arrSize     int\n    extendRatio int\n}\n\n/* \u6784\u9020\u51fd\u6570 */\nfunc newMyList() *myList {\n    return &amp;myList{\n        arrCapacity: 10,              // \u5217\u8868\u5bb9\u91cf\n        arr:         make([]int, 10), // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        arrSize:     0,               // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        extendRatio: 2,               // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n    }\n}\n\n/* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09 */\nfunc (l *myList) size() int {\n    return l.arrSize\n}\n\n/*  \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\nfunc (l *myList) capacity() int {\n    return l.arrCapacity\n}\n\n/* \u8bbf\u95ee\u5143\u7d20 */\nfunc (l *myList) get(index int) int {\n    // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    return l.arr[index]\n}\n\n/* \u66f4\u65b0\u5143\u7d20 */\nfunc (l *myList) set(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    l.arr[index] = num\n}\n\n/* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\nfunc (l *myList) add(num int) {\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    l.arr[l.arrSize] = num\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize++\n}\n\n/* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\nfunc (l *myList) insert(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for j := l.arrSize - 1; j &gt;= index; j-- {\n        l.arr[j+1] = l.arr[j]\n    }\n    l.arr[index] = num\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize++\n}\n\n/* \u5220\u9664\u5143\u7d20 */\nfunc (l *myList) remove(index int) int {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    num := l.arr[index]\n    // \u7d22\u5f15 i \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for j := index; j &lt; l.arrSize-1; j++ {\n        l.arr[j] = l.arr[j+1]\n    }\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize--\n    // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n    return num\n}\n\n/* \u5217\u8868\u6269\u5bb9 */\nfunc (l *myList) extendCapacity() {\n    // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    l.arr = append(l.arr, make([]int, l.arrCapacity*(l.extendRatio-1))...)\n    // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n    l.arrCapacity = len(l.arr)\n}\n\n/* \u8fd4\u56de\u6709\u6548\u957f\u5ea6\u7684\u5217\u8868 */\nfunc (l *myList) toArray() []int {\n    // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    return l.arr[:l.arrSize]\n}\n</code></pre> my_list.swift<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private var arr: [Int] // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private var _capacity = 10 // \u5217\u8868\u5bb9\u91cf\n    private var _size = 0 // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private let extendRatio = 2 // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init() {\n        arr = Array(repeating: 0, count: _capacity)\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    func capacity() -&gt; Int {\n        _capacity\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    func get(index: Int) -&gt; Int {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\u5219\u629b\u51fa\u9519\u8bef\uff0c\u4e0b\u540c\n        if index &lt; 0 || index &gt;= _size {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        return arr[index]\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    func set(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= _size {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        arr[index] = num\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    func add(num: Int) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if _size == _capacity {\n            extendCapacity()\n        }\n        arr[_size] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size += 1\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    func insert(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= _size {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if _size == _capacity {\n            extendCapacity()\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in sequence(first: _size - 1, next: { $0 &gt;= index + 1 ? $0 - 1 : nil }) {\n            arr[j + 1] = arr[j]\n        }\n        arr[index] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size += 1\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    @discardableResult\n    func remove(index: Int) -&gt; Int {\n        if index &lt; 0 || index &gt;= _size {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        let num = arr[index]\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in index ..&lt; (_size - 1) {\n            arr[j] = arr[j + 1]\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size -= 1\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    func extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        arr = arr + Array(repeating: 0, count: _capacity * (extendRatio - 1))\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        _capacity = arr.count\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    func toArray() -&gt; [Int] {\n        var arr = Array(repeating: 0, count: _size)\n        for i in 0 ..&lt; _size {\n            arr[i] = get(index: i)\n        }\n        return arr\n    }\n}\n</code></pre> my_list.js<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    #arr = new Array(); // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    #capacity = 10; // \u5217\u8868\u5bb9\u91cf\n    #size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    #extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.#arr = new Array(this.#capacity);\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    size() {\n        return this.#size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    capacity() {\n        return this.#capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    get(index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        return this.#arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    set(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        this.#arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    add(num) {\n        // \u5982\u679c\u957f\u5ea6\u7b49\u4e8e\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u6269\u5bb9\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u5217\u8868\u5c3e\u90e8\n        this.#arr[this.#size] = num;\n        this.#size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    insert(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (let j = this.#size - 1; j &gt;= index; j--) {\n            this.#arr[j + 1] = this.#arr[j];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.#arr[index] = num;\n        this.#size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    remove(index) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        let num = this.#arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (let j = index; j &lt; this.#size - 1; j++) {\n            this.#arr[j] = this.#arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.#size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        this.#arr = this.#arr.concat(\n            new Array(this.capacity() * (this.#extendRatio - 1))\n        );\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        this.#capacity = this.#arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    toArray() {\n        let size = this.size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.ts<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private arr: Array&lt;number&gt;; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private _capacity: number = 10; // \u5217\u8868\u5bb9\u91cf\n    private _size: number = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private extendRatio: number = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.arr = new Array(this._capacity);\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    public size(): number {\n        return this._size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public capacity(): number {\n        return this._capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public get(index: number): number {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        return this.arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public set(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        this.arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public add(num: number): void {\n        // \u5982\u679c\u957f\u5ea6\u7b49\u4e8e\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u6269\u5bb9\n        if (this._size === this._capacity) this.extendCapacity();\n        // \u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u5217\u8868\u5c3e\u90e8\n        this.arr[this._size] = num;\n        this._size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public insert(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (this._size === this._capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (let j = this._size - 1; j &gt;= index; j--) {\n            this.arr[j + 1] = this.arr[j];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.arr[index] = num;\n        this._size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public remove(index: number): number {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        let num = this.arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (let j = index; j &lt; this._size - 1; j++) {\n            this.arr[j] = this.arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this._size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public extendCapacity(): void {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a size \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        this.arr = this.arr.concat(\n            new Array(this.capacity() * (this.extendRatio - 1))\n        );\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        this._capacity = this.arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public toArray(): number[] {\n        let size = this.size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.dart<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n  late List&lt;int&gt; _arr; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n  int _capacity = 10; // \u5217\u8868\u5bb9\u91cf\n  int _size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n  int _extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  MyList() {\n    _arr = List.filled(_capacity, 0);\n  }\n\n  /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n  int size() =&gt; _size;\n\n  /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n  int capacity() =&gt; _capacity;\n\n  /* \u8bbf\u95ee\u5143\u7d20 */\n  int get(int index) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    return _arr[index];\n  }\n\n  /* \u66f4\u65b0\u5143\u7d20 */\n  void set(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    _arr[index] = _num;\n  }\n\n  /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n  void add(int _num) {\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (_size == _capacity) extendCapacity();\n    _arr[_size] = _num;\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size++;\n  }\n\n  /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n  void insert(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (_size == _capacity) extendCapacity();\n    // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (var j = _size - 1; j &gt;= index; j--) {\n      _arr[j + 1] = _arr[j];\n    }\n    _arr[index] = _num;\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size++;\n  }\n\n  /* \u5220\u9664\u5143\u7d20 */\n  int remove(int index) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    int _num = _arr[index];\n    // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (var j = index; j &lt; _size - 1; j++) {\n      _arr[j] = _arr[j + 1];\n    }\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size--;\n    // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n    return _num;\n  }\n\n  /* \u5217\u8868\u6269\u5bb9 */\n  void extendCapacity() {\n    // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 _extendRatio \u500d\u7684\u65b0\u6570\u7ec4\n    final _newNums = List.filled(_capacity * _extendRatio, 0);\n    // \u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    List.copyRange(_newNums, 0, _arr);\n    // \u66f4\u65b0 _arr \u7684\u5f15\u7528\n    _arr = _newNums;\n    // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n    _capacity = _arr.length;\n  }\n\n  /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n  List&lt;int&gt; toArray() {\n    List&lt;int&gt; arr = [];\n    for (var i = 0; i &lt; _size; i++) {\n      arr.add(get(i));\n    }\n    return arr;\n  }\n}\n</code></pre> my_list.rs<pre><code>/* \u5217\u8868\u7c7b */\n#[allow(dead_code)]\nstruct MyList {\n    arr: Vec&lt;i32&gt;,       // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    capacity: usize,      // \u5217\u8868\u5bb9\u91cf\n    size: usize,          // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    extend_ratio: usize,  // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n}\n\n#[allow(unused,unused_comparisons)]\nimpl MyList {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    pub fn new(capacity: usize) -&gt; Self {\n        let mut vec = Vec::new(); \n        vec.resize(capacity, 0);\n        Self {\n            arr: vec,\n            capacity,\n            size: 0,\n            extend_ratio: 2,\n        }\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    pub fn size(&amp;self) -&gt; usize {\n        return self.size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    pub fn capacity(&amp;self) -&gt; usize {\n        return self.capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    pub fn get(&amp;self, index: usize) -&gt; i32 {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if index &gt;= self.size {panic!(\"\u7d22\u5f15\u8d8a\u754c\")};\n        return self.arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    pub fn set(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size {panic!(\"\u7d22\u5f15\u8d8a\u754c\")};\n        self.arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    pub fn add(&amp;mut self, num: i32) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        self.arr[self.size] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size += 1;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    pub fn insert(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size() {panic!(\"\u7d22\u5f15\u8d8a\u754c\")};\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in (index..self.size).rev() {\n            self.arr[j + 1] = self.arr[j];\n        }\n        self.arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size += 1;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    pub fn remove(&amp;mut self, index: usize) -&gt; i32 {\n        if index &gt;= self.size() {panic!(\"\u7d22\u5f15\u8d8a\u754c\")};\n        let num = self.arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in (index..self.size - 1) {\n            self.arr[j] = self.arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size -= 1;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    pub fn extend_capacity(&amp;mut self) {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extend_ratio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        let new_capacity = self.capacity * self.extend_ratio;\n        self.arr.resize(new_capacity, 0);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        self.capacity = new_capacity;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    pub fn to_array(&amp;mut self) -&gt; Vec&lt;i32&gt; {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        let mut arr = Vec::new();\n        for i in 0..self.size {\n            arr.push(self.get(i));\n        }\n        arr\n    }\n}\n</code></pre> my_list.c<pre><code>/* \u5217\u8868\u7c7b */\ntypedef struct {\n    int *arr;        // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    int capacity;    // \u5217\u8868\u5bb9\u91cf\n    int size;        // \u5217\u8868\u5927\u5c0f\n    int extendRatio; // \u5217\u8868\u6bcf\u6b21\u6269\u5bb9\u7684\u500d\u6570\n} MyList;\n\n/* \u6784\u9020\u51fd\u6570 */\nMyList *newMyList() {\n    MyList *nums = malloc(sizeof(MyList));\n    nums-&gt;capacity = 10;\n    nums-&gt;arr = malloc(sizeof(int) * nums-&gt;capacity);\n    nums-&gt;size = 0;\n    nums-&gt;extendRatio = 2;\n    return nums;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delMyList(MyList *nums) {\n    free(nums-&gt;arr);\n    free(nums);\n}\n\n/* \u83b7\u53d6\u5217\u8868\u957f\u5ea6 */\nint size(MyList *nums) {\n    return nums-&gt;size;\n}\n\n/* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\nint capacity(MyList *nums) {\n    return nums-&gt;capacity;\n}\n\n/* \u8bbf\u95ee\u5143\u7d20 */\nint get(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    return nums-&gt;arr[index];\n}\n\n/* \u66f4\u65b0\u5143\u7d20 */\nvoid set(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    nums-&gt;arr[index] = num;\n}\n\n/* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\nvoid add(MyList *nums, int num) {\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // \u6269\u5bb9\n    }\n    nums-&gt;arr[size(nums)] = num;\n    nums-&gt;size++;\n}\n\n/* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\nvoid insert(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // \u6269\u5bb9\n    }\n    for (int i = size(nums); i &gt; index; --i) {\n        nums-&gt;arr[i] = nums-&gt;arr[i - 1];\n    }\n    nums-&gt;arr[index] = num;\n    nums-&gt;size++;\n}\n\n/* \u5220\u9664\u5143\u7d20 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nint removeItem(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    int num = nums-&gt;arr[index];\n    for (int i = index; i &lt; size(nums) - 1; i++) {\n        nums-&gt;arr[i] = nums-&gt;arr[i + 1];\n    }\n    nums-&gt;size--;\n    return num;\n}\n\n/* \u5217\u8868\u6269\u5bb9 */\nvoid extendCapacity(MyList *nums) {\n    // \u5148\u5206\u914d\u7a7a\u95f4\n    int newCapacity = capacity(nums) * nums-&gt;extendRatio;\n    int *extend = (int *)malloc(sizeof(int) * newCapacity);\n    int *temp = nums-&gt;arr;\n\n    // \u62f7\u8d1d\u65e7\u6570\u636e\u5230\u65b0\u6570\u636e\n    for (int i = 0; i &lt; size(nums); i++)\n        extend[i] = nums-&gt;arr[i];\n\n    // \u91ca\u653e\u65e7\u6570\u636e\n    free(temp);\n\n    // \u66f4\u65b0\u65b0\u6570\u636e\n    nums-&gt;arr = extend;\n    nums-&gt;capacity = newCapacity;\n}\n\n/* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a Array \u7528\u4e8e\u6253\u5370 */\nint *toArray(MyList *nums) {\n    return nums-&gt;arr;\n}\n</code></pre> my_list.zig<pre><code>// \u5217\u8868\u7c7b\nfn MyList(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        arr: []T = undefined,                        // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        arrCapacity: usize = 10,                     // \u5217\u8868\u5bb9\u91cf\n        numSize: usize = 0,                           // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        extendRatio: usize = 2,                       // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined, // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u5217\u8868\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.arr = try self.mem_allocator.alloc(T, self.arrCapacity);\n            @memset(self.arr, @as(T, 0));\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        pub fn size(self: *Self) usize {\n            return self.numSize;\n        }\n\n        // \u83b7\u53d6\u5217\u8868\u5bb9\u91cf\n        pub fn capacity(self: *Self) usize {\n            return self.arrCapacity;\n        }\n\n        // \u8bbf\u95ee\u5143\u7d20\n        pub fn get(self: *Self, index: usize) T {\n            // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            return self.arr[index];\n        }  \n\n        // \u66f4\u65b0\u5143\u7d20\n        pub fn set(self: *Self, index: usize, num: T) void {\n            // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            self.arr[index] = num;\n        }  \n\n        // \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\n        pub fn add(self: *Self, num: T) !void {\n            // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n            if (self.size() == self.capacity()) try self.extendCapacity();\n            self.arr[self.size()] = num;\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize += 1;\n        }  \n\n        // \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20\n        pub fn insert(self: *Self, index: usize, num: T) !void {\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n            if (self.size() == self.capacity()) try self.extendCapacity();\n            // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n            var j = self.size() - 1;\n            while (j &gt;= index) : (j -= 1) {\n                self.arr[j + 1] = self.arr[j];\n            }\n            self.arr[index] = num;\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize += 1;\n        }\n\n        // \u5220\u9664\u5143\u7d20\n        pub fn remove(self: *Self, index: usize) T {\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            var num = self.arr[index];\n            // \u7d22\u5f15 i \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n            var j = index;\n            while (j &lt; self.size() - 1) : (j += 1) {\n                self.arr[j] = self.arr[j + 1];\n            }\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize -= 1;\n            // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n            return num;\n        }\n\n        // \u5217\u8868\u6269\u5bb9\n        pub fn extendCapacity(self: *Self) !void {\n            // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a size * extendRatio \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n            var newCapacity = self.capacity() * self.extendRatio;\n            var extend = try self.mem_allocator.alloc(T, newCapacity);\n            @memset(extend, @as(T, 0));\n            // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n            std.mem.copy(T, extend, self.arr);\n            self.arr = extend;\n            // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n            self.arrCapacity = newCapacity;\n        }\n\n        // \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4\n        pub fn toArray(self: *Self) ![]T {\n            // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n            var arr = try self.mem_allocator.alloc(T, self.size());\n           @memset(arr, @as(T, 0));\n            for (arr, 0..) |*num, i| {\n                num.* = self.get(i);\n            }\n            return arr;\n        }\n    };\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/","title":"4.4 \u00a0 Memory and Cache *","text":"<p>In the first two sections of this chapter, we explored arrays and linked lists, two fundamental and important data structures, representing \"continuous storage\" and \"dispersed storage\" respectively.</p> <p>In fact, the physical structure largely determines the efficiency of a program's use of memory and cache, which in turn affects the overall performance of the algorithm.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#441-computer-storage-devices","title":"4.4.1 \u00a0 Computer Storage Devices","text":"<p>There are three types of storage devices in computers: \"hard disk,\" \"random-access memory (RAM),\" and \"cache memory.\" The following table shows their different roles and performance characteristics in computer systems.</p> <p> Table 4-2 \u00a0 Computer Storage Devices </p> Hard Disk Memory Cache Usage Long-term storage of data, including OS, programs, files, etc. Temporary storage of currently running programs and data being processed Stores frequently accessed data and instructions, reducing the number of CPU accesses to memory Volatility Data is not lost after power off Data is lost after power off Data is lost after power off Capacity Larger, TB level Smaller, GB level Very small, MB level Speed Slower, several hundred to thousands MB/s Faster, several tens of GB/s Very fast, several tens to hundreds of GB/s Price Cheaper, several cents to yuan / GB More expensive, tens to hundreds of yuan / GB Very expensive, priced with CPU <p>We can imagine the computer storage system as a pyramid structure shown in the Figure 4-9 . The storage devices closer to the top of the pyramid are faster, have smaller capacity, and are more costly. This multi-level design is not accidental, but the result of careful consideration by computer scientists and engineers.</p> <ul> <li>Hard disks are difficult to replace with memory. Firstly, data in memory is lost after power off, making it unsuitable for long-term data storage; secondly, the cost of memory is dozens of times that of hard disks, making it difficult to popularize in the consumer market.</li> <li>It is difficult for caches to have both large capacity and high speed. As the capacity of L1, L2, L3 caches gradually increases, their physical size becomes larger, increasing the physical distance from the CPU core, leading to increased data transfer time and higher element access latency. Under current technology, a multi-level cache structure is the best balance between capacity, speed, and cost.</li> </ul> <p></p> <p> Figure 4-9 \u00a0 Computer Storage System </p> <p>Note</p> <p>The storage hierarchy of computers reflects a delicate balance between speed, capacity, and cost. In fact, this kind of trade-off is common in all industrial fields, requiring us to find the best balance between different advantages and limitations.</p> <p>Overall, hard disks are used for long-term storage of large amounts of data, memory is used for temporary storage of data being processed during program execution, and cache is used to store frequently accessed data and instructions to improve program execution efficiency. Together, they ensure the efficient operation of computer systems.</p> <p>As shown in the Figure 4-10 , during program execution, data is read from the hard disk into memory for CPU computation. The cache can be considered a part of the CPU, smartly loading data from memory to provide fast data access to the CPU, significantly enhancing program execution efficiency and reducing reliance on slower memory.</p> <p></p> <p> Figure 4-10 \u00a0 Data Flow Between Hard Disk, Memory, and Cache </p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#442-memory-efficiency-of-data-structures","title":"4.4.2 \u00a0 Memory Efficiency of Data Structures","text":"<p>In terms of memory space utilization, arrays and linked lists have their advantages and limitations.</p> <p>On one hand, memory is limited and cannot be shared by multiple programs, so we hope that data structures can use space as efficiently as possible. The elements of an array are tightly packed without extra space for storing references (pointers) between linked list nodes, making them more space-efficient. However, arrays require allocating sufficient continuous memory space at once, which may lead to memory waste, and array expansion also requires additional time and space costs. In contrast, linked lists allocate and reclaim memory dynamically on a per-node basis, providing greater flexibility.</p> <p>On the other hand, during program execution, as memory is repeatedly allocated and released, the degree of fragmentation of free memory becomes higher, leading to reduced memory utilization efficiency. Arrays, due to their continuous storage method, are relatively less likely to cause memory fragmentation. In contrast, the elements of a linked list are dispersedly stored, and frequent insertion and deletion operations make memory fragmentation more likely.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#443-cache-efficiency-of-data-structures","title":"4.4.3 \u00a0 Cache Efficiency of Data Structures","text":"<p>Although caches are much smaller in space capacity than memory, they are much faster and play a crucial role in program execution speed. Since the cache's capacity is limited and can only store a small part of frequently accessed data, when the CPU tries to access data not in the cache, a \"cache miss\" occurs, forcing the CPU to load the needed data from slower memory.</p> <p>Clearly, the fewer the cache misses, the higher the CPU's data read-write efficiency, and the better the program performance. The proportion of successful data retrieval from the cache by the CPU is called the \"cache hit rate,\" a metric often used to measure cache efficiency.</p> <p>To achieve higher efficiency, caches adopt the following data loading mechanisms.</p> <ul> <li>Cache Lines: Caches don't store and load data byte by byte but in units of cache lines. Compared to byte-by-byte transfer, the transmission of cache lines is more efficient.</li> <li>Prefetch Mechanism: Processors try to predict data access patterns (such as sequential access, fixed stride jumping access, etc.) and load data into the cache according to specific patterns to improve the hit rate.</li> <li>Spatial Locality: If data is accessed, data nearby is likely to be accessed in the near future. Therefore, when loading certain data, the cache also loads nearby data to improve the hit rate.</li> <li>Temporal Locality: If data is accessed, it's likely to be accessed again in the near future. Caches use this principle to retain recently accessed data to improve the hit rate.</li> </ul> <p>In fact, arrays and linked lists have different cache utilization efficiencies, mainly reflected in the following aspects.</p> <ul> <li>Occupied Space: Linked list elements occupy more space than array elements, resulting in less effective data volume in the cache.</li> <li>Cache Lines: Linked list data is scattered throughout memory, and since caches load \"by line,\" the proportion of loading invalid data is higher.</li> <li>Prefetch Mechanism: The data access pattern of arrays is more \"predictable\" than that of linked lists, meaning the system is more likely to guess which data will be loaded next.</li> <li>Spatial Locality: Arrays are stored in concentrated memory spaces, so the data near the loaded data is more likely to be accessed next.</li> </ul> <p>Overall, arrays have a higher cache hit rate and are generally more efficient in operation than linked lists. This makes data structures based on arrays more popular in solving algorithmic problems.</p> <p>It should be noted that high cache efficiency does not mean that arrays are always better than linked lists. Which data structure to choose in actual applications should be based on specific requirements. For example, both arrays and linked lists can implement the \"stack\" data structure (which will be detailed in the next chapter), but they are suitable for different scenarios.</p> <ul> <li>In algorithm problems, we tend to choose stacks based on arrays because they provide higher operational efficiency and random access capabilities, with the only cost being the need to pre-allocate a certain amount of memory space for the array.</li> <li>If the data volume is very large, highly dynamic, and the expected size of the stack is difficult to estimate, then a stack based on a linked list is more appropriate. Linked lists can disperse a large amount of data in different parts of the memory and avoid the additional overhead of array expansion.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/","title":"4.5 \u00a0 Summary","text":""},{"location":"chapter_array_and_linkedlist/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Arrays and linked lists are two fundamental data structures, representing two storage methods in computer memory: continuous space storage and dispersed space storage. Their characteristics complement each other.</li> <li>Arrays support random access and use less memory; however, they are inefficient in inserting and deleting elements and have a fixed length after initialization.</li> <li>Linked lists implement efficient node insertion and deletion through changing references (pointers) and can flexibly adjust their length; however, they have lower node access efficiency and use more memory.</li> <li>Common types of linked lists include singly linked lists, circular linked lists, and doubly linked lists, each with its own application scenarios.</li> <li>Lists are ordered collections of elements that support addition, deletion, and modification, typically implemented based on dynamic arrays, retaining the advantages of arrays while allowing flexible length adjustment.</li> <li>The advent of lists significantly enhanced the practicality of arrays but may lead to some memory space wastage.</li> <li>During program execution, data is mainly stored in memory. Arrays provide higher memory space efficiency, while linked lists are more flexible in memory usage.</li> <li>Caches provide fast data access to CPUs through mechanisms like cache lines, prefetching, spatial locality, and temporal locality, significantly enhancing program execution efficiency.</li> <li>Due to higher cache hit rates, arrays are generally more efficient than linked lists. When choosing a data structure, the appropriate choice should be made based on specific needs and scenarios.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Does storing arrays on the stack versus the heap affect time and space efficiency?</p> <p>Arrays stored on both the stack and heap are stored in continuous memory spaces, and data operation efficiency is essentially the same. However, stacks and heaps have their own characteristics, leading to the following differences.</p> <ol> <li>Allocation and release efficiency: The stack is a smaller memory block, allocated automatically by the compiler; the heap memory is relatively larger and can be dynamically allocated in the code, more prone to fragmentation. Therefore, allocation and release operations on the heap are generally slower than on the stack.</li> <li>Size limitation: Stack memory is relatively small, while the heap size is generally limited by available memory. Therefore, the heap is more suitable for storing large arrays.</li> <li>Flexibility: The size of arrays on the stack needs to be determined at compile-time, while the size of arrays on the heap can be dynamically determined at runtime.</li> </ol> <p>Why do arrays require elements of the same type, while linked lists do not emphasize same-type elements?</p> <p>Linked lists consist of nodes connected by references (pointers), and each node can store data of different types, such as int, double, string, object, etc.</p> <p>In contrast, array elements must be of the same type, allowing the calculation of offsets to access the corresponding element positions. For example, an array containing both int and long types, with single elements occupying 4 bytes and 8 bytes respectively, cannot use the following formula to calculate offsets, as the array contains elements of two different lengths.</p> <pre><code># Element memory address = Array memory address + Element length * Element index\n</code></pre> <p>After deleting a node, is it necessary to set <code>P.next</code> to <code>None</code>?</p> <p>Not modifying <code>P.next</code> is also acceptable. From the perspective of the linked list, traversing from the head node to the tail node will no longer encounter <code>P</code>. This means that node <code>P</code> has been effectively removed from the list, and where <code>P</code> points no longer affects the list.</p> <p>From a garbage collection perspective, for languages with automatic garbage collection mechanisms like Java, Python, and Go, whether node <code>P</code> is collected depends on whether there are still references pointing to it, not on the value of <code>P.next</code>. In languages like C and C++, we need to manually free the node's memory.</p> <p>In linked lists, the time complexity for insertion and deletion operations is <code>O(1)</code>. But searching for the element before insertion or deletion takes <code>O(n)</code> time, so why isn't the time complexity <code>O(n)</code>?</p> <p>If an element is searched first and then deleted, the time complexity is indeed <code>O(n)</code>. However, the <code>O(1)</code> advantage of linked lists in insertion and deletion can be realized in other applications. For example, in the implementation of double-ended queues using linked lists, we maintain pointers always pointing to the head and tail nodes, making each insertion and deletion operation <code>O(1)</code>.</p> <p>In the image 'Linked List Definition and Storage Method', do the light blue storage nodes occupy a single memory address, or do they share half with the node value?</p> <p>The diagram is just a qualitative representation; quantitative analysis depends on specific situations.</p> <ul> <li>Different types of node values occupy different amounts of space, such as int, long, double, and object instances.</li> <li>The memory space occupied by pointer variables depends on the operating system and compilation environment used, usually 8 bytes or 4 bytes.</li> </ul> <p>Is adding elements to the end of a list always <code>O(1)</code>?</p> <p>If adding an element exceeds the list length, the list needs to be expanded first. The system will request a new memory block and move all elements of the original list over, in which case the time complexity becomes <code>O(n)</code>.</p> <p>The statement 'The emergence of lists greatly improves the practicality of arrays, but may lead to some memory space wastage' - does this refer to the memory occupied by additional variables like capacity, length, and expansion multiplier?</p> <p>The space wastage here mainly refers to two aspects: on the one hand, lists are set with an initial length, which we may not always need; on the other hand, to prevent frequent expansion, expansion usually multiplies by a coefficient, such as \\(\\times 1.5\\). This results in many empty slots, which we typically cannot fully fill.</p> <p>In Python, after initializing <code>n = [1, 2, 3]</code>, the addresses of these 3 elements are contiguous, but initializing <code>m = [2, 1, 3]</code> shows that each element's <code>id</code> is not consecutive but identical to those in <code>n</code>. If the addresses of these elements are not contiguous, is <code>m</code> still an array?</p> <p>If we replace list elements with linked list nodes <code>n = [n1, n2, n3, n4, n5]</code>, these 5 node objects are also typically dispersed throughout memory. However, given a list index, we can still access the node's memory address in <code>O(1)</code> time, thereby accessing the corresponding node. This is because the array stores references to the nodes, not the nodes themselves.</p> <p>Unlike many languages, in Python, numbers are also wrapped as objects, and lists store references to these numbers, not the numbers themselves. Therefore, we find that the same number in two arrays has the same <code>id</code>, and these numbers' memory addresses need not be contiguous.</p> <p>The <code>std::list</code> in C++ STL has already implemented a doubly linked list, but it seems that some algorithm books don't directly use it. Is there any limitation?</p> <p>On the one hand, we often prefer to use arrays to implement algorithms, only using linked lists when necessary, mainly for two reasons.</p> <ul> <li>Space overhead: Since each element requires two additional pointers (one for the previous element and one for the next), <code>std::list</code> usually occupies more space than <code>std::vector</code>.</li> <li>Cache unfriendly: As the data is not stored continuously, <code>std::list</code> has a lower cache utilization rate. Generally, <code>std::vector</code> performs better.</li> </ul> <p>On the other hand, linked lists are primarily necessary for binary trees and graphs. Stacks and queues are often implemented using the programming language's <code>stack</code> and <code>queue</code> classes, rather than linked lists.</p> <p>Does initializing a list <code>res = [0] * self.size()</code> result in each element of <code>res</code> referencing the same address?</p> <p>No. However, this issue arises with two-dimensional arrays, for example, initializing a two-dimensional list <code>res = [[0] * self.size()]</code> would reference the same list <code>[0]</code> multiple times.</p> <p>In deleting a node, is it necessary to break the reference to its successor node?</p> <p>From the perspective of data structures and algorithms (problem-solving), it's okay not to break the link, as long as the program's logic is correct. From the perspective of standard libraries, breaking the link is safer and more logically clear. If the link is not broken, and the deleted node is not properly recycled, it could affect the recycling of the successor node's memory.</p>"},{"location":"chapter_computational_complexity/","title":"Chapter 2. \u00a0 Complexity Analysis","text":"<p>Abstract</p> <p>Complexity analysis is like a space-time navigator in the vast universe of algorithms.</p> <p>It guides us in exploring deeper within the the dimensions of time and space, seeking more elegant solutions.</p>"},{"location":"chapter_computational_complexity/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>2.1 \u00a0 Algorithm Efficiency Assessment</li> <li>2.2 \u00a0 Iteration and Recursion</li> <li>2.3 \u00a0 Time Complexity</li> <li>2.4 \u00a0 Space Complexity</li> <li>2.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/","title":"2.2 \u00a0 Iteration and Recursion","text":"<p>In algorithms, repeatedly performing a task is common and closely related to complexity analysis. Therefore, before introducing time complexity and space complexity, let's first understand how to implement task repetition in programs, focusing on two basic programming control structures: iteration and recursion.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#221-iteration","title":"2.2.1 \u00a0 Iteration","text":"<p>\"Iteration\" is a control structure for repeatedly performing a task. In iteration, a program repeats a block of code as long as a certain condition is met, until this condition is no longer satisfied.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-for-loop","title":"1. \u00a0 for Loop","text":"<p>The <code>for</code> loop is one of the most common forms of iteration, suitable for use when the number of iterations is known in advance.</p> <p>The following function implements the sum \\(1 + 2 + \\dots + n\\) using a <code>for</code> loop, with the sum result recorded in the variable <code>res</code>. Note that in Python, <code>range(a, b)</code> corresponds to a \"left-closed, right-open\" interval, covering \\(a, a + 1, \\dots, b-1\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig iteration.py<pre><code>def for_loop(n: int) -&gt; int:\n    \"\"\"for \u5faa\u73af\"\"\"\n    res = 0\n    # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        res += i\n    return res\n</code></pre> iteration.cpp<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* for \u5faa\u73af */\nint ForLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* for \u5faa\u73af */\nfunc forLoop(n int) int {\n    res := 0\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* for \u5faa\u73af */\nfunc forLoop(n: Int) -&gt; Int {\n    var res = 0\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* for \u5faa\u73af */\nfunction forLoop(n) {\n    let res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* for \u5faa\u73af */\nfunction forLoop(n: number): number {\n    let res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n  int res = 0;\n  // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    res += i;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* for \u5faa\u73af */\nfn for_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in 1..=n {\n        res += i;\n    }\n    res\n} \n</code></pre> iteration.c<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.zig<pre><code>// for \u5faa\u73af\nfn forLoop(n: usize) i32 {\n    var res: i32 = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (1..n+1) |i| {\n        res = res + @as(i32, @intCast(i));\n    }\n    return res;\n} \n</code></pre> <p>The flowchart below represents this sum function.</p> <p></p> <p> Figure 2-1 \u00a0 Flowchart of the Sum Function </p> <p>The number of operations in this sum function is proportional to the input data size \\(n\\), or in other words, it has a \"linear relationship\". This is actually what time complexity describes. This topic will be detailed in the next section.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-while-loop","title":"2. \u00a0 while Loop","text":"<p>Similar to the <code>for</code> loop, the <code>while</code> loop is another method to implement iteration. In a <code>while</code> loop, the program checks the condition in each round; if the condition is true, it continues, otherwise, the loop ends.</p> <p>Below we use a <code>while</code> loop to implement the sum \\(1 + 2 + \\dots + n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig iteration.py<pre><code>def while_loop(n: int) -&gt; int:\n    \"\"\"while \u5faa\u73af\"\"\"\n    res = 0\n    i = 1  # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n:\n        res += i\n        i += 1  # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    return res\n</code></pre> iteration.cpp<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while \u5faa\u73af */\nint WhileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i += 1; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while \u5faa\u73af */\nfunc whileLoop(n int) int {\n    res := 0\n    // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    i := 1\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while \u5faa\u73af */\nfunc whileLoop(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i\n        i += 1 // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while \u5faa\u73af */\nfunction whileLoop(n) {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while \u5faa\u73af */\nfunction whileLoop(n: number): number {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n  int res = 0;\n  int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n  // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  while (i &lt;= n) {\n    res += i;\n    i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while \u5faa\u73af */\nfn while_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i;\n        i += 1; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.zig<pre><code>// while \u5faa\u73af\nfn whileLoop(n: i32) i32 {\n    var res: i32 = 0;\n    var i: i32 = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += @intCast(i);\n        i += 1;\n    }\n    return res;\n}\n</code></pre> <p>The <code>while</code> loop is more flexible than the <code>for</code> loop. In a <code>while</code> loop, we can freely design the initialization and update steps of the condition variable.</p> <p>For example, in the following code, the condition variable \\(i\\) is updated twice in each round, which would be inconvenient to implement with a <code>for</code> loop:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig iteration.py<pre><code>def while_loop_ii(n: int) -&gt; int:\n    \"\"\"while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09\"\"\"\n    res = 0\n    i = 1  # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    # \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n:\n        res += i\n        # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1\n        i *= 2\n    return res\n</code></pre> iteration.cpp<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint WhileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, 4, 5...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1; \n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunc whileLoopII(n int) int {\n    res := 0\n    // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    i := 1\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    for i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunc whileLoopII(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunction whileLoopII(n) {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunction whileLoopII(n: number): number {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n  int res = 0;\n  int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n  // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n  while (i &lt;= n) {\n    res += i;\n    // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    i++;\n    i *= 2;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfn while_loop_ii(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1;\n        i *= 2;\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.zig<pre><code>//  while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09\nfn whileLoopII(n: i32) i32 {\n    var res: i32 = 0;\n    var i: i32 = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += @intCast(i);\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> <p>Overall, <code>for</code> loops are more concise, while <code>while</code> loops are more flexible. Both can implement iterative structures. Which one to use should be determined based on the specific requirements of the problem.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-nested-loops","title":"3. \u00a0 Nested Loops","text":"<p>We can nest one loop structure within another. Below is an example using <code>for</code> loops:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig iteration.py<pre><code>def nested_for_loop(n: int) -&gt; str:\n    \"\"\"\u53cc\u5c42 for \u5faa\u73af\"\"\"\n    res = \"\"\n    # \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        # \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in range(1, n + 1):\n            res += f\"({i}, {j}), \"\n    return res\n</code></pre> iteration.cpp<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nstring nestedForLoop(int n) {\n    ostringstream res;\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; ++j) {\n            res &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \"), \";\n        }\n    }\n    return res.str();\n}\n</code></pre> iteration.java<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nString nestedForLoop(int n) {\n    StringBuilder res = new StringBuilder();\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.append(\"(\" + i + \", \" + j + \"), \");\n        }\n    }\n    return res.toString();\n}\n</code></pre> iteration.cs<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nstring NestedForLoop(int n) {\n    StringBuilder res = new();\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.Append($\"({i}, {j}), \");\n        }\n    }\n    return res.ToString();\n}\n</code></pre> iteration.go<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunc nestedForLoop(n int) string {\n    res := \"\"\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j &lt;= n; j++ {\n            // \u5faa\u73af j = 1, 2, ..., n-1, n\n            res += fmt.Sprintf(\"(%d, %d), \", i, j)\n        }\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunc nestedForLoop(n: Int) -&gt; String {\n    var res = \"\"\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in 1 ... n {\n            res.append(\"(\\(i), \\(j)), \")\n        }\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunction nestedForLoop(n) {\n    let res = '';\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunction nestedForLoop(n: number): string {\n    let res = '';\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nString nestedForLoop(int n) {\n  String res = \"\";\n  // \u5faa\u73af i = 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    // \u5faa\u73af j = 1, 2, ..., n-1, n\n    for (int j = 1; j &lt;= n; j++) {\n      res += \"($i, $j), \";\n    }\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfn nested_for_loop(n: i32) -&gt; String {\n    let mut res = vec![];\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in 1..=n {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in 1..=n {\n            res.push(format!(\"({}, {}), \", i, j));\n        }\n    }\n    res.join(\"\")\n}\n</code></pre> iteration.c<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nchar *nestedForLoop(int n) {\n    // n * n \u4e3a\u5bf9\u5e94\u70b9\u6570\u91cf\uff0c\"(i, j), \" \u5bf9\u5e94\u5b57\u7b26\u4e32\u957f\u6700\u5927\u4e3a 6+10*2\uff0c\u52a0\u4e0a\u6700\u540e\u4e00\u4e2a\u7a7a\u5b57\u7b26 \\0 \u7684\u989d\u5916\u7a7a\u95f4\n    int size = n * n * 26 + 1;\n    char *res = malloc(size * sizeof(char));\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            char tmp[26];\n            snprintf(tmp, sizeof(tmp), \"(%d, %d), \", i, j);\n            strncat(res, tmp, size - strlen(res) - 1);\n        }\n    }\n    return res;\n}\n</code></pre> iteration.zig<pre><code>// \u53cc\u5c42 for \u5faa\u73af\nfn nestedForLoop(allocator: Allocator, n: usize) ![]const u8 {\n    var res = std.ArrayList(u8).init(allocator);\n    defer res.deinit();\n    var buffer: [20]u8 = undefined;\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (1..n+1) |i| {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (1..n+1) |j| {\n            var _str = try std.fmt.bufPrint(&amp;buffer, \"({d}, {d}), \", .{i, j});\n            try res.appendSlice(_str);\n        }\n    }\n    return res.toOwnedSlice();\n}\n</code></pre> <p>The flowchart below represents this nested loop.</p> <p></p> <p> Figure 2-2 \u00a0 Flowchart of the Nested Loop </p> <p>In this case, the number of operations in the function is proportional to \\(n^2\\), or the algorithm's running time and the input data size \\(n\\) have a \"quadratic relationship\".</p> <p>We can continue adding nested loops, each nesting is a \"dimensional escalation,\" which will increase the time complexity to \"cubic,\" \"quartic,\" and so on.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#222-recursion","title":"2.2.2 \u00a0 Recursion","text":"<p>\"Recursion\" is an algorithmic strategy that solves problems by having a function call itself. It mainly consists of two phases.</p> <ol> <li>Recursion: The program continuously calls itself, usually with smaller or more simplified parameters, until reaching a \"termination condition.\"</li> <li>Return: Upon triggering the \"termination condition,\" the program begins to return from the deepest recursive function, aggregating the results of each layer.</li> </ol> <p>From an implementation perspective, recursive code mainly includes three elements.</p> <ol> <li>Termination Condition: Determines when to switch from \"recursion\" to \"return.\"</li> <li>Recursive Call: Corresponds to \"recursion,\" where the function calls itself, usually with smaller or more simplified parameters.</li> <li>Return Result: Corresponds to \"return,\" where the result of the current recursion level is returned to the previous layer.</li> </ol> <p>Observe the following code, where calling the function <code>recur(n)</code> completes the computation of \\(1 + 2 + \\dots + n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig recursion.py<pre><code>def recur(n: int) -&gt; int:\n    \"\"\"\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6\n    if n == 1:\n        return 1\n    # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    res = recur(n - 1)\n    # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n</code></pre> recursion.cpp<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.java<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.cs<pre><code>/* \u9012\u5f52 */\nint Recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = Recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.go<pre><code>/* \u9012\u5f52 */\nfunc recur(n int) int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    res := recur(n - 1)\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n}\n</code></pre> recursion.swift<pre><code>/* \u9012\u5f52 */\nfunc recur(n: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    let res = recur(n: n - 1)\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n}\n</code></pre> recursion.js<pre><code>/* \u9012\u5f52 */\nfunction recur(n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 1) return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    const res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.ts<pre><code>/* \u9012\u5f52 */\nfunction recur(n: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 1) return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    const res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.dart<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n  // \u7ec8\u6b62\u6761\u4ef6\n  if (n == 1) return 1;\n  // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  int res = recur(n - 1);\n  // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  return n + res;\n}\n</code></pre> recursion.rs<pre><code>/* \u9012\u5f52 */\nfn recur(n: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1;\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    let res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    n + res\n}\n</code></pre> recursion.c<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.zig<pre><code>// \u9012\u5f52\u51fd\u6570\nfn recur(n: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1) {\n        return 1;\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    var res: i32 = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> <p>The Figure 2-3  shows the recursive process of this function.</p> <p></p> <p> Figure 2-3 \u00a0 Recursive Process of the Sum Function </p> <p>Although iteration and recursion can achieve the same results from a computational standpoint, they represent two entirely different paradigms of thinking and solving problems.</p> <ul> <li>Iteration: Solves problems \"from the bottom up.\" It starts with the most basic steps, then repeatedly adds or accumulates these steps until the task is complete.</li> <li>Recursion: Solves problems \"from the top down.\" It breaks down the original problem into smaller sub-problems, each of which has the same form as the original problem. These sub-problems are then further decomposed into even smaller sub-problems, stopping at the base case (whose solution is known).</li> </ul> <p>Taking the sum function as an example, let's define the problem as \\(f(n) = 1 + 2 + \\dots + n\\).</p> <ul> <li>Iteration: In a loop, simulate the summing process, iterating from \\(1\\) to \\(n\\), performing the sum operation in each round, to obtain \\(f(n)\\).</li> <li>Recursion: Break down the problem into sub-problems \\(f(n) = n + f(n-1)\\), continuously (recursively) decomposing until reaching the base case \\(f(1) = 1\\) and then stopping.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-call-stack","title":"1. \u00a0 Call Stack","text":"<p>Each time a recursive function calls itself, the system allocates memory for the newly initiated function to store local variables, call addresses, and other information. This leads to two main consequences.</p> <ul> <li>The function's context data is stored in a memory area called \"stack frame space\" and is only released after the function returns. Therefore, recursion generally consumes more memory space than iteration.</li> <li>Recursive calls introduce additional overhead. Hence, recursion is usually less time-efficient than loops.</li> </ul> <p>As shown in the Figure 2-4 , there are \\(n\\) unreturned recursive functions before triggering the termination condition, indicating a recursion depth of \\(n\\).</p> <p></p> <p> Figure 2-4 \u00a0 Recursion Call Depth </p> <p>In practice, the depth of recursion allowed by programming languages is usually limited, and excessively deep recursion can lead to stack overflow errors.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-tail-recursion","title":"2. \u00a0 Tail Recursion","text":"<p>Interestingly, if a function makes its recursive call as the last step before returning, it can be optimized by compilers or interpreters to be as space-efficient as iteration. This scenario is known as \"tail recursion\".</p> <ul> <li>Regular Recursion: The function needs to perform more code after returning to the previous level, so the system needs to save the context of the previous call.</li> <li>Tail Recursion: The recursive call is the last operation before the function returns, meaning no further actions are required upon returning to the previous level, so the system doesn't need to save the context of the previous level's function.</li> </ul> <p>For example, in calculating \\(1 + 2 + \\dots + n\\), we can make the result variable <code>res</code> a parameter of the function, thereby achieving tail recursion:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig recursion.py<pre><code>def tail_recur(n, res):\n    \"\"\"\u5c3e\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6\n    if n == 0:\n        return res\n    # \u5c3e\u9012\u5f52\u8c03\u7528\n    return tail_recur(n - 1, res + n)\n</code></pre> recursion.cpp<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.java<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.cs<pre><code>/* \u5c3e\u9012\u5f52 */\nint TailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return TailRecur(n - 1, res + n);\n}\n</code></pre> recursion.go<pre><code>/* \u5c3e\u9012\u5f52 */\nfunc tailRecur(n int, res int) int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n-1, res+n)\n}\n</code></pre> recursion.swift<pre><code>/* \u5c3e\u9012\u5f52 */\nfunc tailRecur(n: Int, res: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n: n - 1, res: res + n)\n}\n</code></pre> recursion.js<pre><code>/* \u5c3e\u9012\u5f52 */\nfunction tailRecur(n, res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 0) return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.ts<pre><code>/* \u5c3e\u9012\u5f52 */\nfunction tailRecur(n: number, res: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 0) return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.dart<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n  // \u7ec8\u6b62\u6761\u4ef6\n  if (n == 0) return res;\n  // \u5c3e\u9012\u5f52\u8c03\u7528\n  return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.rs<pre><code>/* \u5c3e\u9012\u5f52 */\nfn tail_recur(n: i32, res: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res;\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    tail_recur(n - 1, res + n)\n}\n</code></pre> recursion.c<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.zig<pre><code>// \u5c3e\u9012\u5f52\u51fd\u6570\nfn tailRecur(n: i32, res: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0) {\n        return res;\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> <p>The execution process of tail recursion is shown in the following figure. Comparing regular recursion and tail recursion, the point of the summation operation is different.</p> <ul> <li>Regular Recursion: The summation operation occurs during the \"return\" phase, requiring another summation after each layer returns.</li> <li>Tail Recursion: The summation operation occurs during the \"recursion\" phase, and the \"return\" phase only involves returning through each layer.</li> </ul> <p></p> <p> Figure 2-5 \u00a0 Tail Recursion Process </p> <p>Tip</p> <p>Note that many compilers or interpreters do not support tail recursion optimization. For example, Python does not support tail recursion optimization by default, so even if the function is in the form of tail recursion, it may still encounter stack overflow issues.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-recursion-tree","title":"3. \u00a0 Recursion Tree","text":"<p>When dealing with algorithms related to \"divide and conquer\", recursion often offers a more intuitive approach and more readable code than iteration. Take the \"Fibonacci sequence\" as an example.</p> <p>Question</p> <p>Given a Fibonacci sequence \\(0, 1, 1, 2, 3, 5, 8, 13, \\dots\\), find the \\(n\\)th number in the sequence.</p> <p>Let the \\(n\\)th number of the Fibonacci sequence be \\(f(n)\\), it's easy to deduce two conclusions:</p> <ul> <li>The first two numbers of the sequence are \\(f(1) = 0\\) and \\(f(2) = 1\\).</li> <li>Each number in the sequence is the sum of the two preceding ones, that is, \\(f(n) = f(n - 1) + f(n - 2)\\).</li> </ul> <p>Using the recursive relation, and considering the first two numbers as termination conditions, we can write the recursive code. Calling <code>fib(n)</code> will yield the \\(n\\)th number of the Fibonacci sequence:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig recursion.py<pre><code>def fib(n: int) -&gt; int:\n    \"\"\"\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 or n == 2:\n        return n - 1\n    # \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    res = fib(n - 1) + fib(n - 2)\n    # \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n</code></pre> recursion.cpp<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint Fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = Fib(n - 1) + Fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunc fib(n int) int {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    res := fib(n-1) + fib(n-2)\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunc fib(n: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    let res = fib(n: n - 1) + fib(n: n - 2)\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n}\n</code></pre> recursion.js<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunction fib(n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunction fib(n: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n  // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n  if (n == 1 || n == 2) return n - 1;\n  // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n  int res = fib(n - 1) + fib(n - 2);\n  // \u8fd4\u56de\u7ed3\u679c f(n)\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfn fib(n: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1;\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    let res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c\n    res\n}\n</code></pre> recursion.c<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.zig<pre><code>// \u6590\u6ce2\u90a3\u5951\u6570\u5217\nfn fib(n: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 or n == 2) {\n        return n - 1;\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    var res: i32 = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> <p>Observing the above code, we see that it recursively calls two functions within itself, meaning that one call generates two branching calls. As illustrated below, this continuous recursive calling eventually creates a \"recursion tree\" with a depth of \\(n\\).</p> <p></p> <p> Figure 2-6 \u00a0 Fibonacci Sequence Recursion Tree </p> <p>Fundamentally, recursion embodies the paradigm of \"breaking down a problem into smaller sub-problems.\" This divide-and-conquer strategy is crucial.</p> <ul> <li>From an algorithmic perspective, many important strategies like searching, sorting, backtracking, divide-and-conquer, and dynamic programming directly or indirectly use this way of thinking.</li> <li>From a data structure perspective, recursion is naturally suited for dealing with linked lists, trees, and graphs, as they are well suited for analysis using the divide-and-conquer approach.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#223-comparison","title":"2.2.3 \u00a0 Comparison","text":"<p>Summarizing the above content, the following table shows the differences between iteration and recursion in terms of implementation, performance, and applicability.</p> <p> Table: Comparison of Iteration and Recursion Characteristics </p> Iteration Recursion Approach Loop structure Function calls itself Time Efficiency Generally higher efficiency, no function call overhead Each function call generates overhead Memory Usage Typically uses a fixed size of memory space Accumulative function calls can use a substantial amount of stack frame space Suitable Problems Suitable for simple loop tasks, intuitive and readable code Suitable for problem decomposition, like trees, graphs, divide-and-conquer, backtracking, etc., concise and clear code structure <p>Tip</p> <p>If you find the following content difficult to understand, consider revisiting it after reading the \"Stack\" chapter.</p> <p>So, what is the intrinsic connection between iteration and recursion? Taking the above recursive function as an example, the summation operation occurs during the recursion's \"return\" phase. This means that the initially called function is actually the last to complete its summation operation, mirroring the \"last in, first out\" principle of a stack.</p> <p>In fact, recursive terms like \"call stack\" and \"stack frame space\" hint at the close relationship between recursion and stacks.</p> <ol> <li>Recursion: When a function is called, the system allocates a new stack frame on the \"call stack\" for that function, storing local variables, parameters, return addresses, and other data.</li> <li>Return: When a function completes execution and returns, the corresponding stack frame is removed from the \"call stack,\" restoring the execution environment of the previous function.</li> </ol> <p>Therefore, we can use an explicit stack to simulate the behavior of the call stack, thus transforming recursion into an iterative form:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig recursion.py<pre><code>def for_loop_recur(n: int) -&gt; int:\n    \"\"\"\u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52\"\"\"\n    # \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack = []\n    res = 0\n    # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in range(n, 0, -1):\n        # \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.append(i)\n    # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while stack:\n        # \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop()\n    # res = 1+2+3+...+n\n    return res\n</code></pre> recursion.cpp<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack&lt;int&gt; stack;\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (!stack.empty()) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.top();\n        stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (!stack.isEmpty()) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint ForLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    Stack&lt;int&gt; stack = new();\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.Push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.Count &gt; 0) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.Pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunc forLoopRecur(n int) int {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack := list.New()\n    res := 0\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i := n; i &gt; 0; i-- {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.PushBack(i)\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    for stack.Len() != 0 {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.Back().Value.(int)\n        stack.Remove(stack.Back())\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunc forLoopRecur(n: Int) -&gt; Int {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    var stack: [Int] = []\n    var res = 0\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in stride(from: n, to: 0, by: -1) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.append(i)\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while !stack.isEmpty {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.removeLast()\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.js<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunction forLoopRecur(n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    const stack = [];\n    let res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (let i = 1; i &lt;= n; i++) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.length) { \n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunction forLoopRecur(n: number): number {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808 \n    const stack: number[] = [];\n    let res: number = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (let i = 1; i &lt;= n; i++) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.length) { \n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n  // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n  List&lt;int&gt; stack = [];\n  int res = 0;\n  // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  for (int i = n; i &gt; 0; i--) {\n    // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n    stack.add(i);\n  }\n  // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  while (!stack.isEmpty) {\n    // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n    res += stack.removeLast();\n  }\n  // res = 1+2+3+...+n\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfn for_loop_recur(n: i32) -&gt; i32 {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    let mut stack = Vec::new();\n    let mut res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in (1..=n).rev() {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while !stack.is_empty() {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop().unwrap();\n    }\n    // res = 1+2+3+...+n\n    res\n}\n</code></pre> recursion.c<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    int stack[1000]; // \u501f\u52a9\u4e00\u4e2a\u5927\u6570\u7ec4\u6765\u6a21\u62df\u6808\n    int top = -1;    // \u6808\u9876\u7d22\u5f15\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack[1 + top++] = i;\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (top &gt;= 0) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack[top--];\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.zig<pre><code>// \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52\nfn forLoopRecur(comptime n: i32) i32 {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    var stack: [n]i32 = undefined;\n    var res: i32 = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    var i: usize = n;\n    while (i &gt; 0) {\n        stack[i - 1] = @intCast(i);\n        i -= 1;\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    var index: usize = n;\n    while (index &gt; 0) {\n        index -= 1;\n        res += stack[index];\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> <p>Observing the above code, when recursion is transformed into iteration, the code becomes more complex. Although iteration and recursion can often be transformed into each other, it's not always advisable to do so for two reasons:</p> <ul> <li>The transformed code may become harder to understand and less readable.</li> <li>For some complex problems, simulating the behavior of the system's call stack can be quite challenging.</li> </ul> <p>In summary, choosing between iteration and recursion depends on the nature of the specific problem. In programming practice, weighing the pros and cons of each and choosing the appropriate method for the situation is essential.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/","title":"2.1 \u00a0 Algorithm Efficiency Assessment","text":"<p>In algorithm design, we pursue the following two objectives in sequence.</p> <ol> <li>Finding a Solution to the Problem: The algorithm should reliably find the correct solution within the stipulated range of inputs.</li> <li>Seeking the Optimal Solution: For the same problem, multiple solutions might exist, and we aim to find the most efficient algorithm possible.</li> </ol> <p>In other words, under the premise of being able to solve the problem, algorithm efficiency has become the main criterion for evaluating the merits of an algorithm, which includes the following two dimensions.</p> <ul> <li>Time Efficiency: The speed at which an algorithm runs.</li> <li>Space Efficiency: The size of the memory space occupied by an algorithm.</li> </ul> <p>In short, our goal is to design data structures and algorithms that are both fast and memory-efficient. Effectively assessing algorithm efficiency is crucial because only then can we compare various algorithms and guide the process of algorithm design and optimization.</p> <p>There are mainly two methods of efficiency assessment: actual testing and theoretical estimation.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#211-actual-testing","title":"2.1.1 \u00a0 Actual Testing","text":"<p>Suppose we have algorithms <code>A</code> and <code>B</code>, both capable of solving the same problem, and we need to compare their efficiencies. The most direct method is to use a computer to run these two algorithms and monitor and record their runtime and memory usage. This assessment method reflects the actual situation but has significant limitations.</p> <p>On one hand, it's difficult to eliminate interference from the testing environment. Hardware configurations can affect algorithm performance. For example, algorithm <code>A</code> might run faster than <code>B</code> on one computer, but the opposite result may occur on another computer with different configurations. This means we would need to test on a variety of machines to calculate average efficiency, which is impractical.</p> <p>On the other hand, conducting a full test is very resource-intensive. As the volume of input data changes, the efficiency of the algorithms may vary. For example, with smaller data volumes, algorithm <code>A</code> might run faster than <code>B</code>, but the opposite might be true with larger data volumes. Therefore, to draw convincing conclusions, we need to test a wide range of input data sizes, which requires significant computational resources.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#212-theoretical-estimation","title":"2.1.2 \u00a0 Theoretical Estimation","text":"<p>Due to the significant limitations of actual testing, we can consider evaluating algorithm efficiency solely through calculations. This estimation method is known as \"asymptotic complexity analysis,\" or simply \"complexity analysis.\"</p> <p>Complexity analysis reflects the relationship between the time and space resources required for algorithm execution and the size of the input data. It describes the trend of growth in the time and space required by the algorithm as the size of the input data increases. This definition might sound complex, but we can break it down into three key points to understand it better.</p> <ul> <li>\"Time and space resources\" correspond to \"time complexity\" and \"space complexity,\" respectively.</li> <li>\"As the size of input data increases\" means that complexity reflects the relationship between algorithm efficiency and the volume of input data.</li> <li>\"The trend of growth in time and space\" indicates that complexity analysis focuses not on the specific values of runtime or space occupied but on the \"rate\" at which time or space grows.</li> </ul> <p>Complexity analysis overcomes the disadvantages of actual testing methods, reflected in the following aspects:</p> <ul> <li>It is independent of the testing environment and applicable to all operating platforms.</li> <li>It can reflect algorithm efficiency under different data volumes, especially in the performance of algorithms with large data volumes.</li> </ul> <p>Tip</p> <p>If you're still confused about the concept of complexity, don't worry. We will introduce it in detail in subsequent chapters.</p> <p>Complexity analysis provides us with a \"ruler\" to measure the time and space resources needed to execute an algorithm and compare the efficiency between different algorithms.</p> <p>Complexity is a mathematical concept and may be abstract and challenging for beginners. From this perspective, complexity analysis might not be the best content to introduce first. However, when discussing the characteristics of a particular data structure or algorithm, it's hard to avoid analyzing its speed and space usage.</p> <p>In summary, it's recommended that you establish a preliminary understanding of complexity analysis before diving deep into data structures and algorithms, so that you can carry out simple complexity analyses of algorithms.</p>"},{"location":"chapter_computational_complexity/space_complexity/","title":"2.4 \u00a0 Space Complexity","text":"<p>\"Space complexity\" is used to measure the growth trend of the memory space occupied by an algorithm as the amount of data increases. This concept is very similar to time complexity, except that \"running time\" is replaced with \"occupied memory space\".</p>"},{"location":"chapter_computational_complexity/space_complexity/#241-space-related-to-algorithms","title":"2.4.1 \u00a0 Space Related to Algorithms","text":"<p>The memory space used by an algorithm during its execution mainly includes the following types.</p> <ul> <li>Input Space: Used to store the input data of the algorithm.</li> <li>Temporary Space: Used to store variables, objects, function contexts, and other data during the algorithm's execution.</li> <li>Output Space: Used to store the output data of the algorithm.</li> </ul> <p>Generally, the scope of space complexity statistics includes both \"Temporary Space\" and \"Output Space\".</p> <p>Temporary space can be further divided into three parts.</p> <ul> <li>Temporary Data: Used to save various constants, variables, objects, etc., during the algorithm's execution.</li> <li>Stack Frame Space: Used to save the context data of the called function. The system creates a stack frame at the top of the stack each time a function is called, and the stack frame space is released after the function returns.</li> <li>Instruction Space: Used to store compiled program instructions, which are usually negligible in actual statistics.</li> </ul> <p>When analyzing the space complexity of a program, we typically count the Temporary Data, Stack Frame Space, and Output Data, as shown in the Figure 2-15 .</p> <p></p> <p> Figure 2-15 \u00a0 Space Types Used in Algorithms </p> <p>The relevant code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>class Node:\n    \"\"\"Classes\"\"\"\"\n    def __init__(self, x: int):\n        self.val: int = x               # node value\n        self.next: Node | None = None   # reference to the next node\n\ndef function() -&gt; int:\n    \"\"\"\"Functions\"\"\"\"\"\n    # Perform certain operations...\n    return 0\n\ndef algorithm(n) -&gt; int:    # input data\n    A = 0                   # temporary data (constant, usually in uppercase)\n    b = 0                   # temporary data (variable)\n    node = Node(0)          # temporary data (object)\n    c = function()          # Stack frame space (call function)\n    return A + b + c        # output data\n</code></pre> <pre><code>/* Structures */\nstruct Node {\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) {}\n};\n\n/* Functions */\nint func() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {          // input data\n    const int a = 0;            // temporary data (constant)\n    int b = 0;                  // temporary data (variable)\n    Node* node = new Node(0);   // temporary data (object)\n    int c = func();             // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* Functions */\nint function() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {          // input data\n    final int a = 0;            // temporary data (constant)\n    int b = 0;                  // temporary data (variable)\n    Node node = new Node(0);    // temporary data (object)\n    int c = function();         // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* Functions */\nint Function() {\n    // Perform certain operations...\n    return 0;\n}\n\nint Algorithm(int n) {  // input data\n    const int a = 0;    // temporary data (constant)\n    int b = 0;          // temporary data (variable)\n    Node node = new(0); // temporary data (object)\n    int c = Function(); // stack frame space (call function)\n    return a + b + c;   // output data\n}\n</code></pre> <pre><code>/* Structures */\ntype node struct {\n    val  int\n    next *node\n}\n\n/* Create node structure */\nfunc newNode(val int) *node {\n    return &amp;node{val: val}\n}\n\n/* Functions */\nfunc function() int {\n    // Perform certain operations...\n    return 0\n}\n\nfunc algorithm(n int) int { // input data\n    const a = 0             // temporary data (constant)\n    b := 0                  // temporary storage of data (variable)\n    newNode(0)              // temporary data (object)\n    c := function()         // stack frame space (call function)\n    return a + b + c        // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    var val: Int\n    var next: Node?\n\n    init(x: Int) {\n        val = x\n    }\n}\n\n/* Functions */\nfunc function() -&gt; Int {\n    // Perform certain operations...\n    return 0\n}\n\nfunc algorithm(n: Int) -&gt; Int { // input data\n    let a = 0                   // temporary data (constant)\n    var b = 0                   // temporary data (variable)\n    let node = Node(x: 0)       // temporary data (object)\n    let c = function()          // stack frame space (call function)\n    return a + b + c            // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // node value\n        this.next = null;                       // reference to the next node\n    }\n}\n\n/* Functions */\nfunction constFunc() {\n    // Perform certain operations\n    return 0;\n}\n\nfunction algorithm(n) {         // input data\n    const a = 0;                // temporary data (constant)\n    let b = 0;                  // temporary data (variable)\n    const node = new Node(0);   // temporary data (object)\n    const c = constFunc();      // Stack frame space (calling function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    val: number;\n    next: Node | null;\n    constructor(val?: number) {\n        this.val = val === undefined ? 0 : val; // node value\n        this.next = null;                       // reference to the next node\n    }\n}\n\n/* Functions */\nfunction constFunc(): number {\n    // Perform certain operations\n    return 0;\n}\n\nfunction algorithm(n: number): number { // input data\n    const a = 0;                        // temporary data (constant)\n    let b = 0;                          // temporary data (variable)\n    const node = new Node(0);           // temporary data (object)\n    const c = constFunc();              // Stack frame space (calling function)\n    return a + b + c;                   // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n  int val;\n  Node next;\n  Node(this.val, [this.next]);\n}\n\n/* Functions */\nint function() {\n  // Perform certain operations...\n  return 0;\n}\n\nint algorithm(int n) {  // input data\n  const int a = 0;      // temporary data (constant)\n  int b = 0;            // temporary data (variable)\n  Node node = Node(0);  // temporary data (object)\n  int c = function();   // stack frame space (call function)\n  return a + b + c;     // output data\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Structures */\nstruct Node {\n    val: i32,\n    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\n/* Creating a Node structure */\nimpl Node {\n    fn new(val: i32) -&gt; Self {\n        Self { val: val, next: None }\n    }\n}\n\n/* Functions */\nfn function() -&gt; i32 {     \n    // Perform certain operations...\n    return 0;\n}\n\nfn algorithm(n: i32) -&gt; i32 {   // input data\n    const a: i32 = 0;           // temporary data (constant)\n    let mut b = 0;              // temporary data (variable)\n    let node = Node::new(0);    // temporary data (object)\n    let c = function();         // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Functions */\nint func() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {  // input data\n    const int a = 0;    // temporary data (constant)\n    int b = 0;          // temporary data (variable)\n    int c = func();     // stack frame space (call function)\n    return a + b + c;   // output data\n}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#242-calculation-method","title":"2.4.2 \u00a0 Calculation Method","text":"<p>The method for calculating space complexity is roughly similar to that of time complexity, with the only change being the shift of the statistical object from \"number of operations\" to \"size of used space\".</p> <p>However, unlike time complexity, we usually only focus on the worst-case space complexity. This is because memory space is a hard requirement, and we must ensure that there is enough memory space reserved under all input data.</p> <p>Consider the following code, the term \"worst-case\" in worst-case space complexity has two meanings.</p> <ol> <li>Based on the worst input data: When \\(n &lt; 10\\), the space complexity is \\(O(1)\\); but when \\(n &gt; 10\\), the initialized array <code>nums</code> occupies \\(O(n)\\) space, thus the worst-case space complexity is \\(O(n)\\).</li> <li>Based on the peak memory used during the algorithm's execution: For example, before executing the last line, the program occupies \\(O(1)\\) space; when initializing the array <code>nums</code>, the program occupies \\(O(n)\\) space, hence the worst-case space complexity is \\(O(n)\\).</li> </ol> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>def algorithm(n: int):\n    a = 0               # O(1)\n    b = [0] * 10000     # O(1)\n    if n &gt; 10:\n        nums = [0] * n  # O(n)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    vector&lt;int&gt; b(10000);    // O(1)\n    if (n &gt; 10)\n        vector&lt;int&gt; nums(n); // O(n)\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10)\n        int[] nums = new int[n]; // O(n)\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10) {\n        int[] nums = new int[n]; // O(n)\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 0                      // O(1)\n    b := make([]int, 10000)     // O(1)\n    var nums []int\n    if n &gt; 10 {\n        nums := make([]int, n)  // O(n)\n    }\n    fmt.Println(a, b, nums)\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    let a = 0 // O(1)\n    let b = Array(repeating: 0, count: 10000) // O(1)\n    if n &gt; 10 {\n        let nums = Array(repeating: 0, count: n) // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 0;                            // O(1)\n  List&lt;int&gt; b = List.filled(10000, 0);  // O(1)\n  if (n &gt; 10) {\n    List&lt;int&gt; nums = List.filled(n, 0); // O(n)\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let a = 0;                              // O(1)\n    let b = [0; 10000];                     // O(1)\n    if n &gt; 10 {\n        let nums = vec![0; n as usize];     // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    int b[10000];            // O(1)\n    if (n &gt; 10)\n        int nums[n] = {0};   // O(n)\n}\n</code></pre> <pre><code>\n</code></pre> <p>In recursive functions, stack frame space must be taken into count. Consider the following code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>def function() -&gt; int:\n    # Perform certain operations\n    return 0\n\ndef loop(n: int):\n    \"\"\"Loop O(1)\"\"\"\"\"\n    for _ in range(n):\n        function()\n\ndef recur(n: int) -&gt; int:\n    \"\"\"Recursion O(n)\"\"\"\"\"\n    if n == 1: return\n    return recur(n - 1)\n</code></pre> <pre><code>int func() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int Function() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid Loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n/* Recursion O(n) */\nint Recur(int n) {\n    if (n == 1) return 1;\n    return Recur(n - 1);\n}\n</code></pre> <pre><code>func function() int {\n    // Perform certain operations\n    return 0\n}\n\n/* Cycle O(1) */\nfunc loop(n int) {\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n}\n\n/* Recursion O(n) */\nfunc recur(n int) {\n    if n == 1 {\n        return\n    }\n    recur(n - 1)\n}\n</code></pre> <pre><code>@discardableResult\nfunc function() -&gt; Int {\n    // Perform certain operations\n    return 0\n}\n\n/* Cycle O(1) */\nfunc loop(n: Int) {\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n\n/* Recursion O(n) */\nfunc recur(n: Int) {\n    if n == 1 {\n        return\n    }\n    recur(n: n - 1)\n}\n</code></pre> <pre><code>function constFunc() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfunction loop(n) {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion O(n) */\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>function constFunc(): number {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfunction loop(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion O(n) */\nfunction recur(n: number): void {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n  // Perform certain operations\n  return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n  if (n == 1) return;\n  return recur(n - 1);\n}\n</code></pre> <pre><code>fn function() -&gt; i32 {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfn loop(n: i32) {\n    for i in 0..n {\n        function();\n    }\n}\n/* Recursion O(n) */\nvoid recur(n: i32) {\n    if n == 1 {\n        return;\n    }\n    recur(n - 1);\n}\n</code></pre> <pre><code>int func() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>\n</code></pre> <p>The time complexity of both <code>loop()</code> and <code>recur()</code> functions is \\(O(n)\\), but their space complexities differ.</p> <ul> <li>The <code>loop()</code> function calls <code>function()</code> \\(n\\) times in a loop, where each iteration's <code>function()</code> returns and releases its stack frame space, so the space complexity remains \\(O(1)\\).</li> <li>The recursive function <code>recur()</code> will have \\(n\\) instances of unreturned <code>recur()</code> existing simultaneously during its execution, thus occupying \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_computational_complexity/space_complexity/#243-common-types","title":"2.4.3 \u00a0 Common Types","text":"<p>Let the size of the input data be \\(n\\), the following chart displays common types of space complexities (arranged from low to high).</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n^2) &lt; O(2^n) \\newline \\text{Constant Order} &lt; \\text{Logarithmic Order} &lt; \\text{Linear Order} &lt; \\text{Quadratic Order} &lt; \\text{Exponential Order} \\end{aligned} \\] <p></p> <p> Figure 2-16 \u00a0 Common Types of Space Complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant Order \\(O(1)\\)","text":"<p>Constant order is common in constants, variables, objects that are independent of the size of input data \\(n\\).</p> <p>Note that memory occupied by initializing variables or calling functions in a loop, which is released upon entering the next cycle, does not accumulate over space, thus the space complexity remains \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def function() -&gt; int:\n    \"\"\"\u51fd\u6570\"\"\"\n    # \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0\n\ndef constant(n: int):\n    \"\"\"\u5e38\u6570\u9636\"\"\"\n    # \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    a = 0\n    nums = [0] * 10000\n    node = ListNode(0)\n    # \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in range(n):\n        c = 0\n    # \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in range(n):\n        function()\n</code></pre> space_complexity.cpp<pre><code>/* \u51fd\u6570 */\nint func() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const int a = 0;\n    int b = 0;\n    vector&lt;int&gt; nums(10000);\n    ListNode node(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u51fd\u6570 */\nint function() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    final int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u51fd\u6570 */\nint Function() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid Constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u51fd\u6570 */\nfunc function() int {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c...\n    return 0\n}\n\n/* \u5e38\u6570\u9636 */\nfunc spaceConstant(n int) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0\n    b := 0\n    nums := make([]int, 10000)\n    ListNode := newNode(0)\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    var c int\n    for i := 0; i &lt; n; i++ {\n        c = 0\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n    fmt.Println(a, b, nums, c, ListNode)\n}\n</code></pre> space_complexity.swift<pre><code>/* \u51fd\u6570 */\n@discardableResult\nfunc function() -&gt; Int {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0\n}\n\n/* \u5e38\u6570\u9636 */\nfunc constant(n: Int) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    let a = 0\n    var b = 0\n    let nums = Array(repeating: 0, count: 10000)\n    let node = ListNode(x: 0)\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in 0 ..&lt; n {\n        let c = 0\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n</code></pre> space_complexity.js<pre><code>/* \u51fd\u6570 */\nfunction constFunc() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nfunction constant(n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u51fd\u6570 */\nfunction constFunc(): number {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nfunction constant(n: number): void {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u51fd\u6570 */\nint function() {\n  // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n  return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n  // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n  final int a = 0;\n  int b = 0;\n  List&lt;int&gt; nums = List.filled(10000, 0);\n  ListNode node = ListNode(0);\n  // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n  for (var i = 0; i &lt; n; i++) {\n    int c = 0;\n  }\n  // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n  for (var i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u51fd\u6570 */\nfn function() -&gt;i32 {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\n#[allow(unused)]\nfn constant(n: i32) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const A: i32 = 0;\n    let b = 0;\n    let nums = vec![0; 10000];\n    let node = ListNode::new(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for i in 0..n {\n        let c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for i in 0..n {\n        function();\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u51fd\u6570 */\nint func() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const int a = 0;\n    int b = 0;\n    int nums[1000];\n    ListNode *node = newListNode(0);\n    free(node);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.zig<pre><code>// \u51fd\u6570\nfn function() i32 {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n// \u5e38\u6570\u9636\nfn constant(n: i32) void {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a: i32 = 0;\n    var b: i32 = 0;\n    var nums = [_]i32{0}**10000;\n    var node = inc.ListNode(i32){.val = 0};\n    var i: i32 = 0;\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    while (i &lt; n) : (i += 1) {\n        var c: i32 = 0;\n        _ = c;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    i = 0;\n    while (i &lt; n) : (i += 1) {\n        _ = function();\n    }\n    _ = a;\n    _ = b;\n    _ = nums;\n    _ = node;\n}\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#2-linear-order-on","title":"2. \u00a0 Linear Order \\(O(n)\\)","text":"<p>Linear order is common in arrays, linked lists, stacks, queues, etc., where the number of elements is proportional to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def linear(n: int):\n    \"\"\"\u7ebf\u6027\u9636\"\"\"\n    # \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    nums = [0] * n\n    # \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    hmap = dict[int, str]()\n    for i in range(n):\n        hmap[i] = str(i)\n</code></pre> space_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    vector&lt;int&gt; nums(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    vector&lt;ListNode&gt; nodes;\n    for (int i = 0; i &lt; n; i++) {\n        nodes.push_back(ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    unordered_map&lt;int, string&gt; map;\n    for (int i = 0; i &lt; n; i++) {\n        map[i] = to_string(i);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int[] nums = new int[n];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        nodes.add(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        map.put(i, String.valueOf(i));\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u7ebf\u6027\u9636 */\nvoid Linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int[] nums = new int[n];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    List&lt;ListNode&gt; nodes = [];\n    for (int i = 0; i &lt; n; i++) {\n        nodes.Add(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    Dictionary&lt;int, string&gt; map = [];\n    for (int i = 0; i &lt; n; i++) {\n        map.Add(i, i.ToString());\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u7ebf\u6027\u9636 */\nfunc spaceLinear(n int) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    _ = make([]int, n)\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var nodes []*node\n    for i := 0; i &lt; n; i++ {\n        nodes = append(nodes, newNode(i))\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    m := make(map[int]string, n)\n    for i := 0; i &lt; n; i++ {\n        m[i] = strconv.Itoa(i)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n: Int) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    let nums = Array(repeating: 0, count: n)\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let nodes = (0 ..&lt; n).map { ListNode(x: $0) }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let map = Dictionary(uniqueKeysWithValues: (0 ..&lt; n).map { ($0, \"\\($0)\") })\n}\n</code></pre> space_complexity.js<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    const nums = new Array(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const nodes = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n: number): void {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    const nums = new Array(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const nodes: ListNode[] = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n  // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n  List&lt;int&gt; nums = List.filled(n, 0);\n  // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  List&lt;ListNode&gt; nodes = [];\n  for (var i = 0; i &lt; n; i++) {\n    nodes.add(ListNode(i));\n  }\n  // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  Map&lt;int, String&gt; map = HashMap();\n  for (var i = 0; i &lt; n; i++) {\n    map.putIfAbsent(i, () =&gt; i.toString());\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u7ebf\u6027\u9636 */\n#[allow(unused)]\nfn linear(n: i32) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut nums = vec![0; n as usize];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut nodes = Vec::new();\n    for i in 0..n {\n        nodes.push(ListNode::new(i))\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut map = HashMap::new();\n    for i in 0..n {\n        map.insert(i, i.to_string());\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u54c8\u5e0c\u8868 */\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; // \u57fa\u4e8e uthash.h \u5b9e\u73b0\n} HashTable;\n\n/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int *nums = malloc(sizeof(int) * n);\n    free(nums);\n\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    ListNode **nodes = malloc(sizeof(ListNode *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        nodes[i] = newListNode(i);\n    }\n    // \u5185\u5b58\u91ca\u653e\n    for (int i = 0; i &lt; n; i++) {\n        free(nodes[i]);\n    }\n    free(nodes);\n\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    HashTable *h = NULL;\n    for (int i = 0; i &lt; n; i++) {\n        HashTable *tmp = malloc(sizeof(HashTable));\n        tmp-&gt;key = i;\n        tmp-&gt;val = i;\n        HASH_ADD_INT(h, key, tmp);\n    }\n\n    // \u5185\u5b58\u91ca\u653e\n    HashTable *curr, *tmp;\n    HASH_ITER(hh, h, curr, tmp) {\n        HASH_DEL(h, curr);\n        free(curr);\n    }\n}\n</code></pre> space_complexity.zig<pre><code>// \u7ebf\u6027\u9636\nfn linear(comptime n: i32) !void {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    var nums = [_]i32{0}**n;\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var nodes = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer nodes.deinit();\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        try nodes.append(i);\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var map = std.AutoArrayHashMap(i32, []const u8).init(std.heap.page_allocator);\n    defer map.deinit();\n    var j: i32 = 0;\n    while (j &lt; n) : (j += 1) {\n        const string = try std.fmt.allocPrint(std.heap.page_allocator, \"{d}\", .{j});\n        defer std.heap.page_allocator.free(string);\n        try map.put(i, string);\n    }\n    _ = nums;\n}\n</code></pre> <p>As shown below, this function's recursive depth is \\(n\\), meaning there are \\(n\\) instances of unreturned <code>linear_recur()</code> function, using \\(O(n)\\) size of stack frame space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def linear_recur(n: int):\n    \"\"\"\u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    print(\"\u9012\u5f52 n =\", n)\n    if n == 1:\n        return\n    linear_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    cout &lt;&lt; \"\u9012\u5f52 n = \" &lt;&lt; n &lt;&lt; endl;\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    System.out.println(\"\u9012\u5f52 n = \" + n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid LinearRecur(int n) {\n    Console.WriteLine(\"\u9012\u5f52 n = \" + n);\n    if (n == 1) return;\n    LinearRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc spaceLinearRecur(n int) {\n    fmt.Println(\"\u9012\u5f52 n =\", n)\n    if n == 1 {\n        return\n    }\n    spaceLinearRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc linearRecur(n: Int) {\n    print(\"\u9012\u5f52 n = \\(n)\")\n    if n == 1 {\n        return\n    }\n    linearRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction linearRecur(n) {\n    console.log(`\u9012\u5f52 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction linearRecur(n: number): void {\n    console.log(`\u9012\u5f52 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n  print('\u9012\u5f52 n = $n');\n  if (n == 1) return;\n  linearRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn linear_recur(n: i32) {\n    println!(\"\u9012\u5f52 n = {}\", n);\n    if n == 1 {return};\n    linear_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    printf(\"\u9012\u5f52 n = %d\\r\\n\", n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.zig<pre><code>// \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn linearRecur(comptime n: i32) void {\n    std.debug.print(\"\u9012\u5f52 n = {}\\n\", .{n});\n    if (n == 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> <p></p> <p> Figure 2-17 \u00a0 Recursive Function Generating Linear Order Space Complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic Order \\(O(n^2)\\)","text":"<p>Quadratic order is common in matrices and graphs, where the number of elements is quadratic to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def quadratic(n: int):\n    \"\"\"\u5e73\u65b9\u9636\"\"\"\n    # \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    num_matrix = [[0] * n for _ in range(n)]\n</code></pre> space_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    vector&lt;vector&lt;int&gt;&gt; numMatrix;\n    for (int i = 0; i &lt; n; i++) {\n        vector&lt;int&gt; tmp;\n        for (int j = 0; j &lt; n; j++) {\n            tmp.push_back(0);\n        }\n        numMatrix.push_back(tmp);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int[][] numMatrix = new int[n][n];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    List&lt;List&lt;Integer&gt;&gt; numList = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n        for (int j = 0; j &lt; n; j++) {\n            tmp.add(0);\n        }\n        numList.add(tmp);\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u5e73\u65b9\u9636 */\nvoid Quadratic(int n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int[,] numMatrix = new int[n, n];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    List&lt;List&lt;int&gt;&gt; numList = [];\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;int&gt; tmp = [];\n        for (int j = 0; j &lt; n; j++) {\n            tmp.Add(0);\n        }\n        numList.Add(tmp);\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u5e73\u65b9\u9636 */\nfunc spaceQuadratic(n int) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    numMatrix := make([][]int, n)\n    for i := 0; i &lt; n; i++ {\n        numMatrix[i] = make([]int, n)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n: Int) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let numList = Array(repeating: Array(repeating: 0, count: n), count: n)\n}\n</code></pre> space_complexity.js<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n: number): void {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n  // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n  List&lt;List&lt;int&gt;&gt; numMatrix = List.generate(n, (_) =&gt; List.filled(n, 0));\n  // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n  List&lt;List&lt;int&gt;&gt; numList = [];\n  for (var i = 0; i &lt; n; i++) {\n    List&lt;int&gt; tmp = [];\n    for (int j = 0; j &lt; n; j++) {\n      tmp.add(0);\n    }\n    numList.add(tmp);\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u5e73\u65b9\u9636 */\n#[allow(unused)]\nfn quadratic(n: i32) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let num_matrix = vec![vec![0; n as usize]; n as usize];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let mut num_list = Vec::new();\n    for i in 0..n {\n        let mut tmp = Vec::new();\n        for j in 0..n {\n            tmp.push(0);\n        }\n        num_list.push(tmp);\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int **numMatrix = malloc(sizeof(int *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        int *tmp = malloc(sizeof(int) * n);\n        for (int j = 0; j &lt; n; j++) {\n            tmp[j] = 0;\n        }\n        numMatrix[i] = tmp;\n    }\n\n    // \u5185\u5b58\u91ca\u653e\n    for (int i = 0; i &lt; n; i++) {\n        free(numMatrix[i]);\n    }\n    free(numMatrix);\n}\n</code></pre> space_complexity.zig<pre><code>// \u5e73\u65b9\u9636\nfn quadratic(n: i32) !void {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    var nodes = std.ArrayList(std.ArrayList(i32)).init(std.heap.page_allocator);\n    defer nodes.deinit();\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        var tmp = std.ArrayList(i32).init(std.heap.page_allocator);\n        defer tmp.deinit();\n        var j: i32 = 0;\n        while (j &lt; n) : (j += 1) {\n            try tmp.append(0);\n        }\n        try nodes.append(tmp);\n    }\n}\n</code></pre> <p>As shown below, the recursive depth of this function is \\(n\\), and in each recursive call, an array is initialized with lengths \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\), averaging \\(n/2\\), thus overall occupying \\(O(n^2)\\) space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def quadratic_recur(n: int) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n &lt;= 0:\n        return 0\n    # \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    nums = [0] * n\n    return quadratic_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    vector&lt;int&gt; nums(n);\n    cout &lt;&lt; \"\u9012\u5f52 n = \" &lt;&lt; n &lt;&lt; \" \u4e2d\u7684 nums \u957f\u5ea6 = \" &lt;&lt; nums.size() &lt;&lt; endl;\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    int[] nums = new int[n];\n    System.out.println(\"\u9012\u5f52 n = \" + n + \" \u4e2d\u7684 nums \u957f\u5ea6 = \" + nums.length);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint QuadraticRecur(int n) {\n    if (n &lt;= 0) return 0;\n    int[] nums = new int[n];\n    Console.WriteLine(\"\u9012\u5f52 n = \" + n + \" \u4e2d\u7684 nums \u957f\u5ea6 = \" + nums.Length);\n    return QuadraticRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc spaceQuadraticRecur(n int) int {\n    if n &lt;= 0 {\n        return 0\n    }\n    nums := make([]int, n)\n    fmt.Printf(\"\u9012\u5f52 n = %d \u4e2d\u7684 nums \u957f\u5ea6 = %d \\n\", n, len(nums))\n    return spaceQuadraticRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\n@discardableResult\nfunc quadraticRecur(n: Int) -&gt; Int {\n    if n &lt;= 0 {\n        return 0\n    }\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    let nums = Array(repeating: 0, count: n)\n    print(\"\u9012\u5f52 n = \\(n) \u4e2d\u7684 nums \u957f\u5ea6 = \\(nums.count)\")\n    return quadraticRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction quadraticRecur(n) {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`\u9012\u5f52 n = ${n} \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction quadraticRecur(n: number): number {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`\u9012\u5f52 n = ${n} \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n  if (n &lt;= 0) return 0;\n  List&lt;int&gt; nums = List.filled(n, 0);\n  print('\u9012\u5f52 n = $n \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}');\n  return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn quadratic_recur(n: i32) -&gt; i32 {\n    if n &lt;= 0 {return 0};\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    let nums = vec![0; n as usize];\n    println!(\"\u9012\u5f52 n = {} \u4e2d\u7684 nums \u957f\u5ea6 = {}\", n, nums.len());\n    return quadratic_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    int *nums = malloc(sizeof(int) * n);\n    printf(\"\u9012\u5f52 n = %d \u4e2d\u7684 nums \u957f\u5ea6 = %d\\r\\n\", n, n);\n    int res = quadraticRecur(n - 1);\n    free(nums);\n    return res;\n}\n</code></pre> space_complexity.zig<pre><code>// \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn quadraticRecur(comptime n: i32) i32 {\n    if (n &lt;= 0) return 0;\n    var nums = [_]i32{0}**n;\n    std.debug.print(\"\u9012\u5f52 n = {} \u4e2d\u7684 nums \u957f\u5ea6 = {}\\n\", .{n, nums.len});\n    return quadraticRecur(n - 1);\n}\n</code></pre> <p></p> <p> Figure 2-18 \u00a0 Recursive Function Generating Quadratic Order Space Complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential Order \\(O(2^n)\\)","text":"<p>Exponential order is common in binary trees. Observe the below image, a \"full binary tree\" with \\(n\\) levels has \\(2^n - 1\\) nodes, occupying \\(O(2^n)\\) space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig space_complexity.py<pre><code>def build_tree(n: int) -&gt; TreeNode | None:\n    \"\"\"\u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09\"\"\"\n    if n == 0:\n        return None\n    root = TreeNode(0)\n    root.left = build_tree(n - 1)\n    root.right = build_tree(n - 1)\n    return root\n</code></pre> space_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return nullptr;\n    TreeNode *root = new TreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode buildTree(int n) {\n    if (n == 0)\n        return null;\n    TreeNode root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode? BuildTree(int n) {\n    if (n == 0) return null;\n    TreeNode root = new(0) {\n        left = BuildTree(n - 1),\n        right = BuildTree(n - 1)\n    };\n    return root;\n}\n</code></pre> space_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunc buildTree(n int) *treeNode {\n    if n == 0 {\n        return nil\n    }\n    root := newTreeNode(0)\n    root.left = buildTree(n - 1)\n    root.right = buildTree(n - 1)\n    return root\n}\n</code></pre> space_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunc buildTree(n: Int) -&gt; TreeNode? {\n    if n == 0 {\n        return nil\n    }\n    let root = TreeNode(x: 0)\n    root.left = buildTree(n: n - 1)\n    root.right = buildTree(n: n - 1)\n    return root\n}\n</code></pre> space_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunction buildTree(n) {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunction buildTree(n: number): TreeNode | null {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode? buildTree(int n) {\n  if (n == 0) return null;\n  TreeNode root = TreeNode(0);\n  root.left = buildTree(n - 1);\n  root.right = buildTree(n - 1);\n  return root;\n}\n</code></pre> space_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfn build_tree(n: i32) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    if n == 0 {return None};\n    let root = TreeNode::new(0);\n    root.borrow_mut().left = build_tree(n - 1);\n    root.borrow_mut().right = build_tree(n - 1);\n    return Some(root);\n}\n</code></pre> space_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return NULL;\n    TreeNode *root = newTreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09\nfn buildTree(mem_allocator: std.mem.Allocator, n: i32) !?*inc.TreeNode(i32) {\n    if (n == 0) return null;\n    const root = try mem_allocator.create(inc.TreeNode(i32));\n    root.init(0);\n    root.left = try buildTree(mem_allocator, n - 1);\n    root.right = try buildTree(mem_allocator, n - 1);\n    return root;\n}\n</code></pre> <p></p> <p> Figure 2-19 \u00a0 Full Binary Tree Generating Exponential Order Space Complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic Order \\(O(\\log n)\\)","text":"<p>Logarithmic order is common in divide-and-conquer algorithms. For example, in merge sort, an array of length \\(n\\) is recursively divided in half each round, forming a recursion tree of height \\(\\log n\\), using \\(O(\\log n)\\) stack frame space.</p> <p>Another example is converting a number to a string. Given a positive integer \\(n\\), its number of digits is \\(\\log_{10} n + 1\\), corresponding to the length of the string, thus the space complexity is \\(O(\\log_{10} n + 1) = O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/space_complexity/#244-balancing-time-and-space","title":"2.4.4 \u00a0 Balancing Time and Space","text":"<p>Ideally, we aim for both time complexity and space complexity to be optimal. However, in practice, optimizing both simultaneously is often difficult.</p> <p>Lowering time complexity usually comes at the cost of increased space complexity, and vice versa. The approach of sacrificing memory space to improve algorithm speed is known as \"space-time tradeoff\"; the reverse is known as \"time-space tradeoff\".</p> <p>The choice depends on which aspect we value more. In most cases, time is more precious than space, so \"space-time tradeoff\" is often the more common strategy. Of course, controlling space complexity is also very important when dealing with large volumes of data.</p>"},{"location":"chapter_computational_complexity/summary/","title":"2.5 \u00a0 Summary","text":""},{"location":"chapter_computational_complexity/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<p>Algorithm Efficiency Assessment</p> <ul> <li>Time efficiency and space efficiency are the two main criteria for assessing the merits of an algorithm.</li> <li>We can assess algorithm efficiency through actual testing, but it's challenging to eliminate the influence of the test environment, and it consumes substantial computational resources.</li> <li>Complexity analysis can overcome the disadvantages of actual testing. Its results are applicable across all operating platforms and can reveal the efficiency of algorithms at different data scales.</li> </ul> <p>Time Complexity</p> <ul> <li>Time complexity measures the trend of an algorithm's running time with the increase in data volume, effectively assessing algorithm efficiency. However, it can fail in certain cases, such as with small input data volumes or when time complexities are the same, making it challenging to precisely compare the efficiency of algorithms.</li> <li>Worst-case time complexity is denoted using big O notation, representing the asymptotic upper bound, reflecting the growth level of the number of operations \\(T(n)\\) as \\(n\\) approaches infinity.</li> <li>Calculating time complexity involves two steps: first counting the number of operations, then determining the asymptotic upper bound.</li> <li>Common time complexities, arranged from low to high, include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n \\log n)\\), \\(O(n^2)\\), \\(O(2^n)\\), and \\(O(n!)\\), among others.</li> <li>The time complexity of some algorithms is not fixed and depends on the distribution of input data. Time complexities are divided into worst, best, and average cases. The best case is rarely used because input data generally needs to meet strict conditions to achieve the best case.</li> <li>Average time complexity reflects the efficiency of an algorithm under random data inputs, closely resembling the algorithm's performance in actual applications. Calculating average time complexity requires accounting for the distribution of input data and the subsequent mathematical expectation.</li> </ul> <p>Space Complexity</p> <ul> <li>Space complexity, similar to time complexity, measures the trend of memory space occupied by an algorithm with the increase in data volume.</li> <li>The relevant memory space used during the algorithm's execution can be divided into input space, temporary space, and output space. Generally, input space is not included in space complexity calculations. Temporary space can be divided into temporary data, stack frame space, and instruction space, where stack frame space usually affects space complexity only in recursive functions.</li> <li>We usually focus only on the worst-case space complexity, which means calculating the space complexity of the algorithm under the worst input data and at the worst moment of operation.</li> <li>Common space complexities, arranged from low to high, include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n^2)\\), and \\(O(2^n)\\), among others.</li> </ul>"},{"location":"chapter_computational_complexity/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Is the space complexity of tail recursion \\(O(1)\\)?</p> <p>Theoretically, the space complexity of a tail-recursive function can be optimized to \\(O(1)\\). However, most programming languages (such as Java, Python, C++, Go, C#) do not support automatic optimization of tail recursion, so it's generally considered to have a space complexity of \\(O(n)\\).</p> <p>What is the difference between the terms 'function' and 'method'?</p> <p>A \"function\" can be executed independently, with all parameters passed explicitly. A \"method\" is associated with an object and is implicitly passed to the object calling it, able to operate on the data contained within an instance of a class.</p> <p>Here are some examples from common programming languages:</p> <ul> <li>C is a procedural programming language without object-oriented concepts, so it only has functions. However, we can simulate object-oriented programming by creating structures (struct), and functions associated with these structures are equivalent to methods in other programming languages.</li> <li>Java and C# are object-oriented programming languages where code blocks (methods) are typically part of a class. Static methods behave like functions because they are bound to the class and cannot access specific instance variables.</li> <li>C++ and Python support both procedural programming (functions) and object-oriented programming (methods).</li> </ul> <p>Does the 'Common Types of Space Complexity' figure reflect the absolute size of occupied space?</p> <p>No, the figure shows space complexities, which reflect growth trends, not the absolute size of the occupied space.</p> <p>If you take \\(n = 8\\), you might find that the values of each curve don't correspond to their functions. This is because each curve includes a constant term, intended to compress the value range into a visually comfortable range.</p> <p>In practice, since we usually don't know the \"constant term\" complexity of each method, it's generally not possible to choose the best solution for \\(n = 8\\) based solely on complexity. However, for \\(n = 8^5\\), it's much easier to choose, as the growth trend becomes dominant.</p>"},{"location":"chapter_computational_complexity/time_complexity/","title":"2.3 \u00a0 Time Complexity","text":"<p>Time complexity is a concept used to measure how the run time of an algorithm increases with the size of the input data. Understanding time complexity is crucial for accurately assessing the efficiency of an algorithm.</p> <ol> <li>Determining the Running Platform: This includes hardware configuration, programming language, system environment, etc., all of which can affect the efficiency of code execution.</li> <li>Evaluating the Run Time for Various Computational Operations: For instance, an addition operation <code>+</code> might take 1 ns, a multiplication operation <code>*</code> might take 10 ns, a print operation <code>print()</code> might take 5 ns, etc.</li> <li>Counting All the Computational Operations in the Code: Summing the execution times of all these operations gives the total run time.</li> </ol> <p>For example, consider the following code with an input size of \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code># Under an operating platform\ndef algorithm(n: int):\n    a = 2      # 1 ns\n    a = a + 1  # 1 ns\n    a = a * 2  # 10 ns\n    # Cycle n times\n    for _ in range(n):  # 1 ns\n        print(0)        # 5 ns\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        cout &lt;&lt; 0 &lt;&lt; endl;         // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        System.out.println(0);     // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid Algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        Console.WriteLine(0);      // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunc algorithm(n int) {\n    a := 2     // 1 ns\n    a = a + 1  // 1 ns\n    a = a * 2  // 10 ns\n    // Loop n times\n    for i := 0; i &lt; n; i++ {  // 1 ns\n        fmt.Println(a)        // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunc algorithm(n: Int) {\n    var a = 2 // 1 ns\n    a = a + 1 // 1 ns\n    a = a * 2 // 10 ns\n    // Loop n times\n    for _ in 0 ..&lt; n { // 1 ns\n        print(0) // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunction algorithm(n) {\n    var a = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunction algorithm(n: number): void {\n    var a: number = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n  int a = 2; // 1 ns\n  a = a + 1; // 1 ns\n  a = a * 2; // 10 ns\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n    print(0); // 5 ns\n  }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfn algorithm(n: i32) {\n    let mut a = 2;      // 1 ns\n    a = a + 1;          // 1 ns\n    a = a * 2;          // 10 ns\n    // Loop n times\n    for _ in 0..n {     // 1 ns for each round i++\n        println!(\"{}\", 0);  // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // 1 ns , every round i++ is executed\n        printf(\"%d\", 0);            // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfn algorithm(n: usize) void {\n    var a: i32 = 2; // 1 ns\n    a += 1; // 1 ns\n    a *= 2; // 10 ns\n    // Loop n times\n    for (0..n) |_| { // 1 ns\n        std.debug.print(\"{}\\n\", .{0}); // 5 ns\n    }\n}\n</code></pre> <p>Using the above method, the run time of the algorithm can be calculated as \\((6n + 12)\\) ns:</p> \\[ 1 + 1 + 10 + (1 + 5) \\times n = 6n + 12 \\] <p>However, in practice, counting the run time of an algorithm is neither practical nor reasonable. First, we don't want to tie the estimated time to the running platform, as algorithms need to run on various platforms. Second, it's challenging to know the run time for each type of operation, making the estimation process difficult.</p>"},{"location":"chapter_computational_complexity/time_complexity/#231-assessing-time-growth-trend","title":"2.3.1 \u00a0 Assessing Time Growth Trend","text":"<p>Time complexity analysis does not count the algorithm's run time, but rather the growth trend of the run time as the data volume increases.</p> <p>Let's understand this concept of \"time growth trend\" with an example. Assume the input data size is \\(n\\), and consider three algorithms <code>A</code>, <code>B</code>, and <code>C</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code># Time complexity of algorithm A: constant order\ndef algorithm_A(n: int):\n    print(0)\n# Time complexity of algorithm B: linear order\ndef algorithm_B(n: int):\n    for _ in range(n):\n        print(0)\n# Time complexity of algorithm C: constant order\ndef algorithm_C(n: int):\n    for _ in range(1000000):\n        print(0)\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    cout &lt;&lt; 0 &lt;&lt; endl;\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    System.out.println(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        System.out.println(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        System.out.println(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid AlgorithmA(int n) {\n    Console.WriteLine(0);\n}\n// Time complexity of algorithm B: linear order\nvoid AlgorithmB(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Console.WriteLine(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid AlgorithmC(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        Console.WriteLine(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithm_A(n int) {\n    fmt.Println(0)\n}\n// Time complexity of algorithm B: linear order\nfunc algorithm_B(n int) {\n    for i := 0; i &lt; n; i++ {\n        fmt.Println(0)\n    }\n}\n// Time complexity of algorithm C: constant order\nfunc algorithm_C(n int) {\n    for i := 0; i &lt; 1000000; i++ {\n        fmt.Println(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithmA(n: Int) {\n    print(0)\n}\n\n// Time complexity of algorithm B: linear order\nfunc algorithmB(n: Int) {\n    for _ in 0 ..&lt; n {\n        print(0)\n    }\n}\n\n// Time complexity of algorithm C: constant order\nfunc algorithmC(n: Int) {\n    for _ in 0 ..&lt; 1000000 {\n        print(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n) {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n) {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n: number): void {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n: number): void {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithmA(int n) {\n  print(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithmB(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    print(0);\n  }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithmC(int n) {\n  for (int i = 0; i &lt; 1000000; i++) {\n    print(0);\n  }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfn algorithm_A(n: i32) {\n    println!(\"{}\", 0);\n}\n// Time complexity of algorithm B: linear order\nfn algorithm_B(n: i32) {\n    for _ in 0..n {\n        println!(\"{}\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfn algorithm_C(n: i32) {\n    for _ in 0..1000000 {\n        println!(\"{}\", 0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    printf(\"%d\", 0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"%d\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        printf(\"%d\", 0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfn algorithm_A(n: usize) void {\n    _ = n;\n    std.debug.print(\"{}\\n\", .{0});\n}\n// Time complexity of algorithm B: linear order\nfn algorithm_B(n: i32) void {\n    for (0..n) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n// Time complexity of algorithm C: constant order\nfn algorithm_C(n: i32) void {\n    _ = n;\n    for (0..1000000) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n</code></pre> <p>The following figure shows the time complexities of these three algorithms.</p> <ul> <li>Algorithm <code>A</code> has just one print operation, and its run time does not grow with \\(n\\). Its time complexity is considered \"constant order.\"</li> <li>Algorithm <code>B</code> involves a print operation looping \\(n\\) times, and its run time grows linearly with \\(n\\). Its time complexity is \"linear order.\"</li> <li>Algorithm <code>C</code> has a print operation looping 1,000,000 times. Although it takes a long time, it is independent of the input data size \\(n\\). Therefore, the time complexity of <code>C</code> is the same as <code>A</code>, which is \"constant order.\"</li> </ul> <p></p> <p> Figure 2-7 \u00a0 Time Growth Trend of Algorithms A, B, and C </p> <p>Compared to directly counting the run time of an algorithm, what are the characteristics of time complexity analysis?</p> <ul> <li>Time complexity effectively assesses algorithm efficiency. For instance, algorithm <code>B</code> has linearly growing run time, which is slower than algorithm <code>A</code> when \\(n &gt; 1\\) and slower than <code>C</code> when \\(n &gt; 1,000,000\\). In fact, as long as the input data size \\(n\\) is sufficiently large, a \"constant order\" complexity algorithm will always be better than a \"linear order\" one, demonstrating the essence of time growth trend.</li> <li>Time complexity analysis is more straightforward. Obviously, the running platform and the types of computational operations are irrelevant to the trend of run time growth. Therefore, in time complexity analysis, we can simply treat the execution time of all computational operations as the same \"unit time,\" simplifying the \"computational operation run time count\" to a \"computational operation count.\" This significantly reduces the complexity of estimation.</li> <li>Time complexity has its limitations. For example, although algorithms <code>A</code> and <code>C</code> have the same time complexity, their actual run times can be quite different. Similarly, even though algorithm <code>B</code> has a higher time complexity than <code>C</code>, it is clearly superior when the input data size \\(n\\) is small. In these cases, it's difficult to judge the efficiency of algorithms based solely on time complexity. Nonetheless, despite these issues, complexity analysis remains the most effective and commonly used method for evaluating algorithm efficiency.</li> </ul>"},{"location":"chapter_computational_complexity/time_complexity/#232-asymptotic-upper-bound","title":"2.3.2 \u00a0 Asymptotic Upper Bound","text":"<p>Consider a function with an input size of \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>def algorithm(n: int):\n    a = 1      # +1\n    a = a + 1  # +1\n    a = a * 2  # +1\n    # Cycle n times\n    for i in range(n):  # +1\n        print(0)        # +1\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n        cout &lt;&lt; 0 &lt;&lt; endl;    // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n        System.out.println(0);    // +1\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (execute i ++ every round)\n        Console.WriteLine(0);   // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1      // +1\n    a = a + 1   // +1\n    a = a * 2   // +1\n    // Loop n times\n    for i := 0; i &lt; n; i++ {   // +1\n        fmt.Println(a)         // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +1\n    a = a + 1 // +1\n    a = a * 2 // +1\n    // Loop n times\n    for _ in 0 ..&lt; n { // +1\n        print(0) // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    var a = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (execute i ++ every round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void{\n    var a: number = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (execute i ++ every round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +1\n  a = a + 1; // +1\n  a = a * 2; // +1\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n    print(0); // +1\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;   // +1\n    a = a + 1;      // +1\n    a = a * 2;      // +1\n\n    // Loop n times\n    for _ in 0..n { // +1 (execute i ++ every round)\n        println!(\"{}\", 0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (execute i ++ every round)\n        printf(\"%d\", 0);            // +1\n    }\n} \n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for (0..n) |_| { // +1 (execute i ++ every round)\n        std.debug.print(\"{}\\n\", .{0}); // +1\n    }\n}\n</code></pre> <p>Given a function that represents the number of operations of an algorithm as a function of the input size \\(n\\), denoted as \\(T(n)\\), consider the following example:</p> \\[ T(n) = 3 + 2n \\] <p>Since \\(T(n)\\) is a linear function, its growth trend is linear, and therefore, its time complexity is of linear order, denoted as \\(O(n)\\). This mathematical notation, known as \"big-O notation,\" represents the \"asymptotic upper bound\" of the function \\(T(n)\\).</p> <p>In essence, time complexity analysis is about finding the asymptotic upper bound of the \"number of operations \\(T(n)\\)\". It has a precise mathematical definition.</p> <p>Asymptotic Upper Bound</p> <p>If there exist positive real numbers \\(c\\) and \\(n_0\\) such that for all \\(n &gt; n_0\\), \\(T(n) \\leq c \\cdot f(n)\\), then \\(f(n)\\) is considered an asymptotic upper bound of \\(T(n)\\), denoted as \\(T(n) = O(f(n))\\).</p> <p>As illustrated below, calculating the asymptotic upper bound involves finding a function \\(f(n)\\) such that, as \\(n\\) approaches infinity, \\(T(n)\\) and \\(f(n)\\) have the same growth order, differing only by a constant factor \\(c\\).</p> <p></p> <p> Figure 2-8 \u00a0 Asymptotic Upper Bound of a Function </p>"},{"location":"chapter_computational_complexity/time_complexity/#233-calculation-method","title":"2.3.3 \u00a0 Calculation Method","text":"<p>While the concept of asymptotic upper bound might seem mathematically dense, you don't need to fully grasp it right away. Let's first understand the method of calculation, which can be practiced and comprehended over time.</p> <p>Once \\(f(n)\\) is determined, we obtain the time complexity \\(O(f(n))\\). But how do we determine the asymptotic upper bound \\(f(n)\\)? This process generally involves two steps: counting the number of operations and determining the asymptotic upper bound.</p>"},{"location":"chapter_computational_complexity/time_complexity/#1-step-1-counting-the-number-of-operations","title":"1. \u00a0 Step 1: Counting the Number of Operations","text":"<p>This step involves going through the code line by line. However, due to the presence of the constant \\(c\\) in \\(c \\cdot f(n)\\), all coefficients and constant terms in \\(T(n)\\) can be ignored. This principle allows for simplification techniques in counting operations.</p> <ol> <li>Ignore constant terms in \\(T(n)\\), as they do not affect the time complexity being independent of \\(n\\).</li> <li>Omit all coefficients. For example, looping \\(2n\\), \\(5n + 1\\) times, etc., can be simplified to \\(n\\) times since the coefficient before \\(n\\) does not impact the time complexity.</li> <li>Use multiplication for nested loops. The total number of operations equals the product of the number of operations in each loop, applying the simplification techniques from points 1 and 2 for each loop level.</li> </ol> <p>Given a function, we can use these techniques to count operations:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>def algorithm(n: int):\n    a = 1      # +0 (trick 1)\n    a = a + n  # +0 (trick 1)\n    # +n (technique 2)\n    for i in range(5 * n + 1):\n        print(0)\n    # +n*n (technique 3)\n    for i in range(2 * n):\n        for j in range(n + 1):\n            print(0)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            cout &lt;&lt; 0 &lt;&lt; endl;\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        System.out.println(0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            System.out.println(0);\n        }\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        Console.WriteLine(0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            Console.WriteLine(0);\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1     // +0 (trick 1)\n    a = a + n  // +0 (trick 1)\n    // +n (technique 2)\n    for i := 0; i &lt; 5 * n + 1; i++ {\n        fmt.Println(0)\n    }\n    // +n*n (technique 3)\n    for i := 0; i &lt; 2 * n; i++ {\n        for j := 0; j &lt; n + 1; j++ {\n            fmt.Println(0)\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +0 (trick 1)\n    a = a + n // +0 (trick 1)\n    // +n (technique 2)\n    for _ in 0 ..&lt; (5 * n + 1) {\n        print(0)\n    }\n    // +n*n (technique 3)\n    for _ in 0 ..&lt; (2 * n) {\n        for _ in 0 ..&lt; (n + 1) {\n            print(0)\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    let a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    let a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +0 (trick 1)\n  a = a + n; // +0 (trick 1)\n  // +n (technique 2)\n  for (int i = 0; i &lt; 5 * n + 1; i++) {\n    print(0);\n  }\n  // +n*n (technique 3)\n  for (int i = 0; i &lt; 2 * n; i++) {\n    for (int j = 0; j &lt; n + 1; j++) {\n      print(0);\n    }\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;     // +0 (trick 1)\n    a = a + n;        // +0 (trick 1)\n\n    // +n (technique 2)\n    for i in 0..(5 * n + 1) {\n        println!(\"{}\", 0);\n    }\n\n    // +n*n (technique 3)\n    for i in 0..(2 * n) {\n        for j in 0..(n + 1) {\n            println!(\"{}\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        printf(\"%d\", 0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            printf(\"%d\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1;     // +0 (trick 1)\n    a = a + @as(i32, @intCast(n));        // +0 (trick 1)\n\n    // +n (technique 2)\n    for(0..(5 * n + 1)) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n\n    // +n*n (technique 3)\n    for(0..(2 * n)) |_| {\n        for(0..(n + 1)) |_| {\n            std.debug.print(\"{}\\n\", .{0});\n        }\n    }\n}\n</code></pre> <p>The formula below shows the counting results before and after simplification, both leading to a time complexity of \\(O(n^2)\\):</p> \\[ \\begin{aligned} T(n) &amp; = 2n(n + 1) + (5n + 1) + 2 &amp; \\text{Complete Count (-.-|||)} \\newline &amp; = 2n^2 + 7n + 3 \\newline T(n) &amp; = n^2 + n &amp; \\text{Simplified Count (o.O)} \\end{aligned} \\]"},{"location":"chapter_computational_complexity/time_complexity/#2-step-2-determining-the-asymptotic-upper-bound","title":"2. \u00a0 Step 2: Determining the Asymptotic Upper Bound","text":"<p>The time complexity is determined by the highest order term in \\(T(n)\\). This is because, as \\(n\\) approaches infinity, the highest order term dominates, rendering the influence of other terms negligible.</p> <p>The following table illustrates examples of different operation counts and their corresponding time complexities. Some exaggerated values are used to emphasize that coefficients cannot alter the order of growth. When \\(n\\) becomes very large, these constants become insignificant.</p> <p> Table: Time Complexity for Different Operation Counts </p> Operation Count \\(T(n)\\) Time Complexity \\(O(f(n))\\) \\(100000\\) \\(O(1)\\) \\(3n + 2\\) \\(O(n)\\) \\(2n^2 + 3n + 2\\) \\(O(n^2)\\) \\(n^3 + 10000n^2\\) \\(O(n^3)\\) \\(2^n + 10000n^{10000}\\) \\(O(2^n)\\)"},{"location":"chapter_computational_complexity/time_complexity/#234-common-types-of-time-complexity","title":"2.3.4 \u00a0 Common Types of Time Complexity","text":"<p>Let's consider the input data size as \\(n\\). The common types of time complexities are illustrated below, arranged from lowest to highest:</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) \\newline \\text{Constant Order} &lt; \\text{Logarithmic Order} &lt; \\text{Linear Order} &lt; \\text{Linear-Logarithmic Order} &lt; \\text{Quadratic Order} &lt; \\text{Exponential Order} &lt; \\text{Factorial Order} \\end{aligned} \\] <p></p> <p> Figure 2-9 \u00a0 Common Types of Time Complexity </p>"},{"location":"chapter_computational_complexity/time_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant Order \\(O(1)\\)","text":"<p>Constant order means the number of operations is independent of the input data size \\(n\\). In the following function, although the number of operations <code>size</code> might be large, the time complexity remains \\(O(1)\\) as it's unrelated to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def constant(n: int) -&gt; int:\n    \"\"\"\u5e38\u6570\u9636\"\"\"\n    count = 0\n    size = 100000\n    for _ in range(size):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e38\u6570\u9636 */\nint Constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e38\u6570\u9636 */\nfunc constant(n int) int {\n    count := 0\n    size := 100000\n    for i := 0; i &lt; size; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e38\u6570\u9636 */\nfunc constant(n: Int) -&gt; Int {\n    var count = 0\n    let size = 100_000\n    for _ in 0 ..&lt; size {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e38\u6570\u9636 */\nfunction constant(n) {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e38\u6570\u9636 */\nfunction constant(n: number): number {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n  int count = 0;\n  int size = 100000;\n  for (var i = 0; i &lt; size; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e38\u6570\u9636 */\nfn constant(n: i32) -&gt; i32 {\n    _ = n;\n    let mut count = 0;\n    let size = 100_000;\n    for _ in 0..size {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    int i = 0;\n    for (int i = 0; i &lt; size; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u5e38\u6570\u9636\nfn constant(n: i32) i32 {\n    _ = n;\n    var count: i32 = 0;\n    const size: i32 = 100_000;\n    var i: i32 = 0;\n    while(i&lt;size) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#2-linear-order-on","title":"2. \u00a0 Linear Order \\(O(n)\\)","text":"<p>Linear order indicates the number of operations grows linearly with the input data size \\(n\\). Linear order commonly appears in single-loop structures:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def linear(n: int) -&gt; int:\n    \"\"\"\u7ebf\u6027\u9636\"\"\"\n    count = 0\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u9636 */\nint Linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n int) int {\n    count := 0\n    for i := 0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n: Int) -&gt; Int {\n    var count = 0\n    for _ in 0 ..&lt; n {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n) {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n: number): number {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n  int count = 0;\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u9636 */\nfn linear(n: i32) -&gt; i32 {\n    let mut count = 0;\n    for _ in 0..n {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u9636\nfn linear(n: i32) i32 {\n    var count: i32 = 0;\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> <p>Operations like array traversal and linked list traversal have a time complexity of \\(O(n)\\), where \\(n\\) is the length of the array or list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def array_traversal(nums: list[int]) -&gt; int:\n    \"\"\"\u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09\"\"\"\n    count = 0\n    # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for num in nums:\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(vector&lt;int&gt; &amp;nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(int[] nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint ArrayTraversal(int[] nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    foreach (int num in nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunc arrayTraversal(nums []int) int {\n    count := 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for range nums {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunc arrayTraversal(nums: [Int]) -&gt; Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for _ in nums {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunction arrayTraversal(nums) {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunction arrayTraversal(nums: number[]): number {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(List&lt;int&gt; nums) {\n  int count = 0;\n  // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n  for (var _num in nums) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfn array_traversal(nums: &amp;[i32]) -&gt; i32 {\n    let mut count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for _ in nums {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(int *nums, int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09\nfn arrayTraversal(nums: []i32) i32 {\n    var count: i32 = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (nums) |_| {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> <p>It's important to note that the input data size \\(n\\) should be determined based on the type of input data. For example, in the first example, \\(n\\) represents the input data size, while in the second example, the length of the array \\(n\\) is the data size.</p>"},{"location":"chapter_computational_complexity/time_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic Order \\(O(n^2)\\)","text":"<p>Quadratic order means the number of operations grows quadratically with the input data size \\(n\\). Quadratic order typically appears in nested loops, where both the outer and inner loops have a time complexity of \\(O(n)\\), resulting in an overall complexity of \\(O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def quadratic(n: int) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\"\"\"\n    count = 0\n    # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for i in range(n):\n        for j in range(n):\n            count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e73\u65b9\u9636 */\nint Quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n int) int {\n    count := 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; n; j++ {\n            count++\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n: Int) -&gt; Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; n {\n            count += 1\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n) {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n: number): number {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n  int count = 0;\n  // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n      count++;\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e73\u65b9\u9636 */\nfn quadratic(n: i32) -&gt; i32 {\n    let mut count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for _ in 0..n {\n        for _ in 0..n {\n            count += 1;\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u5e73\u65b9\u9636\nfn quadratic(n: i32) i32 {\n    var count: i32 = 0;\n    var i: i32 = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u5e73\u65b9\u5173\u7cfb\n    while (i &lt; n) : (i += 1) {\n        var j: i32 = 0;\n        while (j &lt; n) : (j += 1) {\n            count += 1;\n        }\n    }\n    return count;\n}\n</code></pre> <p>The following image compares constant order, linear order, and quadratic order time complexities.</p> <p></p> <p> Figure 2-10 \u00a0 Constant, Linear, and Quadratic Order Time Complexities </p> <p>For instance, in bubble sort, the outer loop runs \\(n - 1\\) times, and the inner loop runs \\(n-1\\), \\(n-2\\), ..., \\(2\\), \\(1\\) times, averaging \\(n / 2\\) times, resulting in a time complexity of \\(O((n - 1) n / 2) = O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def bubble_sort(nums: list[int]) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09\"\"\"\n    count = 0  # \u8ba1\u6570\u5668\n    # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in range(len(nums) - 1, 0, -1):\n        # \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                tmp: int = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3  # \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(vector&lt;int&gt; &amp;nums) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(int[] nums) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint BubbleSort(int[] nums) {\n    int count = 0;  // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef \n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n                count += 3;  // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunc bubbleSort(nums []int) int {\n    count := 0 // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                tmp := nums[j]\n                nums[j] = nums[j+1]\n                nums[j+1] = tmp\n                count += 3 // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunc bubbleSort(nums: inout [Int]) -&gt; Int {\n    var count = 0 // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in stride(from: nums.count - 1, to: 0, by: -1) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef \n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3 // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunction bubbleSort(nums) {\n    let count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunction bubbleSort(nums: number[]): number {\n    let count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(List&lt;int&gt; nums) {\n  int count = 0; // \u8ba1\u6570\u5668\n  // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n  for (var i = nums.length - 1; i &gt; 0; i--) {\n    // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n    for (var j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n        count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n      }\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfn bubble_sort(nums: &amp;mut [i32]) -&gt; i32 {\n    let mut count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in (1..nums.len()).rev() {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef \n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(int *nums, int n) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = n - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09\nfn bubbleSort(nums: []i32) i32 {\n    var count: i32 = 0;  // \u8ba1\u6570\u5668 \n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    var i: i32 = @as(i32, @intCast(nums.len)) - 1;\n    while (i &gt; 0) : (i -= 1) {\n        var j: usize = 0;\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef \n        while (j &lt; i) : (j += 1) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                var tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3;  // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential Order \\(O(2^n)\\)","text":"<p>Biological \"cell division\" is a classic example of exponential order growth: starting with one cell, it becomes two after one division, four after two divisions, and so on, resulting in \\(2^n\\) cells after \\(n\\) divisions.</p> <p>The following image and code simulate the cell division process, with a time complexity of \\(O(2^n)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def exponential(n: int) -&gt; int:\n    \"\"\"\u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\"\"\"\n    count = 0\n    base = 1\n    # \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in range(n):\n        for _ in range(base):\n            count += 1\n        base *= 2\n    # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint Exponential(int n) {\n    int count = 0, bas = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09*/\nfunc exponential(n int) int {\n    count, base := 0, 1\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; base; j++ {\n            count++\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunc exponential(n: Int) -&gt; Int {\n    var count = 0\n    var base = 1\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; base {\n            count += 1\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction exponential(n) {\n    let count = 0,\n        base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction exponential(n: number): number {\n    let count = 0,\n        base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n  int count = 0, base = 1;\n  // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n  for (var i = 0; i &lt; n; i++) {\n    for (var j = 0; j &lt; base; j++) {\n      count++;\n    }\n    base *= 2;\n  }\n  // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfn exponential(n: i32) -&gt; i32 {\n    let mut count = 0;\n    let mut base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0..n {\n        for _ in 0..base {\n            count += 1\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0;\n    int bas = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\nfn exponential(n: i32) i32 {\n    var count: i32 = 0;\n    var bas: i32 = 1;\n    var i: i32 = 0;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    while (i &lt; n) : (i += 1) {\n        var j: i32 = 0;\n        while (j &lt; bas) : (j += 1) {\n            count += 1;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> <p></p> <p> Figure 2-11 \u00a0 Exponential Order Time Complexity </p> <p>In practice, exponential order often appears in recursive functions. For example, in the code below, it recursively splits into two halves, stopping after \\(n\\) divisions:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def exp_recur(n: int) -&gt; int:\n    \"\"\"\u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n == 1:\n        return 1\n    return exp_recur(n - 1) + exp_recur(n - 1) + 1\n</code></pre> time_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint ExpRecur(int n) {\n    if (n == 1) return 1;\n    return ExpRecur(n - 1) + ExpRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09*/\nfunc expRecur(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n-1) + expRecur(n-1) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc expRecur(n: Int) -&gt; Int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n: n - 1) + expRecur(n: n - 1) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction expRecur(n) {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction expRecur(n: number): number {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n  if (n == 1) return 1;\n  return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn exp_recur(n: i32) -&gt; i32 {\n    if n == 1 {\n        return 1;\n    }\n    exp_recur(n - 1) + exp_recur(n - 1) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn expRecur(n: i32) i32 {\n    if (n == 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> <p>Exponential order growth is extremely rapid and is commonly seen in exhaustive search methods (brute force, backtracking, etc.). For large-scale problems, exponential order is unacceptable, often requiring dynamic programming or greedy algorithms as solutions.</p>"},{"location":"chapter_computational_complexity/time_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic Order \\(O(\\log n)\\)","text":"<p>In contrast to exponential order, logarithmic order reflects situations where \"the size is halved each round.\" Given an input data size \\(n\\), since the size is halved each round, the number of iterations is \\(\\log_2 n\\), the inverse function of \\(2^n\\).</p> <p>The following image and code simulate the \"halving each round\" process, with a time complexity of \\(O(\\log_2 n)\\), commonly abbreviated as \\(O(\\log n)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def logarithmic(n: float) -&gt; int:\n    \"\"\"\u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\"\"\"\n    count = 0\n    while n &gt; 1:\n        n = n / 2\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(float n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(float n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint Logarithmic(float n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n /= 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09*/\nfunc logarithmic(n float64) int {\n    count := 0\n    for n &gt; 1 {\n        n = n / 2\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunc logarithmic(n: Double) -&gt; Int {\n    var count = 0\n    var n = n\n    while n &gt; 1 {\n        n = n / 2\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction logarithmic(n) {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction logarithmic(n: number): number {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(num n) {\n  int count = 0;\n  while (n &gt; 1) {\n    n = n / 2;\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfn logarithmic(mut n: f32) -&gt; i32 {\n    let mut count = 0;\n    while n &gt; 1.0 {\n        n = n / 2.0;\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(float n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\nfn logarithmic(n: f32) i32 {\n    var count: i32 = 0;\n    var n_var = n;\n    while (n_var &gt; 1)\n    {\n        n_var = n_var / 2;\n        count +=1;\n    }\n    return count;\n}\n</code></pre> <p></p> <p> Figure 2-12 \u00a0 Logarithmic Order Time Complexity </p> <p>Like exponential order, logarithmic order also frequently appears in recursive functions. The code below forms a recursive tree of height \\(\\log_2 n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def log_recur(n: float) -&gt; int:\n    \"\"\"\u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n &lt;= 1:\n        return 0\n    return log_recur(n / 2) + 1\n</code></pre> time_complexity.cpp<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(float n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(float n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint LogRecur(float n) {\n    if (n &lt;= 1) return 0;\n    return LogRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09*/\nfunc logRecur(n float64) int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n/2) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc logRecur(n: Double) -&gt; Int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n: n / 2) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction logRecur(n) {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction logRecur(n: number): number {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(num n) {\n  if (n &lt;= 1) return 0;\n  return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn log_recur(n: f32) -&gt; i32 {\n    if n &lt;= 1.0 {\n        return 0;\n    }\n    log_recur(n / 2.0) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(float n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.zig<pre><code>// \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn logRecur(n: f32) i32 {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> <p>Logarithmic order is typical in algorithms based on the divide-and-conquer strategy, embodying the \"split into many\" and \"simplify complex problems\" approach. It's slow-growing and is the most ideal time complexity after constant order.</p> <p>What is the base of \\(O(\\log n)\\)?</p> <p>Technically, \"splitting into \\(m\\)\" corresponds to a time complexity of \\(O(\\log_m n)\\). Using the logarithm base change formula, we can equate different logarithmic complexities:</p> \\[ O(\\log_m n) = O(\\log_k n / \\log_k m) = O(\\log_k n) \\] <p>This means the base \\(m\\) can be changed without affecting the complexity. Therefore, we often omit the base \\(m\\) and simply denote logarithmic order as \\(O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/time_complexity/#6-linear-logarithmic-order-on-log-n","title":"6. \u00a0 Linear-Logarithmic Order \\(O(n \\log n)\\)","text":"<p>Linear-logarithmic order often appears in nested loops, with the complexities of the two loops being \\(O(\\log n)\\) and \\(O(n)\\) respectively. The related code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def linear_log_recur(n: float) -&gt; int:\n    \"\"\"\u7ebf\u6027\u5bf9\u6570\u9636\"\"\"\n    if n &lt;= 1:\n        return 1\n    count: int = linear_log_recur(n // 2) + linear_log_recur(n // 2)\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(float n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(float n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint LinearLogRecur(float n) {\n    if (n &lt;= 1) return 1;\n    int count = LinearLogRecur(n / 2) + LinearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunc linearLogRecur(n float64) int {\n    if n &lt;= 1 {\n        return 1\n    }\n    count := linearLogRecur(n/2) + linearLogRecur(n/2)\n    for i := 0.0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunc linearLogRecur(n: Double) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    var count = linearLogRecur(n: n / 2) + linearLogRecur(n: n / 2)\n    for _ in stride(from: 0, to: n, by: 1) {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunction linearLogRecur(n) {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunction linearLogRecur(n: number): number {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(num n) {\n  if (n &lt;= 1) return 1;\n  int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfn linear_log_recur(n: f32) -&gt; i32 {\n    if n &lt;= 1.0 {\n        return 1;\n    }\n    let mut count = linear_log_recur(n / 2.0) + linear_log_recur(n / 2.0);\n    for _ in 0 ..n as i32 {\n        count += 1;\n    }\n    return count\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(float n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u5bf9\u6570\u9636\nfn linearLogRecur(n: f32) i32 {\n    if (n &lt;= 1) return 1;\n    var count: i32 = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    var i: f32 = 0;\n    while (i &lt; n) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> <p>The image below demonstrates how linear-logarithmic order is generated. Each level of a binary tree has \\(n\\) operations, and the tree has \\(\\log_2 n + 1\\) levels, resulting in a time complexity of \\(O(n \\log n)\\).</p> <p></p> <p> Figure 2-13 \u00a0 Linear-Logarithmic Order Time Complexity </p> <p>Mainstream sorting algorithms typically have a time complexity of \\(O(n \\log n)\\), such as quicksort, mergesort, and heapsort.</p>"},{"location":"chapter_computational_complexity/time_complexity/#7-factorial-order-on","title":"7. \u00a0 Factorial Order \\(O(n!)\\)","text":"<p>Factorial order corresponds to the mathematical problem of \"full permutation.\" Given \\(n\\) distinct elements, the total number of possible permutations is:</p> \\[ n! = n \\times (n - 1) \\times (n - 2) \\times \\dots \\times 2 \\times 1 \\] <p>Factorials are typically implemented using recursion. As shown in the image and code below, the first level splits into \\(n\\) branches, the second level into \\(n - 1\\) branches, and so on, stopping after the \\(n\\)th level:</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig time_complexity.py<pre><code>def factorial_recur(n: int) -&gt; int:\n    \"\"\"\u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    # \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in range(n):\n        count += factorial_recur(n - 1)\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint FactorialRecur(int n) {\n    if (n == 0) return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += FactorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc factorialRecur(n int) int {\n    if n == 0 {\n        return 1\n    }\n    count := 0\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for i := 0; i &lt; n; i++ {\n        count += factorialRecur(n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc factorialRecur(n: Int) -&gt; Int {\n    if n == 0 {\n        return 1\n    }\n    var count = 0\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in 0 ..&lt; n {\n        count += factorialRecur(n: n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction factorialRecur(n) {\n    if (n === 0) return 1;\n    let count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction factorialRecur(n: number): number {\n    if (n === 0) return 1;\n    let count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n  if (n == 0) return 1;\n  int count = 0;\n  // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n  for (var i = 0; i &lt; n; i++) {\n    count += factorialRecur(n - 1);\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn factorial_recur(n: i32) -&gt; i32 {\n    if n == 0 {\n        return 1;\n    }\n    let mut count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in 0..n {\n        count += factorial_recur(n - 1);\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.zig<pre><code>// \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn factorialRecur(n: i32) i32 {\n    if (n == 0) return 1;\n    var count: i32 = 0;\n    var i: i32 = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    while (i &lt; n) : (i += 1) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> <p></p> <p> Figure 2-14 \u00a0 Factorial Order Time Complexity </p> <p>Note that factorial order grows even faster than exponential order; it's unacceptable for larger \\(n\\) values.</p>"},{"location":"chapter_computational_complexity/time_complexity/#235-worst-best-and-average-time-complexities","title":"2.3.5 \u00a0 Worst, Best, and Average Time Complexities","text":"<p>The time efficiency of an algorithm is often not fixed but depends on the distribution of the input data. Assume we have an array <code>nums</code> of length \\(n\\), consisting of numbers from \\(1\\) to \\(n\\), each appearing only once, but in a randomly shuffled order. The task is to return the index of the element \\(1\\). We can draw the following conclusions:</p> <ul> <li>When <code>nums = [?, ?, ..., 1]</code>, that is, when the last element is \\(1\\), it requires a complete traversal of the array, achieving the worst-case time complexity of \\(O(n)\\).</li> <li>When <code>nums = [1, ?, ?, ...]</code>, that is, when the first element is \\(1\\), no matter the length of the array, no further traversal is needed, achieving the best-case time complexity of \\(\\Omega(1)\\).</li> </ul> <p>The \"worst-case time complexity\" corresponds to the asymptotic upper bound, denoted by the big \\(O\\) notation. Correspondingly, the \"best-case time complexity\" corresponds to the asymptotic lower bound, denoted by \\(\\Omega\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig worst_best_time_complexity.py<pre><code>def random_numbers(n: int) -&gt; list[int]:\n    \"\"\"\u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a: 1, 2, ..., n \uff0c\u987a\u5e8f\u88ab\u6253\u4e71\"\"\"\n    # \u751f\u6210\u6570\u7ec4 nums =: 1, 2, 3, ..., n\n    nums = [i for i in range(1, n + 1)]\n    # \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    random.shuffle(nums)\n    return nums\n\ndef find_one(nums: list[int]) -&gt; int:\n    \"\"\"\u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15\"\"\"\n    for i in range(len(nums)):\n        # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1:\n            return i\n    return -1\n</code></pre> worst_best_time_complexity.cpp<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nvector&lt;int&gt; randomNumbers(int n) {\n    vector&lt;int&gt; nums(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u4f7f\u7528\u7cfb\u7edf\u65f6\u95f4\u751f\u6210\u968f\u673a\u79cd\u5b50\n    unsigned seed = chrono::system_clock::now().time_since_epoch().count();\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    shuffle(nums.begin(), nums.end(), default_random_engine(seed));\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(vector&lt;int&gt; &amp;nums) {\n    for (int i = 0; i &lt; nums.size(); i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.java<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint[] randomNumbers(int n) {\n    Integer[] nums = new Integer[n];\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    Collections.shuffle(Arrays.asList(nums));\n    // Integer[] -&gt; int[]\n    int[] res = new int[n];\n    for (int i = 0; i &lt; n; i++) {\n        res[i] = nums[i];\n    }\n    return res;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(int[] nums) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.cs<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint[] RandomNumbers(int n) {\n    int[] nums = new int[n];\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (int i = 0; i &lt; nums.Length; i++) {\n        int index = new Random().Next(i, nums.Length);\n        (nums[i], nums[index]) = (nums[index], nums[i]);\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint FindOne(int[] nums) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.go<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunc randomNumbers(n int) []int {\n    nums := make([]int, n)\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for i := 0; i &lt; n; i++ {\n        nums[i] = i + 1\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    rand.Shuffle(len(nums), func(i, j int) {\n        nums[i], nums[j] = nums[j], nums[i]\n    })\n    return nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunc findOne(nums []int) int {\n    for i := 0; i &lt; len(nums); i++ {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.swift<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunc randomNumbers(n: Int) -&gt; [Int] {\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    var nums = Array(1 ... n)\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    nums.shuffle()\n    return nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunc findOne(nums: [Int]) -&gt; Int {\n    for i in nums.indices {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.js<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunction randomNumbers(n) {\n    const nums = Array(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunction findOne(nums) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.ts<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunction randomNumbers(n: number): number[] {\n    const nums = Array(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunction findOne(nums: number[]): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.dart<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nList&lt;int&gt; randomNumbers(int n) {\n  final nums = List.filled(n, 0);\n  // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n  for (var i = 0; i &lt; n; i++) {\n    nums[i] = i + 1;\n  }\n  // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n  nums.shuffle();\n\n  return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(List&lt;int&gt; nums) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n    // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n    if (nums[i] == 1) return i;\n  }\n\n  return -1;\n}\n</code></pre> worst_best_time_complexity.rs<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfn random_numbers(n: i32) -&gt; Vec&lt;i32&gt; {\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    let mut nums = (1..=n).collect::&lt;Vec&lt;i32&gt;&gt;();\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    nums.shuffle(&amp;mut thread_rng());\n    nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfn find_one(nums: &amp;[i32]) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> worst_best_time_complexity.c<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint *randomNumbers(int n) {\n    // \u5206\u914d\u5806\u533a\u5185\u5b58\uff08\u521b\u5efa\u4e00\u7ef4\u53ef\u53d8\u957f\u6570\u7ec4\uff1a\u6570\u7ec4\u4e2d\u5143\u7d20\u6570\u91cf\u4e3a n \uff0c\u5143\u7d20\u7c7b\u578b\u4e3a int \uff09\n    int *nums = (int *)malloc(n * sizeof(int));\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (int i = n - 1; i &gt; 0; i--) {\n        int j = rand() % (i + 1);\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(int *nums, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.zig<pre><code>// \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71\nfn randomNumbers(comptime n: usize) [n]i32 {\n    var nums: [n]i32 = undefined;\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (&amp;nums, 0..) |*num, i| {\n        num.* = @as(i32, @intCast(i)) + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    const rand = std.crypto.random;\n    rand.shuffle(i32, &amp;nums);\n    return nums;\n}\n\n// \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15\nfn findOne(nums: []i32) i32 {\n    for (nums, 0..) |num, i| {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (num == 1) return @intCast(i);\n    }\n    return -1;\n}\n</code></pre> <p>It's important to note that the best-case time complexity is rarely used in practice, as it is usually only achievable under very low probabilities and might be misleading. The worst-case time complexity is more practical as it provides a safety value for efficiency, allowing us to confidently use the algorithm.</p> <p>From the above example, it's clear that both the worst-case and best-case time complexities only occur under \"special data distributions,\" which may have a small probability of occurrence and may not accurately reflect the algorithm's run efficiency. In contrast, the average time complexity can reflect the algorithm's efficiency under random input data, denoted by the \\(\\Theta\\) notation.</p> <p>For some algorithms, we can simply estimate the average case under a random data distribution. For example, in the aforementioned example, since the input array is shuffled, the probability of element \\(1\\) appearing at any index is equal. Therefore, the average number of loops for the algorithm is half the length of the array \\(n / 2\\), giving an average time complexity of \\(\\Theta(n / 2) = \\Theta(n)\\).</p> <p>However, calculating the average time complexity for more complex algorithms can be quite difficult, as it's challenging to analyze the overall mathematical expectation under the data distribution. In such cases, we usually use the worst-case time complexity as the standard for judging the efficiency of the algorithm.</p> <p>Why is the \\(\\Theta\\) symbol rarely seen?</p> <p>Possibly because the \\(O\\) notation is more commonly spoken, it is often used to represent the average time complexity. However, strictly speaking, this practice is not accurate. In this book and other materials, if you encounter statements like \"average time complexity \\(O(n)\\)\", please understand it directly as \\(\\Theta(n)\\).</p>"},{"location":"chapter_data_structure/","title":"Chapter 3. \u00a0 Data Structures","text":"<p>Abstract</p> <p>Data structures serve as a robust and diverse framework.</p> <p>They offer a blueprint for the orderly organization of data, upon which algorithms come to life.</p>"},{"location":"chapter_data_structure/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>3.1 \u00a0 Classification of Data Structures</li> <li>3.2 \u00a0 Fundamental Data Types</li> <li>3.3 \u00a0 Number Encoding *</li> <li>3.4 \u00a0 Character Encoding *</li> <li>3.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_data_structure/basic_data_types/","title":"3.2 \u00a0 Fundamental Data Types","text":"<p>When we think of data in computers, we imagine various forms like text, images, videos, voice, 3D models, etc. Despite their different organizational forms, they are all composed of various fundamental data types.</p> <p>Fundamental data types are those that the CPU can directly operate on and are directly used in algorithms, mainly including the following.</p> <ul> <li>Integer types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>.</li> <li>Floating-point types: <code>float</code>, <code>double</code>, used to represent decimals.</li> <li>Character type: <code>char</code>, used to represent letters, punctuation, and even emojis in various languages.</li> <li>Boolean type: <code>bool</code>, used for \"yes\" or \"no\" decisions.</li> </ul> <p>Fundamental data types are stored in computers in binary form. One binary digit is equal to 1 bit. In most modern operating systems, 1 byte consists of 8 bits.</p> <p>The range of values for fundamental data types depends on the size of the space they occupy. Below, we take Java as an example.</p> <ul> <li>The integer type <code>byte</code> occupies 1 byte = 8 bits and can represent \\(2^8\\) numbers.</li> <li>The integer type <code>int</code> occupies 4 bytes = 32 bits and can represent \\(2^{32}\\) numbers.</li> </ul> <p>The following table lists the space occupied, value range, and default values of various fundamental data types in Java. This table does not need to be memorized, but understood roughly and referred to when needed.</p> <p> Table 3-1 \u00a0 Space Occupied and Value Range of Fundamental Data Types </p> Type Symbol Space Occupied Minimum Value Maximum Value Default Value Integer <code>byte</code> 1 byte \\(-2^7\\) (\\(-128\\)) \\(2^7 - 1\\) (\\(127\\)) 0 <code>short</code> 2 bytes \\(-2^{15}\\) \\(2^{15} - 1\\) 0 <code>int</code> 4 bytes \\(-2^{31}\\) \\(2^{31} - 1\\) 0 <code>long</code> 8 bytes \\(-2^{63}\\) \\(2^{63} - 1\\) 0 Float <code>float</code> 4 bytes \\(1.175 \\times 10^{-38}\\) \\(3.403 \\times 10^{38}\\) \\(0.0\\text{f}\\) <code>double</code> 8 bytes \\(2.225 \\times 10^{-308}\\) \\(1.798 \\times 10^{308}\\) 0.0 Char <code>char</code> 2 bytes 0 \\(2^{16} - 1\\) 0 Boolean <code>bool</code> 1 byte \\(\\text{false}\\) \\(\\text{true}\\) \\(\\text{false}\\) <p>Please note that the above table is specific to Java's fundamental data types. Each programming language has its own data type definitions, and their space occupied, value ranges, and default values may differ.</p> <ul> <li>In Python, the integer type <code>int</code> can be of any size, limited only by available memory; the floating-point <code>float</code> is double precision 64-bit; there is no <code>char</code> type, as a single character is actually a string <code>str</code> of length 1.</li> <li>C and C++ do not specify the size of fundamental data types, which varies with implementation and platform. The above table follows the LP64 data model, used for Unix 64-bit operating systems including Linux and macOS.</li> <li>The size of <code>char</code> in C and C++ is 1 byte, while in most programming languages, it depends on the specific character encoding method, as detailed in the \"Character Encoding\" chapter.</li> <li>Even though representing a boolean only requires 1 bit (0 or 1), it is usually stored in memory as 1 byte. This is because modern computer CPUs typically use 1 byte as the smallest addressable memory unit.</li> </ul> <p>So, what is the connection between fundamental data types and data structures? We know that data structures are ways to organize and store data in computers. The focus here is on \"structure\" rather than \"data\".</p> <p>If we want to represent \"a row of numbers\", we naturally think of using an array. This is because the linear structure of an array can represent the adjacency and order of numbers, but whether the stored content is an integer <code>int</code>, a decimal <code>float</code>, or a character <code>char</code>, is irrelevant to the \"data structure\".</p> <p>In other words, fundamental data types provide the \"content type\" of data, while data structures provide the \"way of organizing\" data. For example, in the following code, we use the same data structure (array) to store and represent different fundamental data types, including <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, etc.</p> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code># Using various fundamental data types to initialize arrays\nnumbers: list[int] = [0] * 5\ndecimals: list[float] = [0.0] * 5\n# Python's characters are actually strings of length 1\ncharacters: list[str] = ['0'] * 5\nbools: list[bool] = [False] * 5\n# Python's lists can freely store various fundamental data types and object references\ndata = [0, 0.0, 'a', False, ListNode(0)]\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nint numbers[5];\nfloat decimals[5];\nchar characters[5];\nbool bools[5];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nboolean[] bools = new boolean[5];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nbool[] bools = new bool[5];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nvar numbers = [5]int{}\nvar decimals = [5]float64{}\nvar characters = [5]byte{}\nvar bools = [5]bool{}\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nlet numbers = Array(repeating: Int(), count: 5)\nlet decimals = Array(repeating: Double(), count: 5)\nlet characters = Array(repeating: Character(\"a\"), count: 5)\nlet bools = Array(repeating: Bool(), count: 5)\n</code></pre> <pre><code>// JavaScript's arrays can freely store various fundamental data types and objects\nconst array = [0, 0.0, 'a', false];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nconst numbers: number[] = [];\nconst characters: string[] = [];\nconst bools: boolean[] = [];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nList&lt;int&gt; numbers = List.filled(5, 0);\nList&lt;double&gt; decimals = List.filled(5, 0.0);\nList&lt;String&gt; characters = List.filled(5, 'a');\nList&lt;bool&gt; bools = List.filled(5, false);\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nlet numbers: Vec&lt;i32&gt; = vec![0; 5];\nlet decimals: Vec&lt;f32&gt; = vec![0.0, 5];\nlet characters: Vec&lt;char&gt; = vec!['0'; 5];\nlet bools: Vec&lt;bool&gt; = vec![false; 5];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nint numbers[10];\nfloat decimals[10];\nchar characters[10];\nbool bools[10];\n</code></pre> <pre><code>// Using various fundamental data types to initialize arrays\nvar numbers: [5]i32 = undefined;\nvar decimals: [5]f32 = undefined;\nvar characters: [5]u8 = undefined;\nvar bools: [5]bool = undefined;\n</code></pre>"},{"location":"chapter_data_structure/character_encoding/","title":"3.4 \u00a0 Character Encoding *","text":"<p>In computers, all data is stored in binary form, and the character <code>char</code> is no exception. To represent characters, we need to establish a \"character set\" that defines a one-to-one correspondence between each character and binary numbers. With a character set, computers can convert binary numbers to characters by looking up a table.</p>"},{"location":"chapter_data_structure/character_encoding/#341-ascii-character-set","title":"3.4.1 \u00a0 ASCII Character Set","text":"<p>The \"ASCII code\" is one of the earliest character sets, officially known as the American Standard Code for Information Interchange. It uses 7 binary digits (the lower 7 bits of a byte) to represent a character, allowing for a maximum of 128 different characters. As shown in the Figure 3-6 , ASCII includes uppercase and lowercase English letters, numbers 0 ~ 9, some punctuation marks, and some control characters (such as newline and tab).</p> <p></p> <p> Figure 3-6 \u00a0 ASCII Code </p> <p>However, ASCII can only represent English characters. With the globalization of computers, a character set called \"EASCII\" was developed to represent more languages. It expands on the 7-bit basis of ASCII to 8 bits, enabling the representation of 256 different characters.</p> <p>Globally, a series of EASCII character sets for different regions emerged. The first 128 characters of these sets are uniformly ASCII, while the remaining 128 characters are defined differently to cater to various language requirements.</p>"},{"location":"chapter_data_structure/character_encoding/#342-gbk-character-set","title":"3.4.2 \u00a0 GBK Character Set","text":"<p>Later, it was found that EASCII still could not meet the character requirements of many languages. For instance, there are nearly a hundred thousand Chinese characters, with several thousand used in everyday life. In 1980, China's National Standards Bureau released the \"GB2312\" character set, which included 6763 Chinese characters, essentially meeting the computer processing needs for Chinese.</p> <p>However, GB2312 could not handle some rare and traditional characters. The \"GBK\" character set, an expansion of GB2312, includes a total of 21886 Chinese characters. In the GBK encoding scheme, ASCII characters are represented with one byte, while Chinese characters use two bytes.</p>"},{"location":"chapter_data_structure/character_encoding/#343-unicode-character-set","title":"3.4.3 \u00a0 Unicode Character Set","text":"<p>With the rapid development of computer technology and a plethora of character sets and encoding standards, numerous problems arose. On one hand, these character sets generally only defined characters for specific languages and could not function properly in multilingual environments. On the other hand, the existence of multiple character set standards for the same language caused garbled text when information was exchanged between computers using different encoding standards.</p> <p>Researchers of that era thought: What if we introduced a comprehensive character set that included all languages and symbols worldwide, wouldn't that solve the problems of cross-language environments and garbled text? Driven by this idea, the extensive character set, Unicode, was born.</p> <p>The Chinese name for \"Unicode\" is \"\u7edf\u4e00\u7801\" (Unified Code), theoretically capable of accommodating over a million characters. It aims to incorporate characters from all over the world into a single set, providing a universal character set for processing and displaying various languages and reducing the issues of garbled text due to different encoding standards.</p> <p>Since its release in 1991, Unicode has continually expanded to include new languages and characters. As of September 2022, Unicode contains 149,186 characters, including characters, symbols, and even emojis from various languages. In the vast Unicode character set, commonly used characters occupy 2 bytes, while some rare characters take up 3 or even 4 bytes.</p> <p>Unicode is a universal character set that assigns a number (called a \"code point\") to each character, but it does not specify how these character code points should be stored in a computer. One might ask: When Unicode code points of varying lengths appear in a text, how does the system parse the characters? For example, given a 2-byte code, how does the system determine if it represents a single 2-byte character or two 1-byte characters?</p> <p>A straightforward solution to this problem is to store all characters as equal-length encodings. As shown in the Figure 3-7 , each character in \"Hello\" occupies 1 byte, while each character in \"\u7b97\u6cd5\" (algorithm) occupies 2 bytes. We could encode all characters in \"Hello \u7b97\u6cd5\" as 2 bytes by padding the higher bits with zeros. This way, the system can parse a character every 2 bytes, recovering the content of the phrase.</p> <p></p> <p> Figure 3-7 \u00a0 Unicode Encoding Example </p> <p>However, as ASCII has shown us, encoding English only requires 1 byte. Using the above approach would double the space occupied by English text compared to ASCII encoding, which is a waste of memory space. Therefore, a more efficient Unicode encoding method is needed.</p>"},{"location":"chapter_data_structure/character_encoding/#344-utf-8-encoding","title":"3.4.4 \u00a0 UTF-8 Encoding","text":"<p>Currently, UTF-8 has become the most widely used Unicode encoding method internationally. It is a variable-length encoding, using 1 to 4 bytes to represent a character, depending on the complexity of the character. ASCII characters need only 1 byte, Latin and Greek letters require 2 bytes, commonly used Chinese characters need 3 bytes, and some other rare characters need 4 bytes.</p> <p>The encoding rules for UTF-8 are not complex and can be divided into two cases:</p> <ul> <li>For 1-byte characters, set the highest bit to \\(0\\), and the remaining 7 bits to the Unicode code point. Notably, ASCII characters occupy the first 128 code points in the Unicode set. This means that UTF-8 encoding is backward compatible with ASCII. This implies that UTF-8 can be used to parse ancient ASCII text.</li> <li>For characters of length \\(n\\) bytes (where \\(n &gt; 1\\)), set the highest \\(n\\) bits of the first byte to \\(1\\), and the \\((n + 1)^{\\text{th}}\\) bit to \\(0\\); starting from the second byte, set the highest 2 bits of each byte to \\(10\\); the rest of the bits are used to fill the Unicode code point.</li> </ul> <p>The Figure 3-8  shows the UTF-8 encoding for \"Hello\u7b97\u6cd5\". It can be observed that since the highest \\(n\\) bits are set to \\(1\\), the system can determine the length of the character as \\(n\\) by counting the number of highest bits set to \\(1\\).</p> <p>But why set the highest 2 bits of the remaining bytes to \\(10\\)? Actually, this \\(10\\) serves as a kind of checksum. If the system starts parsing text from an incorrect byte, the \\(10\\) at the beginning of the byte can help the system quickly detect an anomaly.</p> <p>The reason for using \\(10\\) as a checksum is that, under UTF-8 encoding rules, it's impossible for the highest two bits of a character to be \\(10\\). This can be proven by contradiction: If the highest two bits of a character are \\(10\\), it indicates that the character's length is \\(1\\), corresponding to ASCII. However, the highest bit of an ASCII character should be \\(0\\), contradicting the assumption.</p> <p></p> <p> Figure 3-8 \u00a0 UTF-8 Encoding Example </p> <p>Apart from UTF-8, other common encoding methods include:</p> <ul> <li>UTF-16 Encoding: Uses 2 or 4 bytes to represent a character. All ASCII characters and commonly used non-English characters are represented with 2 bytes; a few characters require 4 bytes. For 2-byte characters, the UTF-16 encoding is equal to the Unicode code point.</li> <li>UTF-32 Encoding: Every character uses 4 bytes. This means UTF-32 occupies more space than UTF-8 and UTF-16, especially for texts with a high proportion of ASCII characters.</li> </ul> <p>From the perspective of storage space, UTF-8 is highly efficient for representing English characters, requiring only 1 byte; UTF-16 might be more efficient for encoding some non-English characters (like Chinese), as it requires only 2 bytes, while UTF-8 might need 3 bytes.</p> <p>From a compatibility standpoint, UTF-8 is the most versatile, with many tools and libraries supporting UTF-8 as a priority.</p>"},{"location":"chapter_data_structure/character_encoding/#345-character-encoding-in-programming-languages","title":"3.4.5 \u00a0 Character Encoding in Programming Languages","text":"<p>In many classic programming languages, strings during program execution are encoded using fixed-length encodings like UTF-16 or UTF-32. This allows strings to be treated as arrays, offering several advantages:</p> <ul> <li>Random Access: Strings encoded in UTF-16 can be accessed randomly with ease. For UTF-8, which is a variable-length encoding, locating the \\(i^{th}\\) character requires traversing the string from the start to the \\(i^{th}\\) position, taking \\(O(n)\\) time.</li> <li>Character Counting: Similar to random access, counting the number of characters in a UTF-16 encoded string is an \\(O(1)\\) operation. However, counting characters in a UTF-8 encoded string requires traversing the entire string.</li> <li>String Operations: Many string operations like splitting, concatenating, inserting, and deleting are easier on UTF-16 encoded strings. These operations generally require additional computation on UTF-8 encoded strings to ensure the validity of the UTF-8 encoding.</li> </ul> <p>The design of character encoding schemes in programming languages is an interesting topic involving various factors:</p> <ul> <li>Java\u2019s <code>String</code> type uses UTF-16 encoding, with each character occupying 2 bytes. This was based on the initial belief that 16 bits were sufficient to represent all possible characters, a judgment later proven incorrect. As the Unicode standard expanded beyond 16 bits, characters in Java may now be represented by a pair of 16-bit values, known as \u201csurrogate pairs.\u201d</li> <li>JavaScript and TypeScript use UTF-16 encoding for similar reasons as Java. When JavaScript was first introduced by Netscape in 1995, Unicode was still in its early stages, and 16-bit encoding was sufficient to represent all Unicode characters.</li> <li>C# uses UTF-16 encoding, largely because the .NET platform, designed by Microsoft, and many Microsoft technologies, including the Windows operating system, extensively use UTF-16 encoding.</li> </ul> <p>Due to the underestimation of character counts, these languages had to resort to using \"surrogate pairs\" to represent Unicode characters exceeding 16 bits. This approach has its drawbacks: strings containing surrogate pairs may have characters occupying 2 or 4 bytes, losing the advantage of fixed-length encoding, and handling surrogate pairs adds to the complexity and debugging difficulty of programming.</p> <p>Owing to these reasons, some programming languages have adopted different encoding schemes:</p> <ul> <li>Python\u2019s <code>str</code> type uses Unicode encoding with a flexible representation where the storage length of characters depends on the largest Unicode code point in the string. If all characters are ASCII, each character occupies 1 byte; if characters exceed ASCII but are within the Basic Multilingual Plane (BMP), each occupies 2 bytes; if characters exceed the BMP, each occupies 4 bytes.</li> <li>Go\u2019s <code>string</code> type internally uses UTF-8 encoding. Go also provides the <code>rune</code> type for representing individual Unicode code points.</li> <li>Rust\u2019s <code>str</code> and <code>String</code> types use UTF-8 encoding internally. Rust also offers the <code>char</code> type for individual Unicode code points.</li> </ul> <p>It\u2019s important to note that the above discussion pertains to how strings are stored in programming languages, which is a different issue from how strings are stored in files or transmitted over networks. For file storage or network transmission, strings are usually encoded in UTF-8 format for optimal compatibility and space efficiency.</p>"},{"location":"chapter_data_structure/classification_of_data_structure/","title":"3.1 \u00a0 Classification of Data Structures","text":"<p>Common data structures include arrays, linked lists, stacks, queues, hash tables, trees, heaps, and graphs. They can be classified into \"logical structure\" and \"physical structure\".</p>"},{"location":"chapter_data_structure/classification_of_data_structure/#311-logical-structure-linear-and-non-linear","title":"3.1.1 \u00a0 Logical Structure: Linear and Non-Linear","text":"<p>The logical structures reveal the logical relationships between data elements. In arrays and linked lists, data are arranged in a specific sequence, demonstrating the linear relationship between data; while in trees, data are arranged hierarchically from the top down, showing the derived relationship between \"ancestors\" and \"descendants\"; and graphs are composed of nodes and edges, reflecting the intricate network relationship.</p> <p>As shown in the Figure 3-1 , logical structures can be divided into two major categories: \"linear\" and \"non-linear\". Linear structures are more intuitive, indicating data is arranged linearly in logical relationships; non-linear structures, conversely, are arranged non-linearly.</p> <ul> <li>Linear Data Structures: Arrays, Linked Lists, Stacks, Queues, Hash Tables.</li> <li>Non-Linear Data Structures: Trees, Heaps, Graphs, Hash Tables.</li> </ul> <p></p> <p> Figure 3-1 \u00a0 Linear and Non-Linear Data Structures </p> <p>Non-linear data structures can be further divided into tree structures and network structures.</p> <ul> <li>Linear Structures: Arrays, linked lists, queues, stacks, and hash tables, where elements have a one-to-one sequential relationship.</li> <li>Tree Structures: Trees, Heaps, Hash Tables, where elements have a one-to-many relationship.</li> <li>Network Structures: Graphs, where elements have a many-to-many relationships.</li> </ul>"},{"location":"chapter_data_structure/classification_of_data_structure/#312-physical-structure-contiguous-and-dispersed","title":"3.1.2 \u00a0 Physical Structure: Contiguous and Dispersed","text":"<p>During the execution of an algorithm, the data being processed is stored in memory. The Figure 3-2  shows a computer memory stick where each black square is a physical memory space. We can think of memory as a vast Excel spreadsheet, with each cell capable of storing a certain amount of data.</p> <p>The system accesses the data at the target location by means of a memory address. As shown in the Figure 3-2 , the computer assigns a unique identifier to each cell in the table according to specific rules, ensuring that each memory space has a unique memory address. With these addresses, the program can access the data stored in memory.</p> <p></p> <p> Figure 3-2 \u00a0 Memory Stick, Memory Spaces, Memory Addresses </p> <p>Tip</p> <p>It's worth noting that comparing memory to an Excel spreadsheet is a simplified analogy. The actual working mechanism of memory is more complex, involving concepts like address space, memory management, cache mechanisms, virtual memory, and physical memory.</p> <p>Memory is a shared resource for all programs. When a block of memory is occupied by one program, it cannot be simultaneously used by other programs. Therefore, considering memory resources is crucial in designing data structures and algorithms. For instance, the algorithm's peak memory usage should not exceed the remaining free memory of the system; if there is a lack of contiguous memory blocks, then the data structure chosen must be able to be stored in non-contiguous memory blocks.</p> <p>As illustrated in the Figure 3-3 , the physical structure reflects the way data is stored in computer memory and it can be divided into contiguous space storage (arrays) and non-contiguous space storage (linked lists). The two types of physical structures exhibit complementary characteristics in terms of time efficiency and space efficiency.</p> <p></p> <p> Figure 3-3 \u00a0 Contiguous Space Storage and Dispersed Space Storage </p> <p>It is worth noting that all data structures are implemented based on arrays, linked lists, or a combination of both. For example, stacks and queues can be implemented using either arrays or linked lists; while implementations of hash tables may involve both arrays and linked lists. - Array-based implementations: Stacks, Queues, Hash Tables, Trees, Heaps, Graphs, Matrices, Tensors (arrays with dimensions \\(\\geq 3\\)). - Linked-list-based implementations: Stacks, Queues, Hash Tables, Trees, Heaps, Graphs, etc.</p> <p>Data structures implemented based on arrays are also called \u201cStatic Data Structures,\u201d meaning their length cannot be changed after initialization. Conversely, those based on linked lists are called \u201cDynamic Data Structures,\u201d which can still adjust their size during program execution.</p> <p>Tip</p> <p>If you find it challenging to comprehend the physical structure, it is recommended that you read the next chapter, \"Arrays and Linked Lists,\" and revisit this section later.</p>"},{"location":"chapter_data_structure/number_encoding/","title":"3.3 \u00a0 Number Encoding *","text":"<p>Note</p> <p>In this book, chapters marked with an * symbol are optional reads. If you are short on time or find them challenging, you may skip these initially and return to them after completing the essential chapters.</p>"},{"location":"chapter_data_structure/number_encoding/#331-integer-encoding","title":"3.3.1 \u00a0 Integer Encoding","text":"<p>In the table from the previous section, we noticed that all integer types can represent one more negative number than positive numbers, such as the <code>byte</code> range of \\([-128, 127]\\). This phenomenon, somewhat counterintuitive, is rooted in the concepts of sign-magnitude, one's complement, and two's complement encoding.</p> <p>Firstly, it's important to note that numbers are stored in computers using the two's complement form. Before analyzing why this is the case, let's define these three encoding methods:</p> <ul> <li>Sign-magnitude: The highest bit of a binary representation of a number is considered the sign bit, where \\(0\\) represents a positive number and \\(1\\) represents a negative number. The remaining bits represent the value of the number.</li> <li>One's complement: The one's complement of a positive number is the same as its sign-magnitude. For negative numbers, it's obtained by inverting all bits except the sign bit.</li> <li>Two's complement: The two's complement of a positive number is the same as its sign-magnitude. For negative numbers, it's obtained by adding \\(1\\) to their one's complement.</li> </ul> <p>The following diagram illustrates the conversions among sign-magnitude, one's complement, and two's complement:</p> <p></p> <p> Figure 3-4 \u00a0 Conversions between Sign-Magnitude, One's Complement, and Two's Complement </p> <p>Although sign-magnitude is the most intuitive, it has limitations. For one, negative numbers in sign-magnitude cannot be directly used in calculations. For example, in sign-magnitude, calculating \\(1 + (-2)\\) results in \\(-3\\), which is incorrect.</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 + 1000 \\; 0010 \\newline &amp; = 1000 \\; 0011 \\newline &amp; \\rightarrow -3 \\end{aligned} \\] <p>To address this, computers introduced the one's complement. If we convert to one's complement and calculate \\(1 + (-2)\\), then convert the result back to sign-magnitude, we get the correct result of \\(-1\\).</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 \\; \\text{(Sign-magnitude)} + 1000 \\; 0010 \\; \\text{(Sign-magnitude)} \\newline &amp; = 0000 \\; 0001 \\; \\text{(One's complement)} + 1111 \\; 1101 \\; \\text{(One's complement)} \\newline &amp; = 1111 \\; 1110 \\; \\text{(One's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; \\rightarrow -1 \\end{aligned} \\] <p>Additionally, there are two representations of zero in sign-magnitude: \\(+0\\) and \\(-0\\). This means two different binary encodings for zero, which could lead to ambiguity. For example, in conditional checks, not differentiating between positive and negative zero might result in incorrect outcomes. Addressing this ambiguity would require additional checks, potentially reducing computational efficiency.</p> \\[ \\begin{aligned} +0 &amp; \\rightarrow 0000 \\; 0000 \\newline -0 &amp; \\rightarrow 1000 \\; 0000 \\end{aligned} \\] <p>Like sign-magnitude, one's complement also suffers from the positive and negative zero ambiguity. Therefore, computers further introduced the two's complement. Let's observe the conversion process for negative zero in sign-magnitude, one's complement, and two's complement:</p> \\[ \\begin{aligned} -0 \\rightarrow \\; &amp; 1000 \\; 0000 \\; \\text{(Sign-magnitude)} \\newline = \\; &amp; 1111 \\; 1111 \\; \\text{(One's complement)} \\newline = 1 \\; &amp; 0000 \\; 0000 \\; \\text{(Two's complement)} \\newline \\end{aligned} \\] <p>Adding \\(1\\) to the one's complement of negative zero produces a carry, but with <code>byte</code> length being only 8 bits, the carried-over \\(1\\) to the 9<sup>th</sup> bit is discarded. Therefore, the two's complement of negative zero is \\(0000 \\; 0000\\), the same as positive zero, thus resolving the ambiguity.</p> <p>One last puzzle is the \\([-128, 127]\\) range for <code>byte</code>, with an additional negative number, \\(-128\\). We observe that for the interval \\([-127, +127]\\), all integers have corresponding sign-magnitude, one's complement, and two's complement, and these can be converted between each other.</p> <p>However, the two's complement \\(1000 \\; 0000\\) is an exception without a corresponding sign-magnitude. According to the conversion method, its sign-magnitude would be \\(0000 \\; 0000\\), which is a contradiction since this represents zero, and its two's complement should be itself. Computers designate this special two's complement \\(1000 \\; 0000\\) as representing \\(-128\\). In fact, the calculation of \\((-1) + (-127)\\) in two's complement results in \\(-128\\).</p> \\[ \\begin{aligned} &amp; (-127) + (-1) \\newline &amp; \\rightarrow 1111 \\; 1111 \\; \\text{(Sign-magnitude)} + 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(One's complement)} + 1111 \\; 1110 \\; \\text{(One's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(Two's complement)} + 1111 \\; 1111 \\; \\text{(Two's complement)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(Two's complement)} \\newline &amp; \\rightarrow -128 \\end{aligned} \\] <p>As you might have noticed, all these calculations are additions, hinting at an important fact: computers' internal hardware circuits are primarily designed around addition operations. This is because addition is simpler to implement in hardware compared to other operations like multiplication, division, and subtraction, allowing for easier parallelization and faster computation.</p> <p>It's important to note that this doesn't mean computers can only perform addition. By combining addition with basic logical operations, computers can execute a variety of other mathematical operations. For example, the subtraction \\(a - b\\) can be translated into \\(a + (-b)\\); multiplication and division can be translated into multiple additions or subtractions.</p> <p>We can now summarize the reason for using two's complement in computers: with two's complement representation, computers can use the same circuits and operations to handle both positive and negative number addition, eliminating the need for special hardware circuits for subtraction and avoiding the ambiguity of positive and negative zero. This greatly simplifies hardware design and enhances computational efficiency.</p> <p>The design of two's complement is quite ingenious, and due to space constraints, we'll stop here. Interested readers are encouraged to explore further.</p>"},{"location":"chapter_data_structure/number_encoding/#332-floating-point-number-encoding","title":"3.3.2 \u00a0 Floating-Point Number Encoding","text":"<p>You might have noticed something intriguing: despite having the same length of 4 bytes, why does a <code>float</code> have a much larger range of values compared to an <code>int</code>? This seems counterintuitive, as one would expect the range to shrink for <code>float</code> since it needs to represent fractions.</p> <p>In fact, this is due to the different representation method used by floating-point numbers (<code>float</code>). Let's consider a 32-bit binary number as:</p> \\[ b_{31} b_{30} b_{29} \\ldots b_2 b_1 b_0 \\] <p>According to the IEEE 754 standard, a 32-bit <code>float</code> consists of the following three parts:</p> <ul> <li>Sign bit \\(\\mathrm{S}\\): Occupies 1 bit, corresponding to \\(b_{31}\\).</li> <li>Exponent bit \\(\\mathrm{E}\\): Occupies 8 bits, corresponding to \\(b_{30} b_{29} \\ldots b_{23}\\).</li> <li>Fraction bit \\(\\mathrm{N}\\): Occupies 23 bits, corresponding to \\(b_{22} b_{21} \\ldots b_0\\).</li> </ul> <p>The value of a binary <code>float</code> number is calculated as:</p> \\[ \\text{val} = (-1)^{b_{31}} \\times 2^{\\left(b_{30} b_{29} \\ldots b_{23}\\right)_2 - 127} \\times \\left(1 . b_{22} b_{21} \\ldots b_0\\right)_2 \\] <p>Converted to a decimal formula, this becomes:</p> \\[ \\text{val} = (-1)^{\\mathrm{S}} \\times 2^{\\mathrm{E} - 127} \\times (1 + \\mathrm{N}) \\] <p>The range of each component is:</p> \\[ \\begin{aligned} \\mathrm{S} \\in &amp; \\{ 0, 1\\}, \\quad \\mathrm{E} \\in \\{ 1, 2, \\dots, 254 \\} \\newline (1 + \\mathrm{N}) = &amp; (1 + \\sum_{i=1}^{23} b_{23-i} \\times 2^{-i}) \\subset [1, 2 - 2^{-23}] \\end{aligned} \\] <p></p> <p> Figure 3-5 \u00a0 Example Calculation of a float in IEEE 754 Standard </p> <p>Observing the diagram, given an example data \\(\\mathrm{S} = 0\\), \\(\\mathrm{E} = 124\\), \\(\\mathrm{N} = 2^{-2} + 2^{-3} = 0.375\\), we have:</p> \\[ \\text{val} = (-1)^0 \\times 2^{124 - 127} \\times (1 + 0.375) = 0.171875 \\] <p>Now we can answer the initial question: The representation of <code>float</code> includes an exponent bit, leading to a much larger range than <code>int</code>. Based on the above calculation, the maximum positive number representable by <code>float</code> is approximately \\(2^{254 - 127} \\times (2 - 2^{-23}) \\approx 3.4 \\times 10^{38}\\), and the minimum negative number is obtained by switching the sign bit.</p> <p>However, the trade-off for <code>float</code>'s expanded range is a sacrifice in precision. The integer type <code>int</code> uses all 32 bits to represent the number, with values evenly distributed; but due to the exponent bit, the larger the value of a <code>float</code>, the greater the difference between adjacent numbers.</p> <p>As shown in the Table 3-2 , exponent bits \\(E = 0\\) and \\(E = 255\\) have special meanings, used to represent zero, infinity, \\(\\mathrm{NaN}\\), etc.</p> <p> Table 3-2 \u00a0 Meaning of Exponent Bits </p> Exponent Bit E Fraction Bit \\(\\mathrm{N} = 0\\) Fraction Bit \\(\\mathrm{N} \\ne 0\\) Calculation Formula \\(0\\) \\(\\pm 0\\) Subnormal Numbers \\((-1)^{\\mathrm{S}} \\times 2^{-126} \\times (0.\\mathrm{N})\\) \\(1, 2, \\dots, 254\\) Normal Numbers Normal Numbers \\((-1)^{\\mathrm{S}} \\times 2^{(\\mathrm{E} -127)} \\times (1.\\mathrm{N})\\) \\(255\\) \\(\\pm \\infty\\) \\(\\mathrm{NaN}\\) <p>It's worth noting that subnormal numbers significantly improve the precision of floating-point numbers. The smallest positive normal number is \\(2^{-126}\\), and the smallest positive subnormal number is \\(2^{-126} \\times 2^{-23}\\).</p> <p>Double-precision <code>double</code> also uses a similar representation method to <code>float</code>, which is not elaborated here for brevity.</p>"},{"location":"chapter_data_structure/summary/","title":"3.5 \u00a0 Summary","text":""},{"location":"chapter_data_structure/summary/#1-key-review","title":"1. \u00a0 Key Review","text":"<ul> <li>Data structures can be categorized from two perspectives: logical structure and physical structure. Logical structure describes the logical relationships between data elements, while physical structure describes how data is stored in computer memory.</li> <li>Common logical structures include linear, tree-like, and network structures. We generally classify data structures into linear (arrays, linked lists, stacks, queues) and non-linear (trees, graphs, heaps) based on their logical structure. The implementation of hash tables may involve both linear and non-linear data structures.</li> <li>When a program runs, data is stored in computer memory. Each memory space has a corresponding memory address, and the program accesses data through these addresses.</li> <li>Physical structures are primarily divided into contiguous space storage (arrays) and dispersed space storage (linked lists). All data structures are implemented using arrays, linked lists, or a combination of both.</li> <li>Basic data types in computers include integers (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>), floating-point numbers (<code>float</code>, <code>double</code>), characters (<code>char</code>), and booleans (<code>boolean</code>). Their range depends on the size of the space occupied and the representation method.</li> <li>Original code, complement code, and two's complement code are three methods of encoding numbers in computers, and they can be converted into each other. The highest bit of the original code of an integer is the sign bit, and the remaining bits represent the value of the number.</li> <li>Integers are stored in computers in the form of two's complement. In this representation, the computer can treat the addition of positive and negative numbers uniformly, without the need for special hardware circuits for subtraction, and there is no ambiguity of positive and negative zero.</li> <li>The encoding of floating-point numbers consists of 1 sign bit, 8 exponent bits, and 23 fraction bits. Due to the presence of the exponent bit, the range of floating-point numbers is much greater than that of integers, but at the cost of sacrificing precision.</li> <li>ASCII is the earliest English character set, 1 byte in length, and includes 127 characters. The GBK character set is a commonly used Chinese character set, including more than 20,000 Chinese characters. Unicode strives to provide a complete character set standard, including characters from various languages worldwide, thus solving the problem of garbled characters caused by inconsistent character encoding methods.</li> <li>UTF-8 is the most popular Unicode encoding method, with excellent universality. It is a variable-length encoding method with good scalability and effectively improves the efficiency of space usage. UTF-16 and UTF-32 are fixed-length encoding methods. When encoding Chinese characters, UTF-16 occupies less space than UTF-8. Programming languages like Java and C# use UTF-16 encoding by default.</li> </ul>"},{"location":"chapter_data_structure/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Why does a hash table contain both linear and non-linear data structures?</p> <p>The underlying structure of a hash table is an array. To resolve hash collisions, we may use \"chaining\": each bucket in the array points to a linked list, which, when exceeding a certain threshold, might be transformed into a tree (usually a red-black tree). From a storage perspective, the foundation of a hash table is an array, where each bucket slot might contain a value, a linked list, or a tree. Therefore, hash tables may contain both linear data structures (arrays, linked lists) and non-linear data structures (trees).</p> <p>Is the length of the <code>char</code> type 1 byte?</p> <p>The length of the <code>char</code> type is determined by the encoding method used by the programming language. For example, Java, JavaScript, TypeScript, and C# all use UTF-16 encoding (to save Unicode code points), so the length of the char type is 2 bytes.</p> <p>Is there ambiguity in calling data structures based on arrays 'static data structures'? Because operations like push and pop on stacks are 'dynamic.'</p> <p>While stacks indeed allow for dynamic data operations, the data structure itself remains \"static\" (with unchangeable length). Even though data structures based on arrays can dynamically add or remove elements, their capacity is fixed. If the data volume exceeds the pre-allocated size, a new, larger array needs to be created, and the contents of the old array copied into it.</p> <p>When building stacks (queues) without specifying their size, why are they considered 'static data structures'?</p> <p>In high-level programming languages, we don't need to manually specify the initial capacity of stacks (queues); this task is automatically handled internally by the class. For example, the initial capacity of Java's ArrayList is usually 10. Furthermore, the expansion operation is also implemented automatically. See the subsequent \"List\" chapter for details.</p>"},{"location":"chapter_introduction/","title":"Chapter 1. \u00a0 Introduction to Algorithms","text":"<p>Abstract</p> <p>A graceful maiden dances, intertwined with the data, her skirt swaying to the melody of algorithms.</p> <p>She invites you to a dance, follow her steps, and enter the world of algorithms full of logic and beauty.</p>"},{"location":"chapter_introduction/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>1.1 \u00a0 Algorithms are Everywhere</li> <li>1.2 \u00a0 What is an Algorithm</li> <li>1.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_introduction/algorithms_are_everywhere/","title":"1.1 \u00a0 Algorithms are Everywhere","text":"<p>When we hear the word \"algorithm,\" we naturally think of mathematics. However, many algorithms do not involve complex mathematics but rely more on basic logic, which can be seen everywhere in our daily lives.</p> <p>Before formally discussing algorithms, there's an interesting fact worth sharing: you have already unconsciously learned many algorithms and have become accustomed to applying them in your daily life. Here, I will give a few specific examples to prove this point.</p> <p>Example 1: Looking Up a Dictionary. In an English dictionary, words are listed alphabetically. Suppose we're searching for a word that starts with the letter \\(r\\). This is typically done in the following way:</p> <ol> <li>Open the dictionary to about halfway and check the first letter on the page, let's say the letter is \\(m\\).</li> <li>Since \\(r\\) comes after \\(m\\) in the alphabet, we can ignore the first half of the dictionary and focus on the latter half.</li> <li>Repeat steps <code>1.</code> and <code>2.</code> until you find the page where the word starts with \\(r\\).</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 1-1 \u00a0 Process of Looking Up a Dictionary </p> <p>This essential skill for elementary students, looking up a dictionary, is actually the famous \"Binary Search\" algorithm. From a data structure perspective, we can consider the dictionary as a sorted \"array\"; from an algorithmic perspective, the series of actions taken to look up a word in the dictionary can be viewed as \"Binary Search.\"</p> <p>Example 2: Organizing Playing Cards. When playing cards, we need to arrange the cards in our hand in ascending order, as shown in the following process.</p> <ol> <li>Divide the playing cards into \"ordered\" and \"unordered\" sections, assuming initially the leftmost card is already in order.</li> <li>Take out a card from the unordered section and insert it into the correct position in the ordered section; after this, the leftmost two cards are in order.</li> <li>Continue to repeat step <code>2.</code> until all cards are in order.</li> </ol> <p></p> <p> Figure 1-2 \u00a0 Playing Cards Sorting Process </p> <p>The above method of organizing playing cards is essentially the \"Insertion Sort\" algorithm, which is very efficient for small datasets. Many programming languages' sorting functions include the insertion sort.</p> <p>Example 3: Making Change. Suppose we buy goods worth \\(69\\) yuan at a supermarket and give the cashier \\(100\\) yuan, then the cashier needs to give us \\(31\\) yuan in change. They would naturally complete the thought process as shown below.</p> <ol> <li>The options are currencies smaller than \\(31\\), including \\(1\\), \\(5\\), \\(10\\), and \\(20\\).</li> <li>Take out the largest \\(20\\) from the options, leaving \\(31 - 20 = 11\\).</li> <li>Take out the largest \\(10\\) from the remaining options, leaving \\(11 - 10 = 1\\).</li> <li>Take out the largest \\(1\\) from the remaining options, leaving \\(1 - 1 = 0\\).</li> <li>Complete the change-making, with the solution being \\(20 + 10 + 1 = 31\\).</li> </ol> <p></p> <p> Figure 1-3 \u00a0 Change making process </p> <p>In the above steps, we make the best choice at each step (using the largest denomination possible), ultimately resulting in a feasible change-making plan. From the perspective of data structures and algorithms, this method is essentially a \"Greedy\" algorithm.</p> <p>From cooking a meal to interstellar travel, almost all problem-solving involves algorithms. The advent of computers allows us to store data structures in memory and write code to call the CPU and GPU to execute algorithms. In this way, we can transfer real-life problems to computers, solving various complex issues more efficiently.</p> <p>Tip</p> <p>If concepts such as data structures, algorithms, arrays, and binary search still seem somewhat obsecure, I encourage you to continue reading. This book will gently guide you into the realm of understanding data structures and algorithms.</p>"},{"location":"chapter_introduction/summary/","title":"1.3 \u00a0 Summary","text":"<ul> <li>Algorithms are ubiquitous in daily life and are not as inaccessible and complex as they might seem. In fact, we have already unconsciously learned many algorithms to solve various problems in life.</li> <li>The principle of looking up a word in a dictionary is consistent with the binary search algorithm. The binary search algorithm embodies the important algorithmic concept of divide and conquer.</li> <li>The process of organizing playing cards is very similar to the insertion sort algorithm. The insertion sort algorithm is suitable for sorting small datasets.</li> <li>The steps of making change in currency essentially follow the greedy algorithm, where each step involves making the best possible choice at the moment.</li> <li>An algorithm is a set of instructions or steps used to solve a specific problem within a finite amount of time, while a data structure is the way data is organized and stored in a computer.</li> <li>Data structures and algorithms are closely linked. Data structures are the foundation of algorithms, and algorithms are the stage to utilize the functions of data structures.</li> <li>We can liken data structures and algorithms to building blocks. The blocks represent data, the shape and connection method of the blocks represent data structures, and the steps of assembling the blocks correspond to algorithms.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/","title":"1.2 \u00a0 What is an Algorithm","text":""},{"location":"chapter_introduction/what_is_dsa/#121-definition-of-an-algorithm","title":"1.2.1 \u00a0 Definition of an Algorithm","text":"<p>An \"algorithm\" is a set of instructions or steps to solve a specific problem within a finite amount of time. It has the following characteristics:</p> <ul> <li>The problem is clearly defined, including unambiguous definitions of input and output.</li> <li>The algorithm is feasible, meaning it can be completed within a finite number of steps, time, and memory space.</li> <li>Each step has a definitive meaning. The output is consistently the same under the same inputs and conditions.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#122-definition-of-a-data-structure","title":"1.2.2 \u00a0 Definition of a Data Structure","text":"<p>A \"data structure\" is a way of organizing and storing data in a computer, with the following design goals:</p> <ul> <li>Minimize space occupancy to save computer memory.</li> <li>Make data operations as fast as possible, covering data access, addition, deletion, updating, etc.</li> <li>Provide concise data representation and logical information to enable efficient algorithm execution.</li> </ul> <p>Designing data structures is a balancing act, often requiring trade-offs. If you want to improve in one aspect, you often need to compromise in another. Here are two examples:</p> <ul> <li>Compared to arrays, linked lists offer more convenience in data addition and deletion but sacrifice data access speed.</li> <li>Graphs, compared to linked lists, provide richer logical information but require more memory space.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#123-relationship-between-data-structures-and-algorithms","title":"1.2.3 \u00a0 Relationship Between Data Structures and Algorithms","text":"<p>As shown in the Figure 1-4 , data structures and algorithms are highly related and closely integrated, specifically in the following three aspects:</p> <ul> <li>Data structures are the foundation of algorithms. They provide structured data storage and methods for manipulating data for algorithms.</li> <li>Algorithms are the stage where data structures come into play. The data structure alone only stores data information; it is through the application of algorithms that specific problems can be solved.</li> <li>Algorithms can often be implemented based on different data structures, but their execution efficiency can vary greatly. Choosing the right data structure is key.</li> </ul> <p></p> <p> Figure 1-4 \u00a0 Relationship between data structures and algorithms </p> <p>Data structures and algorithms can be likened to a set of building blocks, as illustrated in the Figure 1-5 . A building block set includes numerous pieces, accompanied by detailed assembly instructions. Following these instructions step by step allows us to construct an intricate block model.</p> <p></p> <p> Figure 1-5 \u00a0 Assembling blocks </p> <p>The detailed correspondence between the two is shown in the Table 1-1 .</p> <p> Table 1-1 \u00a0 Comparing Data Structures and Algorithms to Building Blocks </p> Data Structures and Algorithms Building Blocks Input data Unassembled blocks Data structure Organization of blocks, including shape, size, connections, etc Algorithm A series of steps to assemble the blocks into the desired shape Output data Completed Block model <p>It's worth noting that data structures and algorithms are independent of programming languages. For this reason, this book is able to provide implementations in multiple programming languages.</p> <p>Conventional Abbreviation</p> <p>In real-life discussions, we often refer to \"Data Structures and Algorithms\" simply as \"Algorithms\". For example, the well-known LeetCode algorithm problems actually test both data structure and algorithm knowledge.</p>"},{"location":"chapter_preface/","title":"Chapter 0. \u00a0 Preface","text":"<p>Abstract</p> <p>Algorithms are like a beautiful symphony, with each line of code flowing like a rhythm.</p> <p>May this book ring softly in your mind, leaving a unique and profound melody.</p>"},{"location":"chapter_preface/#chapter-contents","title":"Chapter Contents","text":"<ul> <li>0.1 \u00a0 About This Book</li> <li>0.2 \u00a0 How to Read</li> <li>0.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_preface/about_the_book/","title":"0.1 \u00a0 About This Book","text":"<p>This open-source project aims to create a free, and beginner-friendly crash course on data structures and algorithms.</p> <ul> <li>Using animated illustrations, it delivers structured insights into data structures and algorithmic concepts, ensuring comprehensibility and a smooth learning curve.</li> <li>Run code with just one click, supporting Java, C++, Python, Go, JS, TS, C#, Swift, Rust, Dart, Zig and other languages.</li> <li>Readers are encouraged to engage with each other in the discussion area for each section, questions and comments are usually answered within two days.</li> </ul>"},{"location":"chapter_preface/about_the_book/#011-target-audience","title":"0.1.1 \u00a0 Target Audience","text":"<p>If you are new to algorithms with limited exposure, or you have accumulated some experience in algorithms, but you only have a vague understanding of data structures and algorithms, and you are constantly jumping between \"yep\" and \"hmm\", then this book is for you!</p> <p>If you have already accumulated a certain amount of problem-solving experience, and are familiar with most types of problems, then this book can help you review and organize your algorithm knowledge system. The repository's source code can be used as a \"problem-solving toolkit\" or an \"algorithm cheat sheet\".</p> <p>If you are an algorithm expert, we look forward to receiving your valuable suggestions, or join us and collaborate.</p> <p>Prerequisites</p> <p>You should know how to write and read simple code in at least one programming language.</p>"},{"location":"chapter_preface/about_the_book/#012-content-structure","title":"0.1.2 \u00a0 Content Structure","text":"<p>The main content of the book is shown in the following figure.</p> <ul> <li>Complexity Analysis: explores aspects and methods for evaluating data structures and algorithms. Covers methods of deriving time complexity and space complexity, along with common types and examples.</li> <li>Data Structures: focuses on fundamental data types, classification methods, definitions, pros and cons, common operations, types, applications, and implementation methods of data structures such as array, linked list, stack, queue, hash table, tree, heap, graph, etc.</li> <li>Algorithms: defines algorithms, discusses their pros and cons, efficiency, application scenarios, problem-solving steps, and includes sample questions for various algorithms such as search, sorting, divide and conquer, backtracking, dynamic programming, greedy algorithms, and more.</li> </ul> <p></p> <p> Figure 0-1 \u00a0 Main Content of the Book </p>"},{"location":"chapter_preface/about_the_book/#013-acknowledgements","title":"0.1.3 \u00a0 Acknowledgements","text":"<p>This book is continuously improved with the joint efforts of many contributors from the open-source community. Thanks to each writer who invested their time and energy, listed in the order generated by GitHub: krahets\u3001codingonion\u3001nuomi1\u3001Gonglja\u3001Reanon\u3001justin-tse\u3001danielsss\u3001hpstory\u3001S-N-O-R-L-A-X\u3001night-cruise\u3001msk397\u3001gvenusleo\u3001RiverTwilight\u3001gyt95\u3001zhuoqinyue\u3001Zuoxun\u3001Xia-Sang\u3001mingXta\u3001FangYuan33\u3001GN-Yu\u3001IsChristina\u3001xBLACKICEx\u3001guowei-gong\u3001Cathay-Chen\u3001mgisr\u3001JoseHung\u3001qualifier1024\u3001pengchzn\u3001Guanngxu\u3001longsizhuo\u3001L-Super\u3001what-is-me\u3001yuan0221\u3001lhxsm\u3001Slone123c\u3001WSL0809\u3001longranger2\u3001theNefelibatas\u3001xiongsp\u3001JeffersonHuang\u3001hongyun-robot\u3001K3v123\u3001yuelinxin\u3001a16su\u3001gaofer\u3001malone6\u3001Wonderdch\u3001xjr7670\u3001DullSword\u3001Horbin-Magician\u3001NI-SW\u3001reeswell\u3001XC-Zero\u3001XiaChuerwu\u3001yd-j\u3001iron-irax\u3001huawuque404\u3001MolDuM\u3001Nigh\u3001KorsChen\u3001foursevenlove\u300152coder\u3001bubble9um\u3001youshaoXG\u3001curly210102\u3001gltianwen\u3001fanchenggang\u3001Transmigration-zhou\u3001FloranceYeh\u3001FreddieLi\u3001ShiMaRing\u3001lipusheng\u3001Javesun99\u3001JackYang-hellobobo\u3001shanghai-Jerry\u30010130w\u3001Keynman\u3001psychelzh\u3001logan-qiu\u3001ZnYang2018\u3001MwumLi\u30011ch0\u3001Phoenix0415\u3001qingpeng9802\u3001Richard-Zhang1019\u3001QiLOL\u3001Suremotoo\u3001Turing-1024-Lee\u3001Evilrabbit520\u3001GaochaoZhu\u3001ZJKung\u3001linzeyan\u3001hezhizhen\u3001ZongYangL\u3001beintentional\u3001czruby\u3001coderlef\u3001dshlstarr\u3001szu17dmy\u3001fbigm\u3001gledfish\u3001hts0000\u3001boloboloda\u3001iStig\u3001jiaxianhua\u3001wenjianmin\u3001keshida\u3001kilikilikid\u3001lclc6\u3001lwbaptx\u3001liuxjerry\u3001lucaswangdev\u3001lyl625760\u3001chadyi\u3001noobcodemaker\u3001selear\u3001siqyka\u3001syd168\u30014yDX3906\u3001tao363\u3001wangwang105\u3001weibk\u3001yabo083\u3001yi427\u3001yishangzhang\u3001zhouLion\u3001baagod\u3001ElaBosak233\u3001xb534\u3001luluxia\u3001yanedie\u3001thomasq0 \u548c YangXuanyi\u3002</p> <p>The code review work for this book was completed by codingonion, Gonglja, gvenusleo, hpstory, justin\u2010tse, krahets, night-cruise, nuomi1, and Reanon (listed in alphabetical order). Thanks to them for their time and effort, ensuring the standardization and uniformity of the code in various languages.</p> <p>Throughout the creation of this book, numerous individuals provided invaluable assistance, including but not limited to:</p> <ul> <li>Thanks to my mentor at the company, Dr. Xi Li, who encouraged me in a conversation to \"get moving fast,\" which solidified my determination to write this book;</li> <li>Thanks to my girlfriend Bubble, as the first reader of this book, for offering many valuable suggestions from the perspective of a beginner in algorithms, making this book more suitable for newbies;</li> <li>Thanks to Tengbao, Qibao, and Feibao for coming up with a creative name for this book, evoking everyone's fond memories of writing their first line of code \"Hello World!\";</li> <li>Thanks to Xiaoquan for providing professional help in intellectual property, which has played a significant role in the development of this open-source book;</li> <li>Thanks to Sutong for designing a beautiful cover and logo for this book, and for patiently making multiple revisions under my insistence;</li> <li>Thanks to @squidfunk for providing writing and typesetting suggestions, as well as his developed open-source documentation theme Material-for-MkDocs.</li> </ul> <p>Throughout the writing journey, I delved into numerous textbooks and articles on data structures and algorithms. These works served as exemplary models, ensuring the accuracy and quality of this book's content. I extend my gratitude to all who preceded me for their invaluable contributions!</p> <p>This book advocates a combination of hands-on and minds-on learning, inspired in this regard by \"Dive into Deep Learning\". I highly recommend this excellent book to all readers.</p> <p>Heartfelt thanks to my parents, whose ongoing support and encouragement have allowed me to do this interesting work.</p>"},{"location":"chapter_preface/suggestions/","title":"0.2 \u00a0 How to Read","text":"<p>Tip</p> <p>For the best reading experience, it is recommended that you read through this section.</p>"},{"location":"chapter_preface/suggestions/#021-conventions-of-style","title":"0.2.1 \u00a0 Conventions Of Style","text":"<ul> <li>Those labeled <code>*</code> after the title are optional chapters with relatively difficult content. If you have limited time, it is advisable to skip them.</li> <li>Proper nouns and words and phrases with specific meanings are marked with <code>\"double quotes\"</code> to avoid ambiguity.</li> <li>Important proper nouns and their English translations are marked with <code>\" \"</code> in parentheses, e.g. <code>\"array array\"</code> . It is recommended to memorize them for reading the literature.</li> <li>Bolded text Indicates key content or summary statements, which deserve special attention.</li> <li>When it comes to terms that are inconsistent between programming languages, this book follows Python, for example using <code>None</code> to mean \"empty\".</li> <li>This book partially abandons the specification of annotations in programming languages in exchange for a more compact layout of the content. There are three main types of annotations: title annotations, content annotations, and multi-line annotations.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCZig <pre><code>\"\"\"Header comments for labeling functions, classes, test samples, etc.\"\"\"\"\n\n# Content comments for detailed code solutions\n\n\"\"\"\nmulti-line\nmarginal notes\n\"\"\"\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc. */\n\n// Content comments for detailed code solutions.\n\n/**\n * multi-line\n * marginal notes\n */\n</code></pre> <pre><code>// Header comments for labeling functions, classes, test samples, etc.\n\n// Content comments for detailed code solutions.\n\n// Multi-line\n// Annotation\n</code></pre>"},{"location":"chapter_preface/suggestions/#022-learn-efficiently-in-animated-graphic-solutions","title":"0.2.2 \u00a0 Learn Efficiently In Animated Graphic Solutions","text":"<p>Compared with text, videos and pictures have a higher degree of information density and structure and are easier to understand. In this book, key and difficult knowledge will be presented mainly in the form of animations and graphs, while the text serves as an explanation and supplement to the animations and graphs.</p> <p>If, while reading the book, you find that a particular paragraph provides an animation or a graphic solution as shown below, please use the figure as the primary source and the text as a supplement and synthesize the two to understand the content.</p> <p></p> <p> Figure 0-2 \u00a0 Example animation </p>"},{"location":"chapter_preface/suggestions/#023-deeper-understanding-in-code-practice","title":"0.2.3 \u00a0 Deeper Understanding In Code Practice","text":"<p>The companion code for this book is hosted in the GitHub repository. As shown in the Figure 0-3 , the source code is accompanied by test samples that can be run with a single click.</p> <p>If time permits, it is recommended that you refer to the code and knock it through on your own. If you have limited time to study, please read through and run all the code at least once.</p> <p>The process of writing code is often more rewarding than reading it. Learning by doing is really learning.</p> <p></p> <p> Figure 0-3 \u00a0 Running code example </p> <p>The preliminaries for running the code are divided into three main steps.</p> <p>Step 1: Install the local programming environment. Please refer to Appendix Tutorial for installation, or skip this step if already installed.</p> <p>Step 2: Clone or download the code repository. If Git is already installed, you can clone this repository with the following command.</p> <pre><code>git clone https://github.com/krahets/hello-algo.git\n</code></pre> <p>Of course, you can also in the location shown in the Figure 0-4 , click \"Download ZIP\" directly download the code zip, and then in the local solution.</p> <p></p> <p> Figure 0-4 \u00a0 Clone repository with download code </p> <p>Step 3: Run the source code. As shown in the Figure 0-5 , for the code block labeled with the file name at the top, we can find the corresponding source code file in the <code>codes</code> folder of the repository. The source code files can be run with a single click, which will help you save unnecessary debugging time and allow you to focus on what you are learning.</p> <p></p> <p> Figure 0-5 \u00a0 Code block with corresponding source file </p>"},{"location":"chapter_preface/suggestions/#024-growing-together-in-questioning-and-discussion","title":"0.2.4 \u00a0 Growing Together In Questioning And Discussion","text":"<p>While reading this book, please don't skip over the points that you didn't learn. Feel free to ask your questions in the comment section. We will be happy to answer them and can usually respond within two days.</p> <p>As you can see in the Figure 0-6 , each post comes with a comment section at the bottom. I hope you'll pay more attention to the comments section. On the one hand, you can learn about the problems that people encounter, so as to check the gaps and stimulate deeper thinking. On the other hand, we expect you to generously answer other partners' questions, share your insights, and help others improve.</p> <p></p> <p> Figure 0-6 \u00a0 Example of comment section </p>"},{"location":"chapter_preface/suggestions/#025-algorithm-learning-route","title":"0.2.5 \u00a0 Algorithm Learning Route","text":"<p>From a general point of view, we can divide the process of learning data structures and algorithms into three stages.</p> <ol> <li>Introduction to Algorithms. We need to familiarize ourselves with the characteristics and usage of various data structures and learn about the principles, processes, uses and efficiency of different algorithms.</li> <li>Brush up on algorithm questions. It is recommended to start brushing from popular topics, such as Sword to Offer and LeetCode Hot 100, first accumulate at least 100 questions to familiarize yourself with mainstream algorithmic problems. Forgetfulness can be a challenge when first brushing up, but rest assured that this is normal. We can follow the \"Ebbinghaus Forgetting Curve\" to review the questions, and usually after 3-5 rounds of repetitions, we will be able to memorize them.</li> <li>Build the knowledge system. In terms of learning, we can read algorithm column articles, solution frameworks and algorithm textbooks to continuously enrich the knowledge system. In terms of brushing, we can try to adopt advanced brushing strategies, such as categorizing by topic, multiple solutions, multiple solutions, etc. Related brushing tips can be found in various communities.</li> </ol> <p>As shown in the Figure 0-7 , this book mainly covers \"Phase 1\" and is designed to help you start Phase 2 and 3 more efficiently.</p> <p></p> <p> Figure 0-7 \u00a0 algorithm learning route </p>"},{"location":"chapter_preface/summary/","title":"0.3 \u00a0 Summary","text":"<ul> <li>The main audience of this book is beginners in algorithm. If you already have some basic knowledge, this book can help you systematically review your algorithm knowledge, and the source code in this book can also be used as a \"Coding Toolkit\".</li> <li>The book consists of three main sections, Complexity Analysis, Data Structures, and Algorithms, covering most of the topics in the field.</li> <li>For newcomers to algorithms, it is crucial to read an introductory book in the beginning stages to avoid many detours or common pitfalls.</li> <li>Animations and figures within the book are usually used to introduce key points and difficult knowledge. These should be given more attention when reading the book.</li> <li>Practice is the best way to learn programming. It is highly recommended that you run the source code and type in the code yourself.</li> <li>Each chapter in the web version of this book features a discussion section, and you are welcome to share your questions and insights at any time.</li> </ul>"}]}