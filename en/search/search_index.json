{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"chapter_appendix/","title":"Chapter 16. \u00a0 Appendix","text":""},{"location":"chapter_appendix/#chapter-contents","title":"Chapter contents","text":"<ul> <li>16.1 \u00a0 Installation</li> <li>16.2 \u00a0 Contributing</li> <li>16.3 \u00a0 Terminology</li> </ul>"},{"location":"chapter_appendix/contribution/","title":"16.2 \u00a0 Contributing","text":"<p>Due to the limited abilities of the author, some omissions and errors are inevitable in this book. Please understand. If you discover any typos, broken links, missing content, textual ambiguities, unclear explanations, or unreasonable text structures, please assist us in making corrections to provide readers with better quality learning resources.</p> <p>The GitHub IDs of all contributors will be displayed on the repository, web, and PDF versions of the homepage of this book to thank them for their selfless contributions to the open-source community.</p> <p>The charm of open source</p> <p>The interval between two printings of a paper book is often long, making content updates very inconvenient.</p> <p>In this open-source book, however, the content update cycle is shortened to just a few days or even hours.</p>"},{"location":"chapter_appendix/contribution/#1-content-fine-tuning","title":"1. \u00a0 Content fine-tuning","text":"<p>As shown in Figure 16-3, there is an \"edit icon\" in the upper right corner of each page. You can follow these steps to modify text or code.</p> <ol> <li>Click the \"edit icon\". If prompted to \"fork this repository\", please agree to do so.</li> <li>Modify the Markdown source file content, check the accuracy of the content, and try to keep the formatting consistent.</li> <li>Fill in the modification description at the bottom of the page, then click the \"Propose file change\" button. After the page redirects, click the \"Create pull request\" button to initiate the pull request.</li> </ol> <p></p> <p> Figure 16-3 \u00a0 Edit page button </p> <p>Figures cannot be directly modified and require the creation of a new Issue or a comment to describe the problem. We will redraw and replace the figures as soon as possible.</p>"},{"location":"chapter_appendix/contribution/#2-content-creation","title":"2. \u00a0 Content creation","text":"<p>If you are interested in participating in this open-source project, including translating code into other programming languages or expanding article content, then the following Pull Request workflow needs to be implemented.</p> <ol> <li>Log in to GitHub and Fork the code repository of this book to your personal account.</li> <li>Go to your Forked repository web page and use the <code>git clone</code> command to clone the repository to your local machine.</li> <li>Create content locally and perform complete tests to verify the correctness of the code.</li> <li>Commit the changes made locally, then push them to the remote repository.</li> <li>Refresh the repository webpage and click the \"Create pull request\" button to initiate the pull request.</li> </ol>"},{"location":"chapter_appendix/contribution/#3-docker-deployment","title":"3. \u00a0 Docker deployment","text":"<p>In the <code>hello-algo</code> root directory, execute the following Docker script to access the project at <code>http://localhost:8000</code>:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Use the following command to remove the deployment:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"chapter_appendix/installation/","title":"16.1 \u00a0 Installation","text":""},{"location":"chapter_appendix/installation/#1611-install-ide","title":"16.1.1 \u00a0 Install IDE","text":"<p>We recommend using the open-source, lightweight VS Code as your local Integrated Development Environment (IDE). Visit the VS Code official website and choose the version of VS Code appropriate for your operating system to download and install.</p> <p></p> <p> Figure 16-1 \u00a0 Download VS Code from the official website </p> <p>VS Code has a powerful extension ecosystem, supporting the execution and debugging of most programming languages. For example, after installing the \"Python Extension Pack,\" you can debug Python code. The installation steps are shown in Figure 16-2.</p> <p></p> <p> Figure 16-2 \u00a0 Install VS Code Extension Pack </p>"},{"location":"chapter_appendix/installation/#1612-install-language-environments","title":"16.1.2 \u00a0 Install language environments","text":""},{"location":"chapter_appendix/installation/#1-python-environment","title":"1. \u00a0 Python environment","text":"<ol> <li>Download and install Miniconda3, requiring Python 3.10 or newer.</li> <li>In the VS Code extension marketplace, search for <code>python</code> and install the Python Extension Pack.</li> <li>(Optional) Enter <code>pip install black</code> in the command line to install the code formatting tool.</li> </ol>"},{"location":"chapter_appendix/installation/#2-cc-environment","title":"2. \u00a0 C/C++ environment","text":"<ol> <li>Windows systems need to install MinGW (Configuration tutorial); MacOS comes with Clang, so no installation is necessary.</li> <li>In the VS Code extension marketplace, search for <code>c++</code> and install the C/C++ Extension Pack.</li> <li>(Optional) Open the Settings page, search for the <code>Clang_format_fallback Style</code> code formatting option, and set it to <code>{ BasedOnStyle: Microsoft, BreakBeforeBraces: Attach }</code>.</li> </ol>"},{"location":"chapter_appendix/installation/#3-java-environment","title":"3. \u00a0 Java environment","text":"<ol> <li>Download and install OpenJDK (version must be &gt; JDK 9).</li> <li>In the VS Code extension marketplace, search for <code>java</code> and install the Extension Pack for Java.</li> </ol>"},{"location":"chapter_appendix/installation/#4-c-environment","title":"4. \u00a0 C# environment","text":"<ol> <li>Download and install .Net 8.0.</li> <li>In the VS Code extension marketplace, search for <code>C# Dev Kit</code> and install the C# Dev Kit (Configuration tutorial).</li> <li>You can also use Visual Studio (Installation tutorial).</li> </ol>"},{"location":"chapter_appendix/installation/#5-go-environment","title":"5. \u00a0 Go environment","text":"<ol> <li>Download and install go.</li> <li>In the VS Code extension marketplace, search for <code>go</code> and install Go.</li> <li>Press <code>Ctrl + Shift + P</code> to call up the command bar, enter go, choose <code>Go: Install/Update Tools</code>, select all and install.</li> </ol>"},{"location":"chapter_appendix/installation/#6-swift-environment","title":"6. \u00a0 Swift environment","text":"<ol> <li>Download and install Swift.</li> <li>In the VS Code extension marketplace, search for <code>swift</code> and install Swift for Visual Studio Code.</li> </ol>"},{"location":"chapter_appendix/installation/#7-javascript-environment","title":"7. \u00a0 JavaScript environment","text":"<ol> <li>Download and install Node.js.</li> <li>(Optional) In the VS Code extension marketplace, search for <code>Prettier</code> and install the code formatting tool.</li> </ol>"},{"location":"chapter_appendix/installation/#8-typescript-environment","title":"8. \u00a0 TypeScript environment","text":"<ol> <li>Follow the same installation steps as the JavaScript environment.</li> <li>Install TypeScript Execute (tsx).</li> <li>In the VS Code extension marketplace, search for <code>typescript</code> and install Pretty TypeScript Errors.</li> </ol>"},{"location":"chapter_appendix/installation/#9-dart-environment","title":"9. \u00a0 Dart environment","text":"<ol> <li>Download and install Dart.</li> <li>In the VS Code extension marketplace, search for <code>dart</code> and install Dart.</li> </ol>"},{"location":"chapter_appendix/installation/#10-rust-environment","title":"10. \u00a0 Rust environment","text":"<ol> <li>Download and install Rust.</li> <li>In the VS Code extension marketplace, search for <code>rust</code> and install rust-analyzer.</li> </ol>"},{"location":"chapter_appendix/terminology/","title":"16.3 \u00a0 Glossary","text":"<p>Table 16-1 lists the important terms that appear in the book, and it is worth noting the following points.</p> <ul> <li>It is recommended to remember the English names of the terms to facilitate reading English literature.</li> <li>Some terms have different names in Simplified and Traditional Chinese.</li> </ul> <p> Table 16-1 \u00a0 Important Terms in Data Structures and Algorithms </p> English \u7b80\u4f53\u4e2d\u6587 \u7e41\u4f53\u4e2d\u6587 algorithm \u7b97\u6cd5 \u6f14\u7b97\u6cd5 data structure \u6570\u636e\u7ed3\u6784 \u8cc7\u6599\u7d50\u69cb code \u4ee3\u7801 \u7a0b\u5f0f\u78bc file \u6587\u4ef6 \u6a94\u6848 function \u51fd\u6570 \u51fd\u5f0f method \u65b9\u6cd5 \u65b9\u6cd5 variable \u53d8\u91cf \u8b8a\u6578 asymptotic complexity analysis \u6e10\u8fd1\u590d\u6742\u5ea6\u5206\u6790 \u6f38\u8fd1\u8907\u96dc\u5ea6\u5206\u6790 time complexity \u65f6\u95f4\u590d\u6742\u5ea6 \u6642\u9593\u8907\u96dc\u5ea6 space complexity \u7a7a\u95f4\u590d\u6742\u5ea6 \u7a7a\u9593\u8907\u96dc\u5ea6 loop \u5faa\u73af \u8ff4\u5708 iteration \u8fed\u4ee3 \u8fed\u4ee3 recursion \u9012\u5f52 \u905e\u8ff4 tail recursion \u5c3e\u9012\u5f52 \u5c3e\u905e\u8ff4 recursion tree \u9012\u5f52\u6811 \u905e\u8ff4\u6a39 big-\\(O\\) notation \u5927 \\(O\\) \u8bb0\u53f7 \u5927 \\(O\\) \u8a18\u865f asymptotic upper bound \u6e10\u8fd1\u4e0a\u754c \u6f38\u8fd1\u4e0a\u754c sign-magnitude \u539f\u7801 \u539f\u78bc 1\u2019s complement \u53cd\u7801 \u4e00\u88dc\u6578 2\u2019s complement \u8865\u7801 \u4e8c\u88dc\u6578 array \u6570\u7ec4 \u9663\u5217 index \u7d22\u5f15 \u7d22\u5f15 linked list \u94fe\u8868 \u93c8\u7d50\u4e32\u5217 linked list node, list node \u94fe\u8868\u8282\u70b9 \u93c8\u7d50\u4e32\u5217\u7bc0\u9ede head node \u5934\u8282\u70b9 \u982d\u7bc0\u9ede tail node \u5c3e\u8282\u70b9 \u5c3e\u7bc0\u9ede list \u5217\u8868 \u4e32\u5217 dynamic array \u52a8\u6001\u6570\u7ec4 \u52d5\u614b\u9663\u5217 hard disk \u786c\u76d8 \u786c\u789f random-access memory (RAM) \u5185\u5b58 \u8a18\u61b6\u9ad4 cache memory \u7f13\u5b58 \u5feb\u53d6 cache miss \u7f13\u5b58\u672a\u547d\u4e2d \u5feb\u53d6\u672a\u547d\u4e2d cache hit rate \u7f13\u5b58\u547d\u4e2d\u7387 \u5feb\u53d6\u547d\u4e2d\u7387 stack \u6808 \u5806\u758a top of the stack \u6808\u9876 \u5806\u758a\u9802 bottom of the stack \u6808\u5e95 \u5806\u758a\u5e95 queue \u961f\u5217 \u4f47\u5217 double-ended queue \u53cc\u5411\u961f\u5217 \u96d9\u5411\u4f47\u5217 front of the queue \u961f\u9996 \u4f47\u5217\u9996 rear of the queue \u961f\u5c3e \u4f47\u5217\u5c3e hash table \u54c8\u5e0c\u8868 \u96dc\u6e4a\u8868 hash set \u54c8\u5e0c\u96c6\u5408 \u96dc\u6e4a\u96c6\u5408 bucket \u6876 \u6876 hash function \u54c8\u5e0c\u51fd\u6570 \u96dc\u6e4a\u51fd\u5f0f hash collision \u54c8\u5e0c\u51b2\u7a81 \u96dc\u6e4a\u885d\u7a81 load factor \u8d1f\u8f7d\u56e0\u5b50 \u8ca0\u8f09\u56e0\u5b50 separate chaining \u94fe\u5f0f\u5730\u5740 \u93c8\u7d50\u4f4d\u5740 open addressing \u5f00\u653e\u5bfb\u5740 \u958b\u653e\u5b9a\u5740 linear probing \u7ebf\u6027\u63a2\u6d4b \u7dda\u6027\u63a2\u67e5 lazy deletion \u61d2\u5220\u9664 \u61f6\u522a\u9664 binary tree \u4e8c\u53c9\u6811 \u4e8c\u5143\u6a39 tree node \u6811\u8282\u70b9 \u6a39\u7bc0\u9ede left-child node \u5de6\u5b50\u8282\u70b9 \u5de6\u5b50\u7bc0\u9ede right-child node \u53f3\u5b50\u8282\u70b9 \u53f3\u5b50\u7bc0\u9ede parent node \u7236\u8282\u70b9 \u7236\u7bc0\u9ede left subtree \u5de6\u5b50\u6811 \u5de6\u5b50\u6a39 right subtree \u53f3\u5b50\u6811 \u53f3\u5b50\u6a39 root node \u6839\u8282\u70b9 \u6839\u7bc0\u9ede leaf node \u53f6\u8282\u70b9 \u8449\u7bc0\u9ede edge \u8fb9 \u908a level \u5c42 \u5c64 degree \u5ea6 \u5ea6 height \u9ad8\u5ea6 \u9ad8\u5ea6 depth \u6df1\u5ea6 \u6df1\u5ea6 perfect binary tree \u5b8c\u7f8e\u4e8c\u53c9\u6811 \u5b8c\u7f8e\u4e8c\u5143\u6a39 complete binary tree \u5b8c\u5168\u4e8c\u53c9\u6811 \u5b8c\u5168\u4e8c\u5143\u6a39 full binary tree \u5b8c\u6ee1\u4e8c\u53c9\u6811 \u5b8c\u6eff\u4e8c\u5143\u6a39 balanced binary tree \u5e73\u8861\u4e8c\u53c9\u6811 \u5e73\u8861\u4e8c\u5143\u6a39 binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 AVL tree AVL \u6811 AVL \u6a39 red-black tree \u7ea2\u9ed1\u6811 \u7d05\u9ed1\u6a39 level-order traversal \u5c42\u5e8f\u904d\u5386 \u5c64\u5e8f\u8d70\u8a2a breadth-first traversal \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 \u5ee3\u5ea6\u512a\u5148\u8d70\u8a2a depth-first traversal \u6df1\u5ea6\u4f18\u5148\u904d\u5386 \u6df1\u5ea6\u512a\u5148\u8d70\u8a2a binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 balanced binary search tree \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811 \u5e73\u8861\u4e8c\u5143\u641c\u5c0b\u6a39 balance factor \u5e73\u8861\u56e0\u5b50 \u5e73\u8861\u56e0\u5b50 heap \u5806 \u5806\u7a4d max heap \u5927\u9876\u5806 \u5927\u9802\u5806\u7a4d min heap \u5c0f\u9876\u5806 \u5c0f\u9802\u5806\u7a4d priority queue \u4f18\u5148\u961f\u5217 \u512a\u5148\u4f47\u5217 heapify \u5806\u5316 \u5806\u7a4d\u5316 top-\\(k\\) problem Top-\\(k\\) \u95ee\u9898 Top-\\(k\\) \u554f\u984c graph \u56fe \u5716 vertex \u9876\u70b9 \u9802\u9ede undirected graph \u65e0\u5411\u56fe \u7121\u5411\u5716 directed graph \u6709\u5411\u56fe \u6709\u5411\u5716 connected graph \u8fde\u901a\u56fe \u9023\u901a\u5716 disconnected graph \u975e\u8fde\u901a\u56fe \u975e\u9023\u901a\u5716 weighted graph \u6709\u6743\u56fe \u6709\u6b0a\u5716 adjacency \u90bb\u63a5 \u9130\u63a5 path \u8def\u5f84 \u8def\u5f91 in-degree \u5165\u5ea6 \u5165\u5ea6 out-degree \u51fa\u5ea6 \u51fa\u5ea6 adjacency matrix \u90bb\u63a5\u77e9\u9635 \u9130\u63a5\u77e9\u9663 adjacency list \u90bb\u63a5\u8868 \u9130\u63a5\u8868 breadth-first search \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \u5ee3\u5ea6\u512a\u5148\u641c\u5c0b depth-first search \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 \u6df1\u5ea6\u512a\u5148\u641c\u5c0b binary search \u4e8c\u5206\u67e5\u627e \u4e8c\u5206\u641c\u5c0b searching algorithm \u641c\u7d22\u7b97\u6cd5 \u641c\u5c0b\u6f14\u7b97\u6cd5 sorting algorithm \u6392\u5e8f\u7b97\u6cd5 \u6392\u5e8f\u6f14\u7b97\u6cd5 selection sort \u9009\u62e9\u6392\u5e8f \u9078\u64c7\u6392\u5e8f bubble sort \u5192\u6ce1\u6392\u5e8f \u6ce1\u6cab\u6392\u5e8f insertion sort \u63d2\u5165\u6392\u5e8f \u63d2\u5165\u6392\u5e8f quick sort \u5feb\u901f\u6392\u5e8f \u5feb\u901f\u6392\u5e8f merge sort \u5f52\u5e76\u6392\u5e8f \u5408\u4f75\u6392\u5e8f heap sort \u5806\u6392\u5e8f \u5806\u7a4d\u6392\u5e8f bucket sort \u6876\u6392\u5e8f \u6876\u6392\u5e8f counting sort \u8ba1\u6570\u6392\u5e8f \u8a08\u6578\u6392\u5e8f radix sort \u57fa\u6570\u6392\u5e8f \u57fa\u6578\u6392\u5e8f divide and conquer \u5206\u6cbb \u5206\u6cbb hanota problem \u6c49\u8bfa\u5854\u95ee\u9898 \u6cb3\u5167\u5854\u554f\u984c backtracking algorithm \u56de\u6eaf\u7b97\u6cd5 \u56de\u6eaf\u6f14\u7b97\u6cd5 constraint \u7ea6\u675f \u7d04\u675f solution \u89e3 \u89e3 state \u72b6\u6001 \u72c0\u614b pruning \u526a\u679d \u526a\u679d permutations problem \u5168\u6392\u5217\u95ee\u9898 \u5168\u6392\u5217\u554f\u984c subset-sum problem \u5b50\u96c6\u548c\u95ee\u9898 \u5b50\u96c6\u5408\u554f\u984c \\(n\\)-queens problem \\(n\\) \u7687\u540e\u95ee\u9898 \\(n\\) \u7687\u540e\u554f\u984c dynamic programming \u52a8\u6001\u89c4\u5212 \u52d5\u614b\u898f\u5283 initial state \u521d\u59cb\u72b6\u6001 \u521d\u59cb\u72c0\u614b state-transition equation \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \u72c0\u614b\u8f49\u79fb\u65b9\u7a0b knapsack problem \u80cc\u5305\u95ee\u9898 \u80cc\u5305\u554f\u984c edit distance problem \u7f16\u8f91\u8ddd\u79bb\u95ee\u9898 \u7de8\u8f2f\u8ddd\u96e2\u554f\u984c greedy algorithm \u8d2a\u5fc3\u7b97\u6cd5 \u8caa\u5a6a\u6f14\u7b97\u6cd5"},{"location":"chapter_array_and_linkedlist/","title":"Chapter 4. \u00a0 Arrays and linked lists","text":"<p>Abstract</p> <p>The world of data structures resembles a sturdy brick wall.</p> <p>In arrays, envision bricks snugly aligned, each resting seamlessly beside the next, creating a unified formation. Meanwhile, in linked lists, these bricks disperse freely, embraced by vines gracefully knitting connections between them.</p>"},{"location":"chapter_array_and_linkedlist/#chapter-contents","title":"Chapter contents","text":"<ul> <li>4.1 \u00a0 Array</li> <li>4.2 \u00a0 Linked list</li> <li>4.3 \u00a0 List</li> <li>4.4 \u00a0 Memory and cache *</li> <li>4.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/","title":"4.1 \u00a0 Array","text":"<p>An array is a linear data structure that operates as a lineup of similar items, stored together in a computer's memory in contiguous spaces. It's like a sequence that maintains organized storage. Each item in this lineup has its unique 'spot' known as an index. Please refer to Figure 4-1 to observe how arrays work and grasp these key terms.</p> <p></p> <p> Figure 4-1 \u00a0 Array definition and storage method </p>"},{"location":"chapter_array_and_linkedlist/array/#411-common-operations-on-arrays","title":"4.1.1 \u00a0 Common operations on arrays","text":""},{"location":"chapter_array_and_linkedlist/array/#1-initializing-arrays","title":"1. \u00a0 Initializing arrays","text":"<p>Arrays can be initialized in two ways depending on the needs: either without initial values or with specified initial values. When initial values are not specified, most programming languages will set the array elements to \\(0\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig array.py<pre><code># Initialize array\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> array.cpp<pre><code>/* Initialize array */\n// Stored on stack\nint arr[5];\nint nums[5] = { 1, 3, 2, 5, 4 };\n// Stored on heap (manual memory release needed)\nint* arr1 = new int[5];\nint* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n</code></pre> array.java<pre><code>/* Initialize array */\nint[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\nint[] nums = { 1, 3, 2, 5, 4 };\n</code></pre> array.cs<pre><code>/* Initialize array */\nint[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]\nint[] nums = [1, 3, 2, 5, 4];\n</code></pre> array.go<pre><code>/* Initialize array */\nvar arr [5]int\n// In Go, specifying the length ([5]int) denotes an array, while not specifying it ([]int) denotes a slice.\n// Since Go's arrays are designed to have compile-time fixed length, only constants can be used to specify the length.\n// For convenience in implementing the extend() method, the Slice will be considered as an Array here.\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> array.swift<pre><code>/* Initialize array */\nlet arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\nlet nums = [1, 3, 2, 5, 4]\n</code></pre> array.js<pre><code>/* Initialize array */\nvar arr = new Array(5).fill(0);\nvar nums = [1, 3, 2, 5, 4];\n</code></pre> array.ts<pre><code>/* Initialize array */\nlet arr: number[] = new Array(5).fill(0);\nlet nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> array.dart<pre><code>/* Initialize array */\nList&lt;int&gt; arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> array.rs<pre><code>/* Initialize array */\nlet arr: Vec&lt;i32&gt; = vec![0; 5]; // [0, 0, 0, 0, 0]\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> array.c<pre><code>/* Initialize array */\nint arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\nint nums[5] = { 1, 3, 2, 5, 4 };\n</code></pre> array.kt<pre><code>\n</code></pre> array.zig<pre><code>// Initialize array\nvar arr = [_]i32{0} ** 5; // { 0, 0, 0, 0, 0 }\nvar nums = [_]i32{ 1, 3, 2, 5, 4 };\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#2-accessing-elements","title":"2. \u00a0 Accessing elements","text":"<p>Elements in an array are stored in contiguous memory spaces, making it simpler to compute each element's memory address. The formula shown in the Figure below aids in determining an element's memory address, utilizing the array's memory address (specifically, the first element's address) and the element's index. This computation streamlines direct access to the desired element.</p> <p></p> <p> Figure 4-2 \u00a0 Memory address calculation for array elements </p> <p>As observed in the above illustration, array indexing conventionally begins at \\(0\\). While this might appear counterintuitive, considering counting usually starts at \\(1\\), within the address calculation formula, an index is essentially an offset from the memory address. For the first element's address, this offset is \\(0\\), validating its index as \\(0\\).</p> <p>Accessing elements in an array is highly efficient, allowing us to randomly access any element in \\(O(1)\\) time.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def random_access(nums: list[int]) -&gt; int:\n    \"\"\"\u968f\u673a\u8bbf\u95ee\u5143\u7d20\"\"\"\n    # \u5728\u533a\u95f4 [0, len(nums)-1] \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    random_index = random.randint(0, len(nums) - 1)\n    # \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    random_num = nums[random_index]\n    return random_num\n</code></pre> array.cpp<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int *nums, int size) {\n    // \u5728\u533a\u95f4 [0, size) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = rand() % size;\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.java<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int[] nums) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = ThreadLocalRandom.current().nextInt(0, nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.cs<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint RandomAccess(int[] nums) {\n    Random random = new();\n    // \u5728\u533a\u95f4 [0, nums.Length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = random.Next(nums.Length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.go<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunc randomAccess(nums []int) (randomNum int) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    randomIndex := rand.Intn(len(nums))\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    randomNum = nums[randomIndex]\n    return\n}\n</code></pre> array.swift<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunc randomAccess(nums: [Int]) -&gt; Int {\n    // \u5728\u533a\u95f4 [0, nums.count) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    let randomIndex = nums.indices.randomElement()!\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    let randomNum = nums[randomIndex]\n    return randomNum\n}\n</code></pre> array.js<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunction randomAccess(nums) {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    const random_index = Math.floor(Math.random() * nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.ts<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfunction randomAccess(nums: number[]): number {\n    // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    const random_index = Math.floor(Math.random() * nums.length);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    const random_num = nums[random_index];\n    return random_num;\n}\n</code></pre> array.dart<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(List&lt;int&gt; nums) {\n  // \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n  int randomIndex = Random().nextInt(nums.length);\n  // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n  int randomNum = nums[randomIndex];\n  return randomNum;\n}\n</code></pre> array.rs<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfn random_access(nums: &amp;[i32]) -&gt; i32 {\n    // \u5728\u533a\u95f4 [0, nums.len()) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    let random_index = rand::thread_rng().gen_range(0..nums.len());\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    let random_num = nums[random_index];\n    random_num\n}\n</code></pre> array.c<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nint randomAccess(int *nums, int size) {\n    // \u5728\u533a\u95f4 [0, size) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    int randomIndex = rand() % size;\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    int randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> array.kt<pre><code>/* \u968f\u673a\u8bbf\u95ee\u5143\u7d20 */\nfun randomAccess(nums: IntArray): Int {\n    // \u5728\u533a\u95f4 [0, nums.size) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n    val randomIndex = ThreadLocalRandom.current().nextInt(0, nums.size)\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    val randomNum = nums[randomIndex]\n    return randomNum\n}\n</code></pre> array.rb<pre><code>### \u968f\u673a\u8bbf\u95ee\u5143\u7d20 ###\ndef random_access(nums)\n  # \u5728\u533a\u95f4 [0, nums.length) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6570\u5b57\n  random_index = Random.rand(0...nums.length)\n\n  # \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n  nums[random_index]\nend\n</code></pre> array.zig<pre><code>// \u968f\u673a\u8bbf\u95ee\u5143\u7d20\nfn randomAccess(nums: []i32) i32 {\n    // \u5728\u533a\u95f4 [0, nums.len) \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a\u6574\u6570\n    var randomIndex = std.crypto.random.intRangeLessThan(usize, 0, nums.len);\n    // \u83b7\u53d6\u5e76\u8fd4\u56de\u968f\u673a\u5143\u7d20\n    var randomNum = nums[randomIndex];\n    return randomNum;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#3-inserting-elements","title":"3. \u00a0 Inserting elements","text":"<p>Array elements are tightly packed in memory, with no space available to accommodate additional data between them. Illustrated in Figure below, inserting an element in the middle of an array requires shifting all subsequent elements back by one position to create room for the new element.</p> <p></p> <p> Figure 4-3 \u00a0 Array element insertion example </p> <p>It's important to note that due to the fixed length of an array, inserting an element will unavoidably result in the loss of the last element in the array. Solutions to address this issue will be explored in the \"List\" chapter.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def insert(nums: list[int], num: int, index: int):\n    \"\"\"\u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num\"\"\"\n    # \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in range(len(nums) - 1, index, -1):\n        nums[i] = nums[i - 1]\n    # \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n</code></pre> array.cpp<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int *nums, int size, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.java<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int[] nums, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.cs<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid Insert(int[] nums, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = nums.Length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.go<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunc insert(nums []int, num int, index int) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i := len(nums) - 1; i &gt; index; i-- {\n        nums[i] = nums[i-1]\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n}\n</code></pre> array.swift<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunc insert(nums: inout [Int], num: Int, index: Int) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in nums.indices.dropFirst(index).reversed() {\n        nums[i] = nums[i - 1]\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n}\n</code></pre> array.js<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunction insert(nums, num, index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.ts<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfunction insert(nums: number[], num: number, index: number): void {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (let i = nums.length - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.dart<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 _num */\nvoid insert(List&lt;int&gt; nums, int _num, int index) {\n  // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n  for (var i = nums.length - 1; i &gt; index; i--) {\n    nums[i] = nums[i - 1];\n  }\n  // \u5c06 _num \u8d4b\u7ed9 index \u5904\u5143\u7d20\n  nums[index] = _num;\n}\n</code></pre> array.rs<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfn insert(nums: &amp;mut Vec&lt;i32&gt;, num: i32, index: usize) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for i in (index + 1..nums.len()).rev() {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.c<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nvoid insert(int *nums, int size, int num, int index) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (int i = size - 1; i &gt; index; i--) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> array.kt<pre><code>/* \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num */\nfun insert(nums: IntArray, num: Int, index: Int) {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (i in nums.size - 1 downTo index + 1) {\n        nums[i] = nums[i - 1]\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num\n}\n</code></pre> array.rb<pre><code>### \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num ###\ndef insert(nums, num, index)\n  # \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n  for i in (nums.length - 1).downto(index + 1)\n    nums[i] = nums[i - 1]\n  end\n\n  # \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n  nums[index] = num\nend\n</code></pre> array.zig<pre><code>// \u5728\u6570\u7ec4\u7684\u7d22\u5f15 index \u5904\u63d2\u5165\u5143\u7d20 num\nfn insert(nums: []i32, num: i32, index: usize) void {\n    // \u628a\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    var i = nums.len - 1;\n    while (i &gt; index) : (i -= 1) {\n        nums[i] = nums[i - 1];\n    }\n    // \u5c06 num \u8d4b\u7ed9 index \u5904\u7684\u5143\u7d20\n    nums[index] = num;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#4-deleting-elements","title":"4. \u00a0 Deleting elements","text":"<p>Similarly, as depicted in Figure 4-4, to delete an element at index \\(i\\), all elements following index \\(i\\) must be moved forward by one position.</p> <p></p> <p> Figure 4-4 \u00a0 Array element deletion example </p> <p>Please note that after deletion, the former last element becomes \"meaningless,\" hence requiring no specific modification.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def remove(nums: list[int], index: int):\n    \"\"\"\u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20\"\"\"\n    # \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in range(index, len(nums) - 1):\n        nums[i] = nums[i + 1]\n</code></pre> array.cpp<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(int *nums, int size, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.java<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(int[] nums, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.cs<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid Remove(int[] nums, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; nums.Length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.go<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunc remove(nums []int, index int) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i := index; i &lt; len(nums)-1; i++ {\n        nums[i] = nums[i+1]\n    }\n}\n</code></pre> array.swift<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunc remove(nums: inout [Int], index: Int) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in nums.indices.dropFirst(index).dropLast() {\n        nums[i] = nums[i + 1]\n    }\n}\n</code></pre> array.js<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunction remove(nums, index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.ts<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfunction remove(nums: number[], index: number): void {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (let i = index; i &lt; nums.length - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.dart<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nvoid remove(List&lt;int&gt; nums, int index) {\n  // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n  for (var i = index; i &lt; nums.length - 1; i++) {\n    nums[i] = nums[i + 1];\n  }\n}\n</code></pre> array.rs<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfn remove(nums: &amp;mut Vec&lt;i32&gt;, index: usize) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for i in index..nums.len() - 1 {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.c<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nvoid removeItem(int *nums, int size, int index) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (int i = index; i &lt; size - 1; i++) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> array.kt<pre><code>/* \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 */\nfun remove(nums: IntArray, index: Int) {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (i in index..&lt;nums.size - 1) {\n        nums[i] = nums[i + 1]\n    }\n}\n</code></pre> array.rb<pre><code>### \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20 ###\ndef remove(nums, index)\n  # \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n  for i in index...(nums.length - 1)\n    nums[i] = nums[i + 1]\n  end\nend\n</code></pre> array.zig<pre><code>// \u5220\u9664\u7d22\u5f15 index \u5904\u7684\u5143\u7d20\nfn remove(nums: []i32, index: usize) void {\n    // \u628a\u7d22\u5f15 index \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    var i = index;\n    while (i &lt; nums.len - 1) : (i += 1) {\n        nums[i] = nums[i + 1];\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>In summary, the insertion and deletion operations in arrays present the following disadvantages:</p> <ul> <li>High time complexity: Both insertion and deletion in an array have an average time complexity of \\(O(n)\\), where \\(n\\) is the length of the array.</li> <li>Loss of elements: Due to the fixed length of arrays, elements that exceed the array's capacity are lost during insertion.</li> <li>Waste of memory: Initializing a longer array and utilizing only the front part results in \"meaningless\" end elements during insertion, leading to some wasted memory space.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#5-traversing-arrays","title":"5. \u00a0 Traversing arrays","text":"<p>In most programming languages, we can traverse an array either by using indices or by directly iterating over each element:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def traverse(nums: list[int]):\n    \"\"\"\u904d\u5386\u6570\u7ec4\"\"\"\n    count = 0\n    # \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in range(len(nums)):\n        count += nums[i]\n    # \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums:\n        count += num\n    # \u540c\u65f6\u904d\u5386\u6570\u636e\u7d22\u5f15\u548c\u5143\u7d20\n    for i, num in enumerate(nums):\n        count += nums[i]\n        count += num\n</code></pre> array.cpp<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.java<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int[] nums) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (int num : nums) {\n        count += num;\n    }\n}\n</code></pre> array.cs<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid Traverse(int[] nums) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; nums.Length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    foreach (int num in nums) {\n        count += num;\n    }\n}\n</code></pre> array.go<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunc traverse(nums []int) {\n    count := 0\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i := 0; i &lt; len(nums); i++ {\n        count += nums[i]\n    }\n    count = 0\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for _, num := range nums {\n        count += num\n    }\n    // \u540c\u65f6\u904d\u5386\u6570\u636e\u7d22\u5f15\u548c\u5143\u7d20\n    for i, num := range nums {\n        count += nums[i]\n        count += num\n    }\n}\n</code></pre> array.swift<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunc traverse(nums: [Int]) {\n    var count = 0\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in nums.indices {\n        count += nums[i]\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums {\n        count += num\n    }\n    // \u540c\u65f6\u904d\u5386\u6570\u636e\u7d22\u5f15\u548c\u5143\u7d20\n    for (i, num) in nums.enumerated() {\n        count += nums[i]\n        count += num\n    }\n}\n</code></pre> array.js<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunction traverse(nums) {\n    let count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.ts<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfunction traverse(nums: number[]): void {\n    let count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (const num of nums) {\n        count += num;\n    }\n}\n</code></pre> array.dart<pre><code>/* \u904d\u5386\u6570\u7ec4\u5143\u7d20 */\nvoid traverse(List&lt;int&gt; nums) {\n  int count = 0;\n  // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n  for (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n  }\n  // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n  for (int _num in nums) {\n    count += _num;\n  }\n  // \u901a\u8fc7 forEach \u65b9\u6cd5\u904d\u5386\u6570\u7ec4\n  nums.forEach((_num) {\n    count += _num;\n  });\n}\n</code></pre> array.rs<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfn traverse(nums: &amp;[i32]) {\n    let mut _count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for i in 0..nums.len() {\n        _count += nums[i];\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for num in nums {\n        _count += num;\n    }\n}\n</code></pre> array.c<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nvoid traverse(int *nums, int size) {\n    int count = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        count += nums[i];\n    }\n}\n</code></pre> array.kt<pre><code>/* \u904d\u5386\u6570\u7ec4 */\nfun traverse(nums: IntArray) {\n    var count = 0\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    for (i in nums.indices) {\n        count += nums[i]\n    }\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (j in nums) {\n        count += j\n    }\n}\n</code></pre> array.rb<pre><code>### \u904d\u5386\u6570\u7ec4 ###\ndef traverse(nums)\n  count = 0\n\n  # \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n  for i in 0...nums.length\n    count += nums[i]\n  end\n\n  # \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n  for num in nums\n    count += num\n  end\nend\n</code></pre> array.zig<pre><code>// \u904d\u5386\u6570\u7ec4\nfn traverse(nums: []i32) void {\n    var count: i32 = 0;\n    // \u901a\u8fc7\u7d22\u5f15\u904d\u5386\u6570\u7ec4\n    var i: i32 = 0;\n    while (i &lt; nums.len) : (i += 1) {\n        count += nums[i];\n    }\n    count = 0;\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\u5143\u7d20\n    for (nums) |num| {\n        count += num;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#6-finding-elements","title":"6. \u00a0 Finding elements","text":"<p>Locating a specific element within an array involves iterating through the array, checking each element to determine if it matches the desired value.</p> <p>Because arrays are linear data structures, this operation is commonly referred to as \"linear search.\"</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def find(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20\"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n    return -1\n</code></pre> array.cpp<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.java<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.cs<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint Find(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.go<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunc find(nums []int, target int) (index int) {\n    index = -1\n    for i := 0; i &lt; len(nums); i++ {\n        if nums[i] == target {\n            index = i\n            break\n        }\n    }\n    return\n}\n</code></pre> array.swift<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunc find(nums: [Int], target: Int) -&gt; Int {\n    for i in nums.indices {\n        if nums[i] == target {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> array.js<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunction find(nums, target) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) return i;\n    }\n    return -1;\n}\n</code></pre> array.ts<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfunction find(nums: number[], target: number): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (nums[i] === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> array.dart<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(List&lt;int&gt; nums, int target) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    if (nums[i] == target) return i;\n  }\n  return -1;\n}\n</code></pre> array.rs<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfn find(nums: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        if nums[i] == target {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> array.c<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nint find(int *nums, int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] == target)\n            return i;\n    }\n    return -1;\n}\n</code></pre> array.kt<pre><code>/* \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 */\nfun find(nums: IntArray, target: Int): Int {\n    for (i in nums.indices) {\n        if (nums[i] == target)\n            return i\n    }\n    return -1\n}\n</code></pre> array.rb<pre><code>### \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20 ###\ndef find(nums, target)\n  for i in 0...nums.length\n    return i if nums[i] == target\n  end\n\n  -1\nend\n</code></pre> array.zig<pre><code>// \u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u6307\u5b9a\u5143\u7d20\nfn find(nums: []i32, target: i32) i32 {\n    for (nums, 0..) |num, i| {\n        if (num == target) return @intCast(i);\n    }\n    return -1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#7-expanding-arrays","title":"7. \u00a0 Expanding arrays","text":"<p>In complex system environments, ensuring the availability of memory space after an array for safe capacity extension becomes challenging. Consequently, in most programming languages, the length of an array is immutable.</p> <p>To expand an array,  it's necessary to create a larger array and then copy the elements from the original array. This operation has a time complexity of \\(O(n)\\) and can be time-consuming for large arrays. The code are as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array.py<pre><code>def extend(nums: list[int], enlarge: int) -&gt; list[int]:\n    \"\"\"\u6269\u5c55\u6570\u7ec4\u957f\u5ea6\"\"\"\n    # \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    res = [0] * (len(nums) + enlarge)\n    # \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i in range(len(nums)):\n        res[i] = nums[i]\n    # \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n</code></pre> array.cpp<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint *extend(int *nums, int size, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int *res = new int[size + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // \u91ca\u653e\u5185\u5b58\n    delete[] nums;\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.java<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint[] extend(int[] nums, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int[] res = new int[nums.length + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.cs<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint[] Extend(int[] nums, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int[] res = new int[nums.Length + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; nums.Length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.go<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfunc extend(nums []int, enlarge int) []int {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    res := make([]int, len(nums)+enlarge)\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i, num := range nums {\n        res[i] = num\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n}\n</code></pre> array.swift<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfunc extend(nums: [Int], enlarge: Int) -&gt; [Int] {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    var res = Array(repeating: 0, count: nums.count + enlarge)\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for i in nums.indices {\n        res[i] = nums[i]\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n}\n</code></pre> array.js<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\n// \u8bf7\u6ce8\u610f\uff0cJavaScript \u7684 Array \u662f\u52a8\u6001\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u6269\u5c55\n// \u4e3a\u4e86\u65b9\u4fbf\u5b66\u4e60\uff0c\u672c\u51fd\u6570\u5c06 Array \u770b\u4f5c\u957f\u5ea6\u4e0d\u53ef\u53d8\u7684\u6570\u7ec4\nfunction extend(nums, enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    const res = new Array(nums.length + enlarge).fill(0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.ts<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\n// \u8bf7\u6ce8\u610f\uff0cTypeScript \u7684 Array \u662f\u52a8\u6001\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u6269\u5c55\n// \u4e3a\u4e86\u65b9\u4fbf\u5b66\u4e60\uff0c\u672c\u51fd\u6570\u5c06 Array \u770b\u4f5c\u957f\u5ea6\u4e0d\u53ef\u53d8\u7684\u6570\u7ec4\nfunction extend(nums: number[], enlarge: number): number[] {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    const res = new Array(nums.length + enlarge).fill(0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (let i = 0; i &lt; nums.length; i++) {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.dart<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nList&lt;int&gt; extend(List&lt;int&gt; nums, int enlarge) {\n  // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n  List&lt;int&gt; res = List.filled(nums.length + enlarge, 0);\n  // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n  for (var i = 0; i &lt; nums.length; i++) {\n    res[i] = nums[i];\n  }\n  // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n  return res;\n}\n</code></pre> array.rs<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfn extend(nums: Vec&lt;i32&gt;, enlarge: usize) -&gt; Vec&lt;i32&gt; {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    let mut res: Vec&lt;i32&gt; = vec![0; nums.len() + enlarge];\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\n    for i in 0..nums.len() {\n        res[i] = nums[i];\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    res\n}\n</code></pre> array.c<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nint *extend(int *nums, int size, int enlarge) {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    int *res = (int *)malloc(sizeof(int) * (size + enlarge));\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (int i = 0; i &lt; size; i++) {\n        res[i] = nums[i];\n    }\n    // \u521d\u59cb\u5316\u6269\u5c55\u540e\u7684\u7a7a\u95f4\n    for (int i = size; i &lt; size + enlarge; i++) {\n        res[i] = 0;\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> array.kt<pre><code>/* \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 */\nfun extend(nums: IntArray, enlarge: Int): IntArray {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    val res = IntArray(nums.size + enlarge)\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    for (i in nums.indices) {\n        res[i] = nums[i]\n    }\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res\n}\n</code></pre> array.rb<pre><code>### \u6269\u5c55\u6570\u7ec4\u957f\u5ea6 ###\n# \u8bf7\u6ce8\u610f\uff0cRuby \u7684 Array \u662f\u52a8\u6001\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u6269\u5c55\n# \u4e3a\u4e86\u65b9\u4fbf\u5b66\u4e60\uff0c\u672c\u51fd\u6570\u5c06 Array \u770b\u4f5c\u957f\u5ea6\u4e0d\u53ef\u53d8\u7684\u6570\u7ec4\ndef extend(nums, enlarge)\n  # \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n  res = Array.new(nums.length + enlarge, 0)\n\n  # \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n  for i in 0...nums.length\n    res[i] = nums[i]\n  end\n\n  # \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n  res\nend\n</code></pre> array.zig<pre><code>// \u6269\u5c55\u6570\u7ec4\u957f\u5ea6\nfn extend(mem_allocator: std.mem.Allocator, nums: []i32, enlarge: usize) ![]i32 {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u6269\u5c55\u957f\u5ea6\u540e\u7684\u6570\u7ec4\n    var res = try mem_allocator.alloc(i32, nums.len + enlarge);\n    @memset(res, 0);\n    // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    std.mem.copy(i32, res, nums);\n    // \u8fd4\u56de\u6269\u5c55\u540e\u7684\u65b0\u6570\u7ec4\n    return res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/array/#412-advantages-and-limitations-of-arrays","title":"4.1.2 \u00a0 Advantages and limitations of arrays","text":"<p>Arrays are stored in contiguous memory spaces and consist of elements of the same type. This approach provides substantial prior information that systems can leverage to optimize the efficiency of data structure operations.</p> <ul> <li>High space efficiency: Arrays allocate a contiguous block of memory for data, eliminating the need for additional structural overhead.</li> <li>Support for random access: Arrays allow \\(O(1)\\) time access to any element.</li> <li>Cache locality: When accessing array elements, the computer not only loads them but also caches the surrounding data, utilizing high-speed cache to enchance subsequent operation speeds.</li> </ul> <p>However, continuous space storage is a double-edged sword, with the following limitations:</p> <ul> <li>Low efficiency in insertion and deletion: As arrays accumulate many elements, inserting or deleting elements requires shifting a large number of elements.</li> <li>Fixed length: The length of an array is fixed after initialization. Expanding an array requires copying all data to a new array, incurring significant costs.</li> <li>Space wastage: If the allocated array size exceeds the what is necessary, the extra space is wasted.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#413-typical-applications-of-arrays","title":"4.1.3 \u00a0 Typical applications of arrays","text":"<p>Arrays are fundamental and widely used data structures. They find frequent application in various algorithms and serve in the implementation of complex data structures.</p> <ul> <li>Random access: Arrays are ideal for storing data when random sampling is required. By generating a random sequence based on indices, we can achieve random sampling efficiently.</li> <li>Sorting and searching: Arrays are the most commonly used data structure for sorting and searching algorithms.  Techniques like quick sort, merge sort, binary search, etc., are primarily operate on arrays.</li> <li>Lookup tables: Arrays serve as efficient lookup tables for quick element or relationship retrieval. For instance, mapping characters to ASCII codes becomes seamless by using the ASCII code values as indices and storing corresponding elements in the array.</li> <li>Machine learning: Within the domain of neural networks, arrays play a pivotal role in executing crucial linear algebra operations involving vectors, matrices, and tensors. Arrays serve as the primary and most extensively used data structure in neural network programming.</li> <li>Data structure implementation:  Arrays serve as the building blocks for implementing various data structures like stacks, queues, hash tables, heaps, graphs, etc. For instance, the adjacency matrix representation of a graph is essentially a two-dimensional array.</li> </ul>"},{"location":"chapter_array_and_linkedlist/linked_list/","title":"4.2 \u00a0 Linked list","text":"<p>Memory space is a shared resource among all programs. In a complex system environment, available memory can be dispersed throughout the memory space. We understand that the memory allocated for an array must be continuous. However, for very large arrays, finding a sufficiently large contiguous memory space might be challenging. This is where the flexible advantage of linked lists becomes evident.</p> <p>A linked list is a linear data structure in which each element is a node object, and the nodes are interconnected through \"references\". These references hold the memory addresses of subsequent nodes, enabling navigation from one node to the next.</p> <p>The design of linked lists allows for their nodes to be distributed across memory locations without requiring contiguous memory addresses.</p> <p></p> <p> Figure 4-5 \u00a0 Linked list definition and storage method </p> <p>As shown in the figure, we see that the basic building block of a linked list is the node object. Each node comprises two key components: the node's \"value\" and a \"reference\" to the next node.</p> <ul> <li>The first node in a linked list is the \"head node\", and the final one is the \"tail node\".</li> <li>The tail node points to \"null\", designated as <code>null</code> in Java, <code>nullptr</code> in C++, and <code>None</code> in Python.</li> <li>In languages that support pointers, like C, C++, Go, and Rust, this \"reference\" is typically implemented as a \"pointer\".</li> </ul> <p>As the code below illustrates, a <code>ListNode</code> in a linked list, besides holding a value, must also maintain an additional reference (or pointer). Therefore, a linked list occupies more memory space than an array when storing the same quantity of data..</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class ListNode:\n    \"\"\"Linked list node class\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val               # Node value\n        self.next: ListNode | None = None # Reference to the next node\n</code></pre> <pre><code>/* Linked list node structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the next node\n    ListNode(int x) : val(x), next(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode(int x) {  // Constructor\n    int val = x;         // Node value\n    ListNode? next;      // Reference to the next node\n}\n</code></pre> <pre><code>/* Linked list node structure */\ntype ListNode struct {\n    Val  int       // Node value\n    Next *ListNode // Pointer to the next node\n}\n\n// NewListNode Constructor, creates a new linked list\nfunc NewListNode(val int) *ListNode {\n    return &amp;ListNode{\n        Val:  val,\n        Next: nil,\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the next node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);       // Node value\n        this.next = (next === undefined ? null : next); // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = val === undefined ? 0 : val;        // Node value\n        this.next = next === undefined ? null : next;  // Reference to the next node\n    }\n}\n</code></pre> <pre><code>/* Linked list node class */\nclass ListNode {\n  int val; // Node value\n  ListNode? next; // Reference to the next node\n  ListNode(this.val, [this.next]); // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n/* Linked list node class */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to the next node\n}\n</code></pre> <pre><code>/* Linked list node structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the next node\n} ListNode;\n\n/* Constructor */\nListNode *newListNode(int val) {\n    ListNode *node;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    return node;\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Linked list node class\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Node value\n        next: ?*Self = null, // Pointer to the next node\n\n        // Constructor\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n        }\n    };\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#421-common-operations-on-linked-lists","title":"4.2.1 \u00a0 Common operations on linked lists","text":""},{"location":"chapter_array_and_linkedlist/linked_list/#1-initializing-a-linked-list","title":"1. \u00a0 Initializing a linked list","text":"<p>Constructing a linked list is a two-step process: first, initializing each node object, and second, forming the reference links between the nodes. After initialization, we can traverse all nodes sequentially from the head node by following the <code>next</code> reference.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig linked_list.py<pre><code># Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4\n# Initialize each node\nn0 = ListNode(1)\nn1 = ListNode(3)\nn2 = ListNode(2)\nn3 = ListNode(5)\nn4 = ListNode(4)\n# Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.cpp<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = new ListNode(1);\nListNode* n1 = new ListNode(3);\nListNode* n2 = new ListNode(2);\nListNode* n3 = new ListNode(5);\nListNode* n4 = new ListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.java<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new ListNode(1);\nListNode n1 = new ListNode(3);\nListNode n2 = new ListNode(2);\nListNode n3 = new ListNode(5);\nListNode n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.cs<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = new(1);\nListNode n1 = new(3);\nListNode n2 = new(2);\nListNode n3 = new(5);\nListNode n4 = new(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.go<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nn0 := NewListNode(1)\nn1 := NewListNode(3)\nn2 := NewListNode(2)\nn3 := NewListNode(5)\nn4 := NewListNode(4)\n// Build references between nodes\nn0.Next = n1\nn1.Next = n2\nn2.Next = n3\nn3.Next = n4\n</code></pre> linked_list.swift<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = ListNode(x: 1)\nlet n1 = ListNode(x: 3)\nlet n2 = ListNode(x: 2)\nlet n3 = ListNode(x: 5)\nlet n4 = ListNode(x: 4)\n// Build references between nodes\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.js<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.ts<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.dart<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode n0 = ListNode(1);\nListNode n1 = ListNode(3);\nListNode n2 = ListNode(2);\nListNode n3 = ListNode(5);\nListNode n4 = ListNode(4);\n// Build references between nodes\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.rs<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nlet n0 = Rc::new(RefCell::new(ListNode { val: 1, next: None }));\nlet n1 = Rc::new(RefCell::new(ListNode { val: 3, next: None }));\nlet n2 = Rc::new(RefCell::new(ListNode { val: 2, next: None }));\nlet n3 = Rc::new(RefCell::new(ListNode { val: 5, next: None }));\nlet n4 = Rc::new(RefCell::new(ListNode { val: 4, next: None }));\n\n// Build references between nodes\nn0.borrow_mut().next = Some(n1.clone());\nn1.borrow_mut().next = Some(n2.clone());\nn2.borrow_mut().next = Some(n3.clone());\nn3.borrow_mut().next = Some(n4.clone());\n</code></pre> linked_list.c<pre><code>/* Initialize linked list: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Initialize each node\nListNode* n0 = newListNode(1);\nListNode* n1 = newListNode(3);\nListNode* n2 = newListNode(2);\nListNode* n3 = newListNode(5);\nListNode* n4 = newListNode(4);\n// Build references between nodes\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.kt<pre><code>\n</code></pre> linked_list.zig<pre><code>// Initialize linked list\n// Initialize each node\nvar n0 = inc.ListNode(i32){.val = 1};\nvar n1 = inc.ListNode(i32){.val = 3};\nvar n2 = inc.ListNode(i32){.val = 2};\nvar n3 = inc.ListNode(i32){.val = 5};\nvar n4 = inc.ListNode(i32){.val = 4};\n// Build references between nodes\nn0.next = &amp;n1;\nn1.next = &amp;n2;\nn2.next = &amp;n3;\nn3.next = &amp;n4;\n</code></pre> <p>The array as a whole is a variable, for instance, the array <code>nums</code> includes elements like <code>nums[0]</code>, <code>nums[1]</code>, and so on, whereas a linked list is made up of several distinct node objects. We typically refer to a linked list by its head node, for example, the linked list in the previous code snippet is referred to as <code>n0</code>.</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#2-inserting-nodes","title":"2. \u00a0 Inserting nodes","text":"<p>Inserting a node into a linked list is very easy. As shown in the figure, let's assume we aim to insert a new node <code>P</code> between two adjacent nodes <code>n0</code> and <code>n1</code>. This can be achieved by simply modifying two node references (pointers), with a time complexity of \\(O(1)\\).</p> <p>By comparison, inserting an element into an array has a time complexity of \\(O(n)\\), which becomes less efficient when dealing with large data volumes.</p> <p></p> <p> Figure 4-6 \u00a0 Linked list node insertion example </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linked_list.py<pre><code>def insert(n0: ListNode, P: ListNode):\n    \"\"\"\u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P\"\"\"\n    n1 = n0.next\n    P.next = n1\n    n0.next = P\n</code></pre> linked_list.cpp<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.java<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode n0, ListNode P) {\n    ListNode n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid Insert(ListNode n0, ListNode P) {\n    ListNode? n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.go<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunc insertNode(n0 *ListNode, P *ListNode) {\n    n1 := n0.Next\n    P.Next = n1\n    n0.Next = P\n}\n</code></pre> linked_list.swift<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunc insert(n0: ListNode, P: ListNode) {\n    let n1 = n0.next\n    P.next = n1\n    n0.next = P\n}\n</code></pre> linked_list.js<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunction insert(n0, P) {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfunction insert(n0: ListNode, P: ListNode): void {\n    const n1 = n0.next;\n    P.next = n1;\n    n0.next = P;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode n0, ListNode P) {\n  ListNode? n1 = n0.next;\n  P.next = n1;\n  n0.next = P;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\n#[allow(non_snake_case)]\npub fn insert&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, P: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    let n1 = n0.borrow_mut().next.take();\n    P.borrow_mut().next = n1;\n    n0.borrow_mut().next = Some(P);\n}\n</code></pre> linked_list.c<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nvoid insert(ListNode *n0, ListNode *P) {\n    ListNode *n1 = n0-&gt;next;\n    P-&gt;next = n1;\n    n0-&gt;next = P;\n}\n</code></pre> linked_list.kt<pre><code>/* \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P */\nfun insert(n0: ListNode?, p: ListNode?) {\n    val n1 = n0?.next\n    p?.next = n1\n    n0?.next = p\n}\n</code></pre> linked_list.rb<pre><code>### \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 _p ###\n# Ruby \u7684 `p` \u662f\u4e00\u4e2a\u5185\u7f6e\u51fd\u6570\uff0c `P` \u662f\u4e00\u4e2a\u5e38\u91cf\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528 `_p` \u4ee3\u66ff\ndef insert(n0, _p)\n  n1 = n0.next\n  _p.next = n1\n  n0.next = _p\nend\n</code></pre> linked_list.zig<pre><code>// \u5728\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u63d2\u5165\u8282\u70b9 P\nfn insert(n0: ?*inc.ListNode(i32), P: ?*inc.ListNode(i32)) void {\n    var n1 = n0.?.next;\n    P.?.next = n1;\n    n0.?.next = P;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#3-deleting-nodes","title":"3. \u00a0 Deleting nodes","text":"<p>As shown in the figure, deleting a node from a linked list is also very easy, involving only the modification of a single node's reference (pointer).</p> <p>It's important to note that even though node <code>P</code> continues to point to <code>n1</code> after being deleted, it becomes inaccessible during linked list traversal. This effectively means that <code>P</code> is no longer a part of the linked list.</p> <p></p> <p> Figure 4-7 \u00a0 Linked list node deletion </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linked_list.py<pre><code>def remove(n0: ListNode):\n    \"\"\"\u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9\"\"\"\n    if not n0.next:\n        return\n    # n0 -&gt; P -&gt; n1\n    P = n0.next\n    n1 = P.next\n    n0.next = n1\n</code></pre> linked_list.cpp<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode *n0) {\n    if (n0-&gt;next == nullptr)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // \u91ca\u653e\u5185\u5b58\n    delete P;\n}\n</code></pre> linked_list.java<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid Remove(ListNode n0) {\n    if (n0.next == null)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode P = n0.next;\n    ListNode? n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.go<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunc removeItem(n0 *ListNode) {\n    if n0.Next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    P := n0.Next\n    n1 := P.Next\n    n0.Next = n1\n}\n</code></pre> linked_list.swift<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunc remove(n0: ListNode) {\n    if n0.next == nil {\n        return\n    }\n    // n0 -&gt; P -&gt; n1\n    let P = n0.next\n    let n1 = P?.next\n    n0.next = n1\n}\n</code></pre> linked_list.js<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunction remove(n0) {\n    if (!n0.next) return;\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfunction remove(n0: ListNode): void {\n    if (!n0.next) {\n        return;\n    }\n    // n0 -&gt; P -&gt; n1\n    const P = n0.next;\n    const n1 = P.next;\n    n0.next = n1;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nvoid remove(ListNode n0) {\n  if (n0.next == null) return;\n  // n0 -&gt; P -&gt; n1\n  ListNode P = n0.next!;\n  ListNode? n1 = P.next;\n  n0.next = n1;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\n#[allow(non_snake_case)]\npub fn remove&lt;T&gt;(n0: &amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;) {\n    if n0.borrow().next.is_none() {\n        return;\n    };\n    // n0 -&gt; P -&gt; n1\n    let P = n0.borrow_mut().next.take();\n    if let Some(node) = P {\n        let n1 = node.borrow_mut().next.take();\n        n0.borrow_mut().next = n1;\n    }\n}\n</code></pre> linked_list.c<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nvoid removeItem(ListNode *n0) {\n    if (!n0-&gt;next)\n        return;\n    // n0 -&gt; P -&gt; n1\n    ListNode *P = n0-&gt;next;\n    ListNode *n1 = P-&gt;next;\n    n0-&gt;next = n1;\n    // \u91ca\u653e\u5185\u5b58\n    free(P);\n}\n</code></pre> linked_list.kt<pre><code>/* \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 */\nfun remove(n0: ListNode?) {\n    if (n0?.next == null)\n        return\n    // n0 -&gt; P -&gt; n1\n    val p = n0.next\n    val n1 = p?.next\n    n0.next = n1\n}\n</code></pre> linked_list.rb<pre><code>### \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9 ###\ndef remove(n0)\n  return if n0.next.nil?\n\n  # n0 -&gt; remove_node -&gt; n1\n  remove_node = n0.next\n  n1 = remove_node.next\n  n0.next = n1\nend\n</code></pre> linked_list.zig<pre><code>// \u5220\u9664\u94fe\u8868\u7684\u8282\u70b9 n0 \u4e4b\u540e\u7684\u9996\u4e2a\u8282\u70b9\nfn remove(n0: ?*inc.ListNode(i32)) void {\n    if (n0.?.next == null) return;\n    // n0 -&gt; P -&gt; n1\n    var P = n0.?.next;\n    var n1 = P.?.next;\n    n0.?.next = n1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#4-accessing-nodes","title":"4. \u00a0 Accessing nodes","text":"<p>Accessing nodes in a linked list is less efficient. As previously mentioned, any element in an array can be accessed in \\(O(1)\\) time. In contrast, with a linked list, the program involves starting from the head node and sequentially traversing through the nodes until the desired node is found. In other words, to access the \\(i\\)-th node in a linked list, the program must iterate through \\(i - 1\\) nodes, resulting in a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linked_list.py<pre><code>def access(head: ListNode, index: int) -&gt; ListNode | None:\n    \"\"\"\u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9\"\"\"\n    for _ in range(index):\n        if not head:\n            return None\n        head = head.next\n    return head\n</code></pre> linked_list.cpp<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == nullptr)\n            return nullptr;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.java<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode access(ListNode head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.cs<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode? Access(ListNode? head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == null)\n            return null;\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.go<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunc access(head *ListNode, index int) *ListNode {\n    for i := 0; i &lt; index; i++ {\n        if head == nil {\n            return nil\n        }\n        head = head.Next\n    }\n    return head\n}\n</code></pre> linked_list.swift<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunc access(head: ListNode, index: Int) -&gt; ListNode? {\n    var head: ListNode? = head\n    for _ in 0 ..&lt; index {\n        if head == nil {\n            return nil\n        }\n        head = head?.next\n    }\n    return head\n}\n</code></pre> linked_list.js<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunction access(head, index) {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.ts<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfunction access(head: ListNode | null, index: number): ListNode | null {\n    for (let i = 0; i &lt; index; i++) {\n        if (!head) {\n            return null;\n        }\n        head = head.next;\n    }\n    return head;\n}\n</code></pre> linked_list.dart<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode? access(ListNode? head, int index) {\n  for (var i = 0; i &lt; index; i++) {\n    if (head == null) return null;\n    head = head.next;\n  }\n  return head;\n}\n</code></pre> linked_list.rs<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\npub fn access&lt;T&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, index: i32) -&gt; Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt; {\n    if index &lt;= 0 {\n        return head;\n    };\n    if let Some(node) = &amp;head.borrow().next {\n        return access(node.clone(), index - 1);\n    }\n\n    return head;\n}\n</code></pre> linked_list.c<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nListNode *access(ListNode *head, int index) {\n    for (int i = 0; i &lt; index; i++) {\n        if (head == NULL)\n            return NULL;\n        head = head-&gt;next;\n    }\n    return head;\n}\n</code></pre> linked_list.kt<pre><code>/* \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 */\nfun access(head: ListNode?, index: Int): ListNode? {\n    var h = head\n    for (i in 0..&lt;index) {\n        if (h == null)\n            return null\n        h = h.next\n    }\n    return h\n}\n</code></pre> linked_list.rb<pre><code>### \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9 ###\ndef access(head, index)\n  for i in 0...index\n    return nil if head.nil?\n    head = head.next\n  end\n\n  head\nend\n</code></pre> linked_list.zig<pre><code>// \u8bbf\u95ee\u94fe\u8868\u4e2d\u7d22\u5f15\u4e3a index \u7684\u8282\u70b9\nfn access(node: ?*inc.ListNode(i32), index: i32) ?*inc.ListNode(i32) {\n    var head = node;\n    var i: i32 = 0;\n    while (i &lt; index) : (i += 1) {\n        head = head.?.next;\n        if (head == null) return null;\n    }\n    return head;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#5-finding-nodes","title":"5. \u00a0 Finding nodes","text":"<p>Traverse the linked list to locate a node whose value matches <code>target</code>, and then output the index of that node within the linked list. This procedure is also an example of linear search. The corresponding code is provided below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linked_list.py<pre><code>def find(head: ListNode, target: int) -&gt; int:\n    \"\"\"\u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9\"\"\"\n    index = 0\n    while head:\n        if head.val == target:\n            return index\n        head = head.next\n        index += 1\n    return -1\n</code></pre> linked_list.cpp<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head != nullptr) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.java<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.cs<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint Find(ListNode? head, int target) {\n    int index = 0;\n    while (head != null) {\n        if (head.val == target)\n            return index;\n        head = head.next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.go<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunc findNode(head *ListNode, target int) int {\n    index := 0\n    for head != nil {\n        if head.Val == target {\n            return index\n        }\n        head = head.Next\n        index++\n    }\n    return -1\n}\n</code></pre> linked_list.swift<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunc find(head: ListNode, target: Int) -&gt; Int {\n    var head: ListNode? = head\n    var index = 0\n    while head != nil {\n        if head?.val == target {\n            return index\n        }\n        head = head?.next\n        index += 1\n    }\n    return -1\n}\n</code></pre> linked_list.js<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunction find(head, target) {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.ts<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfunction find(head: ListNode | null, target: number): number {\n    let index = 0;\n    while (head !== null) {\n        if (head.val === target) {\n            return index;\n        }\n        head = head.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> linked_list.dart<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode? head, int target) {\n  int index = 0;\n  while (head != null) {\n    if (head.val == target) {\n      return index;\n    }\n    head = head.next;\n    index++;\n  }\n  return -1;\n}\n</code></pre> linked_list.rs<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\npub fn find&lt;T: PartialEq&gt;(head: Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;, target: T, index: i32) -&gt; i32 {\n    if head.borrow().val == target {\n        return index;\n    };\n    if let Some(node) = &amp;head.borrow_mut().next {\n        return find(node.clone(), target, index + 1);\n    }\n    return -1;\n}\n</code></pre> linked_list.c<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nint find(ListNode *head, int target) {\n    int index = 0;\n    while (head) {\n        if (head-&gt;val == target)\n            return index;\n        head = head-&gt;next;\n        index++;\n    }\n    return -1;\n}\n</code></pre> linked_list.kt<pre><code>/* \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 */\nfun find(head: ListNode?, target: Int): Int {\n    var index = 0\n    var h = head\n    while (h != null) {\n        if (h._val == target)\n            return index\n        h = h.next\n        index++\n    }\n    return -1\n}\n</code></pre> linked_list.rb<pre><code>### \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9 ###\ndef find(head, target)\n  index = 0\n  while head\n    return index if head.val == target\n    head = head.next\n    index += 1\n  end\n\n  -1\nend\n</code></pre> linked_list.zig<pre><code>// \u5728\u94fe\u8868\u4e2d\u67e5\u627e\u503c\u4e3a target \u7684\u9996\u4e2a\u8282\u70b9\nfn find(node: ?*inc.ListNode(i32), target: i32) i32 {\n    var head = node;\n    var index: i32 = 0;\n    while (head != null) {\n        if (head.?.val == target) return index;\n        head = head.?.next;\n        index += 1;\n    }\n    return -1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#422-arrays-vs-linked-lists","title":"4.2.2 \u00a0 Arrays vs. linked lists","text":"<p>Table 4-1 summarizes the characteristics of arrays and linked lists, and it also compares their efficiencies in various operations. Because they utilize opposing storage strategies, their respective properties and operational efficiencies exhibit distinct contrasts.</p> <p> Table 4-1 \u00a0 Efficiency comparison of arrays and linked lists </p> Arrays Linked Lists Storage Contiguous Memory Space Dispersed Memory Space Capacity Expansion Fixed Length Flexible Expansion Memory Efficiency Less Memory per Element, Potential Space Wastage More Memory per Element Accessing Elements \\(O(1)\\) \\(O(n)\\) Adding Elements \\(O(n)\\) \\(O(1)\\) Deleting Elements \\(O(n)\\) \\(O(1)\\)"},{"location":"chapter_array_and_linkedlist/linked_list/#423-common-types-of-linked-lists","title":"4.2.3 \u00a0 Common types of linked lists","text":"<p>As shown in the figure, there are three common types of linked lists.</p> <ul> <li>Singly linked list: This is the standard linked list described earlier. Nodes in a singly linked list include a value and a reference to the next node. The first node is known as the head node, and the last node, which points to null (<code>None</code>), is the tail node.</li> <li>Circular linked list: This is formed when the tail node of a singly linked list points back to the head node, creating a loop. In a circular linked list, any node can function as the head node.</li> <li>Doubly linked list: In contrast to a singly linked list, a doubly linked list maintains references in two directions. Each node contains references (pointer) to both its successor (the next node) and predecessor (the previous node). Although doubly linked lists offer more flexibility for traversing in either direction, they also consume more memory space.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class ListNode:\n    \"\"\"Bidirectional linked list node class\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.next: ListNode | None = None  # Reference to the successor node\n        self.prev: ListNode | None = None  # Reference to a predecessor node\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\nstruct ListNode {\n    int val;         // Node value\n    ListNode *next;  // Pointer to the successor node\n    ListNode *prev;  // Pointer to the predecessor node\n    ListNode(int x) : val(x), next(nullptr), prev(nullptr) {}  // Constructor\n};\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n    ListNode(int x) { val = x; }  // Constructor\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode(int x) {  // Constructor\n    int val = x;    // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n}\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\ntype DoublyListNode struct {\n    Val  int             // Node value\n    Next *DoublyListNode // Pointer to the successor node\n    Prev *DoublyListNode // Pointer to the predecessor node\n}\n\n// NewDoublyListNode initialization\nfunc NewDoublyListNode(val int) *DoublyListNode {\n    return &amp;DoublyListNode{\n        Val:  val,\n        Next: nil,\n        Prev: nil,\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    var val: Int // Node value\n    var next: ListNode? // Reference to the next node\n    var prev: ListNode? // Reference to the predecessor node\n\n    init(x: Int) { // Constructor\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    constructor(val, next, prev) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    prev: ListNode | null;\n    constructor(val?: number, next?: ListNode | null, prev?: ListNode | null) {\n        this.val = val  ===  undefined ? 0 : val;        // Node value\n        this.next = next  ===  undefined ? null : next;  // Reference to the successor node\n        this.prev = prev  ===  undefined ? null : prev;  // Reference to the predecessor node\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node class */\nclass ListNode {\n    int val;        // Node value\n    ListNode next;  // Reference to the next node\n    ListNode prev;  // Reference to the predecessor node\n    ListNode(this.val, [this.next, this.prev]);  // Constructor\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Bidirectional linked list node type */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Node value\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to successor node\n    prev: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Pointer to predecessor node\n}\n\n/* Constructors */\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode {\n            val,\n            next: None,\n            prev: None,\n        }\n    }\n}\n</code></pre> <pre><code>/* Bidirectional linked list node structure */\ntypedef struct ListNode {\n    int val;               // Node value\n    struct ListNode *next; // Pointer to the successor node\n    struct ListNode *prev; // Pointer to the predecessor node\n} ListNode;\n\n/* Constructors */\nListNode *newListNode(int val) {\n    ListNode *node, *next;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    node-&gt;prev = NULL;\n    return node;\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Bidirectional linked list node class\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Node value\n        next: ?*Self = null, // Pointer to the successor node\n        prev: ?*Self = null, // Pointer to the predecessor node\n\n        // Constructor\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n            self.prev = null;\n        }\n    };\n}\n</code></pre> <p></p> <p> Figure 4-8 \u00a0 Common types of linked lists </p>"},{"location":"chapter_array_and_linkedlist/linked_list/#424-typical-applications-of-linked-lists","title":"4.2.4 \u00a0 Typical applications of linked lists","text":"<p>Singly linked lists are frequently utilized in implementing stacks, queues, hash tables, and graphs.</p> <ul> <li>Stacks and queues: In singly linked lists, if insertions and deletions occur at the same end, it behaves like a stack (last-in-first-out). Conversely, if insertions are at one end and deletions at the other, it functions like a queue (first-in-first-out).</li> <li>Hash tables: Linked lists are used in chaining, a popular method for resolving hash collisions. Here, all collided elements are grouped into a linked list.</li> <li>Graphs: Adjacency lists, a standard method for graph representation, associate each graph vertex with a linked list. This list contains elements that represent vertices connected to the corresponding vertex.</li> </ul> <p>Doubly linked lists are ideal for scenarios requiring rapid access to preceding and succeeding elements.</p> <ul> <li>Advanced data structures: In structures like red-black trees and B-trees, accessing a node's parent is essential. This is achieved by incorporating a reference to the parent node in each node, akin to a doubly linked list.</li> <li>Browser history: In web browsers, doubly linked lists facilitate navigating the history of visited pages when users click forward or back.</li> <li>LRU algorithm: Doubly linked lists are apt for Least Recently Used (LRU) cache eviction algorithms, enabling swift identification of the least recently used data and facilitating fast node addition and removal.</li> </ul> <p>Circular linked lists are ideal for applications that require periodic operations, such as resource scheduling in operating systems.</p> <ul> <li>Round-robin scheduling algorithm: In operating systems, the round-robin scheduling algorithm is a common CPU scheduling method, requiring cycling through a group of processes. Each process is assigned a time slice, and upon expiration, the CPU rotates to the next process. This cyclical operation can be efficiently realized using a circular linked list, allowing for a fair and time-shared system among all processes.</li> <li>Data buffers: Circular linked lists are also used in data buffers, like in audio and video players, where the data stream is divided into multiple buffer blocks arranged in a circular fashion for seamless playback.</li> </ul>"},{"location":"chapter_array_and_linkedlist/list/","title":"4.3 \u00a0 List","text":"<p>A list is an abstract data structure concept that represents an ordered collection of elements, supporting operations such as element access, modification, addition, deletion, and traversal, without requiring users to consider capacity limitations. Lists can be implemented based on linked lists or arrays.</p> <ul> <li>A linked list inherently serves as a list, supporting operations for adding, deleting, searching, and modifying elements, with the flexibility to dynamically adjust its size.</li> <li>Arrays also support these operations, but due to their immutable length, they can be considered as a list with a length limit.</li> </ul> <p>When implementing lists using arrays, the immutability of length reduces the practicality of the list. This is because predicting the amount of data to be stored in advance is often challenging, making it difficult to choose an appropriate list length. If the length is too small, it may not meet the requirements; if too large, it may waste memory space.</p> <p>To solve this problem, we can implement lists using a dynamic array. It inherits the advantages of arrays and can dynamically expand during program execution.</p> <p>In fact, many programming languages' standard libraries implement lists using dynamic arrays, such as Python's <code>list</code>, Java's <code>ArrayList</code>, C++'s <code>vector</code>, and C#'s <code>List</code>. In the following discussion, we will consider \"list\" and \"dynamic array\" as synonymous concepts.</p>"},{"location":"chapter_array_and_linkedlist/list/#431-common-list-operations","title":"4.3.1 \u00a0 Common list operations","text":""},{"location":"chapter_array_and_linkedlist/list/#1-initializing-a-list","title":"1. \u00a0 Initializing a list","text":"<p>We typically use two initialization methods: \"without initial values\" and \"with initial values\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Initialize list\n# Without initial values\nnums1: list[int] = []\n# With initial values\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> list.cpp<pre><code>/* Initialize list */\n// Note, in C++ the vector is the equivalent of nums described here\n// Without initial values\nvector&lt;int&gt; nums1;\n// With initial values\nvector&lt;int&gt; nums = { 1, 3, 2, 5, 4 };\n</code></pre> list.java<pre><code>/* Initialize list */\n// Without initial values\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();\n// With initial values (note the element type should be the wrapper class Integer[] for int[])\nInteger[] numbers = new Integer[] { 1, 3, 2, 5, 4 };\nList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(Arrays.asList(numbers));\n</code></pre> list.cs<pre><code>/* Initialize list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nint[] numbers = [1, 3, 2, 5, 4];\nList&lt;int&gt; nums = [.. numbers];\n</code></pre> list_test.go<pre><code>/* Initialize list */\n// Without initial values\nnums1 := []int{}\n// With initial values\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> list.swift<pre><code>/* Initialize list */\n// Without initial values\nlet nums1: [Int] = []\n// With initial values\nvar nums = [1, 3, 2, 5, 4]\n</code></pre> list.js<pre><code>/* Initialize list */\n// Without initial values\nconst nums1 = [];\n// With initial values\nconst nums = [1, 3, 2, 5, 4];\n</code></pre> list.ts<pre><code>/* Initialize list */\n// Without initial values\nconst nums1: number[] = [];\n// With initial values\nconst nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> list.dart<pre><code>/* Initialize list */\n// Without initial values\nList&lt;int&gt; nums1 = [];\n// With initial values\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> list.rs<pre><code>/* Initialize list */\n// Without initial values\nlet nums1: Vec&lt;i32&gt; = Vec::new();\n// With initial values\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Initialize list\nvar nums = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums.deinit();\ntry nums.appendSlice(&amp;[_]i32{ 1, 3, 2, 5, 4 });\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#2-accessing-elements","title":"2. \u00a0 Accessing elements","text":"<p>Lists are essentially arrays, thus they can access and update elements in \\(O(1)\\) time, which is very efficient.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Access elements\nnum: int = nums[1]  # Access the element at index 1\n\n# Update elements\nnums[1] = 0    # Update the element at index 1 to 0\n</code></pre> list.cpp<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.java<pre><code>/* Access elements */\nint num = nums.get(1);  // Access the element at index 1\n\n/* Update elements */\nnums.set(1, 0);  // Update the element at index 1 to 0\n</code></pre> list.cs<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list_test.go<pre><code>/* Access elements */\nnum := nums[1]  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0     // Update the element at index 1 to 0\n</code></pre> list.swift<pre><code>/* Access elements */\nlet num = nums[1] // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0 // Update the element at index 1 to 0\n</code></pre> list.js<pre><code>/* Access elements */\nconst num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.ts<pre><code>/* Access elements */\nconst num: number = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.dart<pre><code>/* Access elements */\nint num = nums[1];  // Access the element at index 1\n\n/* Update elements */\nnums[1] = 0;  // Update the element at index 1 to 0\n</code></pre> list.rs<pre><code>/* Access elements */\nlet num: i32 = nums[1];  // Access the element at index 1\n/* Update elements */\nnums[1] = 0;             // Update the element at index 1 to 0\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Access elements\nvar num = nums.items[1]; // Access the element at index 1\n\n// Update elements\nnums.items[1] = 0; // Update the element at index 1 to 0  \n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#3-inserting-and-removing-elements","title":"3. \u00a0 Inserting and removing elements","text":"<p>Compared to arrays, lists offer more flexibility in adding and removing elements. While adding elements to the end of a list is an \\(O(1)\\) operation, the efficiency of inserting and removing elements elsewhere in the list remains the same as in arrays, with a time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Clear list\nnums.clear()\n\n# Append elements at the end\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n# Insert element in the middle\nnums.insert(3, 6)  # Insert number 6 at index 3\n\n# Remove elements\nnums.pop(3)        # Remove the element at index 3\n</code></pre> list.cpp<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.push_back(1);\nnums.push_back(3);\nnums.push_back(2);\nnums.push_back(5);\nnums.push_back(4);\n\n/* Insert element in the middle */\nnums.insert(nums.begin() + 3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.erase(nums.begin() + 3);      // Remove the element at index 3\n</code></pre> list.java<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert element in the middle */\nnums.add(3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(3);  // Remove the element at index 3\n</code></pre> list.cs<pre><code>/* Clear list */\nnums.Clear();\n\n/* Append elements at the end */\nnums.Add(1);\nnums.Add(3);\nnums.Add(2);\nnums.Add(5);\nnums.Add(4);\n\n/* Insert element in the middle */\nnums.Insert(3, 6);\n\n/* Remove elements */\nnums.RemoveAt(3);\n</code></pre> list_test.go<pre><code>/* Clear list */\nnums = nil\n\n/* Append elements at the end */\nnums = append(nums, 1)\nnums = append(nums, 3)\nnums = append(nums, 2)\nnums = append(nums, 5)\nnums = append(nums, 4)\n\n/* Insert element in the middle */\nnums = append(nums[:3], append([]int{6}, nums[3:]...)...) // Insert number 6 at index 3\n\n/* Remove elements */\nnums = append(nums[:3], nums[4:]...) // Remove the element at index 3\n</code></pre> list.swift<pre><code>/* Clear list */\nnums.removeAll()\n\n/* Append elements at the end */\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n/* Insert element in the middle */\nnums.insert(6, at: 3) // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(at: 3) // Remove the element at index 3\n</code></pre> list.js<pre><code>/* Clear list */\nnums.length = 0;\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.splice(3, 0, 6);\n\n/* Remove elements */\nnums.splice(3, 1);\n</code></pre> list.ts<pre><code>/* Clear list */\nnums.length = 0;\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.splice(3, 0, 6);\n\n/* Remove elements */\nnums.splice(3, 1);\n</code></pre> list.dart<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Insert element in the middle */\nnums.insert(3, 6); // Insert number 6 at index 3\n\n/* Remove elements */\nnums.removeAt(3); // Remove the element at index 3\n</code></pre> list.rs<pre><code>/* Clear list */\nnums.clear();\n\n/* Append elements at the end */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Insert element in the middle */\nnums.insert(3, 6);  // Insert number 6 at index 3\n\n/* Remove elements */\nnums.remove(3);    // Remove the element at index 3\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Clear list\nnums.clearRetainingCapacity();\n\n// Append elements at the end\ntry nums.append(1);\ntry nums.append(3);\ntry nums.append(2);\ntry nums.append(5);\ntry nums.append(4);\n\n// Insert element in the middle\ntry nums.insert(3, 6); // Insert number 6 at index 3\n\n// Remove elements\n_ = nums.orderedRemove(3); // Remove the element at index 3\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#4-iterating-the-list","title":"4. \u00a0 Iterating the list","text":"<p>Similar to arrays, lists can be iterated either by using indices or by directly iterating through each element.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Iterate through the list by index\ncount = 0\nfor i in range(len(nums)):\n    count += nums[i]\n\n# Iterate directly through list elements\nfor num in nums:\n    count += num\n</code></pre> list.cpp<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.java<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums.get(i);\n}\n\n/* Iterate directly through list elements */\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.cs<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (int i = 0; i &lt; nums.Count; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nforeach (int num in nums) {\n    count += num;\n}\n</code></pre> list_test.go<pre><code>/* Iterate through the list by index */\ncount := 0\nfor i := 0; i &lt; len(nums); i++ {\n    count += nums[i]\n}\n\n/* Iterate directly through list elements */\ncount = 0\nfor _, num := range nums {\n    count += num\n}\n</code></pre> list.swift<pre><code>/* Iterate through the list by index */\nvar count = 0\nfor i in nums.indices {\n    count += nums[i]\n}\n\n/* Iterate directly through list elements */\ncount = 0\nfor num in nums {\n    count += num\n}\n</code></pre> list.js<pre><code>/* Iterate through the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.ts<pre><code>/* Iterate through the list by index */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.dart<pre><code>/* Iterate through the list by index */\nint count = 0;\nfor (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Iterate directly through list elements */\ncount = 0;\nfor (var num in nums) {\n    count += num;\n}\n</code></pre> list.rs<pre><code>// Iterate through the list by index\nlet mut _count = 0;\nfor i in 0..nums.len() {\n    _count += nums[i];\n}\n\n// Iterate directly through list elements\n_count = 0;\nfor num in &amp;nums {\n    _count += num;\n}\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Iterate through the list by index\nvar count: i32 = 0;\nvar i: i32 = 0;\nwhile (i &lt; nums.items.len) : (i += 1) {\n    count += nums[i];\n}\n\n// Iterate directly through list elements\ncount = 0;\nfor (nums.items) |num| {\n    count += num;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#5-concatenating-lists","title":"5. \u00a0 Concatenating lists","text":"<p>Given a new list <code>nums1</code>, we can append it to the end of the original list.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Concatenate two lists\nnums1: list[int] = [6, 8, 7, 10, 9]\nnums += nums1  # Concatenate nums1 to the end of nums\n</code></pre> list.cpp<pre><code>/* Concatenate two lists */\nvector&lt;int&gt; nums1 = { 6, 8, 7, 10, 9 };\n// Concatenate nums1 to the end of nums\nnums.insert(nums.end(), nums1.begin(), nums1.end());\n</code></pre> list.java<pre><code>/* Concatenate two lists */\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));\nnums.addAll(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.cs<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.AddRange(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list_test.go<pre><code>/* Concatenate two lists */\nnums1 := []int{6, 8, 7, 10, 9}\nnums = append(nums, nums1...)  // Concatenate nums1 to the end of nums\n</code></pre> list.swift<pre><code>/* Concatenate two lists */\nlet nums1 = [6, 8, 7, 10, 9]\nnums.append(contentsOf: nums1) // Concatenate nums1 to the end of nums\n</code></pre> list.js<pre><code>/* Concatenate two lists */\nconst nums1 = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.ts<pre><code>/* Concatenate two lists */\nconst nums1: number[] = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.dart<pre><code>/* Concatenate two lists */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.addAll(nums1);  // Concatenate nums1 to the end of nums\n</code></pre> list.rs<pre><code>/* Concatenate two lists */\nlet nums1: Vec&lt;i32&gt; = vec![6, 8, 7, 10, 9];\nnums.extend(nums1);\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Concatenate two lists\nvar nums1 = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums1.deinit();\ntry nums1.appendSlice(&amp;[_]i32{ 6, 8, 7, 10, 9 });\ntry nums.insertSlice(nums.items.len, nums1.items); // Concatenate nums1 to the end of nums\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#6-sorting-the-list","title":"6. \u00a0 Sorting the list","text":"<p>Once the list is sorted, we can employ algorithms commonly used in array-related algorithm problems, such as \"binary search\" and \"two-pointer\" algorithms.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Sort the list\nnums.sort()  # After sorting, the list elements are in ascending order\n</code></pre> list.cpp<pre><code>/* Sort the list */\nsort(nums.begin(), nums.end());  // After sorting, the list elements are in ascending order\n</code></pre> list.java<pre><code>/* Sort the list */\nCollections.sort(nums);  // After sorting, the list elements are in ascending order\n</code></pre> list.cs<pre><code>/* Sort the list */\nnums.Sort(); // After sorting, the list elements are in ascending order\n</code></pre> list_test.go<pre><code>/* Sort the list */\nsort.Ints(nums)  // After sorting, the list elements are in ascending order\n</code></pre> list.swift<pre><code>/* Sort the list */\nnums.sort() // After sorting, the list elements are in ascending order\n</code></pre> list.js<pre><code>/* Sort the list */  \nnums.sort((a, b) =&gt; a - b);  // After sorting, the list elements are in ascending order\n</code></pre> list.ts<pre><code>/* Sort the list */\nnums.sort((a, b) =&gt; a - b);  // After sorting, the list elements are in ascending order\n</code></pre> list.dart<pre><code>/* Sort the list */\nnums.sort(); // After sorting, the list elements are in ascending order\n</code></pre> list.rs<pre><code>/* Sort the list */\nnums.sort(); // After sorting, the list elements are in ascending order\n</code></pre> list.c<pre><code>// C does not provide built-in dynamic arrays\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Sort the list\nstd.sort.sort(i32, nums.items, {}, comptime std.sort.asc(i32));\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#432-list-implementation","title":"4.3.2 \u00a0 List implementation","text":"<p>Many programming languages come with built-in lists, including Java, C++, Python, etc. Their implementations tend to be intricate, featuring carefully considered settings for various parameters, like initial capacity and expansion factors. Readers who are curious can delve into the source code for further learning.</p> <p>To enhance our understanding of how lists work, we will attempt to implement a simplified version of a list, focusing on three crucial design aspects:</p> <ul> <li>Initial capacity: Choose a reasonable initial capacity for the array. In this example, we choose 10 as the initial capacity.</li> <li>Size recording: Declare a variable <code>size</code> to record the current number of elements in the list, updating in real-time with element insertion and deletion. With this variable, we can locate the end of the list and determine whether expansion is needed.</li> <li>Expansion mechanism: If the list reaches full capacity upon an element insertion, an expansion process is required. This involves creating a larger array based on the expansion factor, and then transferring all elements from the current array to the new one. In this example, we stipulate that the array size should double with each expansion.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_list.py<pre><code>class MyList:\n    \"\"\"\u5217\u8868\u7c7b\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._capacity: int = 10  # \u5217\u8868\u5bb9\u91cf\n        self._arr: list[int] = [0] * self._capacity  # \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        self._size: int = 0  # \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        self._extend_ratio: int = 2  # \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\"\"\"\n        return self._size\n\n    def capacity(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u5217\u8868\u5bb9\u91cf\"\"\"\n        return self._capacity\n\n    def get(self, index: int) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u5143\u7d20\"\"\"\n        # \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        return self._arr[index]\n\n    def set(self, num: int, index: int):\n        \"\"\"\u66f4\u65b0\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        self._arr[index] = num\n\n    def add(self, num: int):\n        \"\"\"\u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\"\"\"\n        # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size() == self.capacity():\n            self.extend_capacity()\n        self._arr[self._size] = num\n        self._size += 1\n\n    def insert(self, num: int, index: int):\n        \"\"\"\u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self._size == self.capacity():\n            self.extend_capacity()\n        # \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in range(self._size - 1, index - 1, -1):\n            self._arr[j + 1] = self._arr[j]\n        self._arr[index] = num\n        # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self._size += 1\n\n    def remove(self, index: int) -&gt; int:\n        \"\"\"\u5220\u9664\u5143\u7d20\"\"\"\n        if index &lt; 0 or index &gt;= self._size:\n            raise IndexError(\"\u7d22\u5f15\u8d8a\u754c\")\n        num = self._arr[index]\n        # \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in range(index, self._size - 1):\n            self._arr[j] = self._arr[j + 1]\n        # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self._size -= 1\n        # \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num\n\n    def extend_capacity(self):\n        \"\"\"\u5217\u8868\u6269\u5bb9\"\"\"\n        # \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 _extend_ratio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        self._arr = self._arr + [0] * self.capacity() * (self._extend_ratio - 1)\n        # \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        self._capacity = len(self._arr)\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u6709\u6548\u957f\u5ea6\u7684\u5217\u8868\"\"\"\n        return self._arr[: self._size]\n</code></pre> my_list.cpp<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n  private:\n    int *arr;             // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    int arrCapacity = 10; // \u5217\u8868\u5bb9\u91cf\n    int arrSize = 0;      // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    int extendRatio = 2;   // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* \u6790\u6784\u65b9\u6cd5 */\n    ~MyList() {\n        delete[] arr;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    int size() {\n        return arrSize;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    int capacity() {\n        return arrCapacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    int get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    void add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size() == capacity())\n            extendCapacity();\n        arr[size()] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size() == capacity())\n            extendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = size() - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    int remove(int index) {\n        if (index &lt; 0 || index &gt;= size())\n            throw out_of_range(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; size() - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    void extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\n        int newCapacity = capacity() * extendRatio;\n        int *tmp = arr;\n        arr = new int[newCapacity];\n        // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        for (int i = 0; i &lt; size(); i++) {\n            arr[i] = tmp[i];\n        }\n        // \u91ca\u653e\u5185\u5b58\n        delete[] tmp;\n        arrCapacity = newCapacity;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a Vector \u7528\u4e8e\u6253\u5370 */\n    vector&lt;int&gt; toVector() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        vector&lt;int&gt; vec(size());\n        for (int i = 0; i &lt; size(); i++) {\n            vec[i] = arr[i];\n        }\n        return vec;\n    }\n};\n</code></pre> my_list.java<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private int[] arr; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private int capacity = 10; // \u5217\u8868\u5bb9\u91cf\n    private int size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private int extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public MyList() {\n        arr = new int[capacity];\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09 */\n    public int size() {\n        return size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public int capacity() {\n        return capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public int get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public void set(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public void add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity();\n        arr[size] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public void insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = size - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public int remove(int index) {\n        if (index &lt; 0 || index &gt;= size)\n            throw new IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; size - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public void extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        arr = Arrays.copyOf(arr, capacity() * extendRatio);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        capacity = arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public int[] toArray() {\n        int size = size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] arr = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            arr[i] = get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.cs<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private int[] arr;           // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private int arrCapacity = 10;    // \u5217\u8868\u5bb9\u91cf\n    private int arrSize = 0;         // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private readonly int extendRatio = 2;  // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public MyList() {\n        arr = new int[arrCapacity];\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    public int Size() {\n        return arrSize;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public int Capacity() {\n        return arrCapacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public int Get(int index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        return arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public void Set(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public void Add(int num) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        arr[arrSize] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public void Insert(int index, int num) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (arrSize == arrCapacity)\n            ExtendCapacity();\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j = arrSize - 1; j &gt;= index; j--) {\n            arr[j + 1] = arr[j];\n        }\n        arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public int Remove(int index) {\n        if (index &lt; 0 || index &gt;= arrSize)\n            throw new IndexOutOfRangeException(\"\u7d22\u5f15\u8d8a\u754c\");\n        int num = arr[index];\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (int j = index; j &lt; arrSize - 1; j++) {\n            arr[j] = arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        arrSize--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public void ExtendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a arrCapacity * extendRatio \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        Array.Resize(ref arr, arrCapacity * extendRatio);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        arrCapacity = arr.Length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public int[] ToArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] arr = new int[arrSize];\n        for (int i = 0; i &lt; arrSize; i++) {\n            arr[i] = Get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.go<pre><code>/* \u5217\u8868\u7c7b */\ntype myList struct {\n    arrCapacity int\n    arr         []int\n    arrSize     int\n    extendRatio int\n}\n\n/* \u6784\u9020\u51fd\u6570 */\nfunc newMyList() *myList {\n    return &amp;myList{\n        arrCapacity: 10,              // \u5217\u8868\u5bb9\u91cf\n        arr:         make([]int, 10), // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        arrSize:     0,               // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        extendRatio: 2,               // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n    }\n}\n\n/* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09 */\nfunc (l *myList) size() int {\n    return l.arrSize\n}\n\n/*  \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\nfunc (l *myList) capacity() int {\n    return l.arrCapacity\n}\n\n/* \u8bbf\u95ee\u5143\u7d20 */\nfunc (l *myList) get(index int) int {\n    // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    return l.arr[index]\n}\n\n/* \u66f4\u65b0\u5143\u7d20 */\nfunc (l *myList) set(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    l.arr[index] = num\n}\n\n/* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\nfunc (l *myList) add(num int) {\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    l.arr[l.arrSize] = num\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize++\n}\n\n/* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\nfunc (l *myList) insert(num, index int) {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if l.arrSize == l.arrCapacity {\n        l.extendCapacity()\n    }\n    // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for j := l.arrSize - 1; j &gt;= index; j-- {\n        l.arr[j+1] = l.arr[j]\n    }\n    l.arr[index] = num\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize++\n}\n\n/* \u5220\u9664\u5143\u7d20 */\nfunc (l *myList) remove(index int) int {\n    if index &lt; 0 || index &gt;= l.arrSize {\n        panic(\"\u7d22\u5f15\u8d8a\u754c\")\n    }\n    num := l.arr[index]\n    // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for j := index; j &lt; l.arrSize-1; j++ {\n        l.arr[j] = l.arr[j+1]\n    }\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    l.arrSize--\n    // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n    return num\n}\n\n/* \u5217\u8868\u6269\u5bb9 */\nfunc (l *myList) extendCapacity() {\n    // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    l.arr = append(l.arr, make([]int, l.arrCapacity*(l.extendRatio-1))...)\n    // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n    l.arrCapacity = len(l.arr)\n}\n\n/* \u8fd4\u56de\u6709\u6548\u957f\u5ea6\u7684\u5217\u8868 */\nfunc (l *myList) toArray() []int {\n    // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    return l.arr[:l.arrSize]\n}\n</code></pre> my_list.swift<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private var arr: [Int] // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private var _capacity: Int // \u5217\u8868\u5bb9\u91cf\n    private var _size: Int // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private let extendRatio: Int // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init() {\n        _capacity = 10\n        _size = 0\n        extendRatio = 2\n        arr = Array(repeating: 0, count: _capacity)\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    func capacity() -&gt; Int {\n        _capacity\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    func get(index: Int) -&gt; Int {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\u5219\u629b\u51fa\u9519\u8bef\uff0c\u4e0b\u540c\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        return arr[index]\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    func set(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        arr[index] = num\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    func add(num: Int) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if size() == capacity() {\n            extendCapacity()\n        }\n        arr[size()] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size += 1\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    func insert(index: Int, num: Int) {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if size() == capacity() {\n            extendCapacity()\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in (index ..&lt; size()).reversed() {\n            arr[j + 1] = arr[j]\n        }\n        arr[index] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size += 1\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    @discardableResult\n    func remove(index: Int) -&gt; Int {\n        if index &lt; 0 || index &gt;= size() {\n            fatalError(\"\u7d22\u5f15\u8d8a\u754c\")\n        }\n        let num = arr[index]\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in index ..&lt; (size() - 1) {\n            arr[j] = arr[j + 1]\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        _size -= 1\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    func extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        arr = arr + Array(repeating: 0, count: capacity() * (extendRatio - 1))\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        _capacity = arr.count\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    func toArray() -&gt; [Int] {\n        Array(arr.prefix(size()))\n    }\n}\n</code></pre> my_list.js<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    #arr = new Array(); // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    #capacity = 10; // \u5217\u8868\u5bb9\u91cf\n    #size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    #extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.#arr = new Array(this.#capacity);\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    size() {\n        return this.#size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    capacity() {\n        return this.#capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    get(index) {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        return this.#arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    set(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        this.#arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    add(num) {\n        // \u5982\u679c\u957f\u5ea6\u7b49\u4e8e\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u6269\u5bb9\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u5217\u8868\u5c3e\u90e8\n        this.#arr[this.#size] = num;\n        this.#size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    insert(index, num) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (this.#size === this.#capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (let j = this.#size - 1; j &gt;= index; j--) {\n            this.#arr[j + 1] = this.#arr[j];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.#arr[index] = num;\n        this.#size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    remove(index) {\n        if (index &lt; 0 || index &gt;= this.#size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        let num = this.#arr[index];\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (let j = index; j &lt; this.#size - 1; j++) {\n            this.#arr[j] = this.#arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.#size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        this.#arr = this.#arr.concat(\n            new Array(this.capacity() * (this.#extendRatio - 1))\n        );\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        this.#capacity = this.#arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    toArray() {\n        let size = this.size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.ts<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private arr: Array&lt;number&gt;; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private _capacity: number = 10; // \u5217\u8868\u5bb9\u91cf\n    private _size: number = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private extendRatio: number = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.arr = new Array(this._capacity);\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    public size(): number {\n        return this._size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    public capacity(): number {\n        return this._capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    public get(index: number): number {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        return this.arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    public set(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        this.arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    public add(num: number): void {\n        // \u5982\u679c\u957f\u5ea6\u7b49\u4e8e\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u6269\u5bb9\n        if (this._size === this._capacity) this.extendCapacity();\n        // \u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u5217\u8868\u5c3e\u90e8\n        this.arr[this._size] = num;\n        this._size++;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    public insert(index: number, num: number): void {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (this._size === this._capacity) {\n            this.extendCapacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (let j = this._size - 1; j &gt;= index; j--) {\n            this.arr[j + 1] = this.arr[j];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this.arr[index] = num;\n        this._size++;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    public remove(index: number): number {\n        if (index &lt; 0 || index &gt;= this._size) throw new Error('\u7d22\u5f15\u8d8a\u754c');\n        let num = this.arr[index];\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (let j = index; j &lt; this._size - 1; j++) {\n            this.arr[j] = this.arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        this._size--;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    public extendCapacity(): void {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a size \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        this.arr = this.arr.concat(\n            new Array(this.capacity() * (this.extendRatio - 1))\n        );\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        this._capacity = this.arr.length;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    public toArray(): number[] {\n        let size = this.size();\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(size);\n        for (let i = 0; i &lt; size; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    }\n}\n</code></pre> my_list.dart<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n  late List&lt;int&gt; _arr; // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n  int _capacity = 10; // \u5217\u8868\u5bb9\u91cf\n  int _size = 0; // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n  int _extendRatio = 2; // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  MyList() {\n    _arr = List.filled(_capacity, 0);\n  }\n\n  /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n  int size() =&gt; _size;\n\n  /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n  int capacity() =&gt; _capacity;\n\n  /* \u8bbf\u95ee\u5143\u7d20 */\n  int get(int index) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    return _arr[index];\n  }\n\n  /* \u66f4\u65b0\u5143\u7d20 */\n  void set(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    _arr[index] = _num;\n  }\n\n  /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n  void add(int _num) {\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (_size == _capacity) extendCapacity();\n    _arr[_size] = _num;\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size++;\n  }\n\n  /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n  void insert(int index, int _num) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (_size == _capacity) extendCapacity();\n    // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for (var j = _size - 1; j &gt;= index; j--) {\n      _arr[j + 1] = _arr[j];\n    }\n    _arr[index] = _num;\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size++;\n  }\n\n  /* \u5220\u9664\u5143\u7d20 */\n  int remove(int index) {\n    if (index &gt;= _size) throw RangeError('\u7d22\u5f15\u8d8a\u754c');\n    int _num = _arr[index];\n    // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for (var j = index; j &lt; _size - 1; j++) {\n      _arr[j] = _arr[j + 1];\n    }\n    // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    _size--;\n    // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n    return _num;\n  }\n\n  /* \u5217\u8868\u6269\u5bb9 */\n  void extendCapacity() {\n    // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 _extendRatio \u500d\u7684\u65b0\u6570\u7ec4\n    final _newNums = List.filled(_capacity * _extendRatio, 0);\n    // \u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    List.copyRange(_newNums, 0, _arr);\n    // \u66f4\u65b0 _arr \u7684\u5f15\u7528\n    _arr = _newNums;\n    // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n    _capacity = _arr.length;\n  }\n\n  /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n  List&lt;int&gt; toArray() {\n    List&lt;int&gt; arr = [];\n    for (var i = 0; i &lt; _size; i++) {\n      arr.add(get(i));\n    }\n    return arr;\n  }\n}\n</code></pre> my_list.rs<pre><code>/* \u5217\u8868\u7c7b */\n#[allow(dead_code)]\nstruct MyList {\n    arr: Vec&lt;i32&gt;,       // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    capacity: usize,     // \u5217\u8868\u5bb9\u91cf\n    size: usize,         // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    extend_ratio: usize, // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n}\n\n#[allow(unused, unused_comparisons)]\nimpl MyList {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    pub fn new(capacity: usize) -&gt; Self {\n        let mut vec = Vec::new();\n        vec.resize(capacity, 0);\n        Self {\n            arr: vec,\n            capacity,\n            size: 0,\n            extend_ratio: 2,\n        }\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09*/\n    pub fn size(&amp;self) -&gt; usize {\n        return self.size;\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    pub fn capacity(&amp;self) -&gt; usize {\n        return self.capacity;\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    pub fn get(&amp;self, index: usize) -&gt; i32 {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if index &gt;= self.size {\n            panic!(\"\u7d22\u5f15\u8d8a\u754c\")\n        };\n        return self.arr[index];\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    pub fn set(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size {\n            panic!(\"\u7d22\u5f15\u8d8a\u754c\")\n        };\n        self.arr[index] = num;\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    pub fn add(&amp;mut self, num: i32) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        self.arr[self.size] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size += 1;\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    pub fn insert(&amp;mut self, index: usize, num: i32) {\n        if index &gt;= self.size() {\n            panic!(\"\u7d22\u5f15\u8d8a\u754c\")\n        };\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if self.size == self.capacity() {\n            self.extend_capacity();\n        }\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for j in (index..self.size).rev() {\n            self.arr[j + 1] = self.arr[j];\n        }\n        self.arr[index] = num;\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size += 1;\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    pub fn remove(&amp;mut self, index: usize) -&gt; i32 {\n        if index &gt;= self.size() {\n            panic!(\"\u7d22\u5f15\u8d8a\u754c\")\n        };\n        let num = self.arr[index];\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for j in (index..self.size - 1) {\n            self.arr[j] = self.arr[j + 1];\n        }\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        self.size -= 1;\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num;\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    pub fn extend_capacity(&amp;mut self) {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extend_ratio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        let new_capacity = self.capacity * self.extend_ratio;\n        self.arr.resize(new_capacity, 0);\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        self.capacity = new_capacity;\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    pub fn to_array(&amp;mut self) -&gt; Vec&lt;i32&gt; {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        let mut arr = Vec::new();\n        for i in 0..self.size {\n            arr.push(self.get(i));\n        }\n        arr\n    }\n}\n</code></pre> my_list.c<pre><code>/* \u5217\u8868\u7c7b */\ntypedef struct {\n    int *arr;        // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    int capacity;    // \u5217\u8868\u5bb9\u91cf\n    int size;        // \u5217\u8868\u5927\u5c0f\n    int extendRatio; // \u5217\u8868\u6bcf\u6b21\u6269\u5bb9\u7684\u500d\u6570\n} MyList;\n\n/* \u6784\u9020\u51fd\u6570 */\nMyList *newMyList() {\n    MyList *nums = malloc(sizeof(MyList));\n    nums-&gt;capacity = 10;\n    nums-&gt;arr = malloc(sizeof(int) * nums-&gt;capacity);\n    nums-&gt;size = 0;\n    nums-&gt;extendRatio = 2;\n    return nums;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delMyList(MyList *nums) {\n    free(nums-&gt;arr);\n    free(nums);\n}\n\n/* \u83b7\u53d6\u5217\u8868\u957f\u5ea6 */\nint size(MyList *nums) {\n    return nums-&gt;size;\n}\n\n/* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\nint capacity(MyList *nums) {\n    return nums-&gt;capacity;\n}\n\n/* \u8bbf\u95ee\u5143\u7d20 */\nint get(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    return nums-&gt;arr[index];\n}\n\n/* \u66f4\u65b0\u5143\u7d20 */\nvoid set(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; nums-&gt;size);\n    nums-&gt;arr[index] = num;\n}\n\n/* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\nvoid add(MyList *nums, int num) {\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // \u6269\u5bb9\n    }\n    nums-&gt;arr[size(nums)] = num;\n    nums-&gt;size++;\n}\n\n/* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\nvoid insert(MyList *nums, int index, int num) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    if (size(nums) == capacity(nums)) {\n        extendCapacity(nums); // \u6269\u5bb9\n    }\n    for (int i = size(nums); i &gt; index; --i) {\n        nums-&gt;arr[i] = nums-&gt;arr[i - 1];\n    }\n    nums-&gt;arr[index] = num;\n    nums-&gt;size++;\n}\n\n/* \u5220\u9664\u5143\u7d20 */\n// \u6ce8\u610f\uff1astdio.h \u5360\u7528\u4e86 remove \u5173\u952e\u8bcd\nint removeItem(MyList *nums, int index) {\n    assert(index &gt;= 0 &amp;&amp; index &lt; size(nums));\n    int num = nums-&gt;arr[index];\n    for (int i = index; i &lt; size(nums) - 1; i++) {\n        nums-&gt;arr[i] = nums-&gt;arr[i + 1];\n    }\n    nums-&gt;size--;\n    return num;\n}\n\n/* \u5217\u8868\u6269\u5bb9 */\nvoid extendCapacity(MyList *nums) {\n    // \u5148\u5206\u914d\u7a7a\u95f4\n    int newCapacity = capacity(nums) * nums-&gt;extendRatio;\n    int *extend = (int *)malloc(sizeof(int) * newCapacity);\n    int *temp = nums-&gt;arr;\n\n    // \u62f7\u8d1d\u65e7\u6570\u636e\u5230\u65b0\u6570\u636e\n    for (int i = 0; i &lt; size(nums); i++)\n        extend[i] = nums-&gt;arr[i];\n\n    // \u91ca\u653e\u65e7\u6570\u636e\n    free(temp);\n\n    // \u66f4\u65b0\u65b0\u6570\u636e\n    nums-&gt;arr = extend;\n    nums-&gt;capacity = newCapacity;\n}\n\n/* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a Array \u7528\u4e8e\u6253\u5370 */\nint *toArray(MyList *nums) {\n    return nums-&gt;arr;\n}\n</code></pre> my_list.kt<pre><code>/* \u5217\u8868\u7c7b */\nclass MyList {\n    private var arr: IntArray = intArrayOf() // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n    private var capacity: Int = 10 // \u5217\u8868\u5bb9\u91cf\n    private var size: Int = 0 // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n    private var extendRatio: Int = 2 // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init {\n        arr = IntArray(capacity)\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09 */\n    fun size(): Int {\n        return size\n    }\n\n    /* \u83b7\u53d6\u5217\u8868\u5bb9\u91cf */\n    fun capacity(): Int {\n        return capacity\n    }\n\n    /* \u8bbf\u95ee\u5143\u7d20 */\n    fun get(index: Int): Int {\n        // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\")\n        return arr[index]\n    }\n\n    /* \u66f4\u65b0\u5143\u7d20 */\n    fun set(index: Int, num: Int) {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\")\n        arr[index] = num\n    }\n\n    /* \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 */\n    fun add(num: Int) {\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity()\n        arr[size] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++\n    }\n\n    /* \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 */\n    fun insert(index: Int, num: Int) {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\")\n        // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n        if (size == capacity())\n            extendCapacity()\n        // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (j in size - 1 downTo index)\n            arr[j + 1] = arr[j]\n        arr[index] = num\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size++\n    }\n\n    /* \u5220\u9664\u5143\u7d20 */\n    fun remove(index: Int): Int {\n        if (index &lt; 0 || index &gt;= size)\n            throw IndexOutOfBoundsException(\"\u7d22\u5f15\u8d8a\u754c\")\n        val num = arr[index]\n        // \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n        for (j in index..&lt;size - 1)\n            arr[j] = arr[j + 1]\n        // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n        size--\n        // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n        return num\n    }\n\n    /* \u5217\u8868\u6269\u5bb9 */\n    fun extendCapacity() {\n        // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extendRatio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n        arr = arr.copyOf(capacity() * extendRatio)\n        // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n        capacity = arr.size\n    }\n\n    /* \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 */\n    fun toArray(): IntArray {\n        val size = size()\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        val arr = IntArray(size)\n        for (i in 0..&lt;size) {\n            arr[i] = get(i)\n        }\n        return arr\n    }\n}\n</code></pre> my_list.rb<pre><code>### \u5217\u8868\u7c7b ###\nclass MyList\n  attr_reader :size       # \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n  attr_reader :capacity   # \u83b7\u53d6\u5217\u8868\u5bb9\u91cf\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @capacity = 10\n    @size = 0\n    @extend_ratio = 2\n    @arr = Array.new(capacity)\n  end\n\n  ### \u8bbf\u95ee\u5143\u7d20 ###\n  def get(index)\n    # \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n    raise IndexError, \"\u7d22\u5f15\u8d8a\u754c\" if index &lt; 0 || index &gt;= size\n    @arr[index]\n  end\n\n  ### \u8bbf\u95ee\u5143\u7d20 ###\n  def set(index, num)\n    raise IndexError, \"\u7d22\u5f15\u8d8a\u754c\" if index &lt; 0 || index &gt;= size\n    @arr[index] = num\n  end\n\n  ### \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20 ###\n  def add(num)\n    # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    extend_capacity if size == capacity\n    @arr[size] = num\n\n    # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    @size += 1\n  end\n\n  ### \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20 ###\n  def insert(index, num)\n    raise IndexError, \"\u7d22\u5f15\u8d8a\u754c\" if index &lt; 0 || index &gt;= size\n\n    # \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n    extend_capacity if size == capacity\n\n    # \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    for j in (size - 1).downto(index)\n      @arr[j + 1] = @arr[j]\n    end\n    @arr[index] = num\n\n    # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    @size += 1\n  end\n\n  ### \u5220\u9664\u5143\u7d20 ###\n  def remove(index)\n    raise IndexError, \"\u7d22\u5f15\u8d8a\u754c\" if index &lt; 0 || index &gt;= size\n    num = @arr[index]\n\n    # \u5c06\u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n    for j in index...size\n      @arr[j] = @arr[j + 1]\n    end\n\n    # \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n    @size -= 1\n\n    # \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n    num\n  end\n\n  ### \u5217\u8868\u6269\u5bb9 ###\n  def extend_capacity\n    # \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a\u539f\u6570\u7ec4 extend_ratio \u500d\u7684\u65b0\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n    arr = @arr.dup + Array.new(capacity * (@extend_ratio - 1))\n    # \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n    @capacity = arr.length\n  end\n\n  ### \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4 ###\n  def to_array\n    sz = size\n    # \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    arr = Array.new(sz)\n    for i in 0...sz\n      arr[i] = get(i)\n    end\n    arr\n  end\nend\n</code></pre> my_list.zig<pre><code>// \u5217\u8868\u7c7b\nfn MyList(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        arr: []T = undefined,                        // \u6570\u7ec4\uff08\u5b58\u50a8\u5217\u8868\u5143\u7d20\uff09\n        arrCapacity: usize = 10,                     // \u5217\u8868\u5bb9\u91cf\n        numSize: usize = 0,                           // \u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        extendRatio: usize = 2,                       // \u6bcf\u6b21\u5217\u8868\u6269\u5bb9\u7684\u500d\u6570\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined, // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u5217\u8868\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.arr = try self.mem_allocator.alloc(T, self.arrCapacity);\n            @memset(self.arr, @as(T, 0));\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u5217\u8868\u957f\u5ea6\uff08\u5f53\u524d\u5143\u7d20\u6570\u91cf\uff09\n        pub fn size(self: *Self) usize {\n            return self.numSize;\n        }\n\n        // \u83b7\u53d6\u5217\u8868\u5bb9\u91cf\n        pub fn capacity(self: *Self) usize {\n            return self.arrCapacity;\n        }\n\n        // \u8bbf\u95ee\u5143\u7d20\n        pub fn get(self: *Self, index: usize) T {\n            // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            return self.arr[index];\n        }  \n\n        // \u66f4\u65b0\u5143\u7d20\n        pub fn set(self: *Self, index: usize, num: T) void {\n            // \u7d22\u5f15\u5982\u679c\u8d8a\u754c\uff0c\u5219\u629b\u51fa\u5f02\u5e38\uff0c\u4e0b\u540c\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            self.arr[index] = num;\n        }  \n\n        // \u5728\u5c3e\u90e8\u6dfb\u52a0\u5143\u7d20\n        pub fn add(self: *Self, num: T) !void {\n            // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n            if (self.size() == self.capacity()) try self.extendCapacity();\n            self.arr[self.size()] = num;\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize += 1;\n        }  \n\n        // \u5728\u4e2d\u95f4\u63d2\u5165\u5143\u7d20\n        pub fn insert(self: *Self, index: usize, num: T) !void {\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            // \u5143\u7d20\u6570\u91cf\u8d85\u51fa\u5bb9\u91cf\u65f6\uff0c\u89e6\u53d1\u6269\u5bb9\u673a\u5236\n            if (self.size() == self.capacity()) try self.extendCapacity();\n            // \u5c06\u7d22\u5f15 index \u4ee5\u53ca\u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n            var j = self.size() - 1;\n            while (j &gt;= index) : (j -= 1) {\n                self.arr[j + 1] = self.arr[j];\n            }\n            self.arr[index] = num;\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize += 1;\n        }\n\n        // \u5220\u9664\u5143\u7d20\n        pub fn remove(self: *Self, index: usize) T {\n            if (index &lt; 0 or index &gt;= self.size()) @panic(\"\u7d22\u5f15\u8d8a\u754c\");\n            var num = self.arr[index];\n            // \u5c06\u7d22\u5f15 index \u4e4b\u540e\u7684\u5143\u7d20\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4f4d\n            var j = index;\n            while (j &lt; self.size() - 1) : (j += 1) {\n                self.arr[j] = self.arr[j + 1];\n            }\n            // \u66f4\u65b0\u5143\u7d20\u6570\u91cf\n            self.numSize -= 1;\n            // \u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\n            return num;\n        }\n\n        // \u5217\u8868\u6269\u5bb9\n        pub fn extendCapacity(self: *Self) !void {\n            // \u65b0\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a size * extendRatio \u7684\u6570\u7ec4\uff0c\u5e76\u5c06\u539f\u6570\u7ec4\u590d\u5236\u5230\u65b0\u6570\u7ec4\n            var newCapacity = self.capacity() * self.extendRatio;\n            var extend = try self.mem_allocator.alloc(T, newCapacity);\n            @memset(extend, @as(T, 0));\n            // \u5c06\u539f\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u590d\u5236\u5230\u65b0\u6570\u7ec4\n            std.mem.copy(T, extend, self.arr);\n            self.arr = extend;\n            // \u66f4\u65b0\u5217\u8868\u5bb9\u91cf\n            self.arrCapacity = newCapacity;\n        }\n\n        // \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4\n        pub fn toArray(self: *Self) ![]T {\n            // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n            var arr = try self.mem_allocator.alloc(T, self.size());\n           @memset(arr, @as(T, 0));\n            for (arr, 0..) |*num, i| {\n                num.* = self.get(i);\n            }\n            return arr;\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/","title":"4.4 \u00a0 Memory and cache *","text":"<p>In the first two sections of this chapter, we explored arrays and linked lists, two fundamental and important data structures, representing \"continuous storage\" and \"dispersed storage\" respectively.</p> <p>In fact, the physical structure largely determines the efficiency of a program's use of memory and cache, which in turn affects the overall performance of the algorithm.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#441-computer-storage-devices","title":"4.4.1 \u00a0 Computer storage devices","text":"<p>There are three types of storage devices in computers: hard disk, random-access memory (RAM), and cache memory. The following table shows their different roles and performance characteristics in computer systems.</p> <p> Table 4-2 \u00a0 Computer storage devices </p> Hard Disk Memory Cache Usage Long-term storage of data, including OS, programs, files, etc. Temporary storage of currently running programs and data being processed Stores frequently accessed data and instructions, reducing the number of CPU accesses to memory Volatility Data is not lost after power off Data is lost after power off Data is lost after power off Capacity Larger, TB level Smaller, GB level Very small, MB level Speed Slower, several hundred to thousands MB/s Faster, several tens of GB/s Very fast, several tens to hundreds of GB/s Price Cheaper, several cents to yuan / GB More expensive, tens to hundreds of yuan / GB Very expensive, priced with CPU <p>We can imagine the computer storage system as a pyramid structure shown in Figure 4-9. The storage devices closer to the top of the pyramid are faster, have smaller capacity, and are more costly. This multi-level design is not accidental, but the result of careful consideration by computer scientists and engineers.</p> <ul> <li>Hard disks are difficult to replace with memory. Firstly, data in memory is lost after power off, making it unsuitable for long-term data storage; secondly, the cost of memory is dozens of times that of hard disks, making it difficult to popularize in the consumer market.</li> <li>It is difficult for caches to have both large capacity and high speed. As the capacity of L1, L2, L3 caches gradually increases, their physical size becomes larger, increasing the physical distance from the CPU core, leading to increased data transfer time and higher element access latency. Under current technology, a multi-level cache structure is the best balance between capacity, speed, and cost.</li> </ul> <p></p> <p> Figure 4-9 \u00a0 Computer storage system </p> <p>Tip</p> <p>The storage hierarchy of computers reflects a delicate balance between speed, capacity, and cost. In fact, this kind of trade-off is common in all industrial fields, requiring us to find the best balance between different advantages and limitations.</p> <p>Overall, hard disks are used for long-term storage of large amounts of data, memory is used for temporary storage of data being processed during program execution, and cache is used to store frequently accessed data and instructions to improve program execution efficiency. Together, they ensure the efficient operation of computer systems.</p> <p>As shown in Figure 4-10, during program execution, data is read from the hard disk into memory for CPU computation. The cache can be considered a part of the CPU, smartly loading data from memory to provide fast data access to the CPU, significantly enhancing program execution efficiency and reducing reliance on slower memory.</p> <p></p> <p> Figure 4-10 \u00a0 Data flow between hard disk, memory, and cache </p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#442-memory-efficiency-of-data-structures","title":"4.4.2 \u00a0 Memory efficiency of data structures","text":"<p>In terms of memory space utilization, arrays and linked lists have their advantages and limitations.</p> <p>On one hand, memory is limited and cannot be shared by multiple programs, so we hope that data structures can use space as efficiently as possible. The elements of an array are tightly packed without extra space for storing references (pointers) between linked list nodes, making them more space-efficient. However, arrays require allocating sufficient continuous memory space at once, which may lead to memory waste, and array expansion also requires additional time and space costs. In contrast, linked lists allocate and reclaim memory dynamically on a per-node basis, providing greater flexibility.</p> <p>On the other hand, during program execution, as memory is repeatedly allocated and released, the degree of fragmentation of free memory becomes higher, leading to reduced memory utilization efficiency. Arrays, due to their continuous storage method, are relatively less likely to cause memory fragmentation. In contrast, the elements of a linked list are dispersedly stored, and frequent insertion and deletion operations make memory fragmentation more likely.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#443-cache-efficiency-of-data-structures","title":"4.4.3 \u00a0 Cache efficiency of data structures","text":"<p>Although caches are much smaller in space capacity than memory, they are much faster and play a crucial role in program execution speed. Since the cache's capacity is limited and can only store a small part of frequently accessed data, when the CPU tries to access data not in the cache, a cache miss occurs, forcing the CPU to load the needed data from slower memory.</p> <p>Clearly, the fewer the cache misses, the higher the CPU's data read-write efficiency, and the better the program performance. The proportion of successful data retrieval from the cache by the CPU is called the cache hit rate, a metric often used to measure cache efficiency.</p> <p>To achieve higher efficiency, caches adopt the following data loading mechanisms.</p> <ul> <li>Cache lines: Caches don't store and load data byte by byte but in units of cache lines. Compared to byte-by-byte transfer, the transmission of cache lines is more efficient.</li> <li>Prefetch mechanism: Processors try to predict data access patterns (such as sequential access, fixed stride jumping access, etc.) and load data into the cache according to specific patterns to improve the hit rate.</li> <li>Spatial locality: If data is accessed, data nearby is likely to be accessed in the near future. Therefore, when loading certain data, the cache also loads nearby data to improve the hit rate.</li> <li>Temporal locality: If data is accessed, it's likely to be accessed again in the near future. Caches use this principle to retain recently accessed data to improve the hit rate.</li> </ul> <p>In fact, arrays and linked lists have different cache utilization efficiencies, mainly reflected in the following aspects.</p> <ul> <li>Occupied space: Linked list elements occupy more space than array elements, resulting in less effective data volume in the cache.</li> <li>Cache lines: Linked list data is scattered throughout memory, and since caches load \"by line,\" the proportion of loading invalid data is higher.</li> <li>Prefetch mechanism: The data access pattern of arrays is more \"predictable\" than that of linked lists, meaning the system is more likely to guess which data will be loaded next.</li> <li>Spatial locality: Arrays are stored in concentrated memory spaces, so the data near the loaded data is more likely to be accessed next.</li> </ul> <p>Overall, arrays have a higher cache hit rate and are generally more efficient in operation than linked lists. This makes data structures based on arrays more popular in solving algorithmic problems.</p> <p>It should be noted that high cache efficiency does not mean that arrays are always better than linked lists. Which data structure to choose in actual applications should be based on specific requirements. For example, both arrays and linked lists can implement the \"stack\" data structure (which will be detailed in the next chapter), but they are suitable for different scenarios.</p> <ul> <li>In algorithm problems, we tend to choose stacks based on arrays because they provide higher operational efficiency and random access capabilities, with the only cost being the need to pre-allocate a certain amount of memory space for the array.</li> <li>If the data volume is very large, highly dynamic, and the expected size of the stack is difficult to estimate, then a stack based on a linked list is more appropriate. Linked lists can disperse a large amount of data in different parts of the memory and avoid the additional overhead of array expansion.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/","title":"4.5 \u00a0 Summary","text":""},{"location":"chapter_array_and_linkedlist/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>Arrays and linked lists are two basic data structures, representing two storage methods in computer memory: contiguous space storage and non-contiguous space storage. Their characteristics complement each other.</li> <li>Arrays support random access and use less memory; however, they are inefficient in inserting and deleting elements and have a fixed length after initialization.</li> <li>Linked lists implement efficient node insertion and deletion through changing references (pointers) and can flexibly adjust their length; however, they have lower node access efficiency and consume more memory.</li> <li>Common types of linked lists include singly linked lists, circular linked lists, and doubly linked lists, each with its own application scenarios.</li> <li>Lists are ordered collections of elements that support addition, deletion, and modification, typically implemented based on dynamic arrays, retaining the advantages of arrays while allowing flexible length adjustment.</li> <li>The advent of lists significantly enhanced the practicality of arrays but may lead to some memory space wastage.</li> <li>During program execution, data is mainly stored in memory. Arrays provide higher memory space efficiency, while linked lists are more flexible in memory usage.</li> <li>Caches provide fast data access to CPUs through mechanisms like cache lines, prefetching, spatial locality, and temporal locality, significantly enhancing program execution efficiency.</li> <li>Due to higher cache hit rates, arrays are generally more efficient than linked lists. When choosing a data structure, the appropriate choice should be made based on specific needs and scenarios.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Does storing arrays on the stack versus the heap affect time and space efficiency?</p> <p>Arrays stored on both the stack and heap are stored in contiguous memory spaces, and data operation efficiency is essentially the same. However, stacks and heaps have their own characteristics, leading to the following differences.</p> <ol> <li>Allocation and release efficiency: The stack is a smaller memory block, allocated automatically by the compiler; the heap memory is relatively larger and can be dynamically allocated in the code, more prone to fragmentation. Therefore, allocation and release operations on the heap are generally slower than on the stack.</li> <li>Size limitation: Stack memory is relatively small, while the heap size is generally limited by available memory. Therefore, the heap is more suitable for storing large arrays.</li> <li>Flexibility: The size of arrays on the stack needs to be determined at compile-time, while the size of arrays on the heap can be dynamically determined at runtime.</li> </ol> <p>Q: Why do arrays require elements of the same type, while linked lists do not emphasize same-type elements?</p> <p>Linked lists consist of nodes connected by references (pointers), and each node can store data of different types, such as int, double, string, object, etc.</p> <p>In contrast, array elements must be of the same type, allowing the calculation of offsets to access the corresponding element positions. For example, an array containing both int and long types, with single elements occupying 4 bytes and 8 bytes respectively, cannot use the following formula to calculate offsets, as the array contains elements of two different lengths.</p> <pre><code># Element memory address = array memory address + element length * element index\n</code></pre> <p>Q: After deleting a node, is it necessary to set <code>P.next</code> to <code>None</code>?</p> <p>Not modifying <code>P.next</code> is also acceptable. From the perspective of the linked list, traversing from the head node to the tail node will no longer encounter <code>P</code>. This means that node <code>P</code> has been effectively removed from the list, and where <code>P</code> points no longer affects the list.</p> <p>From a garbage collection perspective, for languages with automatic garbage collection mechanisms like Java, Python, and Go, whether node <code>P</code> is collected depends on whether there are still references pointing to it, not on the value of <code>P.next</code>. In languages like C and C++, we need to manually free the node's memory.</p> <p>Q: In linked lists, the time complexity for insertion and deletion operations is <code>O(1)</code>. But searching for the element before insertion or deletion takes <code>O(n)</code> time, so why isn't the time complexity <code>O(n)</code>?</p> <p>If an element is searched first and then deleted, the time complexity is indeed <code>O(n)</code>. However, the <code>O(1)</code> advantage of linked lists in insertion and deletion can be realized in other applications. For example, in the implementation of double-ended queues using linked lists, we maintain pointers always pointing to the head and tail nodes, making each insertion and deletion operation <code>O(1)</code>.</p> <p>Q: In the figure \"Linked List Definition and Storage Method\", do the light blue storage nodes occupy a single memory address, or do they share half with the node value?</p> <p>The diagram is just a qualitative representation; quantitative analysis depends on specific situations.</p> <ul> <li>Different types of node values occupy different amounts of space, such as int, long, double, and object instances.</li> <li>The memory space occupied by pointer variables depends on the operating system and compilation environment used, usually 8 bytes or 4 bytes.</li> </ul> <p>Q: Is adding elements to the end of a list always <code>O(1)</code>?</p> <p>If adding an element exceeds the list length, the list needs to be expanded first. The system will request a new memory block and move all elements of the original list over, in which case the time complexity becomes <code>O(n)</code>.</p> <p>Q: The statement \"The emergence of lists greatly improves the practicality of arrays, but may lead to some memory space wastage\" - does this refer to the memory occupied by additional variables like capacity, length, and expansion multiplier?</p> <p>The space wastage here mainly refers to two aspects: on the one hand, lists are set with an initial length, which we may not always need; on the other hand, to prevent frequent expansion, expansion usually multiplies by a coefficient, such as \\(\\times 1.5\\). This results in many empty slots, which we typically cannot fully fill.</p> <p>Q: In Python, after initializing <code>n = [1, 2, 3]</code>, the addresses of these 3 elements are contiguous, but initializing <code>m = [2, 1, 3]</code> shows that each element's <code>id</code> is not consecutive but identical to those in <code>n</code>. If the addresses of these elements are not contiguous, is <code>m</code> still an array?</p> <p>If we replace list elements with linked list nodes <code>n = [n1, n2, n3, n4, n5]</code>, these 5 node objects are also typically dispersed throughout memory. However, given a list index, we can still access the node's memory address in <code>O(1)</code> time, thereby accessing the corresponding node. This is because the array stores references to the nodes, not the nodes themselves.</p> <p>Unlike many languages, in Python, numbers are also wrapped as objects, and lists store references to these numbers, not the numbers themselves. Therefore, we find that the same number in two arrays has the same <code>id</code>, and these numbers' memory addresses need not be contiguous.</p> <p>Q: The <code>std::list</code> in C++ STL has already implemented a doubly linked list, but it seems that some algorithm books don't directly use it. Is there any limitation?</p> <p>On the one hand, we often prefer to use arrays to implement algorithms, only using linked lists when necessary, mainly for two reasons.</p> <ul> <li>Space overhead: Since each element requires two additional pointers (one for the previous element and one for the next), <code>std::list</code> usually occupies more space than <code>std::vector</code>.</li> <li>Cache unfriendly: As the data is not stored continuously, <code>std::list</code> has a lower cache utilization rate. Generally, <code>std::vector</code> performs better.</li> </ul> <p>On the other hand, linked lists are primarily necessary for binary trees and graphs. Stacks and queues are often implemented using the programming language's <code>stack</code> and <code>queue</code> classes, rather than linked lists.</p> <p>Q: Does initializing a list <code>res = [0] * self.size()</code> result in each element of <code>res</code> referencing the same address?</p> <p>No. However, this issue arises with two-dimensional arrays, for example, initializing a two-dimensional list <code>res = [[0] * self.size()]</code> would reference the same list <code>[0]</code> multiple times.</p> <p>Q: In deleting a node, is it necessary to break the reference to its successor node?</p> <p>From the perspective of data structures and algorithms (problem-solving), it's okay not to break the link, as long as the program's logic is correct. From the perspective of standard libraries, breaking the link is safer and more logically clear. If the link is not broken, and the deleted node is not properly recycled, it could affect the recycling of the successor node's memory.</p>"},{"location":"chapter_backtracking/","title":"Chapter 13. \u00a0 Backtracking","text":"<p>Abstract</p> <p>Like explorers in a maze, we may encounter difficulties on our path forward.</p> <p>The power of backtracking allows us to start over, keep trying, and eventually find the exit to the light.</p>"},{"location":"chapter_backtracking/#chapter-contents","title":"Chapter contents","text":"<ul> <li>13.1 \u00a0 Backtracking algorithms</li> <li>13.2 \u00a0 Permutation problem</li> <li>13.3 \u00a0 Subset sum problem</li> <li>13.4 \u00a0 n queens problem</li> <li>13.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_backtracking/backtracking_algorithm/","title":"13.1 \u00a0 Backtracking algorithms","text":"<p>Backtracking algorithm is a method to solve problems by exhaustive search, where the core idea is to start from an initial state and brute force all possible solutions, recording the correct ones until a solution is found or all possible choices are exhausted without finding a solution.</p> <p>Backtracking typically employs \"depth-first search\" to traverse the solution space. In the \"Binary Tree\" chapter, we mentioned that preorder, inorder, and postorder traversals are all depth-first searches. Next, we use preorder traversal to construct a backtracking problem to gradually understand the workings of the backtracking algorithm.</p> <p>Example One</p> <p>Given a binary tree, search and record all nodes with a value of \\(7\\), please return a list of nodes.</p> <p>For this problem, we traverse this tree in preorder and check if the current node's value is \\(7\\). If it is, we add the node's value to the result list <code>res</code>. The relevant process is shown in the following diagram and code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig preorder_traversal_i_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"\u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00\"\"\"\n    if root is None:\n        return\n    if root.val == 7:\n        # \u8bb0\u5f55\u89e3\n        res.append(root)\n    pre_order(root.left)\n    pre_order(root.right)\n</code></pre> preorder_traversal_i_compact.cpp<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr) {\n        return;\n    }\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push_back(root);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n</code></pre> preorder_traversal_i_compact.java<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nvoid preOrder(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.add(root);\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n}\n</code></pre> preorder_traversal_i_compact.cs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) {\n        return;\n    }\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.Add(root);\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n}\n</code></pre> preorder_traversal_i_compact.go<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfunc preOrderI(root *TreeNode, res *[]*TreeNode) {\n    if root == nil {\n        return\n    }\n    if (root.Val).(int) == 7 {\n        // \u8bb0\u5f55\u89e3\n        *res = append(*res, root)\n    }\n    preOrderI(root.Left, res)\n    preOrderI(root.Right, res)\n}\n</code></pre> preorder_traversal_i_compact.swift<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    if root.val == 7 {\n        // \u8bb0\u5f55\u89e3\n        res.append(root)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n}\n</code></pre> preorder_traversal_i_compact.js<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfunction preOrder(root, res) {\n    if (root === null) {\n        return;\n    }\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push(root);\n    }\n    preOrder(root.left, res);\n    preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.ts<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfunction preOrder(root: TreeNode | null, res: TreeNode[]): void {\n    if (root === null) {\n        return;\n    }\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push(root);\n    }\n    preOrder(root.left, res);\n    preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.dart<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nvoid preOrder(TreeNode? root, List&lt;TreeNode&gt; res) {\n  if (root == null) {\n    return;\n  }\n  if (root.val == 7) {\n    // \u8bb0\u5f55\u89e3\n    res.add(root);\n  }\n  preOrder(root.left, res);\n  preOrder(root.right, res);\n}\n</code></pre> preorder_traversal_i_compact.rs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfn pre_order(res: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) {\n    if root.is_none() {\n        return;\n    }\n    if let Some(node) = root {\n        if node.borrow().val == 7 {\n            // \u8bb0\u5f55\u89e3\n            res.push(node.clone());\n        }\n        pre_order(res, node.borrow().left.clone());\n        pre_order(res, node.borrow().right.clone());\n    }\n}\n</code></pre> preorder_traversal_i_compact.c<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nvoid preOrder(TreeNode *root) {\n    if (root == NULL) {\n        return;\n    }\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res[resSize++] = root;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n</code></pre> preorder_traversal_i_compact.kt<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e00 */\nfun preOrder(root: TreeNode?) {\n    if (root == null) {\n        return\n    }\n    if (root._val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res!!.add(root)\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n}\n</code></pre> preorder_traversal_i_compact.rb<pre><code>[class]{}-[func]{pre_order}\n</code></pre> preorder_traversal_i_compact.zig<pre><code>[class]{}-[func]{preOrder}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 13-1 \u00a0 Searching nodes in preorder traversal </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1311-trying-and-retreating","title":"13.1.1 \u00a0 Trying and retreating","text":"<p>The reason it is called backtracking is that the algorithm uses a \"try\" and \"retreat\" strategy when searching the solution space. When the algorithm encounters a state where it can no longer progress or fails to achieve a satisfying solution, it undoes the previous choice, reverts to the previous state, and tries other possible choices.</p> <p>For Example One, visiting each node represents a \"try\", and passing a leaf node or returning to the parent node's <code>return</code> represents \"retreat\".</p> <p>It's worth noting that retreat is not merely about function returns. We expand slightly on Example One for clarification.</p> <p>Example Two</p> <p>In a binary tree, search for all nodes with a value of \\(7\\) and please return the paths from the root node to these nodes.</p> <p>Based on the code from Example One, we need to use a list <code>path</code> to record the visited node paths. When a node with a value of \\(7\\) is reached, we copy <code>path</code> and add it to the result list <code>res</code>. After the traversal, <code>res</code> holds all the solutions. The code is as shown:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig preorder_traversal_ii_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"\u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c\"\"\"\n    if root is None:\n        return\n    # \u5c1d\u8bd5\n    path.append(root)\n    if root.val == 7:\n        # \u8bb0\u5f55\u89e3\n        res.append(list(path))\n    pre_order(root.left)\n    pre_order(root.right)\n    # \u56de\u9000\n    path.pop()\n</code></pre> preorder_traversal_ii_compact.cpp<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push_back(root);\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push_back(path);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // \u56de\u9000\n    path.pop_back();\n}\n</code></pre> preorder_traversal_ii_compact.java<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nvoid preOrder(TreeNode root) {\n    if (root == null) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.add(root);\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.add(new ArrayList&lt;&gt;(path));\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n    // \u56de\u9000\n    path.remove(path.size() - 1);\n}\n</code></pre> preorder_traversal_ii_compact.cs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.Add(root);\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.Add(new List&lt;TreeNode&gt;(path));\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n    // \u56de\u9000\n    path.RemoveAt(path.Count - 1);\n}\n</code></pre> preorder_traversal_ii_compact.go<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfunc preOrderII(root *TreeNode, res *[][]*TreeNode, path *[]*TreeNode) {\n    if root == nil {\n        return\n    }\n    // \u5c1d\u8bd5\n    *path = append(*path, root)\n    if root.Val.(int) == 7 {\n        // \u8bb0\u5f55\u89e3\n        *res = append(*res, append([]*TreeNode{}, *path...))\n    }\n    preOrderII(root.Left, res, path)\n    preOrderII(root.Right, res, path)\n    // \u56de\u9000\n    *path = (*path)[:len(*path)-1]\n}\n</code></pre> preorder_traversal_ii_compact.swift<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // \u5c1d\u8bd5\n    path.append(root)\n    if root.val == 7 {\n        // \u8bb0\u5f55\u89e3\n        res.append(path)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n    // \u56de\u9000\n    path.removeLast()\n}\n</code></pre> preorder_traversal_ii_compact.js<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfunction preOrder(root, path, res) {\n    if (root === null) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push(root);\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // \u56de\u9000\n    path.pop();\n}\n</code></pre> preorder_traversal_ii_compact.ts<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfunction preOrder(\n    root: TreeNode | null,\n    path: TreeNode[],\n    res: TreeNode[][]\n): void {\n    if (root === null) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push(root);\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // \u56de\u9000\n    path.pop();\n}\n</code></pre> preorder_traversal_ii_compact.dart<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nvoid preOrder(\n  TreeNode? root,\n  List&lt;TreeNode&gt; path,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  if (root == null) {\n    return;\n  }\n\n  // \u5c1d\u8bd5\n  path.add(root);\n  if (root.val == 7) {\n    // \u8bb0\u5f55\u89e3\n    res.add(List.from(path));\n  }\n  preOrder(root.left, path, res);\n  preOrder(root.right, path, res);\n  // \u56de\u9000\n  path.removeLast();\n}\n</code></pre> preorder_traversal_ii_compact.rs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfn pre_order(\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n    path: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n) {\n    if root.is_none() {\n        return;\n    }\n    if let Some(node) = root {\n        // \u5c1d\u8bd5\n        path.push(node.clone());\n        if node.borrow().val == 7 {\n            // \u8bb0\u5f55\u89e3\n            res.push(path.clone());\n        }\n        pre_order(res, path, node.borrow().left.clone());\n        pre_order(res, path, node.borrow().right.clone());\n        // \u56de\u9000\n        path.remove(path.len() - 1);\n    }\n}\n</code></pre> preorder_traversal_ii_compact.c<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nvoid preOrder(TreeNode *root) {\n    if (root == NULL) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path[pathSize++] = root;\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        for (int i = 0; i &lt; pathSize; ++i) {\n            res[resSize][i] = path[i];\n        }\n        resSize++;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // \u56de\u9000\n    pathSize--;\n}\n</code></pre> preorder_traversal_ii_compact.kt<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e8c */\nfun preOrder(root: TreeNode?) {\n    if (root == null) {\n        return\n    }\n    // \u5c1d\u8bd5\n    path!!.add(root)\n    if (root._val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res!!.add(path!!.toMutableList())\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n    // \u56de\u9000\n    path!!.removeAt(path!!.size - 1)\n}\n</code></pre> preorder_traversal_ii_compact.rb<pre><code>[class]{}-[func]{pre_order}\n</code></pre> preorder_traversal_ii_compact.zig<pre><code>[class]{}-[func]{preOrder}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>In each \"try\", we record the path by adding the current node to <code>path</code>; before \"retreating\", we need to pop the node from <code>path</code> to restore the state before this attempt.</p> <p>Observe the process shown in Figure 13-2, we can understand trying and retreating as \"advancing\" and \"undoing\", two operations that are reverse to each other.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 13-2 \u00a0 Trying and retreating </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1312-pruning","title":"13.1.2 \u00a0 Pruning","text":"<p>Complex backtracking problems usually involve one or more constraints, which are often used for \"pruning\".</p> <p>Example Three</p> <p>In a binary tree, search for all nodes with a value of \\(7\\) and return the paths from the root to these nodes, requiring that the paths do not contain nodes with a value of \\(3\\).</p> <p>To meet the above constraints, we need to add a pruning operation: during the search process, if a node with a value of \\(3\\) is encountered, it returns early, discontinuing further search. The code is as shown:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig preorder_traversal_iii_compact.py<pre><code>def pre_order(root: TreeNode):\n    \"\"\"\u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09\"\"\"\n    # \u526a\u679d\n    if root is None or root.val == 3:\n        return\n    # \u5c1d\u8bd5\n    path.append(root)\n    if root.val == 7:\n        # \u8bb0\u5f55\u89e3\n        res.append(list(path))\n    pre_order(root.left)\n    pre_order(root.right)\n    # \u56de\u9000\n    path.pop()\n</code></pre> preorder_traversal_iii_compact.cpp<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nvoid preOrder(TreeNode *root) {\n    // \u526a\u679d\n    if (root == nullptr || root-&gt;val == 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push_back(root);\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push_back(path);\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // \u56de\u9000\n    path.pop_back();\n}\n</code></pre> preorder_traversal_iii_compact.java<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nvoid preOrder(TreeNode root) {\n    // \u526a\u679d\n    if (root == null || root.val == 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.add(root);\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.add(new ArrayList&lt;&gt;(path));\n    }\n    preOrder(root.left);\n    preOrder(root.right);\n    // \u56de\u9000\n    path.remove(path.size() - 1);\n}\n</code></pre> preorder_traversal_iii_compact.cs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nvoid PreOrder(TreeNode? root) {\n    // \u526a\u679d\n    if (root == null || root.val == 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.Add(root);\n    if (root.val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res.Add(new List&lt;TreeNode&gt;(path));\n    }\n    PreOrder(root.left);\n    PreOrder(root.right);\n    // \u56de\u9000\n    path.RemoveAt(path.Count - 1);\n}\n</code></pre> preorder_traversal_iii_compact.go<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfunc preOrderIII(root *TreeNode, res *[][]*TreeNode, path *[]*TreeNode) {\n    // \u526a\u679d\n    if root == nil || root.Val == 3 {\n        return\n    }\n    // \u5c1d\u8bd5\n    *path = append(*path, root)\n    if root.Val.(int) == 7 {\n        // \u8bb0\u5f55\u89e3\n        *res = append(*res, append([]*TreeNode{}, *path...))\n    }\n    preOrderIII(root.Left, res, path)\n    preOrderIII(root.Right, res, path)\n    // \u56de\u9000\n    *path = (*path)[:len(*path)-1]\n}\n</code></pre> preorder_traversal_iii_compact.swift<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfunc preOrder(root: TreeNode?) {\n    // \u526a\u679d\n    guard let root = root, root.val != 3 else {\n        return\n    }\n    // \u5c1d\u8bd5\n    path.append(root)\n    if root.val == 7 {\n        // \u8bb0\u5f55\u89e3\n        res.append(path)\n    }\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n    // \u56de\u9000\n    path.removeLast()\n}\n</code></pre> preorder_traversal_iii_compact.js<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfunction preOrder(root, path, res) {\n    // \u526a\u679d\n    if (root === null || root.val === 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push(root);\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // \u56de\u9000\n    path.pop();\n}\n</code></pre> preorder_traversal_iii_compact.ts<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfunction preOrder(\n    root: TreeNode | null,\n    path: TreeNode[],\n    res: TreeNode[][]\n): void {\n    // \u526a\u679d\n    if (root === null || root.val === 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path.push(root);\n    if (root.val === 7) {\n        // \u8bb0\u5f55\u89e3\n        res.push([...path]);\n    }\n    preOrder(root.left, path, res);\n    preOrder(root.right, path, res);\n    // \u56de\u9000\n    path.pop();\n}\n</code></pre> preorder_traversal_iii_compact.dart<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nvoid preOrder(\n  TreeNode? root,\n  List&lt;TreeNode&gt; path,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  if (root == null || root.val == 3) {\n    return;\n  }\n\n  // \u5c1d\u8bd5\n  path.add(root);\n  if (root.val == 7) {\n    // \u8bb0\u5f55\u89e3\n    res.add(List.from(path));\n  }\n  preOrder(root.left, path, res);\n  preOrder(root.right, path, res);\n  // \u56de\u9000\n  path.removeLast();\n}\n</code></pre> preorder_traversal_iii_compact.rs<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfn pre_order(\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n    path: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n) {\n    // \u526a\u679d\n    if root.is_none() || root.as_ref().unwrap().borrow().val == 3 {\n        return;\n    }\n    if let Some(node) = root {\n        // \u5c1d\u8bd5\n        path.push(node.clone());\n        if node.borrow().val == 7 {\n            // \u8bb0\u5f55\u89e3\n            res.push(path.clone());\n        }\n        pre_order(res, path, node.borrow().left.clone());\n        pre_order(res, path, node.borrow().right.clone());\n        // \u56de\u9000\n        path.remove(path.len() - 1);\n    }\n}\n</code></pre> preorder_traversal_iii_compact.c<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nvoid preOrder(TreeNode *root) {\n    // \u526a\u679d\n    if (root == NULL || root-&gt;val == 3) {\n        return;\n    }\n    // \u5c1d\u8bd5\n    path[pathSize++] = root;\n    if (root-&gt;val == 7) {\n        // \u8bb0\u5f55\u89e3\n        for (int i = 0; i &lt; pathSize; i++) {\n            res[resSize][i] = path[i];\n        }\n        resSize++;\n    }\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n    // \u56de\u9000\n    pathSize--;\n}\n</code></pre> preorder_traversal_iii_compact.kt<pre><code>/* \u524d\u5e8f\u904d\u5386\uff1a\u4f8b\u9898\u4e09 */\nfun preOrder(root: TreeNode?) {\n    // \u526a\u679d\n    if (root == null || root._val == 3) {\n        return\n    }\n    // \u5c1d\u8bd5\n    path!!.add(root)\n    if (root._val == 7) {\n        // \u8bb0\u5f55\u89e3\n        res!!.add(path!!.toMutableList())\n    }\n    preOrder(root.left)\n    preOrder(root.right)\n    // \u56de\u9000\n    path!!.removeAt(path!!.size - 1)\n}\n</code></pre> preorder_traversal_iii_compact.rb<pre><code>[class]{}-[func]{pre_order}\n</code></pre> preorder_traversal_iii_compact.zig<pre><code>[class]{}-[func]{preOrder}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>\"Pruning\" is a very vivid noun. As shown in the diagram below, in the search process, we \"cut off\" the search branches that do not meet the constraints, avoiding many meaningless attempts, thus enhancing the search efficiency.</p> <p></p> <p> Figure 13-3 \u00a0 Pruning based on constraints </p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1313-framework-code","title":"13.1.3 \u00a0 Framework code","text":"<p>Next, we attempt to distill the main framework of \"trying, retreating, and pruning\" from backtracking to enhance the code's universality.</p> <p>In the following framework code, <code>state</code> represents the current state of the problem, <code>choices</code> represents the choices available under the current state:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>def backtrack(state: State, choices: list[choice], res: list[state]):\n    \"\"\"Backtracking algorithm framework\"\"\"\n    # Check if it's a solution\n    if is_solution(state):\n        # Record the solution\n        record_solution(state, res)\n        # Stop searching\n        return\n    # Iterate through all choices\n    for choice in choices:\n        # Pruning: check if the choice is valid\n        if is_valid(state, choice):\n            # Try: make a choice, update the state\n            make_choice(state, choice)\n            backtrack(state, choices, res)\n            # Retreat: undo the choice, revert to the previous state\n            undo_choice(state, choice)\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (Choice choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (Choice choice : choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid Backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it's a solution\n    if (IsSolution(state)) {\n        // Record the solution\n        RecordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    foreach (Choice choice in choices) {\n        // Pruning: check if the choice is valid\n        if (IsValid(state, choice)) {\n            // Try: make a choice, update the state\n            MakeChoice(state, choice);\n            Backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            UndoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state *State, choices []Choice, res *[]State) {\n    // Check if it's a solution\n    if isSolution(state) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for _, choice := range choices {\n        // Pruning: check if the choice is valid\n        if isValid(state, choice) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state: inout State, choices: [Choice], res: inout [State]) {\n    // Check if it's a solution\n    if isSolution(state: state) {\n        // Record the solution\n        recordSolution(state: state, res: &amp;res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for choice in choices {\n        // Pruning: check if the choice is valid\n        if isValid(state: state, choice: choice) {\n            // Try: make a choice, update the state\n            makeChoice(state: &amp;state, choice: choice)\n            backtrack(state: &amp;state, choices: choices, res: &amp;res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state: &amp;state, choice: choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state, choices, res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (let choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state: State, choices: Choice[], res: State[]): void {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (let choice of choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt;, List&lt;State&gt; res) {\n  // Check if it's a solution\n  if (isSolution(state)) {\n    // Record the solution\n    recordSolution(state, res);\n    // Stop searching\n    return;\n  }\n  // Iterate through all choices\n  for (Choice choice in choices) {\n    // Pruning: check if the choice is valid\n    if (isValid(state, choice)) {\n      // Try: make a choice, update the state\n      makeChoice(state, choice);\n      backtrack(state, choices, res);\n      // Retreat: undo the choice, revert to the previous state\n      undoChoice(state, choice);\n    }\n  }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfn backtrack(state: &amp;mut State, choices: &amp;Vec&lt;Choice&gt;, res: &amp;mut Vec&lt;State&gt;) {\n    // Check if it's a solution\n    if is_solution(state) {\n        // Record the solution\n        record_solution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for choice in choices {\n        // Pruning: check if the choice is valid\n        if is_valid(state, choice) {\n            // Try: make a choice, update the state\n            make_choice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undo_choice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res, numRes);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (int i = 0; i &lt; numChoices; i++) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, &amp;choices[i])) {\n            // Try: make a choice, update the state\n            makeChoice(state, &amp;choices[i]);\n            backtrack(state, choices, numChoices, res, numRes);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, &amp;choices[i]);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfun backtrack(state: State?, choices: List&lt;Choice?&gt;, res: List&lt;State?&gt;?) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for (choice in choices) {\n        // Pruning: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Try: make a choice, update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Next, we solve Example Three based on the framework code. The <code>state</code> is the node traversal path, <code>choices</code> are the current node's left and right children, and the result <code>res</code> is the list of paths:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig preorder_traversal_iii_template.py<pre><code>def is_solution(state: list[TreeNode]) -&gt; bool:\n    \"\"\"\u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3\"\"\"\n    return state and state[-1].val == 7\n\ndef record_solution(state: list[TreeNode], res: list[list[TreeNode]]):\n    \"\"\"\u8bb0\u5f55\u89e3\"\"\"\n    res.append(list(state))\n\ndef is_valid(state: list[TreeNode], choice: TreeNode) -&gt; bool:\n    \"\"\"\u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5\"\"\"\n    return choice is not None and choice.val != 3\n\ndef make_choice(state: list[TreeNode], choice: TreeNode):\n    \"\"\"\u66f4\u65b0\u72b6\u6001\"\"\"\n    state.append(choice)\n\ndef undo_choice(state: list[TreeNode], choice: TreeNode):\n    \"\"\"\u6062\u590d\u72b6\u6001\"\"\"\n    state.pop()\n\ndef backtrack(\n    state: list[TreeNode], choices: list[TreeNode], res: list[list[TreeNode]]\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09\"\"\"\n    # \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if is_solution(state):\n        # \u8bb0\u5f55\u89e3\n        record_solution(state, res)\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    for choice in choices:\n        # \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if is_valid(state, choice):\n            # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            make_choice(state, choice)\n            # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, [choice.left, choice.right], res)\n            # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undo_choice(state, choice)\n</code></pre> preorder_traversal_iii_template.cpp<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nbool isSolution(vector&lt;TreeNode *&gt; &amp;state) {\n    return !state.empty() &amp;&amp; state.back()-&gt;val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nvoid recordSolution(vector&lt;TreeNode *&gt; &amp;state, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res) {\n    res.push_back(state);\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nbool isValid(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    return choice != nullptr &amp;&amp; choice-&gt;val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nvoid makeChoice(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    state.push_back(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nvoid undoChoice(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice) {\n    state.pop_back();\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nvoid backtrack(vector&lt;TreeNode *&gt; &amp;state, vector&lt;TreeNode *&gt; &amp;choices, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (TreeNode *choice : choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            vector&lt;TreeNode *&gt; nextChoices{choice-&gt;left, choice-&gt;right};\n            backtrack(state, nextChoices, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.java<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nboolean isSolution(List&lt;TreeNode&gt; state) {\n    return !state.isEmpty() &amp;&amp; state.get(state.size() - 1).val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nvoid recordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    res.add(new ArrayList&lt;&gt;(state));\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nboolean isValid(List&lt;TreeNode&gt; state, TreeNode choice) {\n    return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nvoid makeChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.add(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nvoid undoChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.remove(state.size() - 1);\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nvoid backtrack(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (TreeNode choice : choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, Arrays.asList(choice.left, choice.right), res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.cs<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nbool IsSolution(List&lt;TreeNode&gt; state) {\n    return state.Count != 0 &amp;&amp; state[^1].val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nvoid RecordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    res.Add(new List&lt;TreeNode&gt;(state));\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nbool IsValid(List&lt;TreeNode&gt; state, TreeNode choice) {\n    return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nvoid MakeChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.Add(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nvoid UndoChoice(List&lt;TreeNode&gt; state, TreeNode choice) {\n    state.RemoveAt(state.Count - 1);\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nvoid Backtrack(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (IsSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        RecordSolution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    foreach (TreeNode choice in choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (IsValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            MakeChoice(state, choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            Backtrack(state, [choice.left!, choice.right!], res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            UndoChoice(state, choice);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.go<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfunc isSolution(state *[]*TreeNode) bool {\n    return len(*state) != 0 &amp;&amp; (*state)[len(*state)-1].Val == 7\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfunc recordSolution(state *[]*TreeNode, res *[][]*TreeNode) {\n    *res = append(*res, append([]*TreeNode{}, *state...))\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfunc isValid(state *[]*TreeNode, choice *TreeNode) bool {\n    return choice != nil &amp;&amp; choice.Val != 3\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfunc makeChoice(state *[]*TreeNode, choice *TreeNode) {\n    *state = append(*state, choice)\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfunc undoChoice(state *[]*TreeNode, choice *TreeNode) {\n    *state = (*state)[:len(*state)-1]\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfunc backtrackIII(state *[]*TreeNode, choices *[]*TreeNode, res *[][]*TreeNode) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if isSolution(state) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res)\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for _, choice := range *choices {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if isValid(state, choice) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            temp := make([]*TreeNode, 0)\n            temp = append(temp, choice.Left, choice.Right)\n            backtrackIII(state, &amp;temp, res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.swift<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfunc isSolution(state: [TreeNode]) -&gt; Bool {\n    !state.isEmpty &amp;&amp; state.last!.val == 7\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfunc recordSolution(state: [TreeNode], res: inout [[TreeNode]]) {\n    res.append(state)\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfunc isValid(state: [TreeNode], choice: TreeNode?) -&gt; Bool {\n    choice != nil &amp;&amp; choice!.val != 3\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfunc makeChoice(state: inout [TreeNode], choice: TreeNode) {\n    state.append(choice)\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfunc undoChoice(state: inout [TreeNode], choice: TreeNode) {\n    state.removeLast()\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfunc backtrack(state: inout [TreeNode], choices: [TreeNode], res: inout [[TreeNode]]) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if isSolution(state: state) {\n        recordSolution(state: state, res: &amp;res)\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for choice in choices {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if isValid(state: state, choice: choice) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state: &amp;state, choice: choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state: &amp;state, choices: [choice.left, choice.right].compactMap { $0 }, res: &amp;res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state: &amp;state, choice: choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.js<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfunction isSolution(state) {\n    return state &amp;&amp; state[state.length - 1]?.val === 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfunction recordSolution(state, res) {\n    res.push([...state]);\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfunction isValid(state, choice) {\n    return choice !== null &amp;&amp; choice.val !== 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfunction makeChoice(state, choice) {\n    state.push(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfunction undoChoice(state) {\n    state.pop();\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfunction backtrack(state, choices, res) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (const choice of choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, [choice.left, choice.right], res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.ts<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfunction isSolution(state: TreeNode[]): boolean {\n    return state &amp;&amp; state[state.length - 1]?.val === 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfunction recordSolution(state: TreeNode[], res: TreeNode[][]): void {\n    res.push([...state]);\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfunction isValid(state: TreeNode[], choice: TreeNode): boolean {\n    return choice !== null &amp;&amp; choice.val !== 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfunction makeChoice(state: TreeNode[], choice: TreeNode): void {\n    state.push(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfunction undoChoice(state: TreeNode[]): void {\n    state.pop();\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfunction backtrack(\n    state: TreeNode[],\n    choices: TreeNode[],\n    res: TreeNode[][]\n): void {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (const choice of choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, [choice.left, choice.right], res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state);\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.dart<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nbool isSolution(List&lt;TreeNode&gt; state) {\n  return state.isNotEmpty &amp;&amp; state.last.val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nvoid recordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) {\n  res.add(List.from(state));\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nbool isValid(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  return choice != null &amp;&amp; choice.val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nvoid makeChoice(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  state.add(choice!);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nvoid undoChoice(List&lt;TreeNode&gt; state, TreeNode? choice) {\n  state.removeLast();\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nvoid backtrack(\n  List&lt;TreeNode&gt; state,\n  List&lt;TreeNode?&gt; choices,\n  List&lt;List&lt;TreeNode&gt;&gt; res,\n) {\n  // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n  if (isSolution(state)) {\n    // \u8bb0\u5f55\u89e3\n    recordSolution(state, res);\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  for (TreeNode? choice in choices) {\n    // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n    if (isValid(state, choice)) {\n      // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n      makeChoice(state, choice);\n      // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n      backtrack(state, [choice!.left, choice.right], res);\n      // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n      undoChoice(state, choice);\n    }\n  }\n}\n</code></pre> preorder_traversal_iii_template.rs<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfn is_solution(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {\n    return !state.is_empty() &amp;&amp; state.get(state.len() - 1).unwrap().borrow().val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfn record_solution(\n    state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n) {\n    res.push(state.clone());\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfn is_valid(_: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, choice: Rc&lt;RefCell&lt;TreeNode&gt;&gt;) -&gt; bool {\n    return choice.borrow().val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfn make_choice(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, choice: Rc&lt;RefCell&lt;TreeNode&gt;&gt;) {\n    state.push(choice);\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfn undo_choice(state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, _: Rc&lt;RefCell&lt;TreeNode&gt;&gt;) {\n    state.remove(state.len() - 1);\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfn backtrack(\n    state: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    choices: &amp;mut Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;,\n) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if is_solution(state) {\n        // \u8bb0\u5f55\u89e3\n        record_solution(state, res);\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for choice in choices {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if is_valid(state, choice.clone()) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            make_choice(state, choice.clone());\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(\n                state,\n                &amp;mut vec![\n                    choice.borrow().left.clone().unwrap(),\n                    choice.borrow().right.clone().unwrap(),\n                ],\n                res,\n            );\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undo_choice(state, choice.clone());\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.c<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nbool isSolution(void) {\n    return pathSize &gt; 0 &amp;&amp; path[pathSize - 1]-&gt;val == 7;\n}\n\n/* \u8bb0\u5f55\u89e3 */\nvoid recordSolution(void) {\n    for (int i = 0; i &lt; pathSize; i++) {\n        res[resSize][i] = path[i];\n    }\n    resSize++;\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nbool isValid(TreeNode *choice) {\n    return choice != NULL &amp;&amp; choice-&gt;val != 3;\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nvoid makeChoice(TreeNode *choice) {\n    path[pathSize++] = choice;\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nvoid undoChoice(void) {\n    pathSize--;\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nvoid backtrack(TreeNode *choices[2]) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution()) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution();\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; 2; i++) {\n        TreeNode *choice = choices[i];\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            TreeNode *nextChoices[2] = {choice-&gt;left, choice-&gt;right};\n            backtrack(nextChoices);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice();\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.kt<pre><code>/* \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e3a\u89e3 */\nfun isSolution(state: MutableList&lt;TreeNode?&gt;): Boolean {\n    return state.isNotEmpty() &amp;&amp; state[state.size - 1]?._val == 7\n}\n\n/* \u8bb0\u5f55\u89e3 */\nfun recordSolution(state: MutableList&lt;TreeNode?&gt;?, res: MutableList&lt;MutableList&lt;TreeNode?&gt;?&gt;) {\n    res.add(state!!.toMutableList())\n}\n\n/* \u5224\u65ad\u5728\u5f53\u524d\u72b6\u6001\u4e0b\uff0c\u8be5\u9009\u62e9\u662f\u5426\u5408\u6cd5 */\nfun isValid(state: MutableList&lt;TreeNode?&gt;?, choice: TreeNode?): Boolean {\n    return choice != null &amp;&amp; choice._val != 3\n}\n\n/* \u66f4\u65b0\u72b6\u6001 */\nfun makeChoice(state: MutableList&lt;TreeNode?&gt;, choice: TreeNode?) {\n    state.add(choice)\n}\n\n/* \u6062\u590d\u72b6\u6001 */\nfun undoChoice(state: MutableList&lt;TreeNode?&gt;, choice: TreeNode?) {\n    state.removeLast()\n}\n\n/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u4f8b\u9898\u4e09 */\nfun backtrack(\n    state: MutableList&lt;TreeNode?&gt;,\n    choices: MutableList&lt;TreeNode?&gt;,\n    res: MutableList&lt;MutableList&lt;TreeNode?&gt;?&gt;\n) {\n    // \u68c0\u67e5\u662f\u5426\u4e3a\u89e3\n    if (isSolution(state)) {\n        // \u8bb0\u5f55\u89e3\n        recordSolution(state, res)\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (choice in choices) {\n        // \u526a\u679d\uff1a\u68c0\u67e5\u9009\u62e9\u662f\u5426\u5408\u6cd5\n        if (isValid(state, choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            makeChoice(state, choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, mutableListOf(choice!!.left, choice.right), res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> preorder_traversal_iii_template.rb<pre><code>[class]{}-[func]{is_solution}\n\n[class]{}-[func]{record_solution}\n\n[class]{}-[func]{is_valid}\n\n[class]{}-[func]{make_choice}\n\n[class]{}-[func]{undo_choice}\n\n[class]{}-[func]{backtrack}\n</code></pre> preorder_traversal_iii_template.zig<pre><code>[class]{}-[func]{isSolution}\n\n[class]{}-[func]{recordSolution}\n\n[class]{}-[func]{isValid}\n\n[class]{}-[func]{makeChoice}\n\n[class]{}-[func]{undoChoice}\n\n[class]{}-[func]{backtrack}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As per the requirements, after finding a node with a value of \\(7\\), the search should continue, thus the <code>return</code> statement after recording the solution should be removed. The following diagram compares the search processes with and without retaining the <code>return</code> statement.</p> <p></p> <p> Figure 13-4 \u00a0 Comparison of retaining and removing the return in the search process </p> <p>Compared to the implementation based on preorder traversal, the code implementation based on the backtracking algorithm framework seems verbose, but it has better universality. In fact, many backtracking problems can be solved within this framework. We just need to define <code>state</code> and <code>choices</code> according to the specific problem and implement the methods in the framework.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1314-common-terminology","title":"13.1.4 \u00a0 Common terminology","text":"<p>To analyze algorithmic problems more clearly, we summarize the meanings of commonly used terminology in backtracking algorithms and provide corresponding examples from Example Three as shown in Table 13-1.</p> <p> Table 13-1 \u00a0 Common backtracking algorithm terminology </p> Term Definition Example Three Solution (solution) A solution is an answer that satisfies specific conditions of the problem, which may have one or more All paths from the root node to node \\(7\\) that meet the constraint Constraint (constraint) Constraints are conditions in the problem that limit the feasibility of solutions, often used for pruning Paths do not contain node \\(3\\) State (state) State represents the situation of the problem at a certain moment, including choices made Current visited node path, i.e., <code>path</code> node list Attempt (attempt) An attempt is the process of exploring the solution space based on available choices, including making choices, updating the state, and checking if it's a solution Recursively visiting left (right) child nodes, adding nodes to <code>path</code>, checking if the node's value is \\(7\\) Backtracking (backtracking) Backtracking refers to the action of undoing previous choices and returning to the previous state when encountering states that do not meet the constraints When passing leaf nodes, ending node visits, encountering nodes with a value of \\(3\\), terminating the search, and function return Pruning (pruning) Pruning is a method to avoid meaningless search paths based on the characteristics and constraints of the problem, which can enhance search efficiency When encountering a node with a value of \\(3\\), no further search is continued <p>Tip</p> <p>Concepts like problems, solutions, states, etc., are universal, and are involved in divide and conquer, backtracking, dynamic programming, and greedy algorithms, among others.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#1315-advantages-and-limitations","title":"13.1.5 \u00a0 Advantages and limitations","text":"<p>The backtracking algorithm is essentially a depth-first search algorithm that attempts all possible solutions until a satisfying solution is found. The advantage of this method is that it can find all possible solutions, and with reasonable pruning operations, it can be highly efficient.</p> <p>However, when dealing with large-scale or complex problems, the operational efficiency of backtracking may be difficult to accept.</p> <ul> <li>Time: Backtracking algorithms usually need to traverse all possible states in the state space, which can reach exponential or factorial time complexity.</li> <li>Space: In recursive calls, it is necessary to save the current state (such as paths, auxiliary variables for pruning, etc.). When the depth is very large, the space requirement may become significant.</li> </ul> <p>Even so, backtracking remains the best solution for certain search problems and constraint satisfaction problems. For these problems, since it is unpredictable which choices can generate valid solutions, we must traverse all possible choices. In this case, the key is how to optimize efficiency, with common efficiency optimization methods being two types.</p> <ul> <li>Pruning: Avoid searching paths that definitely will not produce a solution, thus saving time and space.</li> <li>Heuristic search: Introduce some strategies or estimates during the search process to prioritize the paths that are most likely to produce valid solutions.</li> </ul>"},{"location":"chapter_backtracking/backtracking_algorithm/#1316-typical-backtracking-problems","title":"13.1.6 \u00a0 Typical backtracking problems","text":"<p>Backtracking algorithms can be used to solve many search problems, constraint satisfaction problems, and combinatorial optimization problems.</p> <p>Search problems: The goal of these problems is to find solutions that meet specific conditions.</p> <ul> <li>Full permutation problem: Given a set, find all possible permutations and combinations of it.</li> <li>Subset sum problem: Given a set and a target sum, find all subsets of the set that sum to the target.</li> <li>Tower of Hanoi problem: Given three rods and a series of different-sized discs, the goal is to move all the discs from one rod to another, moving only one disc at a time, and never placing a larger disc on a smaller one.</li> </ul> <p>Constraint satisfaction problems: The goal of these problems is to find solutions that satisfy all the constraints.</p> <ul> <li>\\(n\\) queens: Place \\(n\\) queens on an \\(n \\times n\\) chessboard so that they do not attack each other.</li> <li>Sudoku: Fill a \\(9 \\times 9\\) grid with the numbers \\(1\\) to \\(9\\), ensuring that the numbers do not repeat in each row, each column, and each \\(3 \\times 3\\) subgrid.</li> <li>Graph coloring problem: Given an undirected graph, color each vertex with the fewest possible colors so that adjacent vertices have different colors.</li> </ul> <p>Combinatorial optimization problems: The goal of these problems is to find the optimal solution within a combination space that meets certain conditions.</p> <ul> <li>0-1 knapsack problem: Given a set of items and a backpack, each item has a certain value and weight. The goal is to choose items to maximize the total value within the backpack's capacity limit.</li> <li>Traveling salesman problem: In a graph, starting from one point, visit all other points exactly once and then return to the starting point, seeking the shortest path.</li> <li>Maximum clique problem: Given an undirected graph, find the largest complete subgraph, i.e., a subgraph where any two vertices are connected by an edge.</li> </ul> <p>Please note that for many combinatorial optimization problems, backtracking is not the optimal solution.</p> <ul> <li>The 0-1 knapsack problem is usually solved using dynamic programming to achieve higher time efficiency.</li> <li>The traveling salesman is a well-known NP-Hard problem, commonly solved using genetic algorithms and ant colony algorithms, among others.</li> <li>The maximum clique problem is a classic problem in graph theory, which can be solved using greedy algorithms and other heuristic methods.</li> </ul>"},{"location":"chapter_backtracking/n_queens_problem/","title":"13.4 \u00a0 n queens problem","text":"<p>Question</p> <p>According to the rules of chess, a queen can attack pieces in the same row, column, or on a diagonal line. Given \\(n\\) queens and an \\(n \\times n\\) chessboard, find arrangements where no two queens can attack each other.</p> <p>As shown in Figure 13-15, when \\(n = 4\\), there are two solutions. From the perspective of the backtracking algorithm, an \\(n \\times n\\) chessboard has \\(n^2\\) squares, presenting all possible choices <code>choices</code>. The state of the chessboard <code>state</code> changes continuously as each queen is placed.</p> <p></p> <p> Figure 13-15 \u00a0 Solution to the 4 queens problem </p> <p>Figure 13-16 shows the three constraints of this problem: multiple queens cannot be on the same row, column, or diagonal. It is important to note that diagonals are divided into the main diagonal <code>\\</code> and the secondary diagonal <code>/</code>.</p> <p></p> <p> Figure 13-16 \u00a0 Constraints of the n queens problem </p>"},{"location":"chapter_backtracking/n_queens_problem/#1-row-by-row-placing-strategy","title":"1. \u00a0 Row-by-row placing strategy","text":"<p>As the number of queens equals the number of rows on the chessboard, both being \\(n\\), it is easy to conclude: each row on the chessboard allows and only allows one queen to be placed.</p> <p>This means that we can adopt a row-by-row placing strategy: starting from the first row, place one queen per row until the last row is reached.</p> <p>Figure 13-17 shows the row-by-row placing process for the 4 queens problem. Due to space limitations, the figure only expands one search branch of the first row, and prunes any placements that do not meet the column and diagonal constraints.</p> <p></p> <p> Figure 13-17 \u00a0 Row-by-row placing strategy </p> <p>Essentially, the row-by-row placing strategy serves as a pruning function, avoiding all search branches that would place multiple queens in the same row.</p>"},{"location":"chapter_backtracking/n_queens_problem/#2-column-and-diagonal-pruning","title":"2. \u00a0 Column and diagonal pruning","text":"<p>To satisfy column constraints, we can use a boolean array <code>cols</code> of length \\(n\\) to track whether a queen occupies each column. Before each placement decision, <code>cols</code> is used to prune the columns that already have queens, and it is dynamically updated during backtracking.</p> <p>How about the diagonal constraints? Let the row and column indices of a cell on the chessboard be \\((row, col)\\). By selecting a specific main diagonal, we notice that the difference \\(row - col\\) is the same for all cells on that diagonal, meaning that \\(row - col\\) is a constant value on that diagonal.</p> <p>Thus, if two cells satisfy \\(row_1 - col_1 = row_2 - col_2\\), they are definitely on the same main diagonal. Using this pattern, we can utilize the array <code>diags1</code> shown in Figure 13-18 to track whether a queen is on any main diagonal.</p> <p>Similarly, the sum \\(row + col\\) is a constant value for all cells on a secondary diagonal. We can also use the array <code>diags2</code> to handle secondary diagonal constraints.</p> <p></p> <p> Figure 13-18 \u00a0 Handling column and diagonal constraints </p>"},{"location":"chapter_backtracking/n_queens_problem/#3-code-implementation","title":"3. \u00a0 Code implementation","text":"<p>Please note, in an \\(n\\)-dimensional matrix, the range of \\(row - col\\) is \\([-n + 1, n - 1]\\), and the range of \\(row + col\\) is \\([0, 2n - 2]\\), thus the number of both main and secondary diagonals is \\(2n - 1\\), meaning the length of both arrays <code>diags1</code> and <code>diags2</code> is \\(2n - 1\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig n_queens.py<pre><code>def backtrack(\n    row: int,\n    n: int,\n    state: list[list[str]],\n    res: list[list[list[str]]],\n    cols: list[bool],\n    diags1: list[bool],\n    diags2: list[bool],\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e\"\"\"\n    # \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if row == n:\n        res.append([list(row) for row in state])\n        return\n    # \u904d\u5386\u6240\u6709\u5217\n    for col in range(n):\n        # \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        diag1 = row - col + n - 1\n        diag2 = row + col\n        # \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if not cols[col] and not diags1[diag1] and not diags2[diag2]:\n            # \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = \"Q\"\n            cols[col] = diags1[diag1] = diags2[diag2] = True\n            # \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2)\n            # \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = \"#\"\n            cols[col] = diags1[diag1] = diags2[diag2] = False\n\ndef n_queens(n: int) -&gt; list[list[list[str]]]:\n    \"\"\"\u6c42\u89e3 n \u7687\u540e\"\"\"\n    # \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    state = [[\"#\" for _ in range(n)] for _ in range(n)]\n    cols = [False] * n  # \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    diags1 = [False] * (2 * n - 1)  # \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    diags2 = [False] * (2 * n - 1)  # \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    res = []\n    backtrack(0, n, state, res, cols, diags1, diags2)\n\n    return res\n</code></pre> n_queens.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nvoid backtrack(int row, int n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;bool&gt; &amp;cols,\n               vector&lt;bool&gt; &amp;diags1, vector&lt;bool&gt; &amp;diags2) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row == n) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (int col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = \"Q\";\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = \"#\";\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nvector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; nQueens(int n) {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    vector&lt;vector&lt;string&gt;&gt; state(n, vector&lt;string&gt;(n, \"#\"));\n    vector&lt;bool&gt; cols(n, false);           // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    vector&lt;bool&gt; diags1(2 * n - 1, false); // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    vector&lt;bool&gt; diags2(2 * n - 1, false); // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nvoid backtrack(int row, int n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,\n        boolean[] cols, boolean[] diags1, boolean[] diags2) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row == n) {\n        List&lt;List&lt;String&gt;&gt; copyState = new ArrayList&lt;&gt;();\n        for (List&lt;String&gt; sRow : state) {\n            copyState.add(new ArrayList&lt;&gt;(sRow));\n        }\n        res.add(copyState);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (int col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state.get(row).set(col, \"Q\");\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state.get(row).set(col, \"#\");\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nList&lt;List&lt;List&lt;String&gt;&gt;&gt; nQueens(int n) {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    List&lt;List&lt;String&gt;&gt; state = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;String&gt; row = new ArrayList&lt;&gt;();\n        for (int j = 0; j &lt; n; j++) {\n            row.add(\"#\");\n        }\n        state.add(row);\n    }\n    boolean[] cols = new boolean[n]; // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    boolean[] diags1 = new boolean[2 * n - 1]; // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    boolean[] diags2 = new boolean[2 * n - 1]; // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = new ArrayList&lt;&gt;();\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nvoid Backtrack(int row, int n, List&lt;List&lt;string&gt;&gt; state, List&lt;List&lt;List&lt;string&gt;&gt;&gt; res,\n        bool[] cols, bool[] diags1, bool[] diags2) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row == n) {\n        List&lt;List&lt;string&gt;&gt; copyState = [];\n        foreach (List&lt;string&gt; sRow in state) {\n            copyState.Add(new List&lt;string&gt;(sRow));\n        }\n        res.Add(copyState);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (int col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = \"Q\";\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            Backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = \"#\";\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nList&lt;List&lt;List&lt;string&gt;&gt;&gt; NQueens(int n) {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    List&lt;List&lt;string&gt;&gt; state = [];\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;string&gt; row = [];\n        for (int j = 0; j &lt; n; j++) {\n            row.Add(\"#\");\n        }\n        state.Add(row);\n    }\n    bool[] cols = new bool[n]; // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    bool[] diags1 = new bool[2 * n - 1]; // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    bool[] diags2 = new bool[2 * n - 1]; // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    List&lt;List&lt;List&lt;string&gt;&gt;&gt; res = [];\n\n    Backtrack(0, n, state, res, cols, diags1, diags2);\n\n    return res;\n}\n</code></pre> n_queens.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfunc backtrack(row, n int, state *[][]string, res *[][][]string, cols, diags1, diags2 *[]bool) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if row == n {\n        newState := make([][]string, len(*state))\n        for i, _ := range newState {\n            newState[i] = make([]string, len((*state)[0]))\n            copy(newState[i], (*state)[i])\n\n        }\n        *res = append(*res, newState)\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for col := 0; col &lt; n; col++ {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        diag1 := row - col + n - 1\n        diag2 := row + col\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if !(*cols)[col] &amp;&amp; !(*diags1)[diag1] &amp;&amp; !(*diags2)[diag2] {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            (*state)[row][col] = \"Q\"\n            (*cols)[col], (*diags1)[diag1], (*diags2)[diag2] = true, true, true\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row+1, n, state, res, cols, diags1, diags2)\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            (*state)[row][col] = \"#\"\n            (*cols)[col], (*diags1)[diag1], (*diags2)[diag2] = false, false, false\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfunc nQueens(n int) [][][]string {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    state := make([][]string, n)\n    for i := 0; i &lt; n; i++ {\n        row := make([]string, n)\n        for i := 0; i &lt; n; i++ {\n            row[i] = \"#\"\n        }\n        state[i] = row\n    }\n    // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    cols := make([]bool, n)\n    diags1 := make([]bool, 2*n-1)\n    diags2 := make([]bool, 2*n-1)\n    res := make([][][]string, 0)\n    backtrack(0, n, &amp;state, &amp;res, &amp;cols, &amp;diags1, &amp;diags2)\n    return res\n}\n</code></pre> n_queens.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfunc backtrack(row: Int, n: Int, state: inout [[String]], res: inout [[[String]]], cols: inout [Bool], diags1: inout [Bool], diags2: inout [Bool]) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if row == n {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for col in 0 ..&lt; n {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        let diag1 = row - col + n - 1\n        let diag2 = row + col\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if !cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2] {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = \"Q\"\n            cols[col] = true\n            diags1[diag1] = true\n            diags2[diag2] = true\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row: row + 1, n: n, state: &amp;state, res: &amp;res, cols: &amp;cols, diags1: &amp;diags1, diags2: &amp;diags2)\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = \"#\"\n            cols[col] = false\n            diags1[diag1] = false\n            diags2[diag2] = false\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfunc nQueens(n: Int) -&gt; [[[String]]] {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    var state = Array(repeating: Array(repeating: \"#\", count: n), count: n)\n    var cols = Array(repeating: false, count: n) // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    var diags1 = Array(repeating: false, count: 2 * n - 1) // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    var diags2 = Array(repeating: false, count: 2 * n - 1) // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    var res: [[[String]]] = []\n\n    backtrack(row: 0, n: n, state: &amp;state, res: &amp;res, cols: &amp;cols, diags1: &amp;diags1, diags2: &amp;diags2)\n\n    return res\n}\n</code></pre> n_queens.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfunction backtrack(row, n, state, res, cols, diags1, diags2) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row === n) {\n        res.push(state.map((row) =&gt; row.slice()));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (let col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        const diag1 = row - col + n - 1;\n        const diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfunction nQueens(n) {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    const state = Array.from({ length: n }, () =&gt; Array(n).fill('#'));\n    const cols = Array(n).fill(false); // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    const diags1 = Array(2 * n - 1).fill(false); // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    const diags2 = Array(2 * n - 1).fill(false); // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    const res = [];\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfunction backtrack(\n    row: number,\n    n: number,\n    state: string[][],\n    res: string[][][],\n    cols: boolean[],\n    diags1: boolean[],\n    diags2: boolean[]\n): void {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row === n) {\n        res.push(state.map((row) =&gt; row.slice()));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (let col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        const diag1 = row - col + n - 1;\n        const diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfunction nQueens(n: number): string[][][] {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    const state = Array.from({ length: n }, () =&gt; Array(n).fill('#'));\n    const cols = Array(n).fill(false); // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    const diags1 = Array(2 * n - 1).fill(false); // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    const diags2 = Array(2 * n - 1).fill(false); // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    const res: string[][][] = [];\n\n    backtrack(0, n, state, res, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nvoid backtrack(\n  int row,\n  int n,\n  List&lt;List&lt;String&gt;&gt; state,\n  List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,\n  List&lt;bool&gt; cols,\n  List&lt;bool&gt; diags1,\n  List&lt;bool&gt; diags2,\n) {\n  // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (row == n) {\n    List&lt;List&lt;String&gt;&gt; copyState = [];\n    for (List&lt;String&gt; sRow in state) {\n      copyState.add(List.from(sRow));\n    }\n    res.add(copyState);\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u5217\n  for (int col = 0; col &lt; n; col++) {\n    // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n    int diag1 = row - col + n - 1;\n    int diag2 = row + col;\n    // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n    if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n      // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n      state[row][col] = \"Q\";\n      cols[col] = true;\n      diags1[diag1] = true;\n      diags2[diag2] = true;\n      // \u653e\u7f6e\u4e0b\u4e00\u884c\n      backtrack(row + 1, n, state, res, cols, diags1, diags2);\n      // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n      state[row][col] = \"#\";\n      cols[col] = false;\n      diags1[diag1] = false;\n      diags2[diag2] = false;\n    }\n  }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nList&lt;List&lt;List&lt;String&gt;&gt;&gt; nQueens(int n) {\n  // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n  List&lt;List&lt;String&gt;&gt; state = List.generate(n, (index) =&gt; List.filled(n, \"#\"));\n  List&lt;bool&gt; cols = List.filled(n, false); // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n  List&lt;bool&gt; diags1 = List.filled(2 * n - 1, false); // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n  List&lt;bool&gt; diags2 = List.filled(2 * n - 1, false); // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n  List&lt;List&lt;List&lt;String&gt;&gt;&gt; res = [];\n\n  backtrack(0, n, state, res, cols, diags1, diags2);\n\n  return res;\n}\n</code></pre> n_queens.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfn backtrack(\n    row: usize,\n    n: usize,\n    state: &amp;mut Vec&lt;Vec&lt;String&gt;&gt;,\n    res: &amp;mut Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt;,\n    cols: &amp;mut [bool],\n    diags1: &amp;mut [bool],\n    diags2: &amp;mut [bool],\n) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if row == n {\n        let mut copy_state: Vec&lt;Vec&lt;String&gt;&gt; = Vec::new();\n        for s_row in state.clone() {\n            copy_state.push(s_row);\n        }\n        res.push(copy_state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for col in 0..n {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        let diag1 = row + n - 1 - col;\n        let diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if !cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2] {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state.get_mut(row).unwrap()[col] = \"Q\".into();\n            (cols[col], diags1[diag1], diags2[diag2]) = (true, true, true);\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state.get_mut(row).unwrap()[col] = \"#\".into();\n            (cols[col], diags1[diag1], diags2[diag2]) = (false, false, false);\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfn n_queens(n: usize) -&gt; Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    let mut state: Vec&lt;Vec&lt;String&gt;&gt; = Vec::new();\n    for _ in 0..n {\n        let mut row: Vec&lt;String&gt; = Vec::new();\n        for _ in 0..n {\n            row.push(\"#\".into());\n        }\n        state.push(row);\n    }\n    let mut cols = vec![false; n]; // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    let mut diags1 = vec![false; 2 * n - 1]; // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    let mut diags2 = vec![false; 2 * n - 1]; // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    let mut res: Vec&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; = Vec::new();\n\n    backtrack(\n        0,\n        n,\n        &amp;mut state,\n        &amp;mut res,\n        &amp;mut cols,\n        &amp;mut diags1,\n        &amp;mut diags2,\n    );\n\n    res\n}\n</code></pre> n_queens.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nvoid backtrack(int row, int n, char state[MAX_SIZE][MAX_SIZE], char ***res, int *resSize, bool cols[MAX_SIZE],\n               bool diags1[2 * MAX_SIZE - 1], bool diags2[2 * MAX_SIZE - 1]) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row == n) {\n        res[*resSize] = (char **)malloc(sizeof(char *) * n);\n        for (int i = 0; i &lt; n; ++i) {\n            res[*resSize][i] = (char *)malloc(sizeof(char) * (n + 1));\n            strcpy(res[*resSize][i], state[i]);\n        }\n        (*resSize)++;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (int col = 0; col &lt; n; col++) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        int diag1 = row - col + n - 1;\n        int diag2 = row + col;\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = 'Q';\n            cols[col] = diags1[diag1] = diags2[diag2] = true;\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, resSize, cols, diags1, diags2);\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = '#';\n            cols[col] = diags1[diag1] = diags2[diag2] = false;\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nchar ***nQueens(int n, int *returnSize) {\n    char state[MAX_SIZE][MAX_SIZE];\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            state[i][j] = '#';\n        }\n        state[i][n] = '\\0';\n    }\n    bool cols[MAX_SIZE] = {false};           // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    bool diags1[2 * MAX_SIZE - 1] = {false}; // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    bool diags2[2 * MAX_SIZE - 1] = {false}; // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n\n    char ***res = (char ***)malloc(sizeof(char **) * MAX_SIZE);\n    *returnSize = 0;\n    backtrack(0, n, state, res, returnSize, cols, diags1, diags2);\n    return res;\n}\n</code></pre> n_queens.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1an \u7687\u540e */\nfun backtrack(\n    row: Int,\n    n: Int,\n    state: MutableList&lt;MutableList&lt;String&gt;&gt;,\n    res: MutableList&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt;,\n    cols: BooleanArray,\n    diags1: BooleanArray,\n    diags2: BooleanArray\n) {\n    // \u5f53\u653e\u7f6e\u5b8c\u6240\u6709\u884c\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (row == n) {\n        val copyState = mutableListOf&lt;MutableList&lt;String&gt;&gt;()\n        for (sRow in state) {\n            copyState.add(sRow.toMutableList())\n        }\n        res.add(copyState)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u5217\n    for (col in 0..&lt;n) {\n        // \u8ba1\u7b97\u8be5\u683c\u5b50\u5bf9\u5e94\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u6b21\u5bf9\u89d2\u7ebf\n        val diag1 = row - col + n - 1\n        val diag2 = row + col\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8be5\u683c\u5b50\u6240\u5728\u5217\u3001\u4e3b\u5bf9\u89d2\u7ebf\u3001\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u5b58\u5728\u7687\u540e\n        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {\n            // \u5c1d\u8bd5\uff1a\u5c06\u7687\u540e\u653e\u7f6e\u5728\u8be5\u683c\u5b50\n            state[row][col] = \"Q\"\n            diags2[diag2] = true\n            diags1[diag1] = diags2[diag2]\n            cols[col] = diags1[diag1]\n            // \u653e\u7f6e\u4e0b\u4e00\u884c\n            backtrack(row + 1, n, state, res, cols, diags1, diags2)\n            // \u56de\u9000\uff1a\u5c06\u8be5\u683c\u5b50\u6062\u590d\u4e3a\u7a7a\u4f4d\n            state[row][col] = \"#\"\n            diags2[diag2] = false\n            diags1[diag1] = diags2[diag2]\n            cols[col] = diags1[diag1]\n        }\n    }\n}\n\n/* \u6c42\u89e3 n \u7687\u540e */\nfun nQueens(n: Int): MutableList&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt; {\n    // \u521d\u59cb\u5316 n*n \u5927\u5c0f\u7684\u68cb\u76d8\uff0c\u5176\u4e2d 'Q' \u4ee3\u8868\u7687\u540e\uff0c'#' \u4ee3\u8868\u7a7a\u4f4d\n    val state = mutableListOf&lt;MutableList&lt;String&gt;&gt;()\n    for (i in 0..&lt;n) {\n        val row = mutableListOf&lt;String&gt;()\n        for (j in 0..&lt;n) {\n            row.add(\"#\")\n        }\n        state.add(row)\n    }\n    val cols = BooleanArray(n) // \u8bb0\u5f55\u5217\u662f\u5426\u6709\u7687\u540e\n    val diags1 = BooleanArray(2 * n - 1) // \u8bb0\u5f55\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    val diags2 = BooleanArray(2 * n - 1) // \u8bb0\u5f55\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u662f\u5426\u6709\u7687\u540e\n    val res = mutableListOf&lt;MutableList&lt;MutableList&lt;String&gt;&gt;?&gt;()\n\n    backtrack(0, n, state, res, cols, diags1, diags2)\n\n    return res\n}\n</code></pre> n_queens.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{n_queens}\n</code></pre> n_queens.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{nQueens}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Placing \\(n\\) queens row-by-row, considering column constraints, from the first row to the last row there are \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\) choices, using \\(O(n!)\\) time. When recording a solution, it is necessary to copy the matrix <code>state</code> and add it to <code>res</code>, with the copying operation using \\(O(n^2)\\) time. Therefore, the overall time complexity is \\(O(n! \\cdot n^2)\\). In practice, pruning based on diagonal constraints can significantly reduce the search space, thus often the search efficiency is better than the above time complexity.</p> <p>Array <code>state</code> uses \\(O(n^2)\\) space, and arrays <code>cols</code>, <code>diags1</code>, and <code>diags2</code> each use \\(O(n)\\) space. The maximum recursion depth is \\(n\\), using \\(O(n)\\) stack space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/","title":"13.2 \u00a0 Permutation problem","text":"<p>The permutation problem is a typical application of the backtracking algorithm. It is defined as finding all possible arrangements of elements from a given set (such as an array or string).</p> <p>Table 13-2 lists several example data, including the input arrays and their corresponding permutations.</p> <p> Table 13-2 \u00a0 Permutation examples </p> Input array Permutations \\([1]\\) \\([1]\\) \\([1, 2]\\) \\([1, 2], [2, 1]\\) \\([1, 2, 3]\\) \\([1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\\)"},{"location":"chapter_backtracking/permutations_problem/#1321-cases-without-equal-elements","title":"13.2.1 \u00a0 Cases without equal elements","text":"<p>Question</p> <p>Enter an integer array without duplicate elements and return all possible permutations.</p> <p>From the perspective of the backtracking algorithm, we can imagine the process of generating permutations as a series of choices. Suppose the input array is \\([1, 2, 3]\\), if we first choose \\(1\\), then \\(3\\), and finally \\(2\\), we obtain the permutation \\([1, 3, 2]\\). Backtracking means undoing a choice and then continuing to try other choices.</p> <p>From the code perspective, the candidate set <code>choices</code> contains all elements of the input array, and the state <code>state</code> contains elements that have been selected so far. Please note that each element can only be chosen once, thus all elements in <code>state</code> must be unique.</p> <p>As shown in Figure 13-5, we can unfold the search process into a recursive tree, where each node represents the current state <code>state</code>. Starting from the root node, after three rounds of choices, we reach the leaf nodes, each corresponding to a permutation.</p> <p></p> <p> Figure 13-5 \u00a0 Permutation recursive tree </p>"},{"location":"chapter_backtracking/permutations_problem/#1-pruning-of-repeated-choices","title":"1. \u00a0 Pruning of repeated choices","text":"<p>To ensure that each element is selected only once, we consider introducing a boolean array <code>selected</code>, where <code>selected[i]</code> indicates whether <code>choices[i]</code> has been selected. We base our pruning operations on this array:</p> <ul> <li>After making the choice <code>choice[i]</code>, we set <code>selected[i]</code> to \\(\\text{True}\\), indicating it has been chosen.</li> <li>When iterating through the choice list <code>choices</code>, skip all nodes that have already been selected, i.e., prune.</li> </ul> <p>As shown in Figure 13-6, suppose we choose 1 in the first round, 3 in the second round, and 2 in the third round, we need to prune the branch of element 1 in the second round and elements 1 and 3 in the third round.</p> <p></p> <p> Figure 13-6 \u00a0 Permutation pruning example </p> <p>Observing Figure 13-6, this pruning operation reduces the search space size from \\(O(n^n)\\) to \\(O(n!)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"<p>After understanding the above information, we can \"fill in the blanks\" in the framework code. To shorten the overall code, we do not implement individual functions within the framework code separately, but expand them in the <code>backtrack()</code> function:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig permutations_i.py<pre><code>def backtrack(\n    state: list[int], choices: list[int], selected: list[bool], res: list[list[int]]\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I\"\"\"\n    # \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if len(state) == len(choices):\n        res.append(list(state))\n        return\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i, choice in enumerate(choices):\n        # \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if not selected[i]:\n            # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = True\n            state.append(choice)\n            # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res)\n            # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = False\n            state.pop()\n\ndef permutations_i(nums: list[int]) -&gt; list[list[int]]:\n    \"\"\"\u5168\u6392\u5217 I\"\"\"\n    res = []\n    backtrack(state=[], choices=nums, selected=[False] * len(nums), res=res)\n    return res\n</code></pre> permutations_i.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nvoid backtrack(vector&lt;int&gt; &amp;state, const vector&lt;int&gt; &amp;choices, vector&lt;bool&gt; &amp;selected, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size() == choices.size()) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choices.size(); i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.push_back(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop_back();\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nvector&lt;vector&lt;int&gt;&gt; permutationsI(vector&lt;int&gt; nums) {\n    vector&lt;int&gt; state;\n    vector&lt;bool&gt; selected(nums.size(), false);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    backtrack(state, nums, selected, res);\n    return res;\n}\n</code></pre> permutations_i.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nvoid backtrack(List&lt;Integer&gt; state, int[] choices, boolean[] selected, List&lt;List&lt;Integer&gt;&gt; res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size() == choices.length) {\n        res.add(new ArrayList&lt;Integer&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choices.length; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.add(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.remove(state.size() - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nList&lt;List&lt;Integer&gt;&gt; permutationsI(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    backtrack(new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length], res);\n    return res;\n}\n</code></pre> permutations_i.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nvoid Backtrack(List&lt;int&gt; state, int[] choices, bool[] selected, List&lt;List&lt;int&gt;&gt; res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.Count == choices.Length) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choices.Length; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.Add(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            Backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.RemoveAt(state.Count - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nList&lt;List&lt;int&gt;&gt; PermutationsI(int[] nums) {\n    List&lt;List&lt;int&gt;&gt; res = [];\n    Backtrack([], nums, new bool[nums.Length], res);\n    return res;\n}\n</code></pre> permutations_i.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfunc backtrackI(state *[]int, choices *[]int, selected *[]bool, res *[][]int) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if len(*state) == len(*choices) {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i := 0; i &lt; len(*choices); i++ {\n        choice := (*choices)[i]\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if !(*selected)[i] {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            (*selected)[i] = true\n            *state = append(*state, choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrackI(state, choices, selected, res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            (*selected)[i] = false\n            *state = (*state)[:len(*state)-1]\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nfunc permutationsI(nums []int) [][]int {\n    res := make([][]int, 0)\n    state := make([]int, 0)\n    selected := make([]bool, len(nums))\n    backtrackI(&amp;state, &amp;nums, &amp;selected, &amp;res)\n    return res\n}\n</code></pre> permutations_i.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfunc backtrack(state: inout [Int], choices: [Int], selected: inout [Bool], res: inout [[Int]]) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if state.count == choices.count {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (i, choice) in choices.enumerated() {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if !selected[i] {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true\n            state.append(choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state: &amp;state, choices: choices, selected: &amp;selected, res: &amp;res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false\n            state.removeLast()\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nfunc permutationsI(nums: [Int]) -&gt; [[Int]] {\n    var state: [Int] = []\n    var selected = Array(repeating: false, count: nums.count)\n    var res: [[Int]] = []\n    backtrack(state: &amp;state, choices: nums, selected: &amp;selected, res: &amp;res)\n    return res\n}\n</code></pre> permutations_i.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfunction backtrack(state, choices, selected, res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    choices.forEach((choice, i) =&gt; {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* \u5168\u6392\u5217 I */\nfunction permutationsI(nums) {\n    const res = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_i.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfunction backtrack(\n    state: number[],\n    choices: number[],\n    selected: boolean[],\n    res: number[][]\n): void {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    choices.forEach((choice, i) =&gt; {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* \u5168\u6392\u5217 I */\nfunction permutationsI(nums: number[]): number[][] {\n    const res: number[][] = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_i.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  List&lt;int&gt; choices,\n  List&lt;bool&gt; selected,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (state.length == choices.length) {\n    res.add(List.from(state));\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  for (int i = 0; i &lt; choices.length; i++) {\n    int choice = choices[i];\n    // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n    if (!selected[i]) {\n      // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n      selected[i] = true;\n      state.add(choice);\n      // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n      backtrack(state, choices, selected, res);\n      // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n      selected[i] = false;\n      state.removeLast();\n    }\n  }\n}\n\n/* \u5168\u6392\u5217 I */\nList&lt;List&lt;int&gt;&gt; permutationsI(List&lt;int&gt; nums) {\n  List&lt;List&lt;int&gt;&gt; res = [];\n  backtrack([], nums, List.filled(nums.length, false), res);\n  return res;\n}\n</code></pre> permutations_i.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfn backtrack(mut state: Vec&lt;i32&gt;, choices: &amp;[i32], selected: &amp;mut [bool], res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if state.len() == choices.len() {\n        res.push(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i in 0..choices.len() {\n        let choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if !selected[i] {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state.clone(), choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.remove(state.len() - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nfn permutations_i(nums: &amp;mut [i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut res = Vec::new(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    backtrack(Vec::new(), nums, &amp;mut vec![false; nums.len()], &amp;mut res);\n    res\n}\n</code></pre> permutations_i.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nvoid backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (stateSize == choicesSize) {\n        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));\n        for (int i = 0; i &lt; choicesSize; i++) {\n            res[*resSize][i] = state[i];\n        }\n        (*resSize)++;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choicesSize; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true;\n            state[stateSize] = choice;\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nint **permutationsI(int *nums, int numsSize, int *returnSize) {\n    int *state = (int *)malloc(numsSize * sizeof(int));\n    bool *selected = (bool *)malloc(numsSize * sizeof(bool));\n    for (int i = 0; i &lt; numsSize; i++) {\n        selected[i] = false;\n    }\n    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));\n    *returnSize = 0;\n\n    backtrack(state, 0, nums, numsSize, selected, res, returnSize);\n\n    free(state);\n    free(selected);\n\n    return res;\n}\n</code></pre> permutations_i.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    choices: IntArray,\n    selected: BooleanArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size == choices.size) {\n        res.add(state.toMutableList())\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (i in choices.indices) {\n        val choice = choices[i]\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20\n        if (!selected[i]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            selected[i] = true\n            state.add(choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false\n            state.removeAt(state.size - 1)\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 I */\nfun permutationsI(nums: IntArray): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;()\n    backtrack(mutableListOf(), nums, BooleanArray(nums.size), res)\n    return res\n}\n</code></pre> permutations_i.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{permutations_i}\n</code></pre> permutations_i.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{permutationsI}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_backtracking/permutations_problem/#1322-considering-cases-with-equal-elements","title":"13.2.2 \u00a0 Considering cases with equal elements","text":"<p>Question</p> <p>Enter an integer array, which may contain duplicate elements, and return all unique permutations.</p> <p>Suppose the input array is \\([1, 1, 2]\\). To differentiate the two duplicate elements \\(1\\), we mark the second \\(1\\) as \\(\\hat{1}\\).</p> <p>As shown in Figure 13-7, half of the permutations generated by the above method are duplicates.</p> <p></p> <p> Figure 13-7 \u00a0 Duplicate permutations </p> <p>So, how do we eliminate duplicate permutations? Most directly, consider using a hash set to deduplicate permutation results. However, this is not elegant, as branches generating duplicate permutations are unnecessary and should be identified and pruned in advance, which can further improve algorithm efficiency.</p>"},{"location":"chapter_backtracking/permutations_problem/#1-pruning-of-equal-elements","title":"1. \u00a0 Pruning of equal elements","text":"<p>Observing Figure 13-8, in the first round, choosing \\(1\\) or \\(\\hat{1}\\) results in identical permutations under both choices, thus we should prune \\(\\hat{1}\\).</p> <p>Similarly, after choosing \\(2\\) in the first round, choosing \\(1\\) and \\(\\hat{1}\\) in the second round also produces duplicate branches, so we should also prune \\(\\hat{1}\\) in the second round.</p> <p>Essentially, our goal is to ensure that multiple equal elements are only selected once in each round of choices.</p> <p></p> <p> Figure 13-8 \u00a0 Duplicate permutations pruning </p>"},{"location":"chapter_backtracking/permutations_problem/#2-code-implementation_1","title":"2. \u00a0 Code implementation","text":"<p>Based on the code from the previous problem, we consider initiating a hash set <code>duplicated</code> in each round of choices, used to record elements that have been tried in that round, and prune duplicate elements:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig permutations_ii.py<pre><code>def backtrack(\n    state: list[int], choices: list[int], selected: list[bool], res: list[list[int]]\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II\"\"\"\n    # \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if len(state) == len(choices):\n        res.append(list(state))\n        return\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    duplicated = set[int]()\n    for i, choice in enumerate(choices):\n        # \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if not selected[i] and choice not in duplicated:\n            # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.add(choice)  # \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = True\n            state.append(choice)\n            # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res)\n            # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = False\n            state.pop()\n\ndef permutations_ii(nums: list[int]) -&gt; list[list[int]]:\n    \"\"\"\u5168\u6392\u5217 II\"\"\"\n    res = []\n    backtrack(state=[], choices=nums, selected=[False] * len(nums), res=res)\n    return res\n</code></pre> permutations_ii.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nvoid backtrack(vector&lt;int&gt; &amp;state, const vector&lt;int&gt; &amp;choices, vector&lt;bool&gt; &amp;selected, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size() == choices.size()) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    unordered_set&lt;int&gt; duplicated;\n    for (int i = 0; i &lt; choices.size(); i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; duplicated.find(choice) == duplicated.end()) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.emplace(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.push_back(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop_back();\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nvector&lt;vector&lt;int&gt;&gt; permutationsII(vector&lt;int&gt; nums) {\n    vector&lt;int&gt; state;\n    vector&lt;bool&gt; selected(nums.size(), false);\n    vector&lt;vector&lt;int&gt;&gt; res;\n    backtrack(state, nums, selected, res);\n    return res;\n}\n</code></pre> permutations_ii.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nvoid backtrack(List&lt;Integer&gt; state, int[] choices, boolean[] selected, List&lt;List&lt;Integer&gt;&gt; res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size() == choices.length) {\n        res.add(new ArrayList&lt;Integer&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    Set&lt;Integer&gt; duplicated = new HashSet&lt;Integer&gt;();\n    for (int i = 0; i &lt; choices.length; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.add(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.add(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.remove(state.size() - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nList&lt;List&lt;Integer&gt;&gt; permutationsII(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    backtrack(new ArrayList&lt;Integer&gt;(), nums, new boolean[nums.length], res);\n    return res;\n}\n</code></pre> permutations_ii.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nvoid Backtrack(List&lt;int&gt; state, int[] choices, bool[] selected, List&lt;List&lt;int&gt;&gt; res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.Count == choices.Length) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    HashSet&lt;int&gt; duplicated = [];\n    for (int i = 0; i &lt; choices.Length; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated.Contains(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.Add(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.Add(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            Backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.RemoveAt(state.Count - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nList&lt;List&lt;int&gt;&gt; PermutationsII(int[] nums) {\n    List&lt;List&lt;int&gt;&gt; res = [];\n    Backtrack([], nums, new bool[nums.Length], res);\n    return res;\n}\n</code></pre> permutations_ii.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfunc backtrackII(state *[]int, choices *[]int, selected *[]bool, res *[][]int) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if len(*state) == len(*choices) {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    duplicated := make(map[int]struct{}, 0)\n    for i := 0; i &lt; len(*choices); i++ {\n        choice := (*choices)[i]\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if _, ok := duplicated[choice]; !ok &amp;&amp; !(*selected)[i] {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            duplicated[choice] = struct{}{}\n            (*selected)[i] = true\n            *state = append(*state, choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrackII(state, choices, selected, res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            (*selected)[i] = false\n            *state = (*state)[:len(*state)-1]\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nfunc permutationsII(nums []int) [][]int {\n    res := make([][]int, 0)\n    state := make([]int, 0)\n    selected := make([]bool, len(nums))\n    backtrackII(&amp;state, &amp;nums, &amp;selected, &amp;res)\n    return res\n}\n</code></pre> permutations_ii.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfunc backtrack(state: inout [Int], choices: [Int], selected: inout [Bool], res: inout [[Int]]) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if state.count == choices.count {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    var duplicated: Set&lt;Int&gt; = []\n    for (i, choice) in choices.enumerated() {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if !selected[i], !duplicated.contains(choice) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.insert(choice) // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true\n            state.append(choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state: &amp;state, choices: choices, selected: &amp;selected, res: &amp;res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false\n            state.removeLast()\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nfunc permutationsII(nums: [Int]) -&gt; [[Int]] {\n    var state: [Int] = []\n    var selected = Array(repeating: false, count: nums.count)\n    var res: [[Int]] = []\n    backtrack(state: &amp;state, choices: nums, selected: &amp;selected, res: &amp;res)\n    return res\n}\n</code></pre> permutations_ii.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfunction backtrack(state, choices, selected, res) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    const duplicated = new Set();\n    choices.forEach((choice, i) =&gt; {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated.has(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.add(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* \u5168\u6392\u5217 II */\nfunction permutationsII(nums) {\n    const res = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_ii.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfunction backtrack(\n    state: number[],\n    choices: number[],\n    selected: boolean[],\n    res: number[][]\n): void {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.length === choices.length) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    const duplicated = new Set();\n    choices.forEach((choice, i) =&gt; {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated.has(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.add(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.pop();\n        }\n    });\n}\n\n/* \u5168\u6392\u5217 II */\nfunction permutationsII(nums: number[]): number[][] {\n    const res: number[][] = [];\n    backtrack([], nums, Array(nums.length).fill(false), res);\n    return res;\n}\n</code></pre> permutations_ii.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nvoid backtrack(\n  List&lt;int&gt; state,\n  List&lt;int&gt; choices,\n  List&lt;bool&gt; selected,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (state.length == choices.length) {\n    res.add(List.from(state));\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  Set&lt;int&gt; duplicated = {};\n  for (int i = 0; i &lt; choices.length; i++) {\n    int choice = choices[i];\n    // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n    if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n      // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n      duplicated.add(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n      selected[i] = true;\n      state.add(choice);\n      // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n      backtrack(state, choices, selected, res);\n      // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n      selected[i] = false;\n      state.removeLast();\n    }\n  }\n}\n\n/* \u5168\u6392\u5217 II */\nList&lt;List&lt;int&gt;&gt; permutationsII(List&lt;int&gt; nums) {\n  List&lt;List&lt;int&gt;&gt; res = [];\n  backtrack([], nums, List.filled(nums.length, false), res);\n  return res;\n}\n</code></pre> permutations_ii.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfn backtrack(mut state: Vec&lt;i32&gt;, choices: &amp;[i32], selected: &amp;mut [bool], res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if state.len() == choices.len() {\n        res.push(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    let mut duplicated = HashSet::&lt;i32&gt;::new();\n    for i in 0..choices.len() {\n        let choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if !selected[i] &amp;&amp; !duplicated.contains(&amp;choice) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.insert(choice); // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state.push(choice);\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state.clone(), choices, selected, res);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n            state.remove(state.len() - 1);\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nfn permutations_ii(nums: &amp;mut [i32]) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let mut res = Vec::new();\n    backtrack(Vec::new(), nums, &amp;mut vec![false; nums.len()], &amp;mut res);\n    res\n}\n</code></pre> permutations_ii.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nvoid backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (stateSize == choicesSize) {\n        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));\n        for (int i = 0; i &lt; choicesSize; i++) {\n            res[*resSize][i] = state[i];\n        }\n        (*resSize)++;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    bool duplicated[MAX_SIZE] = {false};\n    for (int i = 0; i &lt; choicesSize; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated[choice]) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated[choice] = true; // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true;\n            state[stateSize] = choice;\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false;\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nint **permutationsII(int *nums, int numsSize, int *returnSize) {\n    int *state = (int *)malloc(numsSize * sizeof(int));\n    bool *selected = (bool *)malloc(numsSize * sizeof(bool));\n    for (int i = 0; i &lt; numsSize; i++) {\n        selected[i] = false;\n    }\n    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));\n    *returnSize = 0;\n\n    backtrack(state, 0, nums, numsSize, selected, res, returnSize);\n\n    free(state);\n    free(selected);\n\n    return res;\n}\n</code></pre> permutations_ii.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5168\u6392\u5217 II */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    choices: IntArray,\n    selected: BooleanArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // \u5f53\u72b6\u6001\u957f\u5ea6\u7b49\u4e8e\u5143\u7d20\u6570\u91cf\u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (state.size == choices.size) {\n        res.add(state.toMutableList())\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    val duplicated = HashSet&lt;Int&gt;()\n    for (i in choices.indices) {\n        val choice = choices[i]\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u5143\u7d20 \u4e14 \u4e0d\u5141\u8bb8\u91cd\u590d\u9009\u62e9\u76f8\u7b49\u5143\u7d20\n        if (!selected[i] &amp;&amp; !duplicated.contains(choice)) {\n            // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n            duplicated.add(choice) // \u8bb0\u5f55\u9009\u62e9\u8fc7\u7684\u5143\u7d20\u503c\n            selected[i] = true\n            state.add(choice)\n            // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n            backtrack(state, choices, selected, res)\n            // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n            selected[i] = false\n            state.removeAt(state.size - 1)\n        }\n    }\n}\n\n/* \u5168\u6392\u5217 II */\nfun permutationsII(nums: IntArray): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;()\n    backtrack(mutableListOf(), nums, BooleanArray(nums.size), res)\n    return res\n}\n</code></pre> permutations_ii.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{permutations_ii}\n</code></pre> permutations_ii.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{permutationsII}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Assuming all elements are distinct from each other, there are \\(n!\\) (factorial) permutations of \\(n\\) elements; when recording results, it is necessary to copy a list of length \\(n\\), using \\(O(n)\\) time. Thus, the time complexity is \\(O(n!n)\\).</p> <p>The maximum recursion depth is \\(n\\), using \\(O(n)\\) frame space. <code>Selected</code> uses \\(O(n)\\) space. At any one time, there can be up to \\(n\\) <code>duplicated</code>, using \\(O(n^2)\\) space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#3-comparison-of-the-two-pruning-methods","title":"3. \u00a0 Comparison of the two pruning methods","text":"<p>Please note, although both <code>selected</code> and <code>duplicated</code> are used for pruning, their targets are different.</p> <ul> <li>Repeated choice pruning: There is only one <code>selected</code> throughout the search process. It records which elements are currently in the state, aiming to prevent an element from appearing repeatedly in <code>state</code>.</li> <li>Equal element pruning: Each round of choices (each call to the <code>backtrack</code> function) contains a <code>duplicated</code>. It records which elements have been chosen in the current traversal (<code>for</code> loop), aiming to ensure equal elements are selected only once.</li> </ul> <p>Figure 13-9 shows the scope of the two pruning conditions. Note, each node in the tree represents a choice, and the nodes from the root to the leaf form a permutation.</p> <p></p> <p> Figure 13-9 \u00a0 Scope of the two pruning conditions </p>"},{"location":"chapter_backtracking/subset_sum_problem/","title":"13.3 \u00a0 Subset sum problem","text":""},{"location":"chapter_backtracking/subset_sum_problem/#1331-case-without-duplicate-elements","title":"13.3.1 \u00a0 Case without duplicate elements","text":"<p>Question</p> <p>Given an array of positive integers <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations such that the sum of the elements in the combination equals <code>target</code>. The given array has no duplicate elements, and each element can be chosen multiple times. Please return these combinations as a list, which should not contain duplicate combinations.</p> <p>For example, for the input set \\(\\{3, 4, 5\\}\\) and target integer \\(9\\), the solutions are \\(\\{3, 3, 3\\}, \\{4, 5\\}\\). Note the following two points.</p> <ul> <li>Elements in the input set can be chosen an unlimited number of times.</li> <li>Subsets do not distinguish the order of elements, for example \\(\\{4, 5\\}\\) and \\(\\{5, 4\\}\\) are the same subset.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#1-reference-permutation-solution","title":"1. \u00a0 Reference permutation solution","text":"<p>Similar to the permutation problem, we can imagine the generation of subsets as a series of choices, updating the \"element sum\" in real-time during the choice process. When the element sum equals <code>target</code>, the subset is recorded in the result list.</p> <p>Unlike the permutation problem, elements in this problem can be chosen an unlimited number of times, thus there is no need to use a <code>selected</code> boolean list to record whether an element has been chosen. We can make minor modifications to the permutation code to initially solve the problem:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig subset_sum_i_naive.py<pre><code>def backtrack(\n    state: list[int],\n    target: int,\n    total: int,\n    choices: list[int],\n    res: list[list[int]],\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I\"\"\"\n    # \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if total == target:\n        res.append(list(state))\n        return\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i in range(len(choices)):\n        # \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if total + choices[i] &gt; target:\n            continue\n        # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.append(choices[i])\n        # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res)\n        # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop()\n\ndef subset_sum_i_naive(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"\u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09\"\"\"\n    state = []  # \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    total = 0  # \u5b50\u96c6\u548c\n    res = []  # \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res)\n    return res\n</code></pre> subset_sum_i_naive.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, int total, vector&lt;int&gt; &amp;choices, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total == target) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (size_t i = 0; i &lt; choices.size(); i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.push_back(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop_back();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nvector&lt;vector&lt;int&gt;&gt; subsetSumINaive(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;       // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    int total = 0;           // \u5b50\u96c6\u548c\n    vector&lt;vector&lt;int&gt;&gt; res; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(List&lt;Integer&gt; state, int target, int total, int[] choices, List&lt;List&lt;Integer&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total == target) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choices.length; i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.remove(state.size() - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nList&lt;List&lt;Integer&gt;&gt; subsetSumINaive(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    int total = 0; // \u5b50\u96c6\u548c\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid Backtrack(List&lt;int&gt; state, int target, int total, int[] choices, List&lt;List&lt;int&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total == target) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choices.Length; i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.Add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        Backtrack(state, target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nList&lt;List&lt;int&gt;&gt; SubsetSumINaive(int[] nums, int target) {\n    List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    int total = 0; // \u5b50\u96c6\u548c\n    List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    Backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunc backtrackSubsetSumINaive(total, target int, state, choices *[]int, res *[][]int) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == total {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i := 0; i &lt; len(*choices); i++ {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if total+(*choices)[i] &gt; target {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        *state = append(*state, (*choices)[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrackSubsetSumINaive(total+(*choices)[i], target, state, choices, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfunc subsetSumINaive(nums []int, target int) [][]int {\n    state := make([]int, 0) // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    total := 0              // \u5b50\u96c6\u548c\n    res := make([][]int, 0) // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrackSubsetSumINaive(total, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_i_naive.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunc backtrack(state: inout [Int], target: Int, total: Int, choices: [Int], res: inout [[Int]]) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if total == target {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i in choices.indices {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if total + choices[i] &gt; target {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.append(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state: &amp;state, target: target, total: total + choices[i], choices: choices, res: &amp;res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeLast()\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfunc subsetSumINaive(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    let total = 0 // \u5b50\u96c6\u548c\n    var res: [[Int]] = [] // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state: &amp;state, target: target, total: total, choices: nums, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_i_naive.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunction backtrack(state, target, total, choices, res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total === target) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (let i = 0; i &lt; choices.length; i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfunction subsetSumINaive(nums, target) {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    const total = 0; // \u5b50\u96c6\u548c\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunction backtrack(\n    state: number[],\n    target: number,\n    total: number,\n    choices: number[],\n    res: number[][]\n): void {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total === target) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (let i = 0; i &lt; choices.length; i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfunction subsetSumINaive(nums: number[], target: number): number[][] {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    const total = 0; // \u5b50\u96c6\u548c\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res);\n    return res;\n}\n</code></pre> subset_sum_i_naive.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  int total,\n  List&lt;int&gt; choices,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (total == target) {\n    res.add(List.from(state));\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  for (int i = 0; i &lt; choices.length; i++) {\n    // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n    if (total + choices[i] &gt; target) {\n      continue;\n    }\n    // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n    state.add(choices[i]);\n    // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n    backtrack(state, target, total + choices[i], choices, res);\n    // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n    state.removeLast();\n  }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nList&lt;List&lt;int&gt;&gt; subsetSumINaive(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n  int total = 0; // \u5143\u7d20\u548c\n  List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n  backtrack(state, target, total, nums, res);\n  return res;\n}\n</code></pre> subset_sum_i_naive.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfn backtrack(\n    mut state: Vec&lt;i32&gt;,\n    target: i32,\n    total: i32,\n    choices: &amp;[i32],\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if total == target {\n        res.push(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for i in 0..choices.len() {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if total + choices[i] &gt; target {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state.clone(), target, total + choices[i], choices, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfn subset_sum_i_naive(nums: &amp;[i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let state = Vec::new(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    let total = 0; // \u5b50\u96c6\u548c\n    let mut res = Vec::new(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_i_naive.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(int target, int total, int *choices, int choicesSize) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total == target) {\n        for (int i = 0; i &lt; stateSize; i++) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; choicesSize; i++) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state[stateSize++] = choices[i];\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(target, total + choices[i], choices, choicesSize);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        stateSize--;\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nvoid subsetSumINaive(int *nums, int numsSize, int target) {\n    resSize = 0; // \u521d\u59cb\u5316\u89e3\u7684\u6570\u91cf\u4e3a0\n    backtrack(target, 0, nums, numsSize);\n}\n</code></pre> subset_sum_i_naive.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    total: Int,\n    choices: IntArray,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (total == target) {\n        res.add(state.toMutableList())\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (i in choices.indices) {\n        // \u526a\u679d\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u8df3\u8fc7\u8be5\u9009\u62e9\n        if (total + choices[i] &gt; target) {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u5143\u7d20\u548c total\n        state.add(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target, total + choices[i], choices, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I\uff08\u5305\u542b\u91cd\u590d\u5b50\u96c6\uff09 */\nfun subsetSumINaive(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    val total = 0 // \u5b50\u96c6\u548c\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, total, nums, res)\n    return res\n}\n</code></pre> subset_sum_i_naive.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subset_sum_i_naive}\n</code></pre> subset_sum_i_naive.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subsetSumINaive}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Inputting the array \\([3, 4, 5]\\) and target element \\(9\\) into the above code yields the results \\([3, 3, 3], [4, 5], [5, 4]\\). Although it successfully finds all subsets with a sum of \\(9\\), it includes the duplicate subset \\([4, 5]\\) and \\([5, 4]\\).</p> <p>This is because the search process distinguishes the order of choices, however, subsets do not distinguish the choice order. As shown in Figure 13-10, choosing \\(4\\) before \\(5\\) and choosing \\(5\\) before \\(4\\) are different branches, but correspond to the same subset.</p> <p></p> <p> Figure 13-10 \u00a0 Subset search and pruning out of bounds </p> <p>To eliminate duplicate subsets, a straightforward idea is to deduplicate the result list. However, this method is very inefficient for two reasons.</p> <ul> <li>When there are many array elements, especially when <code>target</code> is large, the search process produces a large number of duplicate subsets.</li> <li>Comparing subsets (arrays) for differences is very time-consuming, requiring arrays to be sorted first, then comparing the differences of each element in the arrays.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#2-duplicate-subset-pruning","title":"2. \u00a0 Duplicate subset pruning","text":"<p>We consider deduplication during the search process through pruning. Observing Figure 13-11, duplicate subsets are generated when choosing array elements in different orders, for example in the following situations.</p> <ol> <li>When choosing \\(3\\) in the first round and \\(4\\) in the second round, all subsets containing these two elements are generated, denoted as \\([3, 4, \\dots]\\).</li> <li>Later, when \\(4\\) is chosen in the first round, the second round should skip \\(3\\) because the subset \\([4, 3, \\dots]\\) generated by this choice completely duplicates the subset from step <code>1.</code>.</li> </ol> <p>In the search process, each layer's choices are tried one by one from left to right, so the more to the right a branch is, the more it is pruned.</p> <ol> <li>First two rounds choose \\(3\\) and \\(5\\), generating subset \\([3, 5, \\dots]\\).</li> <li>First two rounds choose \\(4\\) and \\(5\\), generating subset \\([4, 5, \\dots]\\).</li> <li>If \\(5\\) is chosen in the first round, then the second round should skip \\(3\\) and \\(4\\) as the subsets \\([5, 3, \\dots]\\) and \\([5, 4, \\dots]\\) completely duplicate the subsets described in steps <code>1.</code> and <code>2.</code>.</li> </ol> <p></p> <p> Figure 13-11 \u00a0 Different choice orders leading to duplicate subsets </p> <p>In summary, given the input array \\([x_1, x_2, \\dots, x_n]\\), the choice sequence in the search process should be \\([x_{i_1}, x_{i_2}, \\dots, x_{i_m}]\\), which needs to satisfy \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\). Any choice sequence that does not meet this condition will cause duplicates and should be pruned.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#3-code-implementation","title":"3. \u00a0 Code implementation","text":"<p>To implement this pruning, we initialize the variable <code>start</code>, which indicates the starting point for traversal. After making the choice \\(x_{i}\\), set the next round to start from index \\(i\\). This will ensure the choice sequence satisfies \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\), thereby ensuring the uniqueness of the subsets.</p> <p>Besides, we have made the following two optimizations to the code.</p> <ul> <li>Before starting the search, sort the array <code>nums</code>. In the traversal of all choices, end the loop directly when the subset sum exceeds <code>target</code> as subsequent elements are larger and their subset sum will definitely exceed <code>target</code>.</li> <li>Eliminate the element sum variable <code>total</code>, by performing subtraction on <code>target</code> to count the element sum. When <code>target</code> equals \\(0\\), record the solution.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig subset_sum_i.py<pre><code>def backtrack(\n    state: list[int], target: int, choices: list[int], start: int, res: list[list[int]]\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I\"\"\"\n    # \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0:\n        res.append(list(state))\n        return\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    # \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for i in range(start, len(choices)):\n        # \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        # \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0:\n            break\n        # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.append(choices[i])\n        # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res)\n        # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop()\n\ndef subset_sum_i(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"\u6c42\u89e3\u5b50\u96c6\u548c I\"\"\"\n    state = []  # \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort()  # \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    start = 0  # \u904d\u5386\u8d77\u59cb\u70b9\n    res = []  # \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res)\n    return res\n</code></pre> subset_sum_i.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, vector&lt;int&gt; &amp;choices, int start, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (int i = start; i &lt; choices.size(); i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push_back(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop_back();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nvector&lt;vector&lt;int&gt;&gt; subsetSumI(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;              // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    sort(nums.begin(), nums.end()); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0;                  // \u904d\u5386\u8d77\u59cb\u70b9\n    vector&lt;vector&lt;int&gt;&gt; res;        // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(List&lt;Integer&gt; state, int target, int[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (int i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.remove(state.size() - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nList&lt;List&lt;Integer&gt;&gt; subsetSumI(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    Arrays.sort(nums); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid Backtrack(List&lt;int&gt; state, int target, int[] choices, int start, List&lt;List&lt;int&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (int i = start; i &lt; choices.Length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.Add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        Backtrack(state, target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nList&lt;List&lt;int&gt;&gt; SubsetSumI(int[] nums, int target) {\n    List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    Array.Sort(nums); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    Backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunc backtrackSubsetSumI(start, target int, state, choices *[]int, res *[][]int) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for i := start; i &lt; len(*choices); i++ {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target-(*choices)[i] &lt; 0 {\n            break\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        *state = append(*state, (*choices)[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrackSubsetSumI(i, target-(*choices)[i], state, choices, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfunc subsetSumI(nums []int, target int) [][]int {\n    state := make([]int, 0) // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    sort.Ints(nums)         // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    start := 0              // \u904d\u5386\u8d77\u59cb\u70b9\n    res := make([][]int, 0) // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrackSubsetSumI(start, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_i.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunc backtrack(state: inout [Int], target: Int, choices: [Int], start: Int, res: inout [[Int]]) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for i in choices.indices.dropFirst(start) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0 {\n            break\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.append(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state: &amp;state, target: target - choices[i], choices: choices, start: i, res: &amp;res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeLast()\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfunc subsetSumI(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    let nums = nums.sorted() // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    let start = 0 // \u904d\u5386\u8d77\u59cb\u70b9\n    var res: [[Int]] = [] // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state: &amp;state, target: target, choices: nums, start: start, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_i.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunction backtrack(state, target, choices, start, res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (let i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfunction subsetSumI(nums, target) {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort((a, b) =&gt; a - b); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    const start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfunction backtrack(\n    state: number[],\n    target: number,\n    choices: number[],\n    start: number,\n    res: number[][]\n): void {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (let i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfunction subsetSumI(nums: number[], target: number): number[][] {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort((a, b) =&gt; a - b); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    const start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_i.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  List&lt;int&gt; choices,\n  int start,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (target == 0) {\n    res.add(List.from(state));\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n  for (int i = start; i &lt; choices.length; i++) {\n    // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n    // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n    if (target - choices[i] &lt; 0) {\n      break;\n    }\n    // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n    state.add(choices[i]);\n    // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n    backtrack(state, target - choices[i], choices, i, res);\n    // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n    state.removeLast();\n  }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nList&lt;List&lt;int&gt;&gt; subsetSumI(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n  nums.sort(); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n  int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n  List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n  backtrack(state, target, nums, start, res);\n  return res;\n}\n</code></pre> subset_sum_i.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfn backtrack(\n    mut state: Vec&lt;i32&gt;,\n    target: i32,\n    choices: &amp;[i32],\n    start: usize,\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        res.push(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for i in start..choices.len() {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0 {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state.clone(), target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfn subset_sum_i(nums: &amp;mut [i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let state = Vec::new(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort(); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    let start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    let mut res = Vec::new(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_i.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nvoid backtrack(int target, int *choices, int choicesSize, int start) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        for (int i = 0; i &lt; stateSize; ++i) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (int i = start; i &lt; choicesSize; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state[stateSize] = choices[i];\n        stateSize++;\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(target - choices[i], choices, choicesSize, i);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        stateSize--;\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nvoid subsetSumI(int *nums, int numsSize, int target) {\n    qsort(nums, numsSize, sizeof(int), cmp); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0;                           // \u904d\u5386\u8d77\u59cb\u70b9\n    backtrack(target, nums, numsSize, start);\n}\n</code></pre> subset_sum_i.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c I */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    choices: IntArray,\n    start: Int,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.add(state.toMutableList())\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    for (i in start..&lt;choices.size) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.add(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c I */\nfun subsetSumI(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort() // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    val start = 0 // \u904d\u5386\u8d77\u59cb\u70b9\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res)\n    return res\n}\n</code></pre> subset_sum_i.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subset_sum_i}\n</code></pre> subset_sum_i.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subsetSumI}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 13-12 shows the overall backtracking process after inputting the array \\([3, 4, 5]\\) and target element \\(9\\) into the above code.</p> <p></p> <p> Figure 13-12 \u00a0 Subset sum I backtracking process </p>"},{"location":"chapter_backtracking/subset_sum_problem/#1332-considering-cases-with-duplicate-elements","title":"13.3.2 \u00a0 Considering cases with duplicate elements","text":"<p>Question</p> <p>Given an array of positive integers <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations such that the sum of the elements in the combination equals <code>target</code>. The given array may contain duplicate elements, and each element can only be chosen once. Please return these combinations as a list, which should not contain duplicate combinations.</p> <p>Compared to the previous question, this question's input array may contain duplicate elements, introducing new problems. For example, given the array \\([4, \\hat{4}, 5]\\) and target element \\(9\\), the existing code's output results in \\([4, 5], [\\hat{4}, 5]\\), resulting in duplicate subsets.</p> <p>The reason for this duplication is that equal elements are chosen multiple times in a certain round. In Figure 13-13, the first round has three choices, two of which are \\(4\\), generating two duplicate search branches, thus outputting duplicate subsets; similarly, the two \\(4\\)s in the second round also produce duplicate subsets.</p> <p></p> <p> Figure 13-13 \u00a0 Duplicate subsets caused by equal elements </p>"},{"location":"chapter_backtracking/subset_sum_problem/#1-equal-element-pruning","title":"1. \u00a0 Equal element pruning","text":"<p>To solve this issue, we need to limit equal elements to being chosen only once per round. The implementation is quite clever: since the array is sorted, equal elements are adjacent. This means that in a certain round of choices, if the current element is equal to its left-hand element, it means it has already been chosen, so skip the current element directly.</p> <p>At the same time, this question stipulates that each array element can only be chosen once. Fortunately, we can also use the variable <code>start</code> to meet this constraint: after making the choice \\(x_{i}\\), set the next round to start from index \\(i + 1\\) going forward. This not only eliminates duplicate subsets but also avoids repeated selection of elements.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig subset_sum_ii.py<pre><code>def backtrack(\n    state: list[int], target: int, choices: list[int], start: int, res: list[list[int]]\n):\n    \"\"\"\u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II\"\"\"\n    # \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0:\n        res.append(list(state))\n        return\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    # \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    # \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for i in range(start, len(choices)):\n        # \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        # \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0:\n            break\n        # \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if i &gt; start and choices[i] == choices[i - 1]:\n            continue\n        # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.append(choices[i])\n        # \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res)\n        # \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop()\n\ndef subset_sum_ii(nums: list[int], target: int) -&gt; list[list[int]]:\n    \"\"\"\u6c42\u89e3\u5b50\u96c6\u548c II\"\"\"\n    state = []  # \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort()  # \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    start = 0  # \u904d\u5386\u8d77\u59cb\u70b9\n    res = []  # \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res)\n    return res\n</code></pre> subset_sum_ii.cpp<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nvoid backtrack(vector&lt;int&gt; &amp;state, int target, vector&lt;int&gt; &amp;choices, int start, vector&lt;vector&lt;int&gt;&gt; &amp;res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.push_back(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (int i = start; i &lt; choices.size(); i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push_back(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop_back();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nvector&lt;vector&lt;int&gt;&gt; subsetSumII(vector&lt;int&gt; &amp;nums, int target) {\n    vector&lt;int&gt; state;              // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    sort(nums.begin(), nums.end()); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0;                  // \u904d\u5386\u8d77\u59cb\u70b9\n    vector&lt;vector&lt;int&gt;&gt; res;        // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.java<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nvoid backtrack(List&lt;Integer&gt; state, int target, int[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.add(new ArrayList&lt;&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (int i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.remove(state.size() - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nList&lt;List&lt;Integer&gt;&gt; subsetSumII(int[] nums, int target) {\n    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    Arrays.sort(nums); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.cs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nvoid Backtrack(List&lt;int&gt; state, int target, int[] choices, int start, List&lt;List&lt;int&gt;&gt; res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.Add(new List&lt;int&gt;(state));\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (int i = start; i &lt; choices.Length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.Add(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        Backtrack(state, target - choices[i], choices, i + 1, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.RemoveAt(state.Count - 1);\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nList&lt;List&lt;int&gt;&gt; SubsetSumII(int[] nums, int target) {\n    List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    Array.Sort(nums); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    Backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.go<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfunc backtrackSubsetSumII(start, target int, state, choices *[]int, res *[][]int) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        newState := append([]int{}, *state...)\n        *res = append(*res, newState)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for i := start; i &lt; len(*choices); i++ {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target-(*choices)[i] &lt; 0 {\n            break\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if i &gt; start &amp;&amp; (*choices)[i] == (*choices)[i-1] {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        *state = append(*state, (*choices)[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrackSubsetSumII(i+1, target-(*choices)[i], state, choices, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        *state = (*state)[:len(*state)-1]\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfunc subsetSumII(nums []int, target int) [][]int {\n    state := make([]int, 0) // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    sort.Ints(nums)         // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    start := 0              // \u904d\u5386\u8d77\u59cb\u70b9\n    res := make([][]int, 0) // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrackSubsetSumII(start, target, &amp;state, &amp;nums, &amp;res)\n    return res\n}\n</code></pre> subset_sum_ii.swift<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfunc backtrack(state: inout [Int], target: Int, choices: [Int], start: Int, res: inout [[Int]]) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        res.append(state)\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for i in choices.indices.dropFirst(start) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0 {\n            break\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if i &gt; start, choices[i] == choices[i - 1] {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.append(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state: &amp;state, target: target - choices[i], choices: choices, start: i + 1, res: &amp;res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeLast()\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfunc subsetSumII(nums: [Int], target: Int) -&gt; [[Int]] {\n    var state: [Int] = [] // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    let nums = nums.sorted() // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    let start = 0 // \u904d\u5386\u8d77\u59cb\u70b9\n    var res: [[Int]] = [] // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state: &amp;state, target: target, choices: nums, start: start, res: &amp;res)\n    return res\n}\n</code></pre> subset_sum_ii.js<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfunction backtrack(state, target, choices, start, res) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (let i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] === choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfunction subsetSumII(nums, target) {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort((a, b) =&gt; a - b); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    const start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.ts<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfunction backtrack(\n    state: number[],\n    target: number,\n    choices: number[],\n    start: number,\n    res: number[][]\n): void {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target === 0) {\n        res.push([...state]);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (let i = start; i &lt; choices.length; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] === choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfunction subsetSumII(nums: number[], target: number): number[][] {\n    const state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort((a, b) =&gt; a - b); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    const start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    const res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res);\n    return res;\n}\n</code></pre> subset_sum_ii.dart<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nvoid backtrack(\n  List&lt;int&gt; state,\n  int target,\n  List&lt;int&gt; choices,\n  int start,\n  List&lt;List&lt;int&gt;&gt; res,\n) {\n  // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n  if (target == 0) {\n    res.add(List.from(state));\n    return;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n  // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n  for (int i = start; i &lt; choices.length; i++) {\n    // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n    // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n    if (target - choices[i] &lt; 0) {\n      break;\n    }\n    // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n    if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n      continue;\n    }\n    // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n    state.add(choices[i]);\n    // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n    backtrack(state, target - choices[i], choices, i + 1, res);\n    // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n    state.removeLast();\n  }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nList&lt;List&lt;int&gt;&gt; subsetSumII(List&lt;int&gt; nums, int target) {\n  List&lt;int&gt; state = []; // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n  nums.sort(); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n  int start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n  List&lt;List&lt;int&gt;&gt; res = []; // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n  backtrack(state, target, nums, start, res);\n  return res;\n}\n</code></pre> subset_sum_ii.rs<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfn backtrack(\n    mut state: Vec&lt;i32&gt;,\n    target: i32,\n    choices: &amp;[i32],\n    start: usize,\n    res: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if target == 0 {\n        res.push(state);\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for i in start..choices.len() {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if target - choices[i] &lt; 0 {\n            break;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if i &gt; start &amp;&amp; choices[i] == choices[i - 1] {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.push(choices[i]);\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state.clone(), target - choices[i], choices, i, res);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.pop();\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfn subset_sum_ii(nums: &amp;mut [i32], target: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {\n    let state = Vec::new(); // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort(); // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    let start = 0; // \u904d\u5386\u8d77\u59cb\u70b9\n    let mut res = Vec::new(); // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, &amp;mut res);\n    res\n}\n</code></pre> subset_sum_ii.c<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nvoid backtrack(int target, int *choices, int choicesSize, int start) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        for (int i = 0; i &lt; stateSize; i++) {\n            res[resSize][i] = state[i];\n        }\n        resColSizes[resSize++] = stateSize;\n        return;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (int i = start; i &lt; choicesSize; i++) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\n        if (target - choices[i] &lt; 0) {\n            continue;\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state[stateSize] = choices[i];\n        stateSize++;\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(target - choices[i], choices, choicesSize, i + 1);\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        stateSize--;\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nvoid subsetSumII(int *nums, int numsSize, int target) {\n    // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    qsort(nums, numsSize, sizeof(int), cmp);\n    // \u5f00\u59cb\u56de\u6eaf\n    backtrack(target, nums, numsSize, 0);\n}\n</code></pre> subset_sum_ii.kt<pre><code>/* \u56de\u6eaf\u7b97\u6cd5\uff1a\u5b50\u96c6\u548c II */\nfun backtrack(\n    state: MutableList&lt;Int&gt;,\n    target: Int,\n    choices: IntArray,\n    start: Int,\n    res: MutableList&lt;MutableList&lt;Int&gt;?&gt;\n) {\n    // \u5b50\u96c6\u548c\u7b49\u4e8e target \u65f6\uff0c\u8bb0\u5f55\u89e3\n    if (target == 0) {\n        res.add(state.toMutableList())\n        return\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    // \u526a\u679d\u4e8c\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u751f\u6210\u91cd\u590d\u5b50\u96c6\n    // \u526a\u679d\u4e09\uff1a\u4ece start \u5f00\u59cb\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u9009\u62e9\u540c\u4e00\u5143\u7d20\n    for (i in start..&lt;choices.size) {\n        // \u526a\u679d\u4e00\uff1a\u82e5\u5b50\u96c6\u548c\u8d85\u8fc7 target \uff0c\u5219\u76f4\u63a5\u7ed3\u675f\u5faa\u73af\n        // \u8fd9\u662f\u56e0\u4e3a\u6570\u7ec4\u5df2\u6392\u5e8f\uff0c\u540e\u8fb9\u5143\u7d20\u66f4\u5927\uff0c\u5b50\u96c6\u548c\u4e00\u5b9a\u8d85\u8fc7 target\n        if (target - choices[i] &lt; 0) {\n            break\n        }\n        // \u526a\u679d\u56db\uff1a\u5982\u679c\u8be5\u5143\u7d20\u4e0e\u5de6\u8fb9\u5143\u7d20\u76f8\u7b49\uff0c\u8bf4\u660e\u8be5\u641c\u7d22\u5206\u652f\u91cd\u590d\uff0c\u76f4\u63a5\u8df3\u8fc7\n        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0 target, start\n        state.add(choices[i])\n        // \u8fdb\u884c\u4e0b\u4e00\u8f6e\u9009\u62e9\n        backtrack(state, target - choices[i], choices, i + 1, res)\n        // \u56de\u9000\uff1a\u64a4\u9500\u9009\u62e9\uff0c\u6062\u590d\u5230\u4e4b\u524d\u7684\u72b6\u6001\n        state.removeAt(state.size - 1)\n    }\n}\n\n/* \u6c42\u89e3\u5b50\u96c6\u548c II */\nfun subsetSumII(nums: IntArray, target: Int): MutableList&lt;MutableList&lt;Int&gt;?&gt; {\n    val state = mutableListOf&lt;Int&gt;() // \u72b6\u6001\uff08\u5b50\u96c6\uff09\n    nums.sort() // \u5bf9 nums \u8fdb\u884c\u6392\u5e8f\n    val start = 0 // \u904d\u5386\u8d77\u59cb\u70b9\n    val res = mutableListOf&lt;MutableList&lt;Int&gt;?&gt;() // \u7ed3\u679c\u5217\u8868\uff08\u5b50\u96c6\u5217\u8868\uff09\n    backtrack(state, target, nums, start, res)\n    return res\n}\n</code></pre> subset_sum_ii.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subset_sum_ii}\n</code></pre> subset_sum_ii.zig<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{subsetSumII}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 13-14 shows the backtracking process for the array \\([4, 4, 5]\\) and target element \\(9\\), including four types of pruning operations. Please combine the illustration with the code comments to understand the entire search process and how each type of pruning operation works.</p> <p></p> <p> Figure 13-14 \u00a0 Subset sum II backtracking process </p>"},{"location":"chapter_backtracking/summary/","title":"13.5 \u00a0 Summary","text":""},{"location":"chapter_backtracking/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>The essence of the backtracking algorithm is an exhaustive search method, where the solution space is traversed deeply first to find solutions that meet the criteria. During the search, if a satisfying solution is found, it is recorded, until all solutions are found or the search is completed.</li> <li>The search process of the backtracking algorithm includes trying and retreating. It uses depth-first search to explore various choices, and when a choice does not meet the constraint conditions, the previous choice is undone, reverting to the previous state, and other options are then continued to be tried. Trying and retreating are operations in opposite directions.</li> <li>Backtracking problems usually contain multiple constraints, which can be used to perform pruning operations. Pruning can terminate unnecessary search branches early, greatly enhancing search efficiency.</li> <li>Backtracking algorithms are mainly used to solve search problems and constraint satisfaction problems. Although combinatorial optimization problems can be solved using backtracking, there are often more efficient or effective solutions available.</li> <li>The permutation problem aims to search for all possible permutations of a given set of elements. We use an array to record whether each element has been chosen, cutting off branches that repeatedly select the same element, ensuring each element is selected only once.</li> <li>In permutation problems, if the set contains duplicate elements, the final result will include duplicate permutations. We need to restrict that identical elements can only be selected once in each round, which is usually implemented using a hash set.</li> <li>The subset-sum problem aims to find all subsets in a given set that sum to a target value. The set does not distinguish the order of elements, but the search process outputs all ordered results, producing duplicate subsets. Before backtracking, we sort the data and set a variable to indicate the starting point of each round of traversal, thereby pruning the search branches that generate duplicate subsets.</li> <li>For the subset-sum problem, equal elements in the array can produce duplicate sets. Using the precondition that the array is already sorted, we prune by determining if adjacent elements are equal, thus ensuring equal elements are only selected once per round.</li> <li>The \\(n\\) queens problem aims to find schemes to place \\(n\\) queens on an \\(n \\times n\\) size chessboard in such a way that no two queens can attack each other. The constraints of the problem include row constraints, column constraints, main diagonal constraints, and secondary diagonal constraints. To meet the row constraint, we adopt a strategy of placing one queen per row, ensuring each row has one queen placed.</li> <li>The handling of column constraints and diagonal constraints is similar. For column constraints, we use an array to record whether there is a queen in each column, thereby indicating whether the selected cell is legal. For diagonal constraints, we use two arrays to respectively record the presence of queens on the main and secondary diagonals; the challenge is in identifying the row and column index patterns that satisfy the same primary (secondary) diagonal.</li> </ul>"},{"location":"chapter_backtracking/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: How can we understand the relationship between backtracking and recursion?</p> <p>Overall, backtracking is a \"strategic algorithm,\" while recursion is more of a \"tool.\"</p> <ul> <li>Backtracking algorithms are typically based on recursion. However, backtracking is one of the application scenarios of recursion, specifically in search problems.</li> <li>The structure of recursion reflects the \"sub-problem decomposition\" problem-solving paradigm, commonly used in solving problems involving divide and conquer, backtracking, and dynamic programming (memoized recursion).</li> </ul>"},{"location":"chapter_computational_complexity/","title":"Chapter 2. \u00a0 Complexity analysis","text":"<p>Abstract</p> <p>Complexity analysis is like a space-time navigator in the vast universe of algorithms.</p> <p>It guides us in exploring deeper within the the dimensions of time and space, seeking more elegant solutions.</p>"},{"location":"chapter_computational_complexity/#chapter-contents","title":"Chapter contents","text":"<ul> <li>2.1 \u00a0 Algorithm efficiency assessment</li> <li>2.2 \u00a0 Iteration and recursion</li> <li>2.3 \u00a0 Time complexity</li> <li>2.4 \u00a0 Space complexity</li> <li>2.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/","title":"2.2 \u00a0 Iteration and recursion","text":"<p>In algorithms, the repeated execution of a task is quite common and is closely related to the analysis of complexity. Therefore, before delving into the concepts of time complexity and space complexity, let's first explore how to implement repetitive tasks in programming. This involves understanding two fundamental programming control structures: iteration and recursion.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#221-iteration","title":"2.2.1 \u00a0 Iteration","text":"<p>Iteration is a control structure for repeatedly performing a task. In iteration, a program repeats a block of code as long as a certain condition is met until this condition is no longer satisfied.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-for-loops","title":"1. \u00a0 For loops","text":"<p>The <code>for</code> loop is one of the most common forms of iteration, and it's particularly suitable when the number of iterations is known in advance.</p> <p>The following function uses a <code>for</code> loop to perform a summation of \\(1 + 2 + \\dots + n\\), with the sum being stored in the variable <code>res</code>. It's important to note that in Python, <code>range(a, b)</code> creates an interval that is inclusive of <code>a</code> but exclusive of <code>b</code>, meaning it iterates over the range from \\(a\\) up to \\(b\u22121\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig iteration.py<pre><code>def for_loop(n: int) -&gt; int:\n    \"\"\"for \u5faa\u73af\"\"\"\n    res = 0\n    # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        res += i\n    return res\n</code></pre> iteration.cpp<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* for \u5faa\u73af */\nint ForLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* for \u5faa\u73af */\nfunc forLoop(n int) int {\n    res := 0\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* for \u5faa\u73af */\nfunc forLoop(n: Int) -&gt; Int {\n    var res = 0\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* for \u5faa\u73af */\nfunction forLoop(n) {\n    let res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* for \u5faa\u73af */\nfunction forLoop(n: number): number {\n    let res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n  int res = 0;\n  // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    res += i;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* for \u5faa\u73af */\nfn for_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i in 1..=n {\n        res += i;\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* for \u5faa\u73af */\nint forLoop(int n) {\n    int res = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        res += i;\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* for \u5faa\u73af */\nfun forLoop(n: Int): Int {\n    var res = 0\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (i in 1..n) {\n        res += i\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### for \u5faa\u73af ###\ndef for_loop(n)\n  res = 0\n\n  # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  for i in 1..n\n    res += i\n  end\n\n  res\nend\n</code></pre> iteration.zig<pre><code>// for \u5faa\u73af\nfn forLoop(n: usize) i32 {\n    var res: i32 = 0;\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for (1..n+1) |i| {\n        res = res + @as(i32, @intCast(i));\n    }\n    return res;\n} \n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The flowchart below represents this sum function.</p> <p></p> <p> Figure 2-1 \u00a0 Flowchart of the sum function </p> <p>The number of operations in this summation function is proportional to the size of the input data \\(n\\), or in other words, it has a linear relationship. This \"linear relationship\" is what time complexity describes. This topic will be discussed in more detail in the next section.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-while-loops","title":"2. \u00a0 While loops","text":"<p>Similar to <code>for</code> loops, <code>while</code> loops are another approach for implementing iteration. In a <code>while</code> loop, the program checks a condition at the beginning of each iteration; if the condition is true, the execution continues, otherwise, the loop ends.</p> <p>Below we use a <code>while</code> loop to implement the sum \\(1 + 2 + \\dots + n\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig iteration.py<pre><code>def while_loop(n: int) -&gt; int:\n    \"\"\"while \u5faa\u73af\"\"\"\n    res = 0\n    i = 1  # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n:\n        res += i\n        i += 1  # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    return res\n</code></pre> iteration.cpp<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while \u5faa\u73af */\nint WhileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i += 1; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while \u5faa\u73af */\nfunc whileLoop(n int) int {\n    res := 0\n    // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    i := 1\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    for i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while \u5faa\u73af */\nfunc whileLoop(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i\n        i += 1 // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while \u5faa\u73af */\nfunction whileLoop(n) {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while \u5faa\u73af */\nfunction whileLoop(n: number): number {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n  int res = 0;\n  int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n  // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  while (i &lt;= n) {\n    res += i;\n    i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while \u5faa\u73af */\nfn while_loop(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while i &lt;= n {\n        res += i;\n        i += 1; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while \u5faa\u73af */\nint whileLoop(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i;\n        i++; // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* while \u5faa\u73af */\nfun whileLoop(n: Int): Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += i\n        i++ // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### while \u5faa\u73af ###\ndef while_loop(n)\n  res = 0\n  i = 1 # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n\n  # \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n  while i &lt;= n\n    res += i\n    i += 1 # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n  end\n\n  res\nend\n</code></pre> iteration.zig<pre><code>// while \u5faa\u73af\nfn whileLoop(n: i32) i32 {\n    var res: i32 = 0;\n    var i: i32 = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 2, ..., n-1, n\n    while (i &lt;= n) {\n        res += @intCast(i);\n        i += 1;\n    }\n    return res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p><code>while</code> loops provide more flexibility than <code>for</code> loops, especially since they allow for custom initialization and modification of the condition variable at each step.</p> <p>For example, in the following code, the condition variable \\(i\\) is updated twice each round, which would be inconvenient to implement with a <code>for</code> loop.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig iteration.py<pre><code>def while_loop_ii(n: int) -&gt; int:\n    \"\"\"while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09\"\"\"\n    res = 0\n    i = 1  # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    # \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n:\n        res += i\n        # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1\n        i *= 2\n    return res\n</code></pre> iteration.cpp<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.java<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.cs<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint WhileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1; \n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.go<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunc whileLoopII(n int) int {\n    res := 0\n    // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    i := 1\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    for i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunc whileLoopII(n: Int) -&gt; Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunction whileLoopII(n) {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfunction whileLoopII(n: number): number {\n    let res = 0;\n    let i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n  int res = 0;\n  int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n  // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n  while (i &lt;= n) {\n    res += i;\n    // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    i++;\n    i *= 2;\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfn while_loop_ii(n: i32) -&gt; i32 {\n    let mut res = 0;\n    let mut i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while i &lt;= n {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1;\n        i *= 2;\n    }\n    res\n}\n</code></pre> iteration.c<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nint whileLoopII(int n) {\n    int res = 0;\n    int i = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i;\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09 */\nfun whileLoopII(n: Int): Int {\n    var res = 0\n    var i = 1 // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += i\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i++\n        i *= 2\n    }\n    return res\n}\n</code></pre> iteration.rb<pre><code>### while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09###\ndef while_loop_ii(n)\n  res = 0\n  i = 1 # \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n\n  # \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n  while i &lt;= n\n    res += i\n    # \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n    i += 1\n    i *= 2\n  end\n\n  res\nend\n</code></pre> iteration.zig<pre><code>//  while \u5faa\u73af\uff08\u4e24\u6b21\u66f4\u65b0\uff09\nfn whileLoopII(n: i32) i32 {\n    var res: i32 = 0;\n    var i: i32 = 1; // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    // \u5faa\u73af\u6c42\u548c 1, 4, 10, ...\n    while (i &lt;= n) {\n        res += @intCast(i);\n        // \u66f4\u65b0\u6761\u4ef6\u53d8\u91cf\n        i += 1;\n        i *= 2;\n    }\n    return res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Overall, <code>for</code> loops are more concise, while <code>while</code> loops are more flexible. Both can implement iterative structures. Which one to use should be determined based on the specific requirements of the problem.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-nested-loops","title":"3. \u00a0 Nested loops","text":"<p>We can nest one loop structure within another. Below is an example using <code>for</code> loops:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig iteration.py<pre><code>def nested_for_loop(n: int) -&gt; str:\n    \"\"\"\u53cc\u5c42 for \u5faa\u73af\"\"\"\n    res = \"\"\n    # \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in range(1, n + 1):\n        # \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in range(1, n + 1):\n            res += f\"({i}, {j}), \"\n    return res\n</code></pre> iteration.cpp<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nstring nestedForLoop(int n) {\n    ostringstream res;\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; ++i) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; ++j) {\n            res &lt;&lt; \"(\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \"), \";\n        }\n    }\n    return res.str();\n}\n</code></pre> iteration.java<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nString nestedForLoop(int n) {\n    StringBuilder res = new StringBuilder();\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.append(\"(\" + i + \", \" + j + \"), \");\n        }\n    }\n    return res.toString();\n}\n</code></pre> iteration.cs<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nstring NestedForLoop(int n) {\n    StringBuilder res = new();\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            res.Append($\"({i}, {j}), \");\n        }\n    }\n    return res.ToString();\n}\n</code></pre> iteration.go<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunc nestedForLoop(n int) string {\n    res := \"\"\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j &lt;= n; j++ {\n            // \u5faa\u73af j = 1, 2, ..., n-1, n\n            res += fmt.Sprintf(\"(%d, %d), \", i, j)\n        }\n    }\n    return res\n}\n</code></pre> iteration.swift<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunc nestedForLoop(n: Int) -&gt; String {\n    var res = \"\"\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in 1 ... n {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in 1 ... n {\n            res.append(\"(\\(i), \\(j)), \")\n        }\n    }\n    return res\n}\n</code></pre> iteration.js<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunction nestedForLoop(n) {\n    let res = '';\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.ts<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfunction nestedForLoop(n: number): string {\n    let res = '';\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (let j = 1; j &lt;= n; j++) {\n            res += `(${i}, ${j}), `;\n        }\n    }\n    return res;\n}\n</code></pre> iteration.dart<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nString nestedForLoop(int n) {\n  String res = \"\";\n  // \u5faa\u73af i = 1, 2, ..., n-1, n\n  for (int i = 1; i &lt;= n; i++) {\n    // \u5faa\u73af j = 1, 2, ..., n-1, n\n    for (int j = 1; j &lt;= n; j++) {\n      res += \"($i, $j), \";\n    }\n  }\n  return res;\n}\n</code></pre> iteration.rs<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfn nested_for_loop(n: i32) -&gt; String {\n    let mut res = vec![];\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for i in 1..=n {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for j in 1..=n {\n            res.push(format!(\"({}, {}), \", i, j));\n        }\n    }\n    res.join(\"\")\n}\n</code></pre> iteration.c<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nchar *nestedForLoop(int n) {\n    // n * n \u4e3a\u5bf9\u5e94\u70b9\u6570\u91cf\uff0c\"(i, j), \" \u5bf9\u5e94\u5b57\u7b26\u4e32\u957f\u6700\u5927\u4e3a 6+10*2\uff0c\u52a0\u4e0a\u6700\u540e\u4e00\u4e2a\u7a7a\u5b57\u7b26 \\0 \u7684\u989d\u5916\u7a7a\u95f4\n    int size = n * n * 26 + 1;\n    char *res = malloc(size * sizeof(char));\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (int j = 1; j &lt;= n; j++) {\n            char tmp[26];\n            snprintf(tmp, sizeof(tmp), \"(%d, %d), \", i, j);\n            strncat(res, tmp, size - strlen(res) - 1);\n        }\n    }\n    return res;\n}\n</code></pre> iteration.kt<pre><code>/* \u53cc\u5c42 for \u5faa\u73af */\nfun nestedForLoop(n: Int): String {\n    val res = StringBuilder()\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (i in 1..n) {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (j in 1..n) {\n            res.append(\" ($i, $j), \")\n        }\n    }\n    return res.toString()\n}\n</code></pre> iteration.rb<pre><code>### \u53cc\u5c42 for \u5faa\u73af ###\ndef nested_for_loop(n)\n  res = \"\"\n\n  # \u5faa\u73af i = 1, 2, ..., n-1, n\n  for i in 1..n\n    # \u5faa\u73af j = 1, 2, ..., n-1, n\n    for j in 1..n\n      res += \"(#{i}, #{j}), \"\n    end\n  end\n\n  res\nend\n</code></pre> iteration.zig<pre><code>// \u53cc\u5c42 for \u5faa\u73af\nfn nestedForLoop(allocator: Allocator, n: usize) ![]const u8 {\n    var res = std.ArrayList(u8).init(allocator);\n    defer res.deinit();\n    var buffer: [20]u8 = undefined;\n    // \u5faa\u73af i = 1, 2, ..., n-1, n\n    for (1..n+1) |i| {\n        // \u5faa\u73af j = 1, 2, ..., n-1, n\n        for (1..n+1) |j| {\n            var _str = try std.fmt.bufPrint(&amp;buffer, \"({d}, {d}), \", .{i, j});\n            try res.appendSlice(_str);\n        }\n    }\n    return res.toOwnedSlice();\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The flowchart below represents this nested loop.</p> <p></p> <p> Figure 2-2 \u00a0 Flowchart of the nested loop </p> <p>In such cases, the number of operations of the function is proportional to \\(n^2\\), meaning the algorithm's runtime and the size of the input data \\(n\\) has a 'quadratic relationship.'</p> <p>We can further increase the complexity by adding more nested loops, each level of nesting effectively \"increasing the dimension,\" which raises the time complexity to \"cubic,\" \"quartic,\" and so on.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#222-recursion","title":"2.2.2 \u00a0 Recursion","text":"<p>Recursion is an algorithmic strategy where a function solves a problem by calling itself. It primarily involves two phases:</p> <ol> <li>Calling: This is where the program repeatedly calls itself, often with progressively smaller or simpler arguments, moving towards the \"termination condition.\"</li> <li>Returning: Upon triggering the \"termination condition,\" the program begins to return from the deepest recursive function, aggregating the results of each layer.</li> </ol> <p>From an implementation perspective, recursive code mainly includes three elements.</p> <ol> <li>Termination Condition: Determines when to switch from \"calling\" to \"returning.\"</li> <li>Recursive Call: Corresponds to \"calling,\" where the function calls itself, usually with smaller or more simplified parameters.</li> <li>Return Result: Corresponds to \"returning,\" where the result of the current recursion level is returned to the previous layer.</li> </ol> <p>Observe the following code, where simply calling the function <code>recur(n)</code> can compute the sum of \\(1 + 2 + \\dots + n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig recursion.py<pre><code>def recur(n: int) -&gt; int:\n    \"\"\"\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6\n    if n == 1:\n        return 1\n    # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    res = recur(n - 1)\n    # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n</code></pre> recursion.cpp<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.java<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.cs<pre><code>/* \u9012\u5f52 */\nint Recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = Recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.go<pre><code>/* \u9012\u5f52 */\nfunc recur(n int) int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    res := recur(n - 1)\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n}\n</code></pre> recursion.swift<pre><code>/* \u9012\u5f52 */\nfunc recur(n: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    let res = recur(n: n - 1)\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res\n}\n</code></pre> recursion.js<pre><code>/* \u9012\u5f52 */\nfunction recur(n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 1) return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    const res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.ts<pre><code>/* \u9012\u5f52 */\nfunction recur(n: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 1) return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    const res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.dart<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n  // \u7ec8\u6b62\u6761\u4ef6\n  if (n == 1) return 1;\n  // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  int res = recur(n - 1);\n  // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  return n + res;\n}\n</code></pre> recursion.rs<pre><code>/* \u9012\u5f52 */\nfn recur(n: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 1 {\n        return 1;\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    let res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    n + res\n}\n</code></pre> recursion.c<pre><code>/* \u9012\u5f52 */\nint recur(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    int res = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> recursion.kt<pre><code>/* \u9012\u5f52 */\nfun recur(n: Int): Int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1)\n        return 1\n    // \u9012: \u9012\u5f52\u8c03\u7528\n    val res = recur(n - 1)\n    // \u5f52: \u8fd4\u56de\u7ed3\u679c\n    return n + res\n}\n</code></pre> recursion.rb<pre><code>### \u9012\u5f52 ###\ndef recur(n)\n  # \u7ec8\u6b62\u6761\u4ef6\n  return 1 if n == 1\n  # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  res = recur(n - 1)\n  # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  n + res\nend\n</code></pre> recursion.zig<pre><code>// \u9012\u5f52\u51fd\u6570\nfn recur(n: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 1) {\n        return 1;\n    }\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    var res: i32 = recur(n - 1);\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    return n + res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 2-3 shows the recursive process of this function.</p> <p></p> <p> Figure 2-3 \u00a0 Recursive process of the sum function </p> <p>Although iteration and recursion can achieve the same results from a computational standpoint, they represent two entirely different paradigms of thinking and problem-solving.</p> <ul> <li>Iteration: Solves problems \"from the bottom up.\" It starts with the most basic steps, and then repeatedly adds or accumulates these steps until the task is complete.</li> <li>Recursion: Solves problems \"from the top down.\" It breaks down the original problem into smaller sub-problems, each of which has the same form as the original problem. These sub-problems are then further decomposed into even smaller sub-problems, stopping at the base case whose solution is known.</li> </ul> <p>Let's take the earlier example of the summation function, defined as \\(f(n) = 1 + 2 + \\dots + n\\).</p> <ul> <li>Iteration: In this approach, we simulate the summation process within a loop. Starting from \\(1\\) and traversing to \\(n\\), we perform the summation operation in each iteration to eventually compute \\(f(n)\\).</li> <li>Recursion: Here, the problem is broken down into a sub-problem: \\(f(n) = n + f(n-1)\\). This decomposition continues recursively until reaching the base case, \\(f(1) = 1\\), at which point the recursion terminates.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#1-call-stack","title":"1. \u00a0 Call stack","text":"<p>Every time a recursive function calls itself, the system allocates memory for the newly initiated function to store local variables, the return address, and other relevant information. This leads to two primary outcomes.</p> <ul> <li>The function's context data is stored in a memory area called \"stack frame space\" and is only released after the function returns. Therefore, recursion generally consumes more memory space than iteration.</li> <li>Recursive calls introduce additional overhead. Hence, recursion is usually less time-efficient than loops.</li> </ul> <p>As shown in Figure 2-4, there are \\(n\\) unreturned recursive functions before triggering the termination condition, indicating a recursion depth of \\(n\\).</p> <p></p> <p> Figure 2-4 \u00a0 Recursion call depth </p> <p>In practice, the depth of recursion allowed by programming languages is usually limited, and excessively deep recursion can lead to stack overflow errors.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#2-tail-recursion","title":"2. \u00a0 Tail recursion","text":"<p>Interestingly, if a function performs its recursive call as the very last step before returning, it can be optimized by the compiler or interpreter to be as space-efficient as iteration. This scenario is known as tail recursion.</p> <ul> <li>Regular recursion: In standard recursion, when the function returns to the previous level, it continues to execute more code, requiring the system to save the context of the previous call.</li> <li>Tail recursion: Here, the recursive call is the final operation before the function returns. This means that upon returning to the previous level, no further actions are needed, so the system does not need to save the context of the previous level.</li> </ul> <p>For example, in calculating \\(1 + 2 + \\dots + n\\), we can make the result variable <code>res</code> a parameter of the function, thereby achieving tail recursion:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig recursion.py<pre><code>def tail_recur(n, res):\n    \"\"\"\u5c3e\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6\n    if n == 0:\n        return res\n    # \u5c3e\u9012\u5f52\u8c03\u7528\n    return tail_recur(n - 1, res + n)\n</code></pre> recursion.cpp<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.java<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.cs<pre><code>/* \u5c3e\u9012\u5f52 */\nint TailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return TailRecur(n - 1, res + n);\n}\n</code></pre> recursion.go<pre><code>/* \u5c3e\u9012\u5f52 */\nfunc tailRecur(n int, res int) int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n-1, res+n)\n}\n</code></pre> recursion.swift<pre><code>/* \u5c3e\u9012\u5f52 */\nfunc tailRecur(n: Int, res: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n: n - 1, res: res + n)\n}\n</code></pre> recursion.js<pre><code>/* \u5c3e\u9012\u5f52 */\nfunction tailRecur(n, res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 0) return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.ts<pre><code>/* \u5c3e\u9012\u5f52 */\nfunction tailRecur(n: number, res: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n === 0) return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.dart<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n  // \u7ec8\u6b62\u6761\u4ef6\n  if (n == 0) return res;\n  // \u5c3e\u9012\u5f52\u8c03\u7528\n  return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.rs<pre><code>/* \u5c3e\u9012\u5f52 */\nfn tail_recur(n: i32, res: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if n == 0 {\n        return res;\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    tail_recur(n - 1, res + n)\n}\n</code></pre> recursion.c<pre><code>/* \u5c3e\u9012\u5f52 */\nint tailRecur(int n, int res) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res;\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> recursion.kt<pre><code>/* \u5c3e\u9012\u5f52 */\ntailrec fun tailRecur(n: Int, res: Int): Int {\n    // \u6dfb\u52a0 tailrec \u5173\u952e\u8bcd\uff0c\u4ee5\u5f00\u542f\u5c3e\u9012\u5f52\u4f18\u5316\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0)\n        return res\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n)\n}\n</code></pre> recursion.rb<pre><code>### \u5c3e\u9012\u5f52 ###\ndef tail_recur(n, res)\n  # \u7ec8\u6b62\u6761\u4ef6\n  return res if n == 0\n  # \u5c3e\u9012\u5f52\u8c03\u7528\n  tail_recur(n - 1, res + n)\nend\n</code></pre> recursion.zig<pre><code>// \u5c3e\u9012\u5f52\u51fd\u6570\nfn tailRecur(n: i32, res: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (n == 0) {\n        return res;\n    }\n    // \u5c3e\u9012\u5f52\u8c03\u7528\n    return tailRecur(n - 1, res + n);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The execution process of tail recursion is shown in Figure 2-5. Comparing regular recursion and tail recursion, the point of the summation operation is different.</p> <ul> <li>Regular recursion: The summation operation occurs during the \"returning\" phase, requiring another summation after each layer returns.</li> <li>Tail recursion: The summation operation occurs during the \"calling\" phase, and the \"returning\" phase only involves returning through each layer.</li> </ul> <p></p> <p> Figure 2-5 \u00a0 Tail recursion process </p> <p>Tip</p> <p>Note that many compilers or interpreters do not support tail recursion optimization. For example, Python does not support tail recursion optimization by default, so even if the function is in the form of tail recursion, it may still encounter stack overflow issues.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#3-recursion-tree","title":"3. \u00a0 Recursion tree","text":"<p>When dealing with algorithms related to \"divide and conquer\", recursion often offers a more intuitive approach and more readable code than iteration. Take the \"Fibonacci sequence\" as an example.</p> <p>Question</p> <p>Given a Fibonacci sequence \\(0, 1, 1, 2, 3, 5, 8, 13, \\dots\\), find the \\(n\\)th number in the sequence.</p> <p>Let the \\(n\\)th number of the Fibonacci sequence be \\(f(n)\\), it's easy to deduce two conclusions:</p> <ul> <li>The first two numbers of the sequence are \\(f(1) = 0\\) and \\(f(2) = 1\\).</li> <li>Each number in the sequence is the sum of the two preceding ones, that is, \\(f(n) = f(n - 1) + f(n - 2)\\).</li> </ul> <p>Using the recursive relation, and considering the first two numbers as termination conditions, we can write the recursive code. Calling <code>fib(n)</code> will yield the \\(n\\)th number of the Fibonacci sequence:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig recursion.py<pre><code>def fib(n: int) -&gt; int:\n    \"\"\"\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 or n == 2:\n        return n - 1\n    # \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    res = fib(n - 1) + fib(n - 2)\n    # \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n</code></pre> recursion.cpp<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint Fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = Fib(n - 1) + Fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunc fib(n int) int {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    res := fib(n-1) + fib(n-2)\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunc fib(n: Int) -&gt; Int {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    let res = fib(n: n - 1) + fib(n: n - 2)\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n}\n</code></pre> recursion.js<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunction fib(n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfunction fib(n: number): number {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n === 1 || n === 2) return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    const res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n  // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n  if (n == 1 || n == 2) return n - 1;\n  // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n  int res = fib(n - 1) + fib(n - 2);\n  // \u8fd4\u56de\u7ed3\u679c f(n)\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfn fib(n: i32) -&gt; i32 {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if n == 1 || n == 2 {\n        return n - 1;\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    let res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c\n    res\n}\n</code></pre> recursion.c<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nint fib(int n) {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1;\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    int res = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> recursion.kt<pre><code>/* \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 */\nfun fib(n: Int): Int {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 || n == 2)\n        return n - 1\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    val res = fib(n - 1) + fib(n - 2)\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res\n}\n</code></pre> recursion.rb<pre><code>### \u6590\u6ce2\u90a3\u5951\u6570\u5217\uff1a\u9012\u5f52 ###\ndef fib(n)\n  # \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n  return n - 1 if n == 1 || n == 2\n  # \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n  res = fib(n - 1) + fib(n - 2)\n  # \u8fd4\u56de\u7ed3\u679c f(n)\n  res\nend\n</code></pre> recursion.zig<pre><code>// \u6590\u6ce2\u90a3\u5951\u6570\u5217\nfn fib(n: i32) i32 {\n    // \u7ec8\u6b62\u6761\u4ef6 f(1) = 0, f(2) = 1\n    if (n == 1 or n == 2) {\n        return n - 1;\n    }\n    // \u9012\u5f52\u8c03\u7528 f(n) = f(n-1) + f(n-2)\n    var res: i32 = fib(n - 1) + fib(n - 2);\n    // \u8fd4\u56de\u7ed3\u679c f(n)\n    return res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Observing the above code, we see that it recursively calls two functions within itself, meaning that one call generates two branching calls. As illustrated below, this continuous recursive calling eventually creates a recursion tree with a depth of \\(n\\).</p> <p></p> <p> Figure 2-6 \u00a0 Fibonacci sequence recursion tree </p> <p>Fundamentally, recursion embodies the paradigm of \"breaking down a problem into smaller sub-problems.\" This divide-and-conquer strategy is crucial.</p> <ul> <li>From an algorithmic perspective, many important strategies like searching, sorting, backtracking, divide-and-conquer, and dynamic programming directly or indirectly use this way of thinking.</li> <li>From a data structure perspective, recursion is naturally suited for dealing with linked lists, trees, and graphs, as they are well suited for analysis using the divide-and-conquer approach.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#223-comparison","title":"2.2.3 \u00a0 Comparison","text":"<p>Summarizing the above content, the following table shows the differences between iteration and recursion in terms of implementation, performance, and applicability.</p> <p> Table: Comparison of iteration and recursion characteristics </p> Iteration Recursion Approach Loop structure Function calls itself Time Efficiency Generally higher efficiency, no function call overhead Each function call generates overhead Memory Usage Typically uses a fixed size of memory space Accumulative function calls can use a substantial amount of stack frame space Suitable Problems Suitable for simple loop tasks, intuitive and readable code Suitable for problem decomposition, like trees, graphs, divide-and-conquer, backtracking, etc., concise and clear code structure <p>Tip</p> <p>If you find the following content difficult to understand, consider revisiting it after reading the \"Stack\" chapter.</p> <p>So, what is the intrinsic connection between iteration and recursion? Taking the above recursive function as an example, the summation operation occurs during the recursion's \"return\" phase. This means that the initially called function is the last to complete its summation operation, mirroring the \"last in, first out\" principle of a stack.</p> <p>Recursive terms like \"call stack\" and \"stack frame space\" hint at the close relationship between recursion and stacks.</p> <ol> <li>Calling: When a function is called, the system allocates a new stack frame on the \"call stack\" for that function, storing local variables, parameters, return addresses, and other data.</li> <li>Returning: When a function completes execution and returns, the corresponding stack frame is removed from the \"call stack,\" restoring the execution environment of the previous function.</li> </ol> <p>Therefore, we can use an explicit stack to simulate the behavior of the call stack, thus transforming recursion into an iterative form:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig recursion.py<pre><code>def for_loop_recur(n: int) -&gt; int:\n    \"\"\"\u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52\"\"\"\n    # \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack = []\n    res = 0\n    # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in range(n, 0, -1):\n        # \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.append(i)\n    # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while stack:\n        # \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop()\n    # res = 1+2+3+...+n\n    return res\n</code></pre> recursion.cpp<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack&lt;int&gt; stack;\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (!stack.empty()) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.top();\n        stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.java<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (!stack.isEmpty()) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.cs<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint ForLoopRecur(int n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    Stack&lt;int&gt; stack = new();\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.Push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.Count &gt; 0) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.Pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.go<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunc forLoopRecur(n int) int {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    stack := list.New()\n    res := 0\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i := n; i &gt; 0; i-- {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.PushBack(i)\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    for stack.Len() != 0 {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.Back().Value.(int)\n        stack.Remove(stack.Back())\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.swift<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunc forLoopRecur(n: Int) -&gt; Int {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    var stack: [Int] = []\n    var res = 0\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in (1 ... n).reversed() {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.append(i)\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while !stack.isEmpty {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.removeLast()\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.js<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunction forLoopRecur(n) {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    const stack = [];\n    let res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (let i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.length) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.ts<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfunction forLoopRecur(n: number): number {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808 \n    const stack: number[] = [];\n    let res: number = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (let i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (stack.length) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop();\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.dart<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n  // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n  List&lt;int&gt; stack = [];\n  int res = 0;\n  // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  for (int i = n; i &gt; 0; i--) {\n    // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n    stack.add(i);\n  }\n  // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  while (!stack.isEmpty) {\n    // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n    res += stack.removeLast();\n  }\n  // res = 1+2+3+...+n\n  return res;\n}\n</code></pre> recursion.rs<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfn for_loop_recur(n: i32) -&gt; i32 {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    let mut stack = Vec::new();\n    let mut res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for i in (1..=n).rev() {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i);\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while !stack.is_empty() {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop().unwrap();\n    }\n    // res = 1+2+3+...+n\n    res\n}\n</code></pre> recursion.c<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nint forLoopRecur(int n) {\n    int stack[1000]; // \u501f\u52a9\u4e00\u4e2a\u5927\u6570\u7ec4\u6765\u6a21\u62df\u6808\n    int top = -1;    // \u6808\u9876\u7d22\u5f15\n    int res = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    for (int i = n; i &gt; 0; i--) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack[1 + top++] = i;\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    while (top &gt;= 0) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack[top--];\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> recursion.kt<pre><code>/* \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 */\nfun forLoopRecur(n: Int): Int {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    val stack = Stack&lt;Int&gt;()\n    var res = 0\n    // \u9012: \u9012\u5f52\u8c03\u7528\n    for (i in n downTo 0) {\n        // \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n        stack.push(i)\n    }\n    // \u5f52: \u8fd4\u56de\u7ed3\u679c\n    while (stack.isNotEmpty()) {\n        // \u901a\u8fc7\u201c\u51fa\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u5f52\u201d\n        res += stack.pop()\n    }\n    // res = 1+2+3+...+n\n    return res\n}\n</code></pre> recursion.rb<pre><code>### \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52 ###\ndef for_loop_recur(n)\n  # \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n  stack = []\n  res = 0\n\n  # \u9012\uff1a\u9012\u5f52\u8c03\u7528\n  for i in n.downto(0)\n    # \u901a\u8fc7\u201c\u5165\u6808\u64cd\u4f5c\u201d\u6a21\u62df\u201c\u9012\u201d\n    stack &lt;&lt; i\n  end\n  # \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n  while !stack.empty?\n    res += stack.pop\n  end\n\n  # res = 1+2+3+...+n\n  res\nend\n</code></pre> recursion.zig<pre><code>// \u4f7f\u7528\u8fed\u4ee3\u6a21\u62df\u9012\u5f52\nfn forLoopRecur(comptime n: i32) i32 {\n    // \u4f7f\u7528\u4e00\u4e2a\u663e\u5f0f\u7684\u6808\u6765\u6a21\u62df\u7cfb\u7edf\u8c03\u7528\u6808\n    var stack: [n]i32 = undefined;\n    var res: i32 = 0;\n    // \u9012\uff1a\u9012\u5f52\u8c03\u7528\n    var i: usize = n;\n    while (i &gt; 0) {\n        stack[i - 1] = @intCast(i);\n        i -= 1;\n    }\n    // \u5f52\uff1a\u8fd4\u56de\u7ed3\u679c\n    var index: usize = n;\n    while (index &gt; 0) {\n        index -= 1;\n        res += stack[index];\n    }\n    // res = 1+2+3+...+n\n    return res;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Observing the above code, when recursion is transformed into iteration, the code becomes more complex. Although iteration and recursion can often be transformed into each other, it's not always advisable to do so for two reasons:</p> <ul> <li>The transformed code may become more challenging to understand and less readable.</li> <li>For some complex problems, simulating the behavior of the system's call stack can be quite challenging.</li> </ul> <p>In conclusion, whether to choose iteration or recursion depends on the specific nature of the problem. In programming practice, it's crucial to weigh the pros and cons of both and choose the most suitable approach for the situation at hand.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/","title":"2.1 \u00a0 Algorithm efficiency assessment","text":"<p>In algorithm design, we pursue the following two objectives in sequence.</p> <ol> <li>Finding a Solution to the Problem: The algorithm should reliably find the correct solution within the stipulated range of inputs.</li> <li>Seeking the Optimal Solution: For the same problem, multiple solutions might exist, and we aim to find the most efficient algorithm possible.</li> </ol> <p>In other words, under the premise of being able to solve the problem, algorithm efficiency has become the main criterion for evaluating the merits of an algorithm, which includes the following two dimensions.</p> <ul> <li>Time efficiency: The speed at which an algorithm runs.</li> <li>Space efficiency: The size of the memory space occupied by an algorithm.</li> </ul> <p>In short, our goal is to design data structures and algorithms that are both fast and memory-efficient. Effectively assessing algorithm efficiency is crucial because only then can we compare various algorithms and guide the process of algorithm design and optimization.</p> <p>There are mainly two methods of efficiency assessment: actual testing and theoretical estimation.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#211-actual-testing","title":"2.1.1 \u00a0 Actual testing","text":"<p>Suppose we have algorithms <code>A</code> and <code>B</code>, both capable of solving the same problem, and we need to compare their efficiencies. The most direct method is to use a computer to run these two algorithms and monitor and record their runtime and memory usage. This assessment method reflects the actual situation but has significant limitations.</p> <p>On one hand, it's difficult to eliminate interference from the testing environment. Hardware configurations can affect algorithm performance. For example, algorithm <code>A</code> might run faster than <code>B</code> on one computer, but the opposite result may occur on another computer with different configurations. This means we would need to test on a variety of machines to calculate average efficiency, which is impractical.</p> <p>On the other hand, conducting a full test is very resource-intensive. As the volume of input data changes, the efficiency of the algorithms may vary. For example, with smaller data volumes, algorithm <code>A</code> might run faster than <code>B</code>, but the opposite might be true with larger data volumes. Therefore, to draw convincing conclusions, we need to test a wide range of input data sizes, which requires significant computational resources.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#212-theoretical-estimation","title":"2.1.2 \u00a0 Theoretical estimation","text":"<p>Due to the significant limitations of actual testing, we can consider evaluating algorithm efficiency solely through calculations. This estimation method is known as asymptotic complexity analysis, or simply complexity analysis.</p> <p>Complexity analysis reflects the relationship between the time and space resources required for algorithm execution and the size of the input data. It describes the trend of growth in the time and space required by the algorithm as the size of the input data increases. This definition might sound complex, but we can break it down into three key points to understand it better.</p> <ul> <li>\"Time and space resources\" correspond to time complexity and space complexity, respectively.</li> <li>\"As the size of input data increases\" means that complexity reflects the relationship between algorithm efficiency and the volume of input data.</li> <li>\"The trend of growth in time and space\" indicates that complexity analysis focuses not on the specific values of runtime or space occupied but on the \"rate\" at which time or space grows.</li> </ul> <p>Complexity analysis overcomes the disadvantages of actual testing methods, reflected in the following aspects:</p> <ul> <li>It is independent of the testing environment and applicable to all operating platforms.</li> <li>It can reflect algorithm efficiency under different data volumes, especially in the performance of algorithms with large data volumes.</li> </ul> <p>Tip</p> <p>If you're still confused about the concept of complexity, don't worry. We will introduce it in detail in subsequent chapters.</p> <p>Complexity analysis provides us with a \"ruler\" to measure the time and space resources needed to execute an algorithm and compare the efficiency between different algorithms.</p> <p>Complexity is a mathematical concept and may be abstract and challenging for beginners. From this perspective, complexity analysis might not be the best content to introduce first. However, when discussing the characteristics of a particular data structure or algorithm, it's hard to avoid analyzing its speed and space usage.</p> <p>In summary, it's recommended that you establish a preliminary understanding of complexity analysis before diving deep into data structures and algorithms, so that you can carry out simple complexity analyses of algorithms.</p>"},{"location":"chapter_computational_complexity/space_complexity/","title":"2.4 \u00a0 Space complexity","text":"<p>Space complexity is used to measure the growth trend of the memory space occupied by an algorithm as the amount of data increases. This concept is very similar to time complexity, except that \"running time\" is replaced with \"occupied memory space\".</p>"},{"location":"chapter_computational_complexity/space_complexity/#241-space-related-to-algorithms","title":"2.4.1 \u00a0 Space related to algorithms","text":"<p>The memory space used by an algorithm during its execution mainly includes the following types.</p> <ul> <li>Input space: Used to store the input data of the algorithm.</li> <li>Temporary space: Used to store variables, objects, function contexts, and other data during the algorithm's execution.</li> <li>Output space: Used to store the output data of the algorithm.</li> </ul> <p>Generally, the scope of space complexity statistics includes both \"Temporary Space\" and \"Output Space\".</p> <p>Temporary space can be further divided into three parts.</p> <ul> <li>Temporary data: Used to save various constants, variables, objects, etc., during the algorithm's execution.</li> <li>Stack frame space: Used to save the context data of the called function. The system creates a stack frame at the top of the stack each time a function is called, and the stack frame space is released after the function returns.</li> <li>Instruction space: Used to store compiled program instructions, which are usually negligible in actual statistics.</li> </ul> <p>When analyzing the space complexity of a program, we typically count the Temporary Data, Stack Frame Space, and Output Data, as shown in Figure 2-15.</p> <p></p> <p> Figure 2-15 \u00a0 Space types used in algorithms </p> <p>The relevant code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class Node:\n    \"\"\"Classes\"\"\"\n    def __init__(self, x: int):\n        self.val: int = x               # node value\n        self.next: Node | None = None   # reference to the next node\n\ndef function() -&gt; int:\n    \"\"\"Functions\"\"\"\n    # Perform certain operations...\n    return 0\n\ndef algorithm(n) -&gt; int:    # input data\n    A = 0                   # temporary data (constant, usually in uppercase)\n    b = 0                   # temporary data (variable)\n    node = Node(0)          # temporary data (object)\n    c = function()          # Stack frame space (call function)\n    return A + b + c        # output data\n</code></pre> <pre><code>/* Structures */\nstruct Node {\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) {}\n};\n\n/* Functions */\nint func() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {          // input data\n    const int a = 0;            // temporary data (constant)\n    int b = 0;                  // temporary data (variable)\n    Node* node = new Node(0);   // temporary data (object)\n    int c = func();             // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* Functions */\nint function() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {          // input data\n    final int a = 0;            // temporary data (constant)\n    int b = 0;                  // temporary data (variable)\n    Node node = new Node(0);    // temporary data (object)\n    int c = function();         // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* Functions */\nint Function() {\n    // Perform certain operations...\n    return 0;\n}\n\nint Algorithm(int n) {  // input data\n    const int a = 0;    // temporary data (constant)\n    int b = 0;          // temporary data (variable)\n    Node node = new(0); // temporary data (object)\n    int c = Function(); // stack frame space (call function)\n    return a + b + c;   // output data\n}\n</code></pre> <pre><code>/* Structures */\ntype node struct {\n    val  int\n    next *node\n}\n\n/* Create node structure */\nfunc newNode(val int) *node {\n    return &amp;node{val: val}\n}\n\n/* Functions */\nfunc function() int {\n    // Perform certain operations...\n    return 0\n}\n\nfunc algorithm(n int) int { // input data\n    const a = 0             // temporary data (constant)\n    b := 0                  // temporary storage of data (variable)\n    newNode(0)              // temporary data (object)\n    c := function()         // stack frame space (call function)\n    return a + b + c        // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    var val: Int\n    var next: Node?\n\n    init(x: Int) {\n        val = x\n    }\n}\n\n/* Functions */\nfunc function() -&gt; Int {\n    // Perform certain operations...\n    return 0\n}\n\nfunc algorithm(n: Int) -&gt; Int { // input data\n    let a = 0                   // temporary data (constant)\n    var b = 0                   // temporary data (variable)\n    let node = Node(x: 0)       // temporary data (object)\n    let c = function()          // stack frame space (call function)\n    return a + b + c            // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // node value\n        this.next = null;                       // reference to the next node\n    }\n}\n\n/* Functions */\nfunction constFunc() {\n    // Perform certain operations\n    return 0;\n}\n\nfunction algorithm(n) {         // input data\n    const a = 0;                // temporary data (constant)\n    let b = 0;                  // temporary data (variable)\n    const node = new Node(0);   // temporary data (object)\n    const c = constFunc();      // Stack frame space (calling function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n    val: number;\n    next: Node | null;\n    constructor(val?: number) {\n        this.val = val === undefined ? 0 : val; // node value\n        this.next = null;                       // reference to the next node\n    }\n}\n\n/* Functions */\nfunction constFunc(): number {\n    // Perform certain operations\n    return 0;\n}\n\nfunction algorithm(n: number): number { // input data\n    const a = 0;                        // temporary data (constant)\n    let b = 0;                          // temporary data (variable)\n    const node = new Node(0);           // temporary data (object)\n    const c = constFunc();              // Stack frame space (calling function)\n    return a + b + c;                   // output data\n}\n</code></pre> <pre><code>/* Classes */\nclass Node {\n  int val;\n  Node next;\n  Node(this.val, [this.next]);\n}\n\n/* Functions */\nint function() {\n  // Perform certain operations...\n  return 0;\n}\n\nint algorithm(int n) {  // input data\n  const int a = 0;      // temporary data (constant)\n  int b = 0;            // temporary data (variable)\n  Node node = Node(0);  // temporary data (object)\n  int c = function();   // stack frame space (call function)\n  return a + b + c;     // output data\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Structures */\nstruct Node {\n    val: i32,\n    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\n/* Constructor */\nimpl Node {\n    fn new(val: i32) -&gt; Self {\n        Self { val: val, next: None }\n    }\n}\n\n/* Functions */\nfn function() -&gt; i32 {     \n    // Perform certain operations...\n    return 0;\n}\n\nfn algorithm(n: i32) -&gt; i32 {   // input data\n    const a: i32 = 0;           // temporary data (constant)\n    let mut b = 0;              // temporary data (variable)\n    let node = Node::new(0);    // temporary data (object)\n    let c = function();         // stack frame space (call function)\n    return a + b + c;           // output data\n}\n</code></pre> <pre><code>/* Functions */\nint func() {\n    // Perform certain operations...\n    return 0;\n}\n\nint algorithm(int n) {  // input data\n    const int a = 0;    // temporary data (constant)\n    int b = 0;          // temporary data (variable)\n    int c = func();     // stack frame space (call function)\n    return a + b + c;   // output data\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#242-calculation-method","title":"2.4.2 \u00a0 Calculation method","text":"<p>The method for calculating space complexity is roughly similar to that of time complexity, with the only change being the shift of the statistical object from \"number of operations\" to \"size of used space\".</p> <p>However, unlike time complexity, we usually only focus on the worst-case space complexity. This is because memory space is a hard requirement, and we must ensure that there is enough memory space reserved under all input data.</p> <p>Consider the following code, the term \"worst-case\" in worst-case space complexity has two meanings.</p> <ol> <li>Based on the worst input data: When \\(n &lt; 10\\), the space complexity is \\(O(1)\\); but when \\(n &gt; 10\\), the initialized array <code>nums</code> occupies \\(O(n)\\) space, thus the worst-case space complexity is \\(O(n)\\).</li> <li>Based on the peak memory used during the algorithm's execution: For example, before executing the last line, the program occupies \\(O(1)\\) space; when initializing the array <code>nums</code>, the program occupies \\(O(n)\\) space, hence the worst-case space complexity is \\(O(n)\\).</li> </ol> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 0               # O(1)\n    b = [0] * 10000     # O(1)\n    if n &gt; 10:\n        nums = [0] * n  # O(n)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    vector&lt;int&gt; b(10000);    // O(1)\n    if (n &gt; 10)\n        vector&lt;int&gt; nums(n); // O(n)\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10)\n        int[] nums = new int[n]; // O(n)\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10) {\n        int[] nums = new int[n]; // O(n)\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 0                      // O(1)\n    b := make([]int, 10000)     // O(1)\n    var nums []int\n    if n &gt; 10 {\n        nums := make([]int, n)  // O(n)\n    }\n    fmt.Println(a, b, nums)\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    let a = 0 // O(1)\n    let b = Array(repeating: 0, count: 10000) // O(1)\n    if n &gt; 10 {\n        let nums = Array(repeating: 0, count: n) // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 0;                            // O(1)\n  List&lt;int&gt; b = List.filled(10000, 0);  // O(1)\n  if (n &gt; 10) {\n    List&lt;int&gt; nums = List.filled(n, 0); // O(n)\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let a = 0;                           // O(1)\n    let b = [0; 10000];                  // O(1)\n    if n &gt; 10 {\n        let nums = vec![0; n as usize];  // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    int b[10000];            // O(1)\n    if (n &gt; 10)\n        int nums[n] = {0};   // O(n)\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>In recursive functions, stack frame space must be taken into count. Consider the following code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def function() -&gt; int:\n    # Perform certain operations\n    return 0\n\ndef loop(n: int):\n    \"\"\"Loop O(1)\"\"\"\n    for _ in range(n):\n        function()\n\ndef recur(n: int):\n    \"\"\"Recursion O(n)\"\"\"\n    if n == 1:\n        return\n    return recur(n - 1)\n</code></pre> <pre><code>int func() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int Function() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid Loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n/* Recursion O(n) */\nint Recur(int n) {\n    if (n == 1) return 1;\n    return Recur(n - 1);\n}\n</code></pre> <pre><code>func function() int {\n    // Perform certain operations\n    return 0\n}\n\n/* Cycle O(1) */\nfunc loop(n int) {\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n}\n\n/* Recursion O(n) */\nfunc recur(n int) {\n    if n == 1 {\n        return\n    }\n    recur(n - 1)\n}\n</code></pre> <pre><code>@discardableResult\nfunc function() -&gt; Int {\n    // Perform certain operations\n    return 0\n}\n\n/* Cycle O(1) */\nfunc loop(n: Int) {\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n\n/* Recursion O(n) */\nfunc recur(n: Int) {\n    if n == 1 {\n        return\n    }\n    recur(n: n - 1)\n}\n</code></pre> <pre><code>function constFunc() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfunction loop(n) {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion O(n) */\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>function constFunc(): number {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfunction loop(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* Recursion O(n) */\nfunction recur(n: number): void {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n  // Perform certain operations\n  return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n  if (n == 1) return;\n  return recur(n - 1);\n}\n</code></pre> <pre><code>fn function() -&gt; i32 {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nfn loop(n: i32) {\n    for i in 0..n {\n        function();\n    }\n}\n/* Recursion O(n) */\nvoid recur(n: i32) {\n    if n == 1 {\n        return;\n    }\n    recur(n - 1);\n}\n</code></pre> <pre><code>int func() {\n    // Perform certain operations\n    return 0;\n}\n/* Cycle O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* Recursion O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>The time complexity of both <code>loop()</code> and <code>recur()</code> functions is \\(O(n)\\), but their space complexities differ.</p> <ul> <li>The <code>loop()</code> function calls <code>function()</code> \\(n\\) times in a loop, where each iteration's <code>function()</code> returns and releases its stack frame space, so the space complexity remains \\(O(1)\\).</li> <li>The recursive function <code>recur()</code> will have \\(n\\) instances of unreturned <code>recur()</code> existing simultaneously during its execution, thus occupying \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_computational_complexity/space_complexity/#243-common-types","title":"2.4.3 \u00a0 Common types","text":"<p>Let the size of the input data be \\(n\\), the following chart displays common types of space complexities (arranged from low to high).</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n^2) &lt; O(2^n) \\newline \\text{Constant Order} &lt; \\text{Logarithmic Order} &lt; \\text{Linear Order} &lt; \\text{Quadratic Order} &lt; \\text{Exponential Order} \\end{aligned} \\] <p></p> <p> Figure 2-16 \u00a0 Common types of space complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant order \\(O(1)\\)","text":"<p>Constant order is common in constants, variables, objects that are independent of the size of input data \\(n\\).</p> <p>Note that memory occupied by initializing variables or calling functions in a loop, which is released upon entering the next cycle, does not accumulate over space, thus the space complexity remains \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def function() -&gt; int:\n    \"\"\"\u51fd\u6570\"\"\"\n    # \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0\n\ndef constant(n: int):\n    \"\"\"\u5e38\u6570\u9636\"\"\"\n    # \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    a = 0\n    nums = [0] * 10000\n    node = ListNode(0)\n    # \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in range(n):\n        c = 0\n    # \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in range(n):\n        function()\n</code></pre> space_complexity.cpp<pre><code>/* \u51fd\u6570 */\nint func() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const int a = 0;\n    int b = 0;\n    vector&lt;int&gt; nums(10000);\n    ListNode node(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u51fd\u6570 */\nint function() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    final int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u51fd\u6570 */\nint Function() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid Constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    int a = 0;\n    int b = 0;\n    int[] nums = new int[10000];\n    ListNode node = new(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u51fd\u6570 */\nfunc function() int {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c...\n    return 0\n}\n\n/* \u5e38\u6570\u9636 */\nfunc spaceConstant(n int) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0\n    b := 0\n    nums := make([]int, 10000)\n    node := newNode(0)\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    var c int\n    for i := 0; i &lt; n; i++ {\n        c = 0\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n    b += 0\n    c += 0\n    nums[0] = 0\n    node.val = 0\n}\n</code></pre> space_complexity.swift<pre><code>/* \u51fd\u6570 */\n@discardableResult\nfunc function() -&gt; Int {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0\n}\n\n/* \u5e38\u6570\u9636 */\nfunc constant(n: Int) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    let a = 0\n    var b = 0\n    let nums = Array(repeating: 0, count: 10000)\n    let node = ListNode(x: 0)\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in 0 ..&lt; n {\n        let c = 0\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n</code></pre> space_complexity.js<pre><code>/* \u51fd\u6570 */\nfunction constFunc() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nfunction constant(n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u51fd\u6570 */\nfunction constFunc(): number {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nfunction constant(n: number): void {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a = 0;\n    const b = 0;\n    const nums = new Array(10000);\n    const node = new ListNode(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        const c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u51fd\u6570 */\nint function() {\n  // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n  return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n  // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n  final int a = 0;\n  int b = 0;\n  List&lt;int&gt; nums = List.filled(10000, 0);\n  ListNode node = ListNode(0);\n  // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n  for (var i = 0; i &lt; n; i++) {\n    int c = 0;\n  }\n  // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n  for (var i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u51fd\u6570 */\nfn function() -&gt; i32 {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\n#[allow(unused)]\nfn constant(n: i32) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const A: i32 = 0;\n    let b = 0;\n    let nums = vec![0; 10000];\n    let node = ListNode::new(0);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for i in 0..n {\n        let c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for i in 0..n {\n        function();\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u51fd\u6570 */\nint func() {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n/* \u5e38\u6570\u9636 */\nvoid constant(int n) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const int a = 0;\n    int b = 0;\n    int nums[1000];\n    ListNode *node = newListNode(0);\n    free(node);\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        int c = 0;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n</code></pre> space_complexity.kt<pre><code>/* \u51fd\u6570 */\nfun function(): Int {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0\n}\n\n/* \u5e38\u6570\u9636 */\nfun constant(n: Int) {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    val a = 0\n    var b = 0\n    val nums = Array(10000) { 0 }\n    val node = ListNode(0)\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    for (i in 0..&lt;n) {\n        val c = 0\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    for (i in 0..&lt;n) {\n        function()\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### \u51fd\u6570 ###\ndef function\n  # \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n  0\nend\n\n### \u5e38\u6570\u9636 ###\ndef constant(n)\n  # \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n  a = 0\n  nums = [0] * 10000\n  node = ListNode.new\n\n  # \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n  (0...n).each { c = 0 }\n  # \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n  (0...n).each { function }\nend\n</code></pre> space_complexity.zig<pre><code>// \u51fd\u6570\nfn function() i32 {\n    // \u6267\u884c\u67d0\u4e9b\u64cd\u4f5c\n    return 0;\n}\n\n// \u5e38\u6570\u9636\nfn constant(n: i32) void {\n    // \u5e38\u91cf\u3001\u53d8\u91cf\u3001\u5bf9\u8c61\u5360\u7528 O(1) \u7a7a\u95f4\n    const a: i32 = 0;\n    var b: i32 = 0;\n    var nums = [_]i32{0}**10000;\n    var node = inc.ListNode(i32){.val = 0};\n    var i: i32 = 0;\n    // \u5faa\u73af\u4e2d\u7684\u53d8\u91cf\u5360\u7528 O(1) \u7a7a\u95f4\n    while (i &lt; n) : (i += 1) {\n        var c: i32 = 0;\n        _ = c;\n    }\n    // \u5faa\u73af\u4e2d\u7684\u51fd\u6570\u5360\u7528 O(1) \u7a7a\u95f4\n    i = 0;\n    while (i &lt; n) : (i += 1) {\n        _ = function();\n    }\n    _ = a;\n    _ = b;\n    _ = nums;\n    _ = node;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_computational_complexity/space_complexity/#2-linear-order-on","title":"2. \u00a0 Linear order \\(O(n)\\)","text":"<p>Linear order is common in arrays, linked lists, stacks, queues, etc., where the number of elements is proportional to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def linear(n: int):\n    \"\"\"\u7ebf\u6027\u9636\"\"\"\n    # \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    nums = [0] * n\n    # \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    hmap = dict[int, str]()\n    for i in range(n):\n        hmap[i] = str(i)\n</code></pre> space_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    vector&lt;int&gt; nums(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    vector&lt;ListNode&gt; nodes;\n    for (int i = 0; i &lt; n; i++) {\n        nodes.push_back(ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    unordered_map&lt;int, string&gt; map;\n    for (int i = 0; i &lt; n; i++) {\n        map[i] = to_string(i);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int[] nums = new int[n];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        nodes.add(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        map.put(i, String.valueOf(i));\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u7ebf\u6027\u9636 */\nvoid Linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int[] nums = new int[n];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    List&lt;ListNode&gt; nodes = [];\n    for (int i = 0; i &lt; n; i++) {\n        nodes.Add(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    Dictionary&lt;int, string&gt; map = [];\n    for (int i = 0; i &lt; n; i++) {\n        map.Add(i, i.ToString());\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u7ebf\u6027\u9636 */\nfunc spaceLinear(n int) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    _ = make([]int, n)\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var nodes []*node\n    for i := 0; i &lt; n; i++ {\n        nodes = append(nodes, newNode(i))\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    m := make(map[int]string, n)\n    for i := 0; i &lt; n; i++ {\n        m[i] = strconv.Itoa(i)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n: Int) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    let nums = Array(repeating: 0, count: n)\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let nodes = (0 ..&lt; n).map { ListNode(x: $0) }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let map = Dictionary(uniqueKeysWithValues: (0 ..&lt; n).map { ($0, \"\\($0)\") })\n}\n</code></pre> space_complexity.js<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    const nums = new Array(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const nodes = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n: number): void {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    const nums = new Array(n);\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const nodes: ListNode[] = [];\n    for (let i = 0; i &lt; n; i++) {\n        nodes.push(new ListNode(i));\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    const map = new Map();\n    for (let i = 0; i &lt; n; i++) {\n        map.set(i, i.toString());\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n  // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n  List&lt;int&gt; nums = List.filled(n, 0);\n  // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  List&lt;ListNode&gt; nodes = [];\n  for (var i = 0; i &lt; n; i++) {\n    nodes.add(ListNode(i));\n  }\n  // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  Map&lt;int, String&gt; map = HashMap();\n  for (var i = 0; i &lt; n; i++) {\n    map.putIfAbsent(i, () =&gt; i.toString());\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u7ebf\u6027\u9636 */\n#[allow(unused)]\nfn linear(n: i32) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut nums = vec![0; n as usize];\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut nodes = Vec::new();\n    for i in 0..n {\n        nodes.push(ListNode::new(i))\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    let mut map = HashMap::new();\n    for i in 0..n {\n        map.insert(i, i.to_string());\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u54c8\u5e0c\u8868 */\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; // \u57fa\u4e8e uthash.h \u5b9e\u73b0\n} HashTable;\n\n/* \u7ebf\u6027\u9636 */\nvoid linear(int n) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    int *nums = malloc(sizeof(int) * n);\n    free(nums);\n\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    ListNode **nodes = malloc(sizeof(ListNode *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        nodes[i] = newListNode(i);\n    }\n    // \u5185\u5b58\u91ca\u653e\n    for (int i = 0; i &lt; n; i++) {\n        free(nodes[i]);\n    }\n    free(nodes);\n\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    HashTable *h = NULL;\n    for (int i = 0; i &lt; n; i++) {\n        HashTable *tmp = malloc(sizeof(HashTable));\n        tmp-&gt;key = i;\n        tmp-&gt;val = i;\n        HASH_ADD_INT(h, key, tmp);\n    }\n\n    // \u5185\u5b58\u91ca\u653e\n    HashTable *curr, *tmp;\n    HASH_ITER(hh, h, curr, tmp) {\n        HASH_DEL(h, curr);\n        free(curr);\n    }\n}\n</code></pre> space_complexity.kt<pre><code>/* \u7ebf\u6027\u9636 */\nfun linear(n: Int) {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    val nums = Array(n) { 0 }\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    val nodes = mutableListOf&lt;ListNode&gt;()\n    for (i in 0..&lt;n) {\n        nodes.add(ListNode(i))\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    val map = mutableMapOf&lt;Int, String&gt;()\n    for (i in 0..&lt;n) {\n        map[i] = i.toString()\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### \u7ebf\u6027\u9636 ###\ndef linear(n)\n  # \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  nums = Array.new(n, 0)\n\n  # \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n  hmap = {}\n  for i in 0...n\n    hmap[i] = i.to_s\n  end\nend\n</code></pre> space_complexity.zig<pre><code>// \u7ebf\u6027\u9636\nfn linear(comptime n: i32) !void {\n    // \u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4\u5360\u7528 O(n) \u7a7a\u95f4\n    var nums = [_]i32{0}**n;\n    // \u957f\u5ea6\u4e3a n \u7684\u5217\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var nodes = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer nodes.deinit();\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        try nodes.append(i);\n    }\n    // \u957f\u5ea6\u4e3a n \u7684\u54c8\u5e0c\u8868\u5360\u7528 O(n) \u7a7a\u95f4\n    var map = std.AutoArrayHashMap(i32, []const u8).init(std.heap.page_allocator);\n    defer map.deinit();\n    var j: i32 = 0;\n    while (j &lt; n) : (j += 1) {\n        const string = try std.fmt.allocPrint(std.heap.page_allocator, \"{d}\", .{j});\n        defer std.heap.page_allocator.free(string);\n        try map.put(i, string);\n    }\n    _ = nums;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 2-17, this function's recursive depth is \\(n\\), meaning there are \\(n\\) instances of unreturned <code>linear_recur()</code> function, using \\(O(n)\\) size of stack frame space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def linear_recur(n: int):\n    \"\"\"\u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    print(\"\u9012\u5f52 n =\", n)\n    if n == 1:\n        return\n    linear_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    cout &lt;&lt; \"\u9012\u5f52 n = \" &lt;&lt; n &lt;&lt; endl;\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    System.out.println(\"\u9012\u5f52 n = \" + n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid LinearRecur(int n) {\n    Console.WriteLine(\"\u9012\u5f52 n = \" + n);\n    if (n == 1) return;\n    LinearRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc spaceLinearRecur(n int) {\n    fmt.Println(\"\u9012\u5f52 n =\", n)\n    if n == 1 {\n        return\n    }\n    spaceLinearRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc linearRecur(n: Int) {\n    print(\"\u9012\u5f52 n = \\(n)\")\n    if n == 1 {\n        return\n    }\n    linearRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction linearRecur(n) {\n    console.log(`\u9012\u5f52 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction linearRecur(n: number): void {\n    console.log(`\u9012\u5f52 n = ${n}`);\n    if (n === 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n  print('\u9012\u5f52 n = $n');\n  if (n == 1) return;\n  linearRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn linear_recur(n: i32) {\n    println!(\"\u9012\u5f52 n = {}\", n);\n    if n == 1 {\n        return;\n    };\n    linear_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nvoid linearRecur(int n) {\n    printf(\"\u9012\u5f52 n = %d\\r\\n\", n);\n    if (n == 1)\n        return;\n    linearRecur(n - 1);\n}\n</code></pre> space_complexity.kt<pre><code>/* \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfun linearRecur(n: Int) {\n    println(\"\u9012\u5f52 n = $n\")\n    if (n == 1)\n        return\n    linearRecur(n - 1)\n}\n</code></pre> space_complexity.rb<pre><code>### \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09###\ndef linear_recur(n)\n  puts \"\u9012\u5f52 n = #{n}\"\n  return if n == 1\n  linear_recur(n - 1)\nend\n</code></pre> space_complexity.zig<pre><code>// \u7ebf\u6027\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn linearRecur(comptime n: i32) void {\n    std.debug.print(\"\u9012\u5f52 n = {}\\n\", .{n});\n    if (n == 1) return;\n    linearRecur(n - 1);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-17 \u00a0 Recursive function generating linear order space complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic order \\(O(n^2)\\)","text":"<p>Quadratic order is common in matrices and graphs, where the number of elements is quadratic to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def quadratic(n: int):\n    \"\"\"\u5e73\u65b9\u9636\"\"\"\n    # \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    num_matrix = [[0] * n for _ in range(n)]\n</code></pre> space_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    vector&lt;vector&lt;int&gt;&gt; numMatrix;\n    for (int i = 0; i &lt; n; i++) {\n        vector&lt;int&gt; tmp;\n        for (int j = 0; j &lt; n; j++) {\n            tmp.push_back(0);\n        }\n        numMatrix.push_back(tmp);\n    }\n}\n</code></pre> space_complexity.java<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int[][] numMatrix = new int[n][n];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    List&lt;List&lt;Integer&gt;&gt; numList = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n        for (int j = 0; j &lt; n; j++) {\n            tmp.add(0);\n        }\n        numList.add(tmp);\n    }\n}\n</code></pre> space_complexity.cs<pre><code>/* \u5e73\u65b9\u9636 */\nvoid Quadratic(int n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int[,] numMatrix = new int[n, n];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    List&lt;List&lt;int&gt;&gt; numList = [];\n    for (int i = 0; i &lt; n; i++) {\n        List&lt;int&gt; tmp = [];\n        for (int j = 0; j &lt; n; j++) {\n            tmp.Add(0);\n        }\n        numList.Add(tmp);\n    }\n}\n</code></pre> space_complexity.go<pre><code>/* \u5e73\u65b9\u9636 */\nfunc spaceQuadratic(n int) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    numMatrix := make([][]int, n)\n    for i := 0; i &lt; n; i++ {\n        numMatrix[i] = make([]int, n)\n    }\n}\n</code></pre> space_complexity.swift<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n: Int) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let numList = Array(repeating: Array(repeating: 0, count: n), count: n)\n}\n</code></pre> space_complexity.js<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.ts<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n: number): void {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numMatrix = Array(n)\n        .fill(null)\n        .map(() =&gt; Array(n).fill(null));\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    const numList = [];\n    for (let i = 0; i &lt; n; i++) {\n        const tmp = [];\n        for (let j = 0; j &lt; n; j++) {\n            tmp.push(0);\n        }\n        numList.push(tmp);\n    }\n}\n</code></pre> space_complexity.dart<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n  // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n  List&lt;List&lt;int&gt;&gt; numMatrix = List.generate(n, (_) =&gt; List.filled(n, 0));\n  // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n  List&lt;List&lt;int&gt;&gt; numList = [];\n  for (var i = 0; i &lt; n; i++) {\n    List&lt;int&gt; tmp = [];\n    for (int j = 0; j &lt; n; j++) {\n      tmp.add(0);\n    }\n    numList.add(tmp);\n  }\n}\n</code></pre> space_complexity.rs<pre><code>/* \u5e73\u65b9\u9636 */\n#[allow(unused)]\nfn quadratic(n: i32) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let num_matrix = vec![vec![0; n as usize]; n as usize];\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    let mut num_list = Vec::new();\n    for i in 0..n {\n        let mut tmp = Vec::new();\n        for j in 0..n {\n            tmp.push(0);\n        }\n        num_list.push(tmp);\n    }\n}\n</code></pre> space_complexity.c<pre><code>/* \u5e73\u65b9\u9636 */\nvoid quadratic(int n) {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    int **numMatrix = malloc(sizeof(int *) * n);\n    for (int i = 0; i &lt; n; i++) {\n        int *tmp = malloc(sizeof(int) * n);\n        for (int j = 0; j &lt; n; j++) {\n            tmp[j] = 0;\n        }\n        numMatrix[i] = tmp;\n    }\n\n    // \u5185\u5b58\u91ca\u653e\n    for (int i = 0; i &lt; n; i++) {\n        free(numMatrix[i]);\n    }\n    free(numMatrix);\n}\n</code></pre> space_complexity.kt<pre><code>/* \u5e73\u65b9\u9636 */\nfun quadratic(n: Int) {\n    // \u77e9\u9635\u5360\u7528 O(n^2) \u7a7a\u95f4\n    val numMatrix = arrayOfNulls&lt;Array&lt;Int&gt;?&gt;(n)\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    val numList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;()\n    for (i in 0..&lt;n) {\n        val tmp = mutableListOf&lt;Int&gt;()\n        for (j in 0..&lt;n) {\n            tmp.add(0)\n        }\n        numList.add(tmp)\n    }\n}\n</code></pre> space_complexity.rb<pre><code>### \u5e73\u65b9\u9636 ###\ndef quadratic(n)\n  # \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n  Array.new(n) { Array.new(n, 0) }\nend\n</code></pre> space_complexity.zig<pre><code>// \u5e73\u65b9\u9636\nfn quadratic(n: i32) !void {\n    // \u4e8c\u7ef4\u5217\u8868\u5360\u7528 O(n^2) \u7a7a\u95f4\n    var nodes = std.ArrayList(std.ArrayList(i32)).init(std.heap.page_allocator);\n    defer nodes.deinit();\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        var tmp = std.ArrayList(i32).init(std.heap.page_allocator);\n        defer tmp.deinit();\n        var j: i32 = 0;\n        while (j &lt; n) : (j += 1) {\n            try tmp.append(0);\n        }\n        try nodes.append(tmp);\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 2-18, the recursive depth of this function is \\(n\\), and in each recursive call, an array is initialized with lengths \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\), averaging \\(n/2\\), thus overall occupying \\(O(n^2)\\) space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def quadratic_recur(n: int) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n &lt;= 0:\n        return 0\n    # \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    nums = [0] * n\n    return quadratic_recur(n - 1)\n</code></pre> space_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    vector&lt;int&gt; nums(n);\n    cout &lt;&lt; \"\u9012\u5f52 n = \" &lt;&lt; n &lt;&lt; \" \u4e2d\u7684 nums \u957f\u5ea6 = \" &lt;&lt; nums.size() &lt;&lt; endl;\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.java<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    int[] nums = new int[n];\n    System.out.println(\"\u9012\u5f52 n = \" + n + \" \u4e2d\u7684 nums \u957f\u5ea6 = \" + nums.length);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.cs<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint QuadraticRecur(int n) {\n    if (n &lt;= 0) return 0;\n    int[] nums = new int[n];\n    Console.WriteLine(\"\u9012\u5f52 n = \" + n + \" \u4e2d\u7684 nums \u957f\u5ea6 = \" + nums.Length);\n    return QuadraticRecur(n - 1);\n}\n</code></pre> space_complexity.go<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc spaceQuadraticRecur(n int) int {\n    if n &lt;= 0 {\n        return 0\n    }\n    nums := make([]int, n)\n    fmt.Printf(\"\u9012\u5f52 n = %d \u4e2d\u7684 nums \u957f\u5ea6 = %d \\n\", n, len(nums))\n    return spaceQuadraticRecur(n - 1)\n}\n</code></pre> space_complexity.swift<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\n@discardableResult\nfunc quadraticRecur(n: Int) -&gt; Int {\n    if n &lt;= 0 {\n        return 0\n    }\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    let nums = Array(repeating: 0, count: n)\n    print(\"\u9012\u5f52 n = \\(n) \u4e2d\u7684 nums \u957f\u5ea6 = \\(nums.count)\")\n    return quadraticRecur(n: n - 1)\n}\n</code></pre> space_complexity.js<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction quadraticRecur(n) {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`\u9012\u5f52 n = ${n} \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.ts<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction quadraticRecur(n: number): number {\n    if (n &lt;= 0) return 0;\n    const nums = new Array(n);\n    console.log(`\u9012\u5f52 n = ${n} \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}`);\n    return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.dart<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n  if (n &lt;= 0) return 0;\n  List&lt;int&gt; nums = List.filled(n, 0);\n  print('\u9012\u5f52 n = $n \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.length}');\n  return quadraticRecur(n - 1);\n}\n</code></pre> space_complexity.rs<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn quadratic_recur(n: i32) -&gt; i32 {\n    if n &lt;= 0 {\n        return 0;\n    };\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    let nums = vec![0; n as usize];\n    println!(\"\u9012\u5f52 n = {} \u4e2d\u7684 nums \u957f\u5ea6 = {}\", n, nums.len());\n    return quadratic_recur(n - 1);\n}\n</code></pre> space_complexity.c<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint quadraticRecur(int n) {\n    if (n &lt;= 0)\n        return 0;\n    int *nums = malloc(sizeof(int) * n);\n    printf(\"\u9012\u5f52 n = %d \u4e2d\u7684 nums \u957f\u5ea6 = %d\\r\\n\", n, n);\n    int res = quadraticRecur(n - 1);\n    free(nums);\n    return res;\n}\n</code></pre> space_complexity.kt<pre><code>/* \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\ntailrec fun quadraticRecur(n: Int): Int {\n    if (n &lt;= 0)\n        return 0\n    // \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n    val nums = Array(n) { 0 }\n    println(\"\u9012\u5f52 n = $n \u4e2d\u7684 nums \u957f\u5ea6 = ${nums.size}\")\n    return quadraticRecur(n - 1)\n}\n</code></pre> space_complexity.rb<pre><code>### \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09###\ndef quadratic_recur(n)\n  return 0 unless n &gt; 0\n\n  # \u6570\u7ec4 nums \u957f\u5ea6\u4e3a n, n-1, ..., 2, 1\n  nums = Array.new(n, 0)\n  quadratic_recur(n - 1)\nend\n</code></pre> space_complexity.zig<pre><code>// \u5e73\u65b9\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn quadraticRecur(comptime n: i32) i32 {\n    if (n &lt;= 0) return 0;\n    var nums = [_]i32{0}**n;\n    std.debug.print(\"\u9012\u5f52 n = {} \u4e2d\u7684 nums \u957f\u5ea6 = {}\\n\", .{n, nums.len});\n    return quadraticRecur(n - 1);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-18 \u00a0 Recursive function generating quadratic order space complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential order \\(O(2^n)\\)","text":"<p>Exponential order is common in binary trees. Observe Figure 2-19, a \"full binary tree\" with \\(n\\) levels has \\(2^n - 1\\) nodes, occupying \\(O(2^n)\\) space:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig space_complexity.py<pre><code>def build_tree(n: int) -&gt; TreeNode | None:\n    \"\"\"\u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09\"\"\"\n    if n == 0:\n        return None\n    root = TreeNode(0)\n    root.left = build_tree(n - 1)\n    root.right = build_tree(n - 1)\n    return root\n</code></pre> space_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return nullptr;\n    TreeNode *root = new TreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode buildTree(int n) {\n    if (n == 0)\n        return null;\n    TreeNode root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode? BuildTree(int n) {\n    if (n == 0) return null;\n    TreeNode root = new(0) {\n        left = BuildTree(n - 1),\n        right = BuildTree(n - 1)\n    };\n    return root;\n}\n</code></pre> space_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunc buildTree(n int) *TreeNode {\n    if n == 0 {\n        return nil\n    }\n    root := NewTreeNode(0)\n    root.Left = buildTree(n - 1)\n    root.Right = buildTree(n - 1)\n    return root\n}\n</code></pre> space_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunc buildTree(n: Int) -&gt; TreeNode? {\n    if n == 0 {\n        return nil\n    }\n    let root = TreeNode(x: 0)\n    root.left = buildTree(n: n - 1)\n    root.right = buildTree(n: n - 1)\n    return root\n}\n</code></pre> space_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunction buildTree(n) {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfunction buildTree(n: number): TreeNode | null {\n    if (n === 0) return null;\n    const root = new TreeNode(0);\n    root.left = buildTree(n - 1);\n    root.right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode? buildTree(int n) {\n  if (n == 0) return null;\n  TreeNode root = TreeNode(0);\n  root.left = buildTree(n - 1);\n  root.right = buildTree(n - 1);\n  return root;\n}\n</code></pre> space_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfn build_tree(n: i32) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    if n == 0 {\n        return None;\n    };\n    let root = TreeNode::new(0);\n    root.borrow_mut().left = build_tree(n - 1);\n    root.borrow_mut().right = build_tree(n - 1);\n    return Some(root);\n}\n</code></pre> space_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nTreeNode *buildTree(int n) {\n    if (n == 0)\n        return NULL;\n    TreeNode *root = newTreeNode(0);\n    root-&gt;left = buildTree(n - 1);\n    root-&gt;right = buildTree(n - 1);\n    return root;\n}\n</code></pre> space_complexity.kt<pre><code>/* \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09 */\nfun buildTree(n: Int): TreeNode? {\n    if (n == 0)\n        return null\n    val root = TreeNode(0)\n    root.left = buildTree(n - 1)\n    root.right = buildTree(n - 1)\n    return root\n}\n</code></pre> space_complexity.rb<pre><code>### \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09###\ndef build_tree(n)\n  return if n == 0\n\n  TreeNode.new.tap do |root|\n    root.left = build_tree(n - 1)\n    root.right = build_tree(n - 1)\n  end\nend\n</code></pre> space_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u5efa\u7acb\u6ee1\u4e8c\u53c9\u6811\uff09\nfn buildTree(mem_allocator: std.mem.Allocator, n: i32) !?*inc.TreeNode(i32) {\n    if (n == 0) return null;\n    const root = try mem_allocator.create(inc.TreeNode(i32));\n    root.init(0);\n    root.left = try buildTree(mem_allocator, n - 1);\n    root.right = try buildTree(mem_allocator, n - 1);\n    return root;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-19 \u00a0 Full binary tree generating exponential order space complexity </p>"},{"location":"chapter_computational_complexity/space_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic order \\(O(\\log n)\\)","text":"<p>Logarithmic order is common in divide-and-conquer algorithms. For example, in merge sort, an array of length \\(n\\) is recursively divided in half each round, forming a recursion tree of height \\(\\log n\\), using \\(O(\\log n)\\) stack frame space.</p> <p>Another example is converting a number to a string. Given a positive integer \\(n\\), its number of digits is \\(\\log_{10} n + 1\\), corresponding to the length of the string, thus the space complexity is \\(O(\\log_{10} n + 1) = O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/space_complexity/#244-balancing-time-and-space","title":"2.4.4 \u00a0 Balancing time and space","text":"<p>Ideally, we aim for both time complexity and space complexity to be optimal. However, in practice, optimizing both simultaneously is often difficult.</p> <p>Lowering time complexity usually comes at the cost of increased space complexity, and vice versa. The approach of sacrificing memory space to improve algorithm speed is known as \"space-time tradeoff\"; the reverse is known as \"time-space tradeoff\".</p> <p>The choice depends on which aspect we value more. In most cases, time is more precious than space, so \"space-time tradeoff\" is often the more common strategy. Of course, controlling space complexity is also very important when dealing with large volumes of data.</p>"},{"location":"chapter_computational_complexity/summary/","title":"2.5 \u00a0 Summary","text":""},{"location":"chapter_computational_complexity/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<p>Algorithm Efficiency Assessment</p> <ul> <li>Time efficiency and space efficiency are the two main criteria for assessing the merits of an algorithm.</li> <li>We can assess algorithm efficiency through actual testing, but it's challenging to eliminate the influence of the test environment, and it consumes substantial computational resources.</li> <li>Complexity analysis can overcome the disadvantages of actual testing. Its results are applicable across all operating platforms and can reveal the efficiency of algorithms at different data scales.</li> </ul> <p>Time Complexity</p> <ul> <li>Time complexity measures the trend of an algorithm's running time with the increase in data volume, effectively assessing algorithm efficiency. However, it can fail in certain cases, such as with small input data volumes or when time complexities are the same, making it challenging to precisely compare the efficiency of algorithms.</li> <li>Worst-case time complexity is denoted using big-\\(O\\) notation, representing the asymptotic upper bound, reflecting the growth level of the number of operations \\(T(n)\\) as \\(n\\) approaches infinity.</li> <li>Calculating time complexity involves two steps: first counting the number of operations, then determining the asymptotic upper bound.</li> <li>Common time complexities, arranged from low to high, include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n \\log n)\\), \\(O(n^2)\\), \\(O(2^n)\\), and \\(O(n!)\\), among others.</li> <li>The time complexity of some algorithms is not fixed and depends on the distribution of input data. Time complexities are divided into worst, best, and average cases. The best case is rarely used because input data generally needs to meet strict conditions to achieve the best case.</li> <li>Average time complexity reflects the efficiency of an algorithm under random data inputs, closely resembling the algorithm's performance in actual applications. Calculating average time complexity requires accounting for the distribution of input data and the subsequent mathematical expectation.</li> </ul> <p>Space Complexity</p> <ul> <li>Space complexity, similar to time complexity, measures the trend of memory space occupied by an algorithm with the increase in data volume.</li> <li>The relevant memory space used during the algorithm's execution can be divided into input space, temporary space, and output space. Generally, input space is not included in space complexity calculations. Temporary space can be divided into temporary data, stack frame space, and instruction space, where stack frame space usually affects space complexity only in recursive functions.</li> <li>We usually focus only on the worst-case space complexity, which means calculating the space complexity of the algorithm under the worst input data and at the worst moment of operation.</li> <li>Common space complexities, arranged from low to high, include \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n^2)\\), and \\(O(2^n)\\), among others.</li> </ul>"},{"location":"chapter_computational_complexity/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is the space complexity of tail recursion \\(O(1)\\)?</p> <p>Theoretically, the space complexity of a tail-recursive function can be optimized to \\(O(1)\\). However, most programming languages (such as Java, Python, C++, Go, C#) do not support automatic optimization of tail recursion, so it's generally considered to have a space complexity of \\(O(n)\\).</p> <p>Q: What is the difference between the terms \"function\" and \"method\"?</p> <p>A function can be executed independently, with all parameters passed explicitly. A method is associated with an object and is implicitly passed to the object calling it, able to operate on the data contained within an instance of a class.</p> <p>Here are some examples from common programming languages:</p> <ul> <li>C is a procedural programming language without object-oriented concepts, so it only has functions. However, we can simulate object-oriented programming by creating structures (struct), and functions associated with these structures are equivalent to methods in other programming languages.</li> <li>Java and C# are object-oriented programming languages where code blocks (methods) are typically part of a class. Static methods behave like functions because they are bound to the class and cannot access specific instance variables.</li> <li>C++ and Python support both procedural programming (functions) and object-oriented programming (methods).</li> </ul> <p>Q: Does the \"Common Types of Space Complexity\" figure reflect the absolute size of occupied space?</p> <p>No, the figure shows space complexities, which reflect growth trends, not the absolute size of the occupied space.</p> <p>If you take \\(n = 8\\), you might find that the values of each curve don't correspond to their functions. This is because each curve includes a constant term, intended to compress the value range into a visually comfortable range.</p> <p>In practice, since we usually don't know the \"constant term\" complexity of each method, it's generally not possible to choose the best solution for \\(n = 8\\) based solely on complexity. However, for \\(n = 8^5\\), it's much easier to choose, as the growth trend becomes dominant.</p>"},{"location":"chapter_computational_complexity/time_complexity/","title":"2.3 \u00a0 Time complexity","text":"<p>Time complexity is a concept used to measure how the run time of an algorithm increases with the size of the input data. Understanding time complexity is crucial for accurately assessing the efficiency of an algorithm.</p> <ol> <li>Determining the Running Platform: This includes hardware configuration, programming language, system environment, etc., all of which can affect the efficiency of code execution.</li> <li>Evaluating the Run Time for Various Computational Operations: For instance, an addition operation <code>+</code> might take 1 ns, a multiplication operation <code>*</code> might take 10 ns, a print operation <code>print()</code> might take 5 ns, etc.</li> <li>Counting All the Computational Operations in the Code: Summing the execution times of all these operations gives the total run time.</li> </ol> <p>For example, consider the following code with an input size of \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># Under an operating platform\ndef algorithm(n: int):\n    a = 2      # 1 ns\n    a = a + 1  # 1 ns\n    a = a * 2  # 10 ns\n    # Cycle n times\n    for _ in range(n):  # 1 ns\n        print(0)        # 5 ns\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        cout &lt;&lt; 0 &lt;&lt; endl;         // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        System.out.println(0);     // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid Algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , every round i++ is executed\n        Console.WriteLine(0);      // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunc algorithm(n int) {\n    a := 2     // 1 ns\n    a = a + 1  // 1 ns\n    a = a * 2  // 10 ns\n    // Loop n times\n    for i := 0; i &lt; n; i++ {  // 1 ns\n        fmt.Println(a)        // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunc algorithm(n: Int) {\n    var a = 2 // 1 ns\n    a = a + 1 // 1 ns\n    a = a * 2 // 10 ns\n    // Loop n times\n    for _ in 0 ..&lt; n { // 1 ns\n        print(0) // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunction algorithm(n) {\n    var a = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfunction algorithm(n: number): void {\n    var a: number = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // Loop n times\n    for(let i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n  int a = 2; // 1 ns\n  a = a + 1; // 1 ns\n  a = a * 2; // 10 ns\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // 1 ns , every round i++ is executed\n    print(0); // 5 ns\n  }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nfn algorithm(n: i32) {\n    let mut a = 2;      // 1 ns\n    a = a + 1;          // 1 ns\n    a = a * 2;          // 10 ns\n    // Loop n times\n    for _ in 0..n {     // 1 ns for each round i++\n        println!(\"{}\", 0);  // 5 ns\n    }\n}\n</code></pre> <pre><code>// Under a particular operating platform\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // 1 ns , every round i++ is executed\n        printf(\"%d\", 0);            // 5 ns\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Under a particular operating platform\nfn algorithm(n: usize) void {\n    var a: i32 = 2; // 1 ns\n    a += 1; // 1 ns\n    a *= 2; // 10 ns\n    // Loop n times\n    for (0..n) |_| { // 1 ns\n        std.debug.print(\"{}\\n\", .{0}); // 5 ns\n    }\n}\n</code></pre> <p>Using the above method, the run time of the algorithm can be calculated as \\((6n + 12)\\) ns:</p> \\[ 1 + 1 + 10 + (1 + 5) \\times n = 6n + 12 \\] <p>However, in practice, counting the run time of an algorithm is neither practical nor reasonable. First, we don't want to tie the estimated time to the running platform, as algorithms need to run on various platforms. Second, it's challenging to know the run time for each type of operation, making the estimation process difficult.</p>"},{"location":"chapter_computational_complexity/time_complexity/#231-assessing-time-growth-trend","title":"2.3.1 \u00a0 Assessing time growth trend","text":"<p>Time complexity analysis does not count the algorithm's run time, but rather the growth trend of the run time as the data volume increases.</p> <p>Let's understand this concept of \"time growth trend\" with an example. Assume the input data size is \\(n\\), and consider three algorithms <code>A</code>, <code>B</code>, and <code>C</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># Time complexity of algorithm A: constant order\ndef algorithm_A(n: int):\n    print(0)\n# Time complexity of algorithm B: linear order\ndef algorithm_B(n: int):\n    for _ in range(n):\n        print(0)\n# Time complexity of algorithm C: constant order\ndef algorithm_C(n: int):\n    for _ in range(1000000):\n        print(0)\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    cout &lt;&lt; 0 &lt;&lt; endl;\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    System.out.println(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        System.out.println(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        System.out.println(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid AlgorithmA(int n) {\n    Console.WriteLine(0);\n}\n// Time complexity of algorithm B: linear order\nvoid AlgorithmB(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Console.WriteLine(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid AlgorithmC(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        Console.WriteLine(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithm_A(n int) {\n    fmt.Println(0)\n}\n// Time complexity of algorithm B: linear order\nfunc algorithm_B(n int) {\n    for i := 0; i &lt; n; i++ {\n        fmt.Println(0)\n    }\n}\n// Time complexity of algorithm C: constant order\nfunc algorithm_C(n int) {\n    for i := 0; i &lt; 1000000; i++ {\n        fmt.Println(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunc algorithmA(n: Int) {\n    print(0)\n}\n\n// Time complexity of algorithm B: linear order\nfunc algorithmB(n: Int) {\n    for _ in 0 ..&lt; n {\n        print(0)\n    }\n}\n\n// Time complexity of algorithm C: constant order\nfunc algorithmC(n: Int) {\n    for _ in 0 ..&lt; 1_000_000 {\n        print(0)\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n) {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n) {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfunction algorithm_A(n: number): void {\n    console.log(0);\n}\n// Time complexity of algorithm B: linear order\nfunction algorithm_B(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfunction algorithm_C(n: number): void {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithmA(int n) {\n  print(0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithmB(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    print(0);\n  }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithmC(int n) {\n  for (int i = 0; i &lt; 1000000; i++) {\n    print(0);\n  }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfn algorithm_A(n: i32) {\n    println!(\"{}\", 0);\n}\n// Time complexity of algorithm B: linear order\nfn algorithm_B(n: i32) {\n    for _ in 0..n {\n        println!(\"{}\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nfn algorithm_C(n: i32) {\n    for _ in 0..1000000 {\n        println!(\"{}\", 0);\n    }\n}\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nvoid algorithm_A(int n) {\n    printf(\"%d\", 0);\n}\n// Time complexity of algorithm B: linear order\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"%d\", 0);\n    }\n}\n// Time complexity of algorithm C: constant order\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        printf(\"%d\", 0);\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Time complexity of algorithm A: constant order\nfn algorithm_A(n: usize) void {\n    _ = n;\n    std.debug.print(\"{}\\n\", .{0});\n}\n// Time complexity of algorithm B: linear order\nfn algorithm_B(n: i32) void {\n    for (0..n) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n// Time complexity of algorithm C: constant order\nfn algorithm_C(n: i32) void {\n    _ = n;\n    for (0..1000000) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n</code></pre> <p>Figure 2-7 shows the time complexities of these three algorithms.</p> <ul> <li>Algorithm <code>A</code> has just one print operation, and its run time does not grow with \\(n\\). Its time complexity is considered \"constant order.\"</li> <li>Algorithm <code>B</code> involves a print operation looping \\(n\\) times, and its run time grows linearly with \\(n\\). Its time complexity is \"linear order.\"</li> <li>Algorithm <code>C</code> has a print operation looping 1,000,000 times. Although it takes a long time, it is independent of the input data size \\(n\\). Therefore, the time complexity of <code>C</code> is the same as <code>A</code>, which is \"constant order.\"</li> </ul> <p></p> <p> Figure 2-7 \u00a0 Time growth trend of algorithms a, b, and c </p> <p>Compared to directly counting the run time of an algorithm, what are the characteristics of time complexity analysis?</p> <ul> <li>Time complexity effectively assesses algorithm efficiency. For instance, algorithm <code>B</code> has linearly growing run time, which is slower than algorithm <code>A</code> when \\(n &gt; 1\\) and slower than <code>C</code> when \\(n &gt; 1,000,000\\). In fact, as long as the input data size \\(n\\) is sufficiently large, a \"constant order\" complexity algorithm will always be better than a \"linear order\" one, demonstrating the essence of time growth trend.</li> <li>Time complexity analysis is more straightforward. Obviously, the running platform and the types of computational operations are irrelevant to the trend of run time growth. Therefore, in time complexity analysis, we can simply treat the execution time of all computational operations as the same \"unit time,\" simplifying the \"computational operation run time count\" to a \"computational operation count.\" This significantly reduces the complexity of estimation.</li> <li>Time complexity has its limitations. For example, although algorithms <code>A</code> and <code>C</code> have the same time complexity, their actual run times can be quite different. Similarly, even though algorithm <code>B</code> has a higher time complexity than <code>C</code>, it is clearly superior when the input data size \\(n\\) is small. In these cases, it's difficult to judge the efficiency of algorithms based solely on time complexity. Nonetheless, despite these issues, complexity analysis remains the most effective and commonly used method for evaluating algorithm efficiency.</li> </ul>"},{"location":"chapter_computational_complexity/time_complexity/#232-asymptotic-upper-bound","title":"2.3.2 \u00a0 Asymptotic upper bound","text":"<p>Consider a function with an input size of \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 1      # +1\n    a = a + 1  # +1\n    a = a * 2  # +1\n    # Cycle n times\n    for i in range(n):  # +1\n        print(0)        # +1\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n        cout &lt;&lt; 0 &lt;&lt; endl;    // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n        System.out.println(0);    // +1\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (execute i ++ every round)\n        Console.WriteLine(0);   // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1      // +1\n    a = a + 1   // +1\n    a = a * 2   // +1\n    // Loop n times\n    for i := 0; i &lt; n; i++ {   // +1\n        fmt.Println(a)         // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +1\n    a = a + 1 // +1\n    a = a * 2 // +1\n    // Loop n times\n    for _ in 0 ..&lt; n { // +1\n        print(0) // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    var a = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (execute i ++ every round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void{\n    var a: number = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for(let i = 0; i &lt; n; i++){ // +1 (execute i ++ every round)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +1\n  a = a + 1; // +1\n  a = a * 2; // +1\n  // Loop n times\n  for (int i = 0; i &lt; n; i++) { // +1 (execute i ++ every round)\n    print(0); // +1\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;   // +1\n    a = a + 1;      // +1\n    a = a * 2;      // +1\n\n    // Loop n times\n    for _ in 0..n { // +1 (execute i ++ every round)\n        println!(\"{}\", 0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // Loop n times\n    for (int i = 0; i &lt; n; i++) {   // +1 (execute i ++ every round)\n        printf(\"%d\", 0);            // +1\n    }\n} \n</code></pre> <pre><code>\n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // Loop n times\n    for (0..n) |_| { // +1 (execute i ++ every round)\n        std.debug.print(\"{}\\n\", .{0}); // +1\n    }\n}\n</code></pre> <p>Given a function that represents the number of operations of an algorithm as a function of the input size \\(n\\), denoted as \\(T(n)\\), consider the following example:</p> \\[ T(n) = 3 + 2n \\] <p>Since \\(T(n)\\) is a linear function, its growth trend is linear, and therefore, its time complexity is of linear order, denoted as \\(O(n)\\). This mathematical notation, known as big-O notation, represents the asymptotic upper bound of the function \\(T(n)\\).</p> <p>In essence, time complexity analysis is about finding the asymptotic upper bound of the \"number of operations \\(T(n)\\)\". It has a precise mathematical definition.</p> <p>Asymptotic Upper Bound</p> <p>If there exist positive real numbers \\(c\\) and \\(n_0\\) such that for all \\(n &gt; n_0\\), \\(T(n) \\leq c \\cdot f(n)\\), then \\(f(n)\\) is considered an asymptotic upper bound of \\(T(n)\\), denoted as \\(T(n) = O(f(n))\\).</p> <p>As illustrated below, calculating the asymptotic upper bound involves finding a function \\(f(n)\\) such that, as \\(n\\) approaches infinity, \\(T(n)\\) and \\(f(n)\\) have the same growth order, differing only by a constant factor \\(c\\).</p> <p></p> <p> Figure 2-8 \u00a0 Asymptotic upper bound of a function </p>"},{"location":"chapter_computational_complexity/time_complexity/#233-calculation-method","title":"2.3.3 \u00a0 Calculation method","text":"<p>While the concept of asymptotic upper bound might seem mathematically dense, you don't need to fully grasp it right away. Let's first understand the method of calculation, which can be practiced and comprehended over time.</p> <p>Once \\(f(n)\\) is determined, we obtain the time complexity \\(O(f(n))\\). But how do we determine the asymptotic upper bound \\(f(n)\\)? This process generally involves two steps: counting the number of operations and determining the asymptotic upper bound.</p>"},{"location":"chapter_computational_complexity/time_complexity/#1-step-1-counting-the-number-of-operations","title":"1. \u00a0 Step 1: counting the number of operations","text":"<p>This step involves going through the code line by line. However, due to the presence of the constant \\(c\\) in \\(c \\cdot f(n)\\), all coefficients and constant terms in \\(T(n)\\) can be ignored. This principle allows for simplification techniques in counting operations.</p> <ol> <li>Ignore constant terms in \\(T(n)\\), as they do not affect the time complexity being independent of \\(n\\).</li> <li>Omit all coefficients. For example, looping \\(2n\\), \\(5n + 1\\) times, etc., can be simplified to \\(n\\) times since the coefficient before \\(n\\) does not impact the time complexity.</li> <li>Use multiplication for nested loops. The total number of operations equals the product of the number of operations in each loop, applying the simplification techniques from points 1 and 2 for each loop level.</li> </ol> <p>Given a function, we can use these techniques to count operations:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 1      # +0 (trick 1)\n    a = a + n  # +0 (trick 1)\n    # +n (technique 2)\n    for i in range(5 * n + 1):\n        print(0)\n    # +n*n (technique 3)\n    for i in range(2 * n):\n        for j in range(n + 1):\n            print(0)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            cout &lt;&lt; 0 &lt;&lt; endl;\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        System.out.println(0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            System.out.println(0);\n        }\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        Console.WriteLine(0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            Console.WriteLine(0);\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1     // +0 (trick 1)\n    a = a + n  // +0 (trick 1)\n    // +n (technique 2)\n    for i := 0; i &lt; 5 * n + 1; i++ {\n        fmt.Println(0)\n    }\n    // +n*n (technique 3)\n    for i := 0; i &lt; 2 * n; i++ {\n        for j := 0; j &lt; n + 1; j++ {\n            fmt.Println(0)\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +0 (trick 1)\n    a = a + n // +0 (trick 1)\n    // +n (technique 2)\n    for _ in 0 ..&lt; (5 * n + 1) {\n        print(0)\n    }\n    // +n*n (technique 3)\n    for _ in 0 ..&lt; (2 * n) {\n        for _ in 0 ..&lt; (n + 1) {\n            print(0)\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    let a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    let a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (technique 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +0 (trick 1)\n  a = a + n; // +0 (trick 1)\n  // +n (technique 2)\n  for (int i = 0; i &lt; 5 * n + 1; i++) {\n    print(0);\n  }\n  // +n*n (technique 3)\n  for (int i = 0; i &lt; 2 * n; i++) {\n    for (int j = 0; j &lt; n + 1; j++) {\n      print(0);\n    }\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;     // +0 (trick 1)\n    a = a + n;        // +0 (trick 1)\n\n    // +n (technique 2)\n    for i in 0..(5 * n + 1) {\n        println!(\"{}\", 0);\n    }\n\n    // +n*n (technique 3)\n    for i in 0..(2 * n) {\n        for j in 0..(n + 1) {\n            println!(\"{}\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (trick 1)\n    a = a + n;  // +0 (trick 1)\n    // +n (technique 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        printf(\"%d\", 0);\n    }\n    // +n*n (technique 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            printf(\"%d\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1;     // +0 (trick 1)\n    a = a + @as(i32, @intCast(n));        // +0 (trick 1)\n\n    // +n (technique 2)\n    for(0..(5 * n + 1)) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n\n    // +n*n (technique 3)\n    for(0..(2 * n)) |_| {\n        for(0..(n + 1)) |_| {\n            std.debug.print(\"{}\\n\", .{0});\n        }\n    }\n}\n</code></pre> <p>The formula below shows the counting results before and after simplification, both leading to a time complexity of \\(O(n^2)\\):</p> \\[ \\begin{aligned} T(n) &amp; = 2n(n + 1) + (5n + 1) + 2 &amp; \\text{Complete Count (-.-|||)} \\newline &amp; = 2n^2 + 7n + 3 \\newline T(n) &amp; = n^2 + n &amp; \\text{Simplified Count (o.O)} \\end{aligned} \\]"},{"location":"chapter_computational_complexity/time_complexity/#2-step-2-determining-the-asymptotic-upper-bound","title":"2. \u00a0 Step 2: determining the asymptotic upper bound","text":"<p>The time complexity is determined by the highest order term in \\(T(n)\\). This is because, as \\(n\\) approaches infinity, the highest order term dominates, rendering the influence of other terms negligible.</p> <p>The following table illustrates examples of different operation counts and their corresponding time complexities. Some exaggerated values are used to emphasize that coefficients cannot alter the order of growth. When \\(n\\) becomes very large, these constants become insignificant.</p> <p> Table: Time complexity for different operation counts </p> Operation Count \\(T(n)\\) Time Complexity \\(O(f(n))\\) \\(100000\\) \\(O(1)\\) \\(3n + 2\\) \\(O(n)\\) \\(2n^2 + 3n + 2\\) \\(O(n^2)\\) \\(n^3 + 10000n^2\\) \\(O(n^3)\\) \\(2^n + 10000n^{10000}\\) \\(O(2^n)\\)"},{"location":"chapter_computational_complexity/time_complexity/#234-common-types-of-time-complexity","title":"2.3.4 \u00a0 Common types of time complexity","text":"<p>Let's consider the input data size as \\(n\\). The common types of time complexities are illustrated below, arranged from lowest to highest:</p> \\[ \\begin{aligned} O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) \\newline \\text{Constant Order} &lt; \\text{Logarithmic Order} &lt; \\text{Linear Order} &lt; \\text{Linear-Logarithmic Order} &lt; \\text{Quadratic Order} &lt; \\text{Exponential Order} &lt; \\text{Factorial Order} \\end{aligned} \\] <p></p> <p> Figure 2-9 \u00a0 Common types of time complexity </p>"},{"location":"chapter_computational_complexity/time_complexity/#1-constant-order-o1","title":"1. \u00a0 Constant order \\(O(1)\\)","text":"<p>Constant order means the number of operations is independent of the input data size \\(n\\). In the following function, although the number of operations <code>size</code> might be large, the time complexity remains \\(O(1)\\) as it's unrelated to \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def constant(n: int) -&gt; int:\n    \"\"\"\u5e38\u6570\u9636\"\"\"\n    count = 0\n    size = 100000\n    for _ in range(size):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e38\u6570\u9636 */\nint Constant(int n) {\n    int count = 0;\n    int size = 100000;\n    for (int i = 0; i &lt; size; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e38\u6570\u9636 */\nfunc constant(n int) int {\n    count := 0\n    size := 100000\n    for i := 0; i &lt; size; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e38\u6570\u9636 */\nfunc constant(n: Int) -&gt; Int {\n    var count = 0\n    let size = 100_000\n    for _ in 0 ..&lt; size {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e38\u6570\u9636 */\nfunction constant(n) {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e38\u6570\u9636 */\nfunction constant(n: number): number {\n    let count = 0;\n    const size = 100000;\n    for (let i = 0; i &lt; size; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n  int count = 0;\n  int size = 100000;\n  for (var i = 0; i &lt; size; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e38\u6570\u9636 */\nfn constant(n: i32) -&gt; i32 {\n    _ = n;\n    let mut count = 0;\n    let size = 100_000;\n    for _ in 0..size {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e38\u6570\u9636 */\nint constant(int n) {\n    int count = 0;\n    int size = 100000;\n    int i = 0;\n    for (int i = 0; i &lt; size; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u5e38\u6570\u9636 */\nfun constant(n: Int): Int {\n    var count = 0\n    val size = 100000\n    for (i in 0..&lt;size)\n        count++\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u5e38\u6570\u9636 ###\ndef constant(n)\n  count = 0\n  size = 100000\n\n  (0...size).each { count += 1 }\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u5e38\u6570\u9636\nfn constant(n: i32) i32 {\n    _ = n;\n    var count: i32 = 0;\n    const size: i32 = 100_000;\n    var i: i32 = 0;\n    while(i&lt;size) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_computational_complexity/time_complexity/#2-linear-order-on","title":"2. \u00a0 Linear order \\(O(n)\\)","text":"<p>Linear order indicates the number of operations grows linearly with the input data size \\(n\\). Linear order commonly appears in single-loop structures:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def linear(n: int) -&gt; int:\n    \"\"\"\u7ebf\u6027\u9636\"\"\"\n    count = 0\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u9636 */\nint Linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++)\n        count++;\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n int) int {\n    count := 0\n    for i := 0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u9636 */\nfunc linear(n: Int) -&gt; Int {\n    var count = 0\n    for _ in 0 ..&lt; n {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n) {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u9636 */\nfunction linear(n: number): number {\n    let count = 0;\n    for (let i = 0; i &lt; n; i++) count++;\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n  int count = 0;\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u9636 */\nfn linear(n: i32) -&gt; i32 {\n    let mut count = 0;\n    for _ in 0..n {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u9636 */\nint linear(int n) {\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u7ebf\u6027\u9636 */\nfun linear(n: Int): Int {\n    var count = 0\n    for (i in 0..&lt;n)\n        count++\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u7ebf\u6027\u9636 ###\ndef linear(n)\n  count = 0\n  (0...n).each { count += 1 }\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u9636\nfn linear(n: i32) i32 {\n    var count: i32 = 0;\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Operations like array traversal and linked list traversal have a time complexity of \\(O(n)\\), where \\(n\\) is the length of the array or list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def array_traversal(nums: list[int]) -&gt; int:\n    \"\"\"\u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09\"\"\"\n    count = 0\n    # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for num in nums:\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(vector&lt;int&gt; &amp;nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(int[] nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int num : nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint ArrayTraversal(int[] nums) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    foreach (int num in nums) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunc arrayTraversal(nums []int) int {\n    count := 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for range nums {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunc arrayTraversal(nums: [Int]) -&gt; Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for _ in nums {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunction arrayTraversal(nums) {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfunction arrayTraversal(nums: number[]): number {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (let i = 0; i &lt; nums.length; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(List&lt;int&gt; nums) {\n  int count = 0;\n  // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n  for (var _num in nums) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfn array_traversal(nums: &amp;[i32]) -&gt; i32 {\n    let mut count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for _ in nums {\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nint arrayTraversal(int *nums, int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09 */\nfun arrayTraversal(nums: IntArray): Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (num in nums) {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09###\ndef array_traversal(nums)\n  count = 0\n\n  # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n  for num in nums\n    count += 1\n  end\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u9636\uff08\u904d\u5386\u6570\u7ec4\uff09\nfn arrayTraversal(nums: []i32) i32 {\n    var count: i32 = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u7ec4\u957f\u5ea6\u6210\u6b63\u6bd4\n    for (nums) |_| {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>It's important to note that the input data size \\(n\\) should be determined based on the type of input data. For example, in the first example, \\(n\\) represents the input data size, while in the second example, the length of the array \\(n\\) is the data size.</p>"},{"location":"chapter_computational_complexity/time_complexity/#3-quadratic-order-on2","title":"3. \u00a0 Quadratic order \\(O(n^2)\\)","text":"<p>Quadratic order means the number of operations grows quadratically with the input data size \\(n\\). Quadratic order typically appears in nested loops, where both the outer and inner loops have a time complexity of \\(O(n)\\), resulting in an overall complexity of \\(O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def quadratic(n: int) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\"\"\"\n    count = 0\n    # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for i in range(n):\n        for j in range(n):\n            count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e73\u65b9\u9636 */\nint Quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n int) int {\n    count := 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; n; j++ {\n            count++\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e73\u65b9\u9636 */\nfunc quadratic(n: Int) -&gt; Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; n {\n            count += 1\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n) {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e73\u65b9\u9636 */\nfunction quadratic(n: number): number {\n    let count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n  int count = 0;\n  // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n      count++;\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e73\u65b9\u9636 */\nfn quadratic(n: i32) -&gt; i32 {\n    let mut count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for _ in 0..n {\n        for _ in 0..n {\n            count += 1;\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e73\u65b9\u9636 */\nint quadratic(int n) {\n    int count = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u5e73\u65b9\u9636 */\nfun quadratic(n: Int): Int {\n    var count = 0\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    for (i in 0..&lt;n) {\n        for (j in 0..&lt;n) {\n            count++\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u5e73\u65b9\u9636 ###\ndef quadratic(n)\n  count = 0\n\n  # \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n  for i in 0...n\n    for j in 0...n\n      count += 1\n    end\n  end\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u5e73\u65b9\u9636\nfn quadratic(n: i32) i32 {\n    var count: i32 = 0;\n    var i: i32 = 0;\n    // \u5faa\u73af\u6b21\u6570\u4e0e\u6570\u636e\u5927\u5c0f n \u6210\u5e73\u65b9\u5173\u7cfb\n    while (i &lt; n) : (i += 1) {\n        var j: i32 = 0;\n        while (j &lt; n) : (j += 1) {\n            count += 1;\n        }\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 2-10 compares constant order, linear order, and quadratic order time complexities.</p> <p></p> <p> Figure 2-10 \u00a0 Constant, linear, and quadratic order time complexities </p> <p>For instance, in bubble sort, the outer loop runs \\(n - 1\\) times, and the inner loop runs \\(n-1\\), \\(n-2\\), ..., \\(2\\), \\(1\\) times, averaging \\(n / 2\\) times, resulting in a time complexity of \\(O((n - 1) n / 2) = O(n^2)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def bubble_sort(nums: list[int]) -&gt; int:\n    \"\"\"\u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09\"\"\"\n    count = 0  # \u8ba1\u6570\u5668\n    # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in range(len(nums) - 1, 0, -1):\n        # \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                tmp: int = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3  # \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(vector&lt;int&gt; &amp;nums) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(int[] nums) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint BubbleSort(int[] nums) {\n    int count = 0;  // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n                count += 3;  // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunc bubbleSort(nums []int) int {\n    count := 0 // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                tmp := nums[j]\n                nums[j] = nums[j+1]\n                nums[j+1] = tmp\n                count += 3 // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunc bubbleSort(nums: inout [Int]) -&gt; Int {\n    var count = 0 // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = tmp\n                count += 3 // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunction bubbleSort(nums) {\n    let count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfunction bubbleSort(nums: number[]): number {\n    let count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(List&lt;int&gt; nums) {\n  int count = 0; // \u8ba1\u6570\u5668\n  // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n  for (var i = nums.length - 1; i &gt; 0; i--) {\n    // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n    for (var j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n        count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n      }\n    }\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfn bubble_sort(nums: &amp;mut [i32]) -&gt; i32 {\n    let mut count = 0; // \u8ba1\u6570\u5668\n\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in (1..nums.len()).rev() {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nint bubbleSort(int *nums, int n) {\n    int count = 0; // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = n - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3; // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09 */\nfun bubbleSort(nums: IntArray): Int {\n    var count = 0 // \u8ba1\u6570\u5668\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n                count += 3 // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09###\ndef bubble_sort(nums)\n  count = 0  # \u8ba1\u6570\u5668\n\n  # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n  for i in (nums.length - 1).downto(0)\n    # \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n    for j in 0...i\n      if nums[j] &gt; nums[j + 1]\n        # \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n        tmp = nums[j]\n        nums[j] = nums[j + 1]\n        nums[j + 1] = tmp\n        count += 3 # \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n      end\n    end\n  end\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u5e73\u65b9\u9636\uff08\u5192\u6ce1\u6392\u5e8f\uff09\nfn bubbleSort(nums: []i32) i32 {\n    var count: i32 = 0;  // \u8ba1\u6570\u5668 \n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    var i: i32 = @as(i32, @intCast(nums.len)) - 1;\n    while (i &gt; 0) : (i -= 1) {\n        var j: usize = 0;\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        while (j &lt; i) : (j += 1) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                var tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                count += 3;  // \u5143\u7d20\u4ea4\u6362\u5305\u542b 3 \u4e2a\u5355\u5143\u64cd\u4f5c\n            }\n        }\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_computational_complexity/time_complexity/#4-exponential-order-o2n","title":"4. \u00a0 Exponential order \\(O(2^n)\\)","text":"<p>Biological \"cell division\" is a classic example of exponential order growth: starting with one cell, it becomes two after one division, four after two divisions, and so on, resulting in \\(2^n\\) cells after \\(n\\) divisions.</p> <p>Figure 2-11 and code simulate the cell division process, with a time complexity of \\(O(2^n)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def exponential(n: int) -&gt; int:\n    \"\"\"\u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\"\"\"\n    count = 0\n    base = 1\n    # \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in range(n):\n        for _ in range(base):\n            count += 1\n        base *= 2\n    # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0, base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint Exponential(int n) {\n    int count = 0, bas = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09*/\nfunc exponential(n int) int {\n    count, base := 0, 1\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; base; j++ {\n            count++\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunc exponential(n: Int) -&gt; Int {\n    var count = 0\n    var base = 1\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0 ..&lt; n {\n        for _ in 0 ..&lt; base {\n            count += 1\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction exponential(n) {\n    let count = 0,\n        base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction exponential(n: number): number {\n    let count = 0,\n        base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; base; j++) {\n            count++;\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n  int count = 0, base = 1;\n  // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n  for (var i = 0; i &lt; n; i++) {\n    for (var j = 0; j &lt; base; j++) {\n      count++;\n    }\n    base *= 2;\n  }\n  // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfn exponential(n: i32) -&gt; i32 {\n    let mut count = 0;\n    let mut base = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for _ in 0..n {\n        for _ in 0..base {\n            count += 1\n        }\n        base *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint exponential(int n) {\n    int count = 0;\n    int bas = 1;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfun exponential(n: Int): Int {\n    var count = 0\n    var base = 1\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    for (i in 0..&lt;n) {\n        for (j in 0..&lt;base) {\n            count++\n        }\n        base *= 2\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09###\ndef exponential(n)\n  count, base = 0, 1\n\n  # \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n  (0...n).each do\n    (0...base).each { count += 1 }\n    base *= 2\n  end\n\n  # count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\nfn exponential(n: i32) i32 {\n    var count: i32 = 0;\n    var bas: i32 = 1;\n    var i: i32 = 0;\n    // \u7ec6\u80de\u6bcf\u8f6e\u4e00\u5206\u4e3a\u4e8c\uff0c\u5f62\u6210\u6570\u5217 1, 2, 4, 8, ..., 2^(n-1)\n    while (i &lt; n) : (i += 1) {\n        var j: i32 = 0;\n        while (j &lt; bas) : (j += 1) {\n            count += 1;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-11 \u00a0 Exponential order time complexity </p> <p>In practice, exponential order often appears in recursive functions. For example, in the code below, it recursively splits into two halves, stopping after \\(n\\) divisions:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def exp_recur(n: int) -&gt; int:\n    \"\"\"\u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n == 1:\n        return 1\n    return exp_recur(n - 1) + exp_recur(n - 1) + 1\n</code></pre> time_complexity.cpp<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint ExpRecur(int n) {\n    if (n == 1) return 1;\n    return ExpRecur(n - 1) + ExpRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09*/\nfunc expRecur(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n-1) + expRecur(n-1) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc expRecur(n: Int) -&gt; Int {\n    if n == 1 {\n        return 1\n    }\n    return expRecur(n: n - 1) + expRecur(n: n - 1) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction expRecur(n) {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction expRecur(n: number): number {\n    if (n === 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n  if (n == 1) return 1;\n  return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn exp_recur(n: i32) -&gt; i32 {\n    if n == 1 {\n        return 1;\n    }\n    exp_recur(n - 1) + exp_recur(n - 1) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint expRecur(int n) {\n    if (n == 1)\n        return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfun expRecur(n: Int): Int {\n    if (n == 1) {\n        return 1\n    }\n    return expRecur(n - 1) + expRecur(n - 1) + 1\n}\n</code></pre> time_complexity.rb<pre><code>### \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09###\ndef exp_recur(n)\n  return 1 if n == 1\n  exp_recur(n - 1) + exp_recur(n - 1) + 1\nend\n</code></pre> time_complexity.zig<pre><code>// \u6307\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn expRecur(n: i32) i32 {\n    if (n == 1) return 1;\n    return expRecur(n - 1) + expRecur(n - 1) + 1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Exponential order growth is extremely rapid and is commonly seen in exhaustive search methods (brute force, backtracking, etc.). For large-scale problems, exponential order is unacceptable, often requiring dynamic programming or greedy algorithms as solutions.</p>"},{"location":"chapter_computational_complexity/time_complexity/#5-logarithmic-order-olog-n","title":"5. \u00a0 Logarithmic order \\(O(\\log n)\\)","text":"<p>In contrast to exponential order, logarithmic order reflects situations where \"the size is halved each round.\" Given an input data size \\(n\\), since the size is halved each round, the number of iterations is \\(\\log_2 n\\), the inverse function of \\(2^n\\).</p> <p>Figure 2-12 and code simulate the \"halving each round\" process, with a time complexity of \\(O(\\log_2 n)\\), commonly abbreviated as \\(O(\\log n)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def logarithmic(n: int) -&gt; int:\n    \"\"\"\u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\"\"\"\n    count = 0\n    while n &gt; 1:\n        n = n / 2\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint Logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n /= 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09*/\nfunc logarithmic(n int) int {\n    count := 0\n    for n &gt; 1 {\n        n = n / 2\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunc logarithmic(n: Int) -&gt; Int {\n    var count = 0\n    var n = n\n    while n &gt; 1 {\n        n = n / 2\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction logarithmic(n) {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfunction logarithmic(n: number): number {\n    let count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(int n) {\n  int count = 0;\n  while (n &gt; 1) {\n    n = n ~/ 2;\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfn logarithmic(mut n: i32) -&gt; i32 {\n    let mut count = 0;\n    while n &gt; 1 {\n        n = n / 2;\n        count += 1;\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nint logarithmic(int n) {\n    int count = 0;\n    while (n &gt; 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09 */\nfun logarithmic(n: Int): Int {\n    var n1 = n\n    var count = 0\n    while (n1 &gt; 1) {\n        n1 /= 2\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09###\ndef logarithmic(n)\n  count = 0\n\n  while n &gt; 1\n    n /= 2\n    count += 1\n  end\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u5bf9\u6570\u9636\uff08\u5faa\u73af\u5b9e\u73b0\uff09\nfn logarithmic(n: i32) i32 {\n    var count: i32 = 0;\n    var n_var = n;\n    while (n_var &gt; 1)\n    {\n        n_var = n_var / 2;\n        count +=1;\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-12 \u00a0 Logarithmic order time complexity </p> <p>Like exponential order, logarithmic order also frequently appears in recursive functions. The code below forms a recursive tree of height \\(\\log_2 n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def log_recur(n: int) -&gt; int:\n    \"\"\"\u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n &lt;= 1:\n        return 0\n    return log_recur(n / 2) + 1\n</code></pre> time_complexity.cpp<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.java<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint LogRecur(int n) {\n    if (n &lt;= 1) return 0;\n    return LogRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.go<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09*/\nfunc logRecur(n int) int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n/2) + 1\n}\n</code></pre> time_complexity.swift<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc logRecur(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 0\n    }\n    return logRecur(n: n / 2) + 1\n}\n</code></pre> time_complexity.js<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction logRecur(n) {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction logRecur(n: number): number {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(int n) {\n  if (n &lt;= 1) return 0;\n  return logRecur(n ~/ 2) + 1;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn log_recur(n: i32) -&gt; i32 {\n    if n &lt;= 1 {\n        return 0;\n    }\n    log_recur(n / 2) + 1\n}\n</code></pre> time_complexity.c<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint logRecur(int n) {\n    if (n &lt;= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfun logRecur(n: Int): Int {\n    if (n &lt;= 1)\n        return 0\n    return logRecur(n / 2) + 1\n}\n</code></pre> time_complexity.rb<pre><code>### \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09###\ndef log_recur(n)\n  return 0 unless n &gt; 1\n  log_recur(n / 2) + 1\nend\n</code></pre> time_complexity.zig<pre><code>// \u5bf9\u6570\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn logRecur(n: i32) i32 {\n    if (n &lt;= 1) return 0;\n    return logRecur(n / 2) + 1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Logarithmic order is typical in algorithms based on the divide-and-conquer strategy, embodying the \"split into many\" and \"simplify complex problems\" approach. It's slow-growing and is the most ideal time complexity after constant order.</p> <p>What is the base of \\(O(\\log n)\\)?</p> <p>Technically, \"splitting into \\(m\\)\" corresponds to a time complexity of \\(O(\\log_m n)\\). Using the logarithm base change formula, we can equate different logarithmic complexities:</p> \\[ O(\\log_m n) = O(\\log_k n / \\log_k m) = O(\\log_k n) \\] <p>This means the base \\(m\\) can be changed without affecting the complexity. Therefore, we often omit the base \\(m\\) and simply denote logarithmic order as \\(O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/time_complexity/#6-linear-logarithmic-order-on-log-n","title":"6. \u00a0 Linear-logarithmic order \\(O(n \\log n)\\)","text":"<p>Linear-logarithmic order often appears in nested loops, with the complexities of the two loops being \\(O(\\log n)\\) and \\(O(n)\\) respectively. The related code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def linear_log_recur(n: int) -&gt; int:\n    \"\"\"\u7ebf\u6027\u5bf9\u6570\u9636\"\"\"\n    if n &lt;= 1:\n        return 1\n    count: int = linear_log_recur(n // 2) + linear_log_recur(n // 2)\n    for _ in range(n):\n        count += 1\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint LinearLogRecur(int n) {\n    if (n &lt;= 1) return 1;\n    int count = LinearLogRecur(n / 2) + LinearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunc linearLogRecur(n int) int {\n    if n &lt;= 1 {\n        return 1\n    }\n    count := linearLogRecur(n/2) + linearLogRecur(n/2)\n    for i := 0; i &lt; n; i++ {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunc linearLogRecur(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    var count = linearLogRecur(n: n / 2) + linearLogRecur(n: n / 2)\n    for _ in stride(from: 0, to: n, by: 1) {\n        count += 1\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunction linearLogRecur(n) {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfunction linearLogRecur(n: number): number {\n    if (n &lt;= 1) return 1;\n    let count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (let i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(int n) {\n  if (n &lt;= 1) return 1;\n  int count = linearLogRecur(n ~/ 2) + linearLogRecur(n ~/ 2);\n  for (var i = 0; i &lt; n; i++) {\n    count++;\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfn linear_log_recur(n: i32) -&gt; i32 {\n    if n &lt;= 1 {\n        return 1;\n    }\n    let mut count = linear_log_recur(n / 2) + linear_log_recur(n / 2);\n    for _ in 0..n as i32 {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> time_complexity.c<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nint linearLogRecur(int n) {\n    if (n &lt;= 1)\n        return 1;\n    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    for (int i = 0; i &lt; n; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u7ebf\u6027\u5bf9\u6570\u9636 */\nfun linearLogRecur(n: Int): Int {\n    if (n &lt;= 1)\n        return 1\n    var count = linearLogRecur(n / 2) + linearLogRecur(n / 2)\n    for (i in 0..&lt;n) {\n        count++\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u7ebf\u6027\u5bf9\u6570\u9636 ###\ndef linear_log_recur(n)\n  return 1 unless n &gt; 1\n\n  count = linear_log_recur(n / 2) + linear_log_recur(n / 2)\n  (0...n).each { count += 1 }\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u7ebf\u6027\u5bf9\u6570\u9636\nfn linearLogRecur(n: i32) i32 {\n    if (n &lt;= 1) return 1;\n    var count: i32 = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n    var i: i32 = 0;\n    while (i &lt; n) : (i += 1) {\n        count += 1;\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 2-13 demonstrates how linear-logarithmic order is generated. Each level of a binary tree has \\(n\\) operations, and the tree has \\(\\log_2 n + 1\\) levels, resulting in a time complexity of \\(O(n \\log n)\\).</p> <p></p> <p> Figure 2-13 \u00a0 Linear-logarithmic order time complexity </p> <p>Mainstream sorting algorithms typically have a time complexity of \\(O(n \\log n)\\), such as quicksort, mergesort, and heapsort.</p>"},{"location":"chapter_computational_complexity/time_complexity/#7-factorial-order-on","title":"7. \u00a0 Factorial order \\(O(n!)\\)","text":"<p>Factorial order corresponds to the mathematical problem of \"full permutation.\" Given \\(n\\) distinct elements, the total number of possible permutations is:</p> \\[ n! = n \\times (n - 1) \\times (n - 2) \\times \\dots \\times 2 \\times 1 \\] <p>Factorials are typically implemented using recursion. As shown in the code and Figure 2-14, the first level splits into \\(n\\) branches, the second level into \\(n - 1\\) branches, and so on, stopping after the \\(n\\)th level:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig time_complexity.py<pre><code>def factorial_recur(n: int) -&gt; int:\n    \"\"\"\u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    # \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in range(n):\n        count += factorial_recur(n - 1)\n    return count\n</code></pre> time_complexity.cpp<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.java<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.cs<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint FactorialRecur(int n) {\n    if (n == 0) return 1;\n    int count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (int i = 0; i &lt; n; i++) {\n        count += FactorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.go<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc factorialRecur(n int) int {\n    if n == 0 {\n        return 1\n    }\n    count := 0\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for i := 0; i &lt; n; i++ {\n        count += factorialRecur(n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.swift<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunc factorialRecur(n: Int) -&gt; Int {\n    if n == 0 {\n        return 1\n    }\n    var count = 0\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in 0 ..&lt; n {\n        count += factorialRecur(n: n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.js<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction factorialRecur(n) {\n    if (n === 0) return 1;\n    let count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.ts<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfunction factorialRecur(n: number): number {\n    if (n === 0) return 1;\n    let count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (let i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.dart<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n  if (n == 0) return 1;\n  int count = 0;\n  // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n  for (var i = 0; i &lt; n; i++) {\n    count += factorialRecur(n - 1);\n  }\n  return count;\n}\n</code></pre> time_complexity.rs<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfn factorial_recur(n: i32) -&gt; i32 {\n    if n == 0 {\n        return 1;\n    }\n    let mut count = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for _ in 0..n {\n        count += factorial_recur(n - 1);\n    }\n    count\n}\n</code></pre> time_complexity.c<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> time_complexity.kt<pre><code>/* \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09 */\nfun factorialRecur(n: Int): Int {\n    if (n == 0)\n        return 1\n    var count = 0\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    for (i in 0..&lt;n) {\n        count += factorialRecur(n - 1)\n    }\n    return count\n}\n</code></pre> time_complexity.rb<pre><code>### \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09###\ndef factorial_recur(n)\n  return 1 if n == 0\n\n  count = 0\n  # \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n  (0...n).each { count += factorial_recur(n - 1) }\n\n  count\nend\n</code></pre> time_complexity.zig<pre><code>// \u9636\u4e58\u9636\uff08\u9012\u5f52\u5b9e\u73b0\uff09\nfn factorialRecur(n: i32) i32 {\n    if (n == 0) return 1;\n    var count: i32 = 0;\n    var i: i32 = 0;\n    // \u4ece 1 \u4e2a\u5206\u88c2\u51fa n \u4e2a\n    while (i &lt; n) : (i += 1) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 2-14 \u00a0 Factorial order time complexity </p> <p>Note that factorial order grows even faster than exponential order; it's unacceptable for larger \\(n\\) values.</p>"},{"location":"chapter_computational_complexity/time_complexity/#235-worst-best-and-average-time-complexities","title":"2.3.5 \u00a0 Worst, best, and average time complexities","text":"<p>The time efficiency of an algorithm is often not fixed but depends on the distribution of the input data. Assume we have an array <code>nums</code> of length \\(n\\), consisting of numbers from \\(1\\) to \\(n\\), each appearing only once, but in a randomly shuffled order. The task is to return the index of the element \\(1\\). We can draw the following conclusions:</p> <ul> <li>When <code>nums = [?, ?, ..., 1]</code>, that is, when the last element is \\(1\\), it requires a complete traversal of the array, achieving the worst-case time complexity of \\(O(n)\\).</li> <li>When <code>nums = [1, ?, ?, ...]</code>, that is, when the first element is \\(1\\), no matter the length of the array, no further traversal is needed, achieving the best-case time complexity of \\(\\Omega(1)\\).</li> </ul> <p>The \"worst-case time complexity\" corresponds to the asymptotic upper bound, denoted by the big \\(O\\) notation. Correspondingly, the \"best-case time complexity\" corresponds to the asymptotic lower bound, denoted by \\(\\Omega\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig worst_best_time_complexity.py<pre><code>def random_numbers(n: int) -&gt; list[int]:\n    \"\"\"\u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a: 1, 2, ..., n \uff0c\u987a\u5e8f\u88ab\u6253\u4e71\"\"\"\n    # \u751f\u6210\u6570\u7ec4 nums =: 1, 2, 3, ..., n\n    nums = [i for i in range(1, n + 1)]\n    # \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    random.shuffle(nums)\n    return nums\n\ndef find_one(nums: list[int]) -&gt; int:\n    \"\"\"\u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15\"\"\"\n    for i in range(len(nums)):\n        # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1:\n            return i\n    return -1\n</code></pre> worst_best_time_complexity.cpp<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nvector&lt;int&gt; randomNumbers(int n) {\n    vector&lt;int&gt; nums(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u4f7f\u7528\u7cfb\u7edf\u65f6\u95f4\u751f\u6210\u968f\u673a\u79cd\u5b50\n    unsigned seed = chrono::system_clock::now().time_since_epoch().count();\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    shuffle(nums.begin(), nums.end(), default_random_engine(seed));\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(vector&lt;int&gt; &amp;nums) {\n    for (int i = 0; i &lt; nums.size(); i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.java<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint[] randomNumbers(int n) {\n    Integer[] nums = new Integer[n];\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    Collections.shuffle(Arrays.asList(nums));\n    // Integer[] -&gt; int[]\n    int[] res = new int[n];\n    for (int i = 0; i &lt; n; i++) {\n        res[i] = nums[i];\n    }\n    return res;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(int[] nums) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.cs<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint[] RandomNumbers(int n) {\n    int[] nums = new int[n];\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (int i = 0; i &lt; nums.Length; i++) {\n        int index = new Random().Next(i, nums.Length);\n        (nums[i], nums[index]) = (nums[index], nums[i]);\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint FindOne(int[] nums) {\n    for (int i = 0; i &lt; nums.Length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.go<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunc randomNumbers(n int) []int {\n    nums := make([]int, n)\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for i := 0; i &lt; n; i++ {\n        nums[i] = i + 1\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    rand.Shuffle(len(nums), func(i, j int) {\n        nums[i], nums[j] = nums[j], nums[i]\n    })\n    return nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunc findOne(nums []int) int {\n    for i := 0; i &lt; len(nums); i++ {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.swift<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunc randomNumbers(n: Int) -&gt; [Int] {\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    var nums = Array(1 ... n)\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    nums.shuffle()\n    return nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunc findOne(nums: [Int]) -&gt; Int {\n    for i in nums.indices {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.js<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunction randomNumbers(n) {\n    const nums = Array(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunction findOne(nums) {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.ts<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfunction randomNumbers(n: number): number[] {\n    const nums = Array(n);\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (let i = 0; i &lt; n; i++) {\n        const r = Math.floor(Math.random() * (i + 1));\n        const temp = nums[i];\n        nums[i] = nums[r];\n        nums[r] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfunction findOne(nums: number[]): number {\n    for (let i = 0; i &lt; nums.length; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] === 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.dart<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nList&lt;int&gt; randomNumbers(int n) {\n  final nums = List.filled(n, 0);\n  // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n  for (var i = 0; i &lt; n; i++) {\n    nums[i] = i + 1;\n  }\n  // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n  nums.shuffle();\n\n  return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(List&lt;int&gt; nums) {\n  for (var i = 0; i &lt; nums.length; i++) {\n    // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n    // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n    if (nums[i] == 1) return i;\n  }\n\n  return -1;\n}\n</code></pre> worst_best_time_complexity.rs<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfn random_numbers(n: i32) -&gt; Vec&lt;i32&gt; {\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    let mut nums = (1..=n).collect::&lt;Vec&lt;i32&gt;&gt;();\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    nums.shuffle(&amp;mut thread_rng());\n    nums\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfn find_one(nums: &amp;[i32]) -&gt; Option&lt;usize&gt; {\n    for i in 0..nums.len() {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if nums[i] == 1 {\n            return Some(i);\n        }\n    }\n    None\n}\n</code></pre> worst_best_time_complexity.c<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nint *randomNumbers(int n) {\n    // \u5206\u914d\u5806\u533a\u5185\u5b58\uff08\u521b\u5efa\u4e00\u7ef4\u53ef\u53d8\u957f\u6570\u7ec4\uff1a\u6570\u7ec4\u4e2d\u5143\u7d20\u6570\u91cf\u4e3a n \uff0c\u5143\u7d20\u7c7b\u578b\u4e3a int \uff09\n    int *nums = (int *)malloc(n * sizeof(int));\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = i + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    for (int i = n - 1; i &gt; 0; i--) {\n        int j = rand() % (i + 1);\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    return nums;\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nint findOne(int *nums, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i;\n    }\n    return -1;\n}\n</code></pre> worst_best_time_complexity.kt<pre><code>/* \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71 */\nfun randomNumbers(n: Int): Array&lt;Int?&gt; {\n    val nums = IntArray(n)\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (i in 0..&lt;n) {\n        nums[i] = i + 1\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    nums.shuffle()\n    val res = arrayOfNulls&lt;Int&gt;(n)\n    for (i in 0..&lt;n) {\n        res[i] = nums[i]\n    }\n    return res\n}\n\n/* \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 */\nfun findOne(nums: Array&lt;Int?&gt;): Int {\n    for (i in nums.indices) {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (nums[i] == 1)\n            return i\n    }\n    return -1\n}\n</code></pre> worst_best_time_complexity.rb<pre><code>### \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a: 1, 2, ..., n \uff0c\u987a\u5e8f\u88ab\u6253\u4e71 ###\ndef random_numbers(n)\n  # \u751f\u6210\u6570\u7ec4 nums =: 1, 2, 3, ..., n\n  nums = Array.new(n) { |i| i + 1 }\n  # \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n  nums.shuffle!\nend\n\n### \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15 ###\ndef find_one(nums)\n  for i in 0...nums.length\n    # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n    # \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n    return i if nums[i] == 1\n  end\n\n  -1\nend\n</code></pre> worst_best_time_complexity.zig<pre><code>// \u751f\u6210\u4e00\u4e2a\u6570\u7ec4\uff0c\u5143\u7d20\u4e3a { 1, 2, ..., n }\uff0c\u987a\u5e8f\u88ab\u6253\u4e71\nfn randomNumbers(comptime n: usize) [n]i32 {\n    var nums: [n]i32 = undefined;\n    // \u751f\u6210\u6570\u7ec4 nums = { 1, 2, 3, ..., n }\n    for (&amp;nums, 0..) |*num, i| {\n        num.* = @as(i32, @intCast(i)) + 1;\n    }\n    // \u968f\u673a\u6253\u4e71\u6570\u7ec4\u5143\u7d20\n    const rand = std.crypto.random;\n    rand.shuffle(i32, &amp;nums);\n    return nums;\n}\n\n// \u67e5\u627e\u6570\u7ec4 nums \u4e2d\u6570\u5b57 1 \u6240\u5728\u7d22\u5f15\nfn findOne(nums: []i32) i32 {\n    for (nums, 0..) |num, i| {\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5934\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u4f73\u65f6\u95f4\u590d\u6742\u5ea6 O(1)\n        // \u5f53\u5143\u7d20 1 \u5728\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u8fbe\u5230\u6700\u5dee\u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        if (num == 1) return @intCast(i);\n    }\n    return -1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>It's important to note that the best-case time complexity is rarely used in practice, as it is usually only achievable under very low probabilities and might be misleading. The worst-case time complexity is more practical as it provides a safety value for efficiency, allowing us to confidently use the algorithm.</p> <p>From the above example, it's clear that both the worst-case and best-case time complexities only occur under \"special data distributions,\" which may have a small probability of occurrence and may not accurately reflect the algorithm's run efficiency. In contrast, the average time complexity can reflect the algorithm's efficiency under random input data, denoted by the \\(\\Theta\\) notation.</p> <p>For some algorithms, we can simply estimate the average case under a random data distribution. For example, in the aforementioned example, since the input array is shuffled, the probability of element \\(1\\) appearing at any index is equal. Therefore, the average number of loops for the algorithm is half the length of the array \\(n / 2\\), giving an average time complexity of \\(\\Theta(n / 2) = \\Theta(n)\\).</p> <p>However, calculating the average time complexity for more complex algorithms can be quite difficult, as it's challenging to analyze the overall mathematical expectation under the data distribution. In such cases, we usually use the worst-case time complexity as the standard for judging the efficiency of the algorithm.</p> <p>Why is the \\(\\Theta\\) symbol rarely seen?</p> <p>Possibly because the \\(O\\) notation is more commonly spoken, it is often used to represent the average time complexity. However, strictly speaking, this practice is not accurate. In this book and other materials, if you encounter statements like \"average time complexity \\(O(n)\\)\", please understand it directly as \\(\\Theta(n)\\).</p>"},{"location":"chapter_data_structure/","title":"Chapter 3. \u00a0 Data structures","text":"<p>Abstract</p> <p>Data structures serve as a robust and diverse framework.</p> <p>They offer a blueprint for the orderly organization of data, upon which algorithms come to life.</p>"},{"location":"chapter_data_structure/#chapter-contents","title":"Chapter contents","text":"<ul> <li>3.1 \u00a0 Classification of data structures</li> <li>3.2 \u00a0 Basic data types</li> <li>3.3 \u00a0 Number encoding *</li> <li>3.4 \u00a0 Character encoding *</li> <li>3.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_data_structure/basic_data_types/","title":"3.2 \u00a0 Basic data types","text":"<p>When discussing data in computers, various forms like text, images, videos, voice and 3D models comes to mind. Despite their different organizational forms, they are all composed of various basic data types.</p> <p>Basic data types are those that the CPU can directly operate on and are directly used in algorithms, mainly including the following.</p> <ul> <li>Integer types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>.</li> <li>Floating-point types: <code>float</code>, <code>double</code>, used to represent decimals.</li> <li>Character type: <code>char</code>, used to represent letters, punctuation, and even emojis in various languages.</li> <li>Boolean type: <code>bool</code>, used to represent \"yes\" or \"no\" decisions.</li> </ul> <p>Basic data types are stored in computers in binary form. One binary digit is 1 bit. In most modern operating systems, 1 byte consists of 8 bits.</p> <p>The range of values for basic data types depends on the size of the space they occupy. Below, we take Java as an example.</p> <ul> <li>The integer type <code>byte</code> occupies 1 byte = 8 bits and can represent \\(2^8\\) numbers.</li> <li>The integer type <code>int</code> occupies 4 bytes = 32 bits and can represent \\(2^{32}\\) numbers.</li> </ul> <p>The following table lists the space occupied, value range, and default values of various basic data types in Java. While memorizing this table isn't necessary, having a general understanding of it and referencing it when required is recommended.</p> <p> Table 3-1 \u00a0 Space occupied and value range of basic data types </p> Type Symbol Space Occupied Minimum Value Maximum Value Default Value Integer <code>byte</code> 1 byte \\(-2^7\\) (\\(-128\\)) \\(2^7 - 1\\) (\\(127\\)) 0 <code>short</code> 2 bytes \\(-2^{15}\\) \\(2^{15} - 1\\) 0 <code>int</code> 4 bytes \\(-2^{31}\\) \\(2^{31} - 1\\) 0 <code>long</code> 8 bytes \\(-2^{63}\\) \\(2^{63} - 1\\) 0 Float <code>float</code> 4 bytes \\(1.175 \\times 10^{-38}\\) \\(3.403 \\times 10^{38}\\) \\(0.0\\text{f}\\) <code>double</code> 8 bytes \\(2.225 \\times 10^{-308}\\) \\(1.798 \\times 10^{308}\\) 0.0 Char <code>char</code> 2 bytes 0 \\(2^{16} - 1\\) 0 Boolean <code>bool</code> 1 byte \\(\\text{false}\\) \\(\\text{true}\\) \\(\\text{false}\\) <p>Please note that the above table is specific to Java's basic data types. Every programming language has its own data type definitions, which might differ in space occupied, value ranges, and default values.</p> <ul> <li>In Python, the integer type <code>int</code> can be of any size, limited only by available memory; the floating-point <code>float</code> is double precision 64-bit; there is no <code>char</code> type, as a single character is actually a string <code>str</code> of length 1.</li> <li>C and C++ do not specify the size of basic data types, it varies with implementation and platform. The above table follows the LP64 data model, used for Unix 64-bit operating systems including Linux and macOS.</li> <li>The size of <code>char</code> in C and C++ is 1 byte, while in most programming languages, it depends on the specific character encoding method, as detailed in the \"Character Encoding\" chapter.</li> <li>Even though representing a boolean only requires 1 bit (0 or 1), it is usually stored in memory as 1 byte. This is because modern computer CPUs typically use 1 byte as the smallest addressable memory unit.</li> </ul> <p>So, what is the connection between basic data types and data structures? We know that data structures are ways to organize and store data in computers. The focus here is on \"structure\" rather than \"data\".</p> <p>If we want to represent \"a row of numbers\", we naturally think of using an array. This is because the linear structure of an array can represent the adjacency and the ordering of the numbers, but whether the stored content is an integer <code>int</code>, a decimal <code>float</code>, or a character <code>char</code>, is irrelevant to the \"data structure\".</p> <p>In other words, basic data types provide the \"content type\" of data, while data structures provide the \"way of organizing\" data. For example, in the following code, we use the same data structure (array) to store and represent different basic data types, including <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, etc.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># Using various basic data types to initialize arrays\nnumbers: list[int] = [0] * 5\ndecimals: list[float] = [0.0] * 5\n# Python's characters are actually strings of length 1\ncharacters: list[str] = ['0'] * 5\nbools: list[bool] = [False] * 5\n# Python's lists can freely store various basic data types and object references\ndata = [0, 0.0, 'a', False, ListNode(0)]\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nint numbers[5];\nfloat decimals[5];\nchar characters[5];\nbool bools[5];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nboolean[] bools = new boolean[5];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nbool[] bools = new bool[5];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nvar numbers = [5]int{}\nvar decimals = [5]float64{}\nvar characters = [5]byte{}\nvar bools = [5]bool{}\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nlet numbers = Array(repeating: 0, count: 5)\nlet decimals = Array(repeating: 0.0, count: 5)\nlet characters: [Character] = Array(repeating: \"a\", count: 5)\nlet bools = Array(repeating: false, count: 5)\n</code></pre> <pre><code>// JavaScript's arrays can freely store various basic data types and objects\nconst array = [0, 0.0, 'a', false];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nconst numbers: number[] = [];\nconst characters: string[] = [];\nconst bools: boolean[] = [];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nList&lt;int&gt; numbers = List.filled(5, 0);\nList&lt;double&gt; decimals = List.filled(5, 0.0);\nList&lt;String&gt; characters = List.filled(5, 'a');\nList&lt;bool&gt; bools = List.filled(5, false);\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nlet numbers: Vec&lt;i32&gt; = vec![0; 5];\nlet decimals: Vec&lt;f32&gt; = vec![0.0, 5];\nlet characters: Vec&lt;char&gt; = vec!['0'; 5];\nlet bools: Vec&lt;bool&gt; = vec![false; 5];\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nint numbers[10];\nfloat decimals[10];\nchar characters[10];\nbool bools[10];\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Using various basic data types to initialize arrays\nvar numbers: [5]i32 = undefined;\nvar decimals: [5]f32 = undefined;\nvar characters: [5]u8 = undefined;\nvar bools: [5]bool = undefined;\n</code></pre>"},{"location":"chapter_data_structure/character_encoding/","title":"3.4 \u00a0 Character encoding *","text":"<p>In the computer system, all data is stored in binary form, and <code>char</code> is no exception. To represent characters, we need to develop a \"character set\" that defines a one-to-one mapping between each character and binary numbers. With the character set, computers can convert binary numbers to characters by looking up the table.</p>"},{"location":"chapter_data_structure/character_encoding/#341-ascii-character-set","title":"3.4.1 \u00a0 ASCII character set","text":"<p>The ASCII code is one of the earliest character sets, officially known as the American Standard Code for Information Interchange. It uses 7 binary digits (the lower 7 bits of a byte) to represent a character, allowing for a maximum of 128 different characters. As shown in Figure 3-6, ASCII includes uppercase and lowercase English letters, numbers 0 ~ 9, various punctuation marks, and certain control characters (such as newline and tab).</p> <p></p> <p> Figure 3-6 \u00a0 ASCII code </p> <p>However, ASCII can only represent English characters. With the globalization of computers, a character set called EASCII was developed to represent more languages. It expands from the 7-bit structure of ASCII to 8 bits, enabling the representation of 256 characters.</p> <p>Globally, various region-specific EASCII character sets have been introduced. The first 128 characters of these sets are consistent with the ASCII, while the remaining 128 characters are defined differently to accommodate the requirements of different languages.</p>"},{"location":"chapter_data_structure/character_encoding/#342-gbk-character-set","title":"3.4.2 \u00a0 GBK character set","text":"<p>Later, it was found that EASCII still could not meet the character requirements of many languages. For instance, there are nearly a hundred thousand Chinese characters, with several thousand used regularly. In 1980, the Standardization Administration of China released the GB2312 character set, which included 6763 Chinese characters, essentially fulfilling the computer processing needs for the Chinese language.</p> <p>However, GB2312 could not handle some rare and traditional characters. The GBK character set expands GB2312 and includes 21886 Chinese characters. In the GBK encoding scheme, ASCII characters are represented with one byte, while Chinese characters use two bytes.</p>"},{"location":"chapter_data_structure/character_encoding/#343-unicode-character-set","title":"3.4.3 \u00a0 Unicode character set","text":"<p>With the rapid evolution of computer technology and a plethora of character sets and encoding standards, numerous problems arose. On the one hand, these character sets generally only defined characters for specific languages and could not function properly in multilingual environments. On the other hand, the existence of multiple character set standards for the same language caused garbled text when information was exchanged between computers using different encoding standards.</p> <p>Researchers of that era thought: What if a comprehensive character set encompassing all global languages and symbols was developed? Wouldn't this resolve the issues associated with cross-linguistic environments and garbled text? Inspired by this idea, the extensive character set, Unicode, was born.</p> <p>Unicode is referred to as \"\u7edf\u4e00\u7801\" (Unified Code) in Chinese, theoretically capable of accommodating over a million characters. It aims to incorporate characters from all over the world into a single set, providing a universal character set for processing and displaying various languages and reducing the issues of garbled text due to different encoding standards.</p> <p>Since its release in 1991, Unicode has continually expanded to include new languages and characters. As of September 2022, Unicode contains 149,186 characters, including characters, symbols, and even emojis from various languages. In the vast Unicode character set, commonly used characters occupy 2 bytes, while some rare characters may occupy 3 or even 4 bytes.</p> <p>Unicode is a universal character set that assigns a number (called a \"code point\") to each character, but it does not specify how these character code points should be stored in a computer system. One might ask: How does a system interpret Unicode code points of varying lengths within a text? For example, given a 2-byte code, how does the system determine if it represents a single 2-byte character or two 1-byte characters?</p> <p>A straightforward solution to this problem is to store all characters as equal-length encodings. As shown in Figure 3-7, each character in \"Hello\" occupies 1 byte, while each character in \"\u7b97\u6cd5\" (algorithm) occupies 2 bytes. We could encode all characters in \"Hello \u7b97\u6cd5\" as 2 bytes by padding the higher bits with zeros. This method would enable the system to interpret a character every 2 bytes, recovering the content of the phrase.</p> <p></p> <p> Figure 3-7 \u00a0 Unicode encoding example </p> <p>However, as ASCII has shown us, encoding English only requires 1 byte. Using the above approach would double the space occupied by English text compared to ASCII encoding, which is a waste of memory space. Therefore, a more efficient Unicode encoding method is needed.</p>"},{"location":"chapter_data_structure/character_encoding/#344-utf-8-encoding","title":"3.4.4 \u00a0 UTF-8 encoding","text":"<p>Currently, UTF-8 has become the most widely used Unicode encoding method internationally. It is a variable-length encoding, using 1 to 4 bytes to represent a character, depending on the complexity of the character. ASCII characters need only 1 byte, Latin and Greek letters require 2 bytes, commonly used Chinese characters need 3 bytes, and some other rare characters need 4 bytes.</p> <p>The encoding rules for UTF-8 are not complex and can be divided into two cases:</p> <ul> <li>For 1-byte characters, set the highest bit to \\(0\\), and the remaining 7 bits to the Unicode code point. Notably, ASCII characters occupy the first 128 code points in the Unicode set. This means that UTF-8 encoding is backward compatible with ASCII. This implies that UTF-8 can be used to parse ancient ASCII text.</li> <li>For characters of length \\(n\\) bytes (where \\(n &gt; 1\\)), set the highest \\(n\\) bits of the first byte to \\(1\\), and the \\((n + 1)^{\\text{th}}\\) bit to \\(0\\); starting from the second byte, set the highest 2 bits of each byte to \\(10\\); the rest of the bits are used to fill the Unicode code point.</li> </ul> <p>Figure 3-8 shows the UTF-8 encoding for \"Hello\u7b97\u6cd5\". It can be observed that since the highest \\(n\\) bits are set to \\(1\\), the system can determine the length of the character as \\(n\\) by counting the number of highest bits set to \\(1\\).</p> <p>But why set the highest 2 bits of the remaining bytes to \\(10\\)? Actually, this \\(10\\) serves as a kind of checksum. If the system starts parsing text from an incorrect byte, the \\(10\\) at the beginning of the byte can help the system quickly detect anomalies.</p> <p>The reason for using \\(10\\) as a checksum is that, under UTF-8 encoding rules, it's impossible for the highest two bits of a character to be \\(10\\). This can be proven by contradiction: If the highest two bits of a character are \\(10\\), it indicates that the character's length is \\(1\\), corresponding to ASCII. However, the highest bit of an ASCII character should be \\(0\\), which contradicts the assumption.</p> <p></p> <p> Figure 3-8 \u00a0 UTF-8 encoding example </p> <p>Apart from UTF-8, other common encoding methods include:</p> <ul> <li>UTF-16 encoding: Uses 2 or 4 bytes to represent a character. All ASCII characters and commonly used non-English characters are represented with 2 bytes; a few characters require 4 bytes. For 2-byte characters, the UTF-16 encoding equals the Unicode code point.</li> <li>UTF-32 encoding: Every character uses 4 bytes. This means UTF-32 occupies more space than UTF-8 and UTF-16, especially for texts with a high proportion of ASCII characters.</li> </ul> <p>From the perspective of storage space, using UTF-8 to represent English characters is very efficient because it only requires 1 byte; using UTF-16 to encode some non-English characters (such as Chinese) can be more efficient because it only requires 2 bytes, while UTF-8 might need 3 bytes.</p> <p>From a compatibility perspective, UTF-8 is the most versatile, with many tools and libraries supporting UTF-8 as a priority.</p>"},{"location":"chapter_data_structure/character_encoding/#345-character-encoding-in-programming-languages","title":"3.4.5 \u00a0 Character encoding in programming languages","text":"<p>Historically, many programming languages utilized fixed-length encodings such as UTF-16 or UTF-32 for processing strings during program execution. This allows strings to be handled as arrays, offering several advantages:</p> <ul> <li>Random access: Strings encoded in UTF-16 can be accessed randomly with ease. For UTF-8, which is a variable-length encoding, locating the \\(i^{th}\\) character requires traversing the string from the start to the \\(i^{th}\\) position, taking \\(O(n)\\) time.</li> <li>Character counting: Similar to random access, counting the number of characters in a UTF-16 encoded string is an \\(O(1)\\) operation. However, counting characters in a UTF-8 encoded string requires traversing the entire string.</li> <li>String operations: Many string operations like splitting, concatenating, inserting, and deleting are easier on UTF-16 encoded strings. These operations generally require additional computation on UTF-8 encoded strings to ensure the validity of the UTF-8 encoding.</li> </ul> <p>The design of character encoding schemes in programming languages is an interesting topic involving various factors:</p> <ul> <li>Java\u2019s <code>String</code> type uses UTF-16 encoding, with each character occupying 2 bytes. This was based on the initial belief that 16 bits were sufficient to represent all possible characters and proven incorrect later. As the Unicode standard expanded beyond 16 bits, characters in Java may now be represented by a pair of 16-bit values, known as \u201csurrogate pairs.\u201d</li> <li>JavaScript and TypeScript use UTF-16 encoding for similar reasons as Java. When JavaScript was first introduced by Netscape in 1995, Unicode was still in its early stages, and 16-bit encoding was sufficient to represent all Unicode characters.</li> <li>C# uses UTF-16 encoding, largely because the .NET platform, designed by Microsoft, and many Microsoft technologies, including the Windows operating system, extensively use UTF-16 encoding.</li> </ul> <p>Due to the underestimation of character counts, these languages had to use \"surrogate pairs\" to represent Unicode characters exceeding 16 bits. This approach has its drawbacks: strings containing surrogate pairs may have characters occupying 2 or 4 bytes, losing the advantage of fixed-length encoding. Additionally, handling surrogate pairs adds complexity and debugging difficulty to programming.</p> <p>Addressing these challenges, some languages have adopted alternative encoding strategies:</p> <ul> <li>Python\u2019s <code>str</code> type uses Unicode encoding with a flexible representation where the storage length of characters depends on the largest Unicode code point in the string. If all characters are ASCII, each character occupies 1 byte, 2 bytes for characters within the Basic Multilingual Plane (BMP), and 4 bytes for characters beyond the BMP.</li> <li>Go\u2019s <code>string</code> type internally uses UTF-8 encoding. Go also provides the <code>rune</code> type for representing individual Unicode code points.</li> <li>Rust\u2019s <code>str</code> and <code>String</code> types use UTF-8 encoding internally. Rust also offers the <code>char</code> type for individual Unicode code points.</li> </ul> <p>It\u2019s important to note that the above discussion pertains to how strings are stored in programming languages, which is different from how strings are stored in files or transmitted over networks. For file storage or network transmission, strings are usually encoded in UTF-8 format for optimal compatibility and space efficiency.</p>"},{"location":"chapter_data_structure/classification_of_data_structure/","title":"3.1 \u00a0 Classification of data structures","text":"<p>Common data structures include arrays, linked lists, stacks, queues, hash tables, trees, heaps, and graphs. They can be classified into \"logical structure\" and \"physical structure\".</p>"},{"location":"chapter_data_structure/classification_of_data_structure/#311-logical-structure-linear-and-non-linear","title":"3.1.1 \u00a0 Logical structure: linear and non-linear","text":"<p>The logical structures reveal the logical relationships between data elements. In arrays and linked lists, data are arranged in a specific sequence, demonstrating the linear relationship between data; while in trees, data are arranged hierarchically from the top down, showing the derived relationship between \"ancestors\" and \"descendants\"; and graphs are composed of nodes and edges, reflecting the intricate network relationship.</p> <p>As shown in Figure 3-1, logical structures can be divided into two major categories: \"linear\" and \"non-linear\". Linear structures are more intuitive, indicating data is arranged linearly in logical relationships; non-linear structures, conversely, are arranged non-linearly.</p> <ul> <li>Linear data structures: Arrays, Linked Lists, Stacks, Queues, Hash Tables.</li> <li>Non-linear data structures: Trees, Heaps, Graphs, Hash Tables.</li> </ul> <p>Non-linear data structures can be further divided into tree structures and network structures.</p> <ul> <li>Tree structures: Trees, Heaps, Hash Tables, where elements have a one-to-many relationship.</li> <li>Network structures: Graphs, where elements have a many-to-many relationships.</li> </ul> <p></p> <p> Figure 3-1 \u00a0 Linear and non-linear data structures </p>"},{"location":"chapter_data_structure/classification_of_data_structure/#312-physical-structure-contiguous-and-dispersed","title":"3.1.2 \u00a0 Physical structure: contiguous and dispersed","text":"<p>During the execution of an algorithm, the data being processed is stored in memory. Figure 3-2 shows a computer memory stick where each black square is a physical memory space. We can think of memory as a vast Excel spreadsheet, with each cell capable of storing a certain amount of data.</p> <p>The system accesses the data at the target location by means of a memory address. As shown in Figure 3-2, the computer assigns a unique identifier to each cell in the table according to specific rules, ensuring that each memory space has a unique memory address. With these addresses, the program can access the data stored in memory.</p> <p></p> <p> Figure 3-2 \u00a0 Memory stick, memory spaces, memory addresses </p> <p>Tip</p> <p>It's worth noting that comparing memory to an Excel spreadsheet is a simplified analogy. The actual working mechanism of memory is more complex, involving concepts like address space, memory management, cache mechanisms, virtual memory, and physical memory.</p> <p>Memory is a shared resource for all programs. When a block of memory is occupied by one program, it cannot be simultaneously used by other programs. Therefore, considering memory resources is crucial in designing data structures and algorithms. For instance, the algorithm's peak memory usage should not exceed the remaining free memory of the system; if there is a lack of contiguous memory blocks, then the data structure chosen must be able to be stored in non-contiguous memory blocks.</p> <p>As illustrated in Figure 3-3, the physical structure reflects the way data is stored in computer memory and it can be divided into contiguous space storage (arrays) and non-contiguous space storage (linked lists). The two types of physical structures exhibit complementary characteristics in terms of time efficiency and space efficiency.</p> <p></p> <p> Figure 3-3 \u00a0 Contiguous space storage and dispersed space storage </p> <p>It is worth noting that all data structures are implemented based on arrays, linked lists, or a combination of both. For example, stacks and queues can be implemented using either arrays or linked lists; while implementations of hash tables may involve both arrays and linked lists.</p> <ul> <li>Array-based implementations: Stacks, Queues, Hash Tables, Trees, Heaps, Graphs, Matrices, Tensors (arrays with dimensions \\(\\geq 3\\)).</li> <li>Linked-list-based implementations: Stacks, Queues, Hash Tables, Trees, Heaps, Graphs, etc.</li> </ul> <p>Data structures implemented based on arrays are also called \u201cStatic Data Structures,\u201d meaning their length cannot be changed after initialization. Conversely, those based on linked lists are called \u201cDynamic Data Structures,\u201d which can still adjust their size during program execution.</p> <p>Tip</p> <p>If you find it challenging to comprehend the physical structure, it is recommended that you read the next chapter, \"Arrays and Linked Lists,\" and revisit this section later.</p>"},{"location":"chapter_data_structure/number_encoding/","title":"3.3 \u00a0 Number encoding *","text":"<p>Tip</p> <p>In this book, chapters marked with an asterisk '*' are optional readings. If you are short on time or find them challenging, you may skip these initially and return to them after completing the essential chapters.</p>"},{"location":"chapter_data_structure/number_encoding/#331-integer-encoding","title":"3.3.1 \u00a0 Integer encoding","text":"<p>In the table from the previous section, we observed that all integer types can represent one more negative number than positive numbers, such as the <code>byte</code> range of \\([-128, 127]\\). This phenomenon seems counterintuitive, and its underlying reason involves knowledge of sign-magnitude, one's complement, and two's complement encoding.</p> <p>Firstly, it's important to note that numbers are stored in computers using the two's complement form. Before analyzing why this is the case, let's define these three encoding methods:</p> <ul> <li>Sign-magnitude: The highest bit of a binary representation of a number is considered the sign bit, where \\(0\\) represents a positive number and \\(1\\) represents a negative number. The remaining bits represent the value of the number.</li> <li>One's complement: The one's complement of a positive number is the same as its sign-magnitude. For negative numbers, it's obtained by inverting all bits except the sign bit.</li> <li>Two's complement: The two's complement of a positive number is the same as its sign-magnitude. For negative numbers, it's obtained by adding \\(1\\) to their one's complement.</li> </ul> <p>The following diagram illustrates the conversions among sign-magnitude, one's complement, and two's complement:</p> <p></p> <p> Figure 3-4 \u00a0 Conversions between sign-magnitude, one's complement, and two's complement </p> <p>Although sign-magnitude is the most intuitive, it has limitations. For one, negative numbers in sign-magnitude cannot be directly used in calculations. For example, in sign-magnitude, calculating \\(1 + (-2)\\) results in \\(-3\\), which is incorrect.</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 + 1000 \\; 0010 \\newline &amp; = 1000 \\; 0011 \\newline &amp; \\rightarrow -3 \\end{aligned} \\] <p>To address this, computers introduced the one's complement. If we convert to one's complement and calculate \\(1 + (-2)\\), then convert the result back to sign-magnitude, we get the correct result of \\(-1\\).</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 \\; \\text{(Sign-magnitude)} + 1000 \\; 0010 \\; \\text{(Sign-magnitude)} \\newline &amp; = 0000 \\; 0001 \\; \\text{(One's complement)} + 1111 \\; 1101 \\; \\text{(One's complement)} \\newline &amp; = 1111 \\; 1110 \\; \\text{(One's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; \\rightarrow -1 \\end{aligned} \\] <p>Additionally, there are two representations of zero in sign-magnitude: \\(+0\\) and \\(-0\\). This means two different binary encodings for zero, which could lead to ambiguity. For example, in conditional checks, not differentiating between positive and negative zero might result in incorrect outcomes. Addressing this ambiguity would require additional checks, potentially reducing computational efficiency.</p> \\[ \\begin{aligned} +0 &amp; \\rightarrow 0000 \\; 0000 \\newline -0 &amp; \\rightarrow 1000 \\; 0000 \\end{aligned} \\] <p>Like sign-magnitude, one's complement also suffers from the positive and negative zero ambiguity. Therefore, computers further introduced the two's complement. Let's observe the conversion process for negative zero in sign-magnitude, one's complement, and two's complement:</p> \\[ \\begin{aligned} -0 \\rightarrow \\; &amp; 1000 \\; 0000 \\; \\text{(Sign-magnitude)} \\newline = \\; &amp; 1111 \\; 1111 \\; \\text{(One's complement)} \\newline = 1 \\; &amp; 0000 \\; 0000 \\; \\text{(Two's complement)} \\newline \\end{aligned} \\] <p>Adding \\(1\\) to the one's complement of negative zero produces a carry, but with <code>byte</code> length being only 8 bits, the carried-over \\(1\\) to the 9<sup>th</sup> bit is discarded. Therefore, the two's complement of negative zero is \\(0000 \\; 0000\\), the same as positive zero, thus resolving the ambiguity.</p> <p>One last puzzle is the \\([-128, 127]\\) range for <code>byte</code>, with an additional negative number, \\(-128\\). We observe that for the interval \\([-127, +127]\\), all integers have corresponding sign-magnitude, one's complement, and two's complement, allowing for mutual conversion between them.</p> <p>However, the two's complement \\(1000 \\; 0000\\) is an exception without a corresponding sign-magnitude. According to the conversion method, its sign-magnitude would be \\(0000 \\; 0000\\), indicating zero. This presents a contradiction because its two's complement should represent itself. Computers designate this special two's complement \\(1000 \\; 0000\\) as representing \\(-128\\). In fact, the calculation of \\((-1) + (-127)\\) in two's complement results in \\(-128\\).</p> \\[ \\begin{aligned} &amp; (-127) + (-1) \\newline &amp; \\rightarrow 1111 \\; 1111 \\; \\text{(Sign-magnitude)} + 1000 \\; 0001 \\; \\text{(Sign-magnitude)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(One's complement)} + 1111 \\; 1110 \\; \\text{(One's complement)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(Two's complement)} + 1111 \\; 1111 \\; \\text{(Two's complement)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(Two's complement)} \\newline &amp; \\rightarrow -128 \\end{aligned} \\] <p>As you might have noticed, all these calculations are additions, hinting at an important fact: computers' internal hardware circuits are primarily designed around addition operations. This is because addition is simpler to implement in hardware compared to other operations like multiplication, division, and subtraction, allowing for easier parallelization and faster computation.</p> <p>It's important to note that this doesn't mean computers can only perform addition. By combining addition with basic logical operations, computers can execute a variety of other mathematical operations. For example, the subtraction \\(a - b\\) can be translated into \\(a + (-b)\\); multiplication and division can be translated into multiple additions or subtractions.</p> <p>We can now summarize the reason for using two's complement in computers: with two's complement representation, computers can use the same circuits and operations to handle both positive and negative number addition, eliminating the need for special hardware circuits for subtraction and avoiding the ambiguity of positive and negative zero. This greatly simplifies hardware design and enhances computational efficiency.</p> <p>The design of two's complement is quite ingenious, and due to space constraints, we'll stop here. Interested readers are encouraged to explore further.</p>"},{"location":"chapter_data_structure/number_encoding/#332-floating-point-number-encoding","title":"3.3.2 \u00a0 Floating-point number encoding","text":"<p>You might have noticed something intriguing: despite having the same length of 4 bytes, why does a <code>float</code> have a much larger range of values compared to an <code>int</code>? This seems counterintuitive, as one would expect the range to shrink for <code>float</code> since it needs to represent fractions.</p> <p>In fact, this is due to the different representation method used by floating-point numbers (<code>float</code>). Let's consider a 32-bit binary number as:</p> \\[ b_{31} b_{30} b_{29} \\ldots b_2 b_1 b_0 \\] <p>According to the IEEE 754 standard, a 32-bit <code>float</code> consists of the following three parts:</p> <ul> <li>Sign bit \\(\\mathrm{S}\\): Occupies 1 bit, corresponding to \\(b_{31}\\).</li> <li>Exponent bit \\(\\mathrm{E}\\): Occupies 8 bits, corresponding to \\(b_{30} b_{29} \\ldots b_{23}\\).</li> <li>Fraction bit \\(\\mathrm{N}\\): Occupies 23 bits, corresponding to \\(b_{22} b_{21} \\ldots b_0\\).</li> </ul> <p>The value of a binary <code>float</code> number is calculated as:</p> \\[ \\text{val} = (-1)^{b_{31}} \\times 2^{\\left(b_{30} b_{29} \\ldots b_{23}\\right)_2 - 127} \\times \\left(1 . b_{22} b_{21} \\ldots b_0\\right)_2 \\] <p>Converted to a decimal formula, this becomes:</p> \\[ \\text{val} = (-1)^{\\mathrm{S}} \\times 2^{\\mathrm{E} - 127} \\times (1 + \\mathrm{N}) \\] <p>The range of each component is:</p> \\[ \\begin{aligned} \\mathrm{S} \\in &amp; \\{ 0, 1\\}, \\quad \\mathrm{E} \\in \\{ 1, 2, \\dots, 254 \\} \\newline (1 + \\mathrm{N}) = &amp; (1 + \\sum_{i=1}^{23} b_{23-i} \\times 2^{-i}) \\subset [1, 2 - 2^{-23}] \\end{aligned} \\] <p></p> <p> Figure 3-5 \u00a0 Example calculation of a float in IEEE 754 standard </p> <p>Observing the diagram, given an example data \\(\\mathrm{S} = 0\\), \\(\\mathrm{E} = 124\\), \\(\\mathrm{N} = 2^{-2} + 2^{-3} = 0.375\\), we have:</p> \\[ \\text{val} = (-1)^0 \\times 2^{124 - 127} \\times (1 + 0.375) = 0.171875 \\] <p>Now we can answer the initial question: The representation of <code>float</code> includes an exponent bit, leading to a much larger range than <code>int</code>. Based on the above calculation, the maximum positive number representable by <code>float</code> is approximately \\(2^{254 - 127} \\times (2 - 2^{-23}) \\approx 3.4 \\times 10^{38}\\), and the minimum negative number is obtained by switching the sign bit.</p> <p>However, the trade-off for <code>float</code>'s expanded range is a sacrifice in precision. The integer type <code>int</code> uses all 32 bits to represent the number, with values evenly distributed; but due to the exponent bit, the larger the value of a <code>float</code>, the greater the difference between adjacent numbers.</p> <p>As shown in Table 3-2, exponent bits \\(\\mathrm{E} = 0\\) and \\(\\mathrm{E} = 255\\) have special meanings, used to represent zero, infinity, \\(\\mathrm{NaN}\\), etc.</p> <p> Table 3-2 \u00a0 Meaning of exponent bits </p> Exponent Bit E Fraction Bit \\(\\mathrm{N} = 0\\) Fraction Bit \\(\\mathrm{N} \\ne 0\\) Calculation Formula \\(0\\) \\(\\pm 0\\) Subnormal Numbers \\((-1)^{\\mathrm{S}} \\times 2^{-126} \\times (0.\\mathrm{N})\\) \\(1, 2, \\dots, 254\\) Normal Numbers Normal Numbers \\((-1)^{\\mathrm{S}} \\times 2^{(\\mathrm{E} -127)} \\times (1.\\mathrm{N})\\) \\(255\\) \\(\\pm \\infty\\) \\(\\mathrm{NaN}\\) <p>It's worth noting that subnormal numbers significantly improve the precision of floating-point numbers. The smallest positive normal number is \\(2^{-126}\\), and the smallest positive subnormal number is \\(2^{-126} \\times 2^{-23}\\).</p> <p>Double-precision <code>double</code> also uses a similar representation method to <code>float</code>, which is not elaborated here for brevity.</p>"},{"location":"chapter_data_structure/summary/","title":"3.5 \u00a0 Summary","text":""},{"location":"chapter_data_structure/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>Data structures can be categorized from two perspectives: logical structure and physical structure. Logical structure describes the logical relationships between data elements, while physical structure describes how data is stored in computer memory.</li> <li>Common logical structures include linear, tree-like, and network structures. We generally classify data structures into linear (arrays, linked lists, stacks, queues) and non-linear (trees, graphs, heaps) based on their logical structure. The implementation of hash tables may involve both linear and non-linear data structures.</li> <li>When a program runs, data is stored in computer memory. Each memory space has a corresponding memory address, and the program accesses data through these addresses.</li> <li>Physical structures are primarily divided into contiguous space storage (arrays) and dispersed space storage (linked lists). All data structures are implemented using arrays, linked lists, or a combination of both.</li> <li>Basic data types in computers include integers (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>), floating-point numbers (<code>float</code>, <code>double</code>), characters (<code>char</code>), and booleans (<code>boolean</code>). Their range depends on the size of the space occupied and the representation method.</li> <li>Original code, complement code, and two's complement code are three methods of encoding numbers in computers, and they can be converted into each other. The highest bit of the original code of an integer is the sign bit, and the remaining bits represent the value of the number.</li> <li>Integers are stored in computers in the form of two's complement. In this representation, the computer can treat the addition of positive and negative numbers uniformly, without the need for special hardware circuits for subtraction, and there is no ambiguity of positive and negative zero.</li> <li>The encoding of floating-point numbers consists of 1 sign bit, 8 exponent bits, and 23 fraction bits. Due to the presence of the exponent bit, the range of floating-point numbers is much greater than that of integers, but at the cost of sacrificing precision.</li> <li>ASCII is the earliest English character set, 1 byte in length, and includes 127 characters. The GBK character set is a commonly used Chinese character set, including more than 20,000 Chinese characters. Unicode strives to provide a complete character set standard, including characters from various languages worldwide, thus solving the problem of garbled characters caused by inconsistent character encoding methods.</li> <li>UTF-8 is the most popular Unicode encoding method, with excellent universality. It is a variable-length encoding method with good scalability and effectively improves the efficiency of space usage. UTF-16 and UTF-32 are fixed-length encoding methods. When encoding Chinese characters, UTF-16 occupies less space than UTF-8. Programming languages like Java and C# use UTF-16 encoding by default.</li> </ul>"},{"location":"chapter_data_structure/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Why does a hash table contain both linear and non-linear data structures?</p> <p>The underlying structure of a hash table is an array. To resolve hash collisions, we may use \"chaining\": each bucket in the array points to a linked list, which, when exceeding a certain threshold, might be transformed into a tree (usually a red-black tree). From a storage perspective, the foundation of a hash table is an array, where each bucket slot might contain a value, a linked list, or a tree. Therefore, hash tables may contain both linear data structures (arrays, linked lists) and non-linear data structures (trees).</p> <p>Q: Is the length of the <code>char</code> type 1 byte?</p> <p>The length of the <code>char</code> type is determined by the encoding method used by the programming language. For example, Java, JavaScript, TypeScript, and C# all use UTF-16 encoding (to save Unicode code points), so the length of the char type is 2 bytes.</p> <p>Q: Is there ambiguity in calling data structures based on arrays \"static data structures\"? Because operations like push and pop on stacks are \"dynamic\".</p> <p>While stacks indeed allow for dynamic data operations, the data structure itself remains \"static\" (with unchangeable length). Even though data structures based on arrays can dynamically add or remove elements, their capacity is fixed. If the data volume exceeds the pre-allocated size, a new, larger array needs to be created, and the contents of the old array copied into it.</p> <p>Q: When building stacks (queues) without specifying their size, why are they considered \"static data structures\"?</p> <p>In high-level programming languages, we don't need to manually specify the initial capacity of stacks (queues); this task is automatically handled internally by the class. For example, the initial capacity of Java's ArrayList is usually 10. Furthermore, the expansion operation is also implemented automatically. See the subsequent \"List\" chapter for details.</p>"},{"location":"chapter_divide_and_conquer/","title":"Chapter 12. \u00a0 Divide and conquer","text":"<p>Abstract</p> <p>Difficult problems are decomposed layer by layer, each decomposition making them simpler.</p> <p>Divide and conquer reveals an important truth: start with simplicity, and nothing is complex anymore.</p>"},{"location":"chapter_divide_and_conquer/#chapter-contents","title":"Chapter contents","text":"<ul> <li>12.1 \u00a0 Divide and conquer algorithms</li> <li>12.2 \u00a0 Divide and conquer search strategy</li> <li>12.3 \u00a0 Building binary tree problem</li> <li>12.4 \u00a0 Tower of Hanoi Problem</li> <li>12.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_divide_and_conquer/binary_search_recur/","title":"12.2 \u00a0 Divide and conquer search strategy","text":"<p>We have learned that search algorithms fall into two main categories.</p> <ul> <li>Brute-force search: It is implemented by traversing the data structure, with a time complexity of \\(O(n)\\).</li> <li>Adaptive search: It utilizes a unique data organization form or prior information, and its time complexity can reach \\(O(\\log n)\\) or even \\(O(1)\\).</li> </ul> <p>In fact, search algorithms with a time complexity of \\(O(\\log n)\\) are usually based on the divide-and-conquer strategy, such as binary search and trees.</p> <ul> <li>Each step of binary search divides the problem (searching for a target element in an array) into a smaller problem (searching for the target element in half of the array), continuing until the array is empty or the target element is found.</li> <li>Trees represent the divide-and-conquer idea, where in data structures like binary search trees, AVL trees, and heaps, the time complexity of various operations is \\(O(\\log n)\\).</li> </ul> <p>The divide-and-conquer strategy of binary search is as follows.</p> <ul> <li>The problem can be divided: Binary search recursively divides the original problem (searching in an array) into subproblems (searching in half of the array), achieved by comparing the middle element with the target element.</li> <li>Subproblems are independent: In binary search, each round handles one subproblem, unaffected by other subproblems.</li> <li>The solutions of subproblems do not need to be merged: Binary search aims to find a specific element, so there is no need to merge the solutions of subproblems. When a subproblem is solved, the original problem is also solved.</li> </ul> <p>Divide-and-conquer can enhance search efficiency because brute-force search can only eliminate one option per round, whereas divide-and-conquer can eliminate half of the options.</p>"},{"location":"chapter_divide_and_conquer/binary_search_recur/#1-implementing-binary-search-based-on-divide-and-conquer","title":"1. \u00a0 Implementing binary search based on divide-and-conquer","text":"<p>In previous chapters, binary search was implemented based on iteration. Now, we implement it based on divide-and-conquer (recursion).</p> <p>Question</p> <p>Given an ordered array <code>nums</code> of length \\(n\\), where all elements are unique, please find the element <code>target</code>.</p> <p>From a divide-and-conquer perspective, we denote the subproblem corresponding to the search interval \\([i, j]\\) as \\(f(i, j)\\).</p> <p>Starting from the original problem \\(f(0, n-1)\\), perform the binary search through the following steps.</p> <ol> <li>Calculate the midpoint \\(m\\) of the search interval \\([i, j]\\), and use it to eliminate half of the search interval.</li> <li>Recursively solve the subproblem reduced by half in size, which could be \\(f(i, m-1)\\) or \\(f(m+1, j)\\).</li> <li>Repeat steps <code>1.</code> and <code>2.</code>, until <code>target</code> is found or the interval is empty and returns.</li> </ol> <p>The diagram below shows the divide-and-conquer process of binary search for element \\(6\\) in an array.</p> <p></p> <p> Figure 12-4 \u00a0 The divide-and-conquer process of binary search </p> <p>In the implementation code, we declare a recursive function <code>dfs()</code> to solve the problem \\(f(i, j)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_recur.py<pre><code>def dfs(nums: list[int], target: int, i: int, j: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j)\"\"\"\n    # \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if i &gt; j:\n        return -1\n    # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    m = (i + j) // 2\n    if nums[m] &lt; target:\n        # \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j)\n    elif nums[m] &gt; target:\n        # \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1)\n    else:\n        # \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m\n\ndef binary_search(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\"\"\"\n    n = len(nums)\n    # \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1)\n</code></pre> binary_search_recur.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nint dfs(vector&lt;int&gt; &amp;nums, int target, int i, int j) {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n    int n = nums.size();\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nint dfs(int[] nums, int target, int i, int j) {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nint binarySearch(int[] nums, int target) {\n    int n = nums.length;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nint DFS(int[] nums, int target, int i, int j) {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return DFS(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return DFS(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nint BinarySearch(int[] nums, int target) {\n    int n = nums.Length;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return DFS(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfunc dfs(nums []int, target, i, j int) int {\n    // \u5982\u679c\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u6ca1\u6709\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if i &gt; j {\n        return -1\n    }\n    //    \u8ba1\u7b97\u7d22\u5f15\u4e2d\u70b9\n    m := i + ((j - i) &gt;&gt; 1)\n    //\u5224\u65ad\u4e2d\u70b9\u4e0e\u76ee\u6807\u5143\u7d20\u5927\u5c0f\n    if nums[m] &lt; target {\n        // \u5c0f\u4e8e\u5219\u9012\u5f52\u53f3\u534a\u6570\u7ec4\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m+1, j)\n    } else if nums[m] &gt; target {\n        // \u5c0f\u4e8e\u5219\u9012\u5f52\u5de6\u534a\u6570\u7ec4\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m-1)\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfunc binarySearch(nums []int, target int) int {\n    n := len(nums)\n    return dfs(nums, target, 0, n-1)\n}\n</code></pre> binary_search_recur.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfunc dfs(nums: [Int], target: Int, i: Int, j: Int) -&gt; Int {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if i &gt; j {\n        return -1\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    let m = (i + j) / 2\n    if nums[m] &lt; target {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums: nums, target: target, i: m + 1, j: j)\n    } else if nums[m] &gt; target {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums: nums, target: target, i: i, j: m - 1)\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfunc binarySearch(nums: [Int], target: Int) -&gt; Int {\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    dfs(nums: nums, target: target, i: nums.startIndex, j: nums.endIndex - 1)\n}\n</code></pre> binary_search_recur.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfunction dfs(nums, target, i, j) {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    const m = i + ((j - i) &gt;&gt; 1);\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfunction binarySearch(nums, target) {\n    const n = nums.length;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfunction dfs(nums: number[], target: number, i: number, j: number): number {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    const m = i + ((j - i) &gt;&gt; 1);\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfunction binarySearch(nums: number[], target: number): number {\n    const n = nums.length;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nint dfs(List&lt;int&gt; nums, int target, int i, int j) {\n  // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n  if (i &gt; j) {\n    return -1;\n  }\n  // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n  int m = (i + j) ~/ 2;\n  if (nums[m] &lt; target) {\n    // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n    return dfs(nums, target, m + 1, j);\n  } else if (nums[m] &gt; target) {\n    // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n    return dfs(nums, target, i, m - 1);\n  } else {\n    // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    return m;\n  }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nint binarySearch(List&lt;int&gt; nums, int target) {\n  int n = nums.length;\n  // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n  return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfn dfs(nums: &amp;[i32], target: i32, i: i32, j: i32) -&gt; i32 {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if i &gt; j {\n        return -1;\n    }\n    let m: i32 = (i + j) / 2;\n    if nums[m as usize] &lt; target {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if nums[m as usize] &gt; target {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfn binary_search(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let n = nums.len() as i32;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    dfs(nums, target, 0, n - 1)\n}\n</code></pre> binary_search_recur.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nint dfs(int nums[], int target, int i, int j) {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1;\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    int m = (i + j) / 2;\n    if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        return dfs(nums, target, m + 1, j);\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        return dfs(nums, target, i, m - 1);\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        return m;\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nint binarySearch(int nums[], int target, int numsSize) {\n    int n = numsSize;\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1);\n}\n</code></pre> binary_search_recur.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff1a\u95ee\u9898 f(i, j) */\nfun dfs(\n    nums: IntArray,\n    target: Int,\n    i: Int,\n    j: Int\n): Int {\n    // \u82e5\u533a\u95f4\u4e3a\u7a7a\uff0c\u4ee3\u8868\u65e0\u76ee\u6807\u5143\u7d20\uff0c\u5219\u8fd4\u56de -1\n    if (i &gt; j) {\n        return -1\n    }\n    // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    val m = (i + j) / 2\n    return if (nums[m] &lt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(m+1, j)\n        dfs(nums, target, m + 1, j)\n    } else if (nums[m] &gt; target) {\n        // \u9012\u5f52\u5b50\u95ee\u9898 f(i, m-1)\n        dfs(nums, target, i, m - 1)\n    } else {\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        m\n    }\n}\n\n/* \u4e8c\u5206\u67e5\u627e */\nfun binarySearch(nums: IntArray, target: Int): Int {\n    val n = nums.size\n    // \u6c42\u89e3\u95ee\u9898 f(0, n-1)\n    return dfs(nums, target, 0, n - 1)\n}\n</code></pre> binary_search_recur.rb<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{binary_search}\n</code></pre> binary_search_recur.zig<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{binarySearch}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/","title":"12.3 \u00a0 Building binary tree problem","text":"<p>Question</p> <p>Given the preorder traversal <code>preorder</code> and inorder traversal <code>inorder</code> of a binary tree, construct the binary tree and return the root node of the binary tree. Assume that there are no duplicate values in the nodes of the binary tree (as shown in the diagram below).</p> <p></p> <p> Figure 12-5 \u00a0 Example data for building a binary tree </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#1-determining-if-it-is-a-divide-and-conquer-problem","title":"1. \u00a0 Determining if it is a divide and conquer problem","text":"<p>The original problem of constructing a binary tree from <code>preorder</code> and <code>inorder</code> is a typical divide and conquer problem.</p> <ul> <li>The problem can be decomposed: From the perspective of divide and conquer, we can divide the original problem into two subproblems: building the left subtree and building the right subtree, plus one operation: initializing the root node. For each subtree (subproblem), we can still use the above division method, dividing it into smaller subtrees (subproblems), until the smallest subproblem (empty subtree) is reached.</li> <li>The subproblems are independent: The left and right subtrees are independent of each other, with no overlap. When building the left subtree, we only need to focus on the parts of the inorder and preorder traversals that correspond to the left subtree. The same applies to the right subtree.</li> <li>Solutions to subproblems can be combined: Once the solutions for the left and right subtrees (solutions to subproblems) are obtained, we can link them to the root node to obtain the solution to the original problem.</li> </ul>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#2-how-to-divide-the-subtrees","title":"2. \u00a0 How to divide the subtrees","text":"<p>Based on the above analysis, this problem can be solved using divide and conquer, but how do we use the preorder traversal <code>preorder</code> and inorder traversal <code>inorder</code> to divide the left and right subtrees?</p> <p>By definition, <code>preorder</code> and <code>inorder</code> can be divided into three parts.</p> <ul> <li>Preorder traversal: <code>[ Root | Left Subtree | Right Subtree ]</code>, for example, the tree in the diagram corresponds to <code>[ 3 | 9 | 2 1 7 ]</code>.</li> <li>Inorder traversal: <code>[ Left Subtree | Root | Right Subtree ]</code>, for example, the tree in the diagram corresponds to <code>[ 9 | 3 | 1 2 7 ]</code>.</li> </ul> <p>Using the data in the diagram above, we can obtain the division results as shown in the steps below.</p> <ol> <li>The first element 3 in the preorder traversal is the value of the root node.</li> <li>Find the index of the root node 3 in <code>inorder</code>, and use this index to divide <code>inorder</code> into <code>[ 9 | 3 \uff5c 1 2 7 ]</code>.</li> <li>Based on the division results of <code>inorder</code>, it is easy to determine the number of nodes in the left and right subtrees as 1 and 3, respectively, thus dividing <code>preorder</code> into <code>[ 3 | 9 | 2 1 7 ]</code>.</li> </ol> <p></p> <p> Figure 12-6 \u00a0 Dividing the subtrees in preorder and inorder traversals </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#3-describing-subtree-intervals-based-on-variables","title":"3. \u00a0 Describing subtree intervals based on variables","text":"<p>Based on the above division method, we have now obtained the index intervals of the root, left subtree, and right subtree in <code>preorder</code> and <code>inorder</code>. To describe these index intervals, we need the help of several pointer variables.</p> <ul> <li>Let the index of the current tree's root node in <code>preorder</code> be denoted as \\(i\\).</li> <li>Let the index of the current tree's root node in <code>inorder</code> be denoted as \\(m\\).</li> <li>Let the index interval of the current tree in <code>inorder</code> be denoted as \\([l, r]\\).</li> </ul> <p>As shown in Table 12-1, the above variables can represent the index of the root node in <code>preorder</code> as well as the index intervals of the subtrees in <code>inorder</code>.</p> <p> Table 12-1 \u00a0 Indexes of the root node and subtrees in preorder and inorder traversals </p> Root node index in <code>preorder</code> Subtree index interval in <code>inorder</code> Current tree \\(i\\) \\([l, r]\\) Left subtree \\(i + 1\\) \\([l, m-1]\\) Right subtree \\(i + 1 + (m - l)\\) \\([m+1, r]\\) <p>Please note, the meaning of \\((m-l)\\) in the right subtree root index is \"the number of nodes in the left subtree\", which is suggested to be understood in conjunction with the diagram below.</p> <p></p> <p> Figure 12-7 \u00a0 Indexes of the root node and left and right subtrees </p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#4-code-implementation","title":"4. \u00a0 Code implementation","text":"<p>To improve the efficiency of querying \\(m\\), we use a hash table <code>hmap</code> to store the mapping of elements in <code>inorder</code> to their indexes:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig build_tree.py<pre><code>def dfs(\n    preorder: list[int],\n    inorder_map: dict[int, int],\n    i: int,\n    l: int,\n    r: int,\n) -&gt; TreeNode | None:\n    \"\"\"\u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb\"\"\"\n    # \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if r - l &lt; 0:\n        return None\n    # \u521d\u59cb\u5316\u6839\u8282\u70b9\n    root = TreeNode(preorder[i])\n    # \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    m = inorder_map[preorder[i]]\n    # \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder, inorder_map, i + 1, l, m - 1)\n    # \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder, inorder_map, i + 1 + m - l, m + 1, r)\n    # \u8fd4\u56de\u6839\u8282\u70b9\n    return root\n\ndef build_tree(preorder: list[int], inorder: list[int]) -&gt; TreeNode | None:\n    \"\"\"\u6784\u5efa\u4e8c\u53c9\u6811\"\"\"\n    # \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    root = dfs(preorder, inorder_map, 0, 0, len(inorder) - 1)\n    return root\n</code></pre> build_tree.cpp<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nTreeNode *dfs(vector&lt;int&gt; &amp;preorder, unordered_map&lt;int, int&gt; &amp;inorderMap, int i, int l, int r) {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0)\n        return NULL;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    TreeNode *root = new TreeNode(preorder[i]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    int m = inorderMap[preorder[i]];\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root-&gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root-&gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nTreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    unordered_map&lt;int, int&gt; inorderMap;\n    for (int i = 0; i &lt; inorder.size(); i++) {\n        inorderMap[inorder[i]] = i;\n    }\n    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorder.size() - 1);\n    return root;\n}\n</code></pre> build_tree.java<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nTreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; inorderMap, int i, int l, int r) {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0)\n        return null;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    TreeNode root = new TreeNode(preorder[i]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    int m = inorderMap.get(preorder[i]);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nTreeNode buildTree(int[] preorder, int[] inorder) {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;();\n    for (int i = 0; i &lt; inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n    TreeNode root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.cs<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nTreeNode? DFS(int[] preorder, Dictionary&lt;int, int&gt; inorderMap, int i, int l, int r) {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0)\n        return null;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    TreeNode root = new(preorder[i]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    int m = inorderMap[preorder[i]];\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = DFS(preorder, inorderMap, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = DFS(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nTreeNode? BuildTree(int[] preorder, int[] inorder) {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    Dictionary&lt;int, int&gt; inorderMap = [];\n    for (int i = 0; i &lt; inorder.Length; i++) {\n        inorderMap.TryAdd(inorder[i], i);\n    }\n    TreeNode? root = DFS(preorder, inorderMap, 0, 0, inorder.Length - 1);\n    return root;\n}\n</code></pre> build_tree.go<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfunc dfsBuildTree(preorder []int, inorderMap map[int]int, i, l, r int) *TreeNode {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if r-l &lt; 0 {\n        return nil\n    }\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    root := NewTreeNode(preorder[i])\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    m := inorderMap[preorder[i]]\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.Left = dfsBuildTree(preorder, inorderMap, i+1, l, m-1)\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.Right = dfsBuildTree(preorder, inorderMap, i+1+m-l, m+1, r)\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfunc buildTree(preorder, inorder []int) *TreeNode {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    inorderMap := make(map[int]int, len(inorder))\n    for i := 0; i &lt; len(inorder); i++ {\n        inorderMap[inorder[i]] = i\n    }\n\n    root := dfsBuildTree(preorder, inorderMap, 0, 0, len(inorder)-1)\n    return root\n}\n</code></pre> build_tree.swift<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfunc dfs(preorder: [Int], inorderMap: [Int: Int], i: Int, l: Int, r: Int) -&gt; TreeNode? {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if r - l &lt; 0 {\n        return nil\n    }\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    let root = TreeNode(x: preorder[i])\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    let m = inorderMap[preorder[i]]!\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder: preorder, inorderMap: inorderMap, i: i + 1, l: l, r: m - 1)\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder: preorder, inorderMap: inorderMap, i: i + 1 + m - l, l: m + 1, r: r)\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfunc buildTree(preorder: [Int], inorder: [Int]) -&gt; TreeNode? {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    let inorderMap = inorder.enumerated().reduce(into: [:]) { $0[$1.element] = $1.offset }\n    return dfs(preorder: preorder, inorderMap: inorderMap, i: inorder.startIndex, l: inorder.startIndex, r: inorder.endIndex - 1)\n}\n</code></pre> build_tree.js<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfunction dfs(preorder, inorderMap, i, l, r) {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0) return null;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    const root = new TreeNode(preorder[i]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    const m = inorderMap.get(preorder[i]);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfunction buildTree(preorder, inorder) {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    let inorderMap = new Map();\n    for (let i = 0; i &lt; inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    const root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.ts<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfunction dfs(\n    preorder: number[],\n    inorderMap: Map&lt;number, number&gt;,\n    i: number,\n    l: number,\n    r: number\n): TreeNode | null {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0) return null;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    const root: TreeNode = new TreeNode(preorder[i]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    const m = inorderMap.get(preorder[i]);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    let inorderMap = new Map&lt;number, number&gt;();\n    for (let i = 0; i &lt; inorder.length; i++) {\n        inorderMap.set(inorder[i], i);\n    }\n    const root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n    return root;\n}\n</code></pre> build_tree.dart<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nTreeNode? dfs(\n  List&lt;int&gt; preorder,\n  Map&lt;int, int&gt; inorderMap,\n  int i,\n  int l,\n  int r,\n) {\n  // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n  if (r - l &lt; 0) {\n    return null;\n  }\n  // \u521d\u59cb\u5316\u6839\u8282\u70b9\n  TreeNode? root = TreeNode(preorder[i]);\n  // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n  int m = inorderMap[preorder[i]]!;\n  // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n  root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n  // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n  root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n  // \u8fd4\u56de\u6839\u8282\u70b9\n  return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nTreeNode? buildTree(List&lt;int&gt; preorder, List&lt;int&gt; inorder) {\n  // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n  Map&lt;int, int&gt; inorderMap = {};\n  for (int i = 0; i &lt; inorder.length; i++) {\n    inorderMap[inorder[i]] = i;\n  }\n  TreeNode? root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n  return root;\n}\n</code></pre> build_tree.rs<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfn dfs(\n    preorder: &amp;[i32],\n    inorder_map: &amp;HashMap&lt;i32, i32&gt;,\n    i: i32,\n    l: i32,\n    r: i32,\n) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if r - l &lt; 0 {\n        return None;\n    }\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    let root = TreeNode::new(preorder[i as usize]);\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    let m = inorder_map.get(&amp;preorder[i as usize]).unwrap();\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.borrow_mut().left = dfs(preorder, inorder_map, i + 1, l, m - 1);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.borrow_mut().right = dfs(preorder, inorder_map, i + 1 + m - l, m + 1, r);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    Some(root)\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfn build_tree(preorder: &amp;[i32], inorder: &amp;[i32]) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    let mut inorder_map: HashMap&lt;i32, i32&gt; = HashMap::new();\n    for i in 0..inorder.len() {\n        inorder_map.insert(inorder[i], i as i32);\n    }\n    let root = dfs(preorder, &amp;inorder_map, 0, 0, inorder.len() as i32 - 1);\n    root\n}\n</code></pre> build_tree.c<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nTreeNode *dfs(int *preorder, int *inorderMap, int i, int l, int r, int size) {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0)\n        return NULL;\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    TreeNode *root = (TreeNode *)malloc(sizeof(TreeNode));\n    root-&gt;val = preorder[i];\n    root-&gt;left = NULL;\n    root-&gt;right = NULL;\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    int m = inorderMap[preorder[i]];\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root-&gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1, size);\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root-&gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r, size);\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root;\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nTreeNode *buildTree(int *preorder, int preorderSize, int *inorder, int inorderSize) {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    int *inorderMap = (int *)malloc(sizeof(int) * MAX_SIZE);\n    for (int i = 0; i &lt; inorderSize; i++) {\n        inorderMap[inorder[i]] = i;\n    }\n    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorderSize - 1, inorderSize);\n    free(inorderMap);\n    return root;\n}\n</code></pre> build_tree.kt<pre><code>/* \u6784\u5efa\u4e8c\u53c9\u6811\uff1a\u5206\u6cbb */\nfun dfs(\n    preorder: IntArray,\n    inorderMap: Map&lt;Int?, Int?&gt;,\n    i: Int,\n    l: Int,\n    r: Int\n): TreeNode? {\n    // \u5b50\u6811\u533a\u95f4\u4e3a\u7a7a\u65f6\u7ec8\u6b62\n    if (r - l &lt; 0) return null\n    // \u521d\u59cb\u5316\u6839\u8282\u70b9\n    val root = TreeNode(preorder[i])\n    // \u67e5\u8be2 m \uff0c\u4ece\u800c\u5212\u5206\u5de6\u53f3\u5b50\u6811\n    val m = inorderMap[preorder[i]]!!\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u5de6\u5b50\u6811\n    root.left = dfs(preorder, inorderMap, i + 1, l, m - 1)\n    // \u5b50\u95ee\u9898\uff1a\u6784\u5efa\u53f3\u5b50\u6811\n    root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r)\n    // \u8fd4\u56de\u6839\u8282\u70b9\n    return root\n}\n\n/* \u6784\u5efa\u4e8c\u53c9\u6811 */\nfun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? {\n    // \u521d\u59cb\u5316\u54c8\u5e0c\u8868\uff0c\u5b58\u50a8 inorder \u5143\u7d20\u5230\u7d22\u5f15\u7684\u6620\u5c04\n    val inorderMap = HashMap&lt;Int?, Int?&gt;()\n    for (i in inorder.indices) {\n        inorderMap[inorder[i]] = i\n    }\n    val root = dfs(preorder, inorderMap, 0, 0, inorder.size - 1)\n    return root\n}\n</code></pre> build_tree.rb<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{build_tree}\n</code></pre> build_tree.zig<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{buildTree}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The diagram below shows the recursive process of building the binary tree, where each node is established during the \"descending\" process, and each edge (reference) is established during the \"ascending\" process.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 12-8 \u00a0 Recursive process of building a binary tree </p> <p>Each recursive function's division results of <code>preorder</code> and <code>inorder</code> are shown in the diagram below.</p> <p></p> <p> Figure 12-9 \u00a0 Division results in each recursive function </p> <p>Assuming the number of nodes in the tree is \\(n\\), initializing each node (executing a recursive function <code>dfs()</code>) takes \\(O(1)\\) time. Thus, the overall time complexity is \\(O(n)\\).</p> <p>The hash table stores the mapping of <code>inorder</code> elements to their indexes, with a space complexity of \\(O(n)\\). In the worst case, when the binary tree degenerates into a linked list, the recursive depth reaches \\(n\\), using \\(O(n)\\) stack frame space. Therefore, the overall space complexity is \\(O(n)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/","title":"12.1 \u00a0 Divide and conquer algorithms","text":"<p>Divide and conquer, fully referred to as \"divide and rule\", is an extremely important and common algorithm strategy. Divide and conquer is usually based on recursion and includes two steps: \"divide\" and \"conquer\".</p> <ol> <li>Divide (partition phase): Recursively decompose the original problem into two or more sub-problems until the smallest sub-problem is reached and the process terminates.</li> <li>Conquer (merge phase): Starting from the smallest sub-problem with a known solution, merge the solutions of the sub-problems from bottom to top to construct the solution to the original problem.</li> </ol> <p>As shown in Figure 12-1, \"merge sort\" is one of the typical applications of the divide and conquer strategy.</p> <ol> <li>Divide: Recursively divide the original array (original problem) into two sub-arrays (sub-problems), until the sub-array has only one element (smallest sub-problem).</li> <li>Conquer: Merge the ordered sub-arrays (solutions to the sub-problems) from bottom to top to obtain an ordered original array (solution to the original problem).</li> </ol> <p></p> <p> Figure 12-1 \u00a0 Merge sort's divide and conquer strategy </p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1211-how-to-identify-divide-and-conquer-problems","title":"12.1.1 \u00a0 How to identify divide and conquer problems","text":"<p>Whether a problem is suitable for a divide and conquer solution can usually be judged based on the following criteria.</p> <ol> <li>The problem can be decomposed: The original problem can be decomposed into smaller, similar sub-problems and can be recursively divided in the same manner.</li> <li>Sub-problems are independent: There is no overlap between sub-problems, and they are independent and can be solved separately.</li> <li>Solutions to sub-problems can be merged: The solution to the original problem is obtained by merging the solutions of the sub-problems.</li> </ol> <p>Clearly, merge sort meets these three criteria.</p> <ol> <li>The problem can be decomposed: Recursively divide the array (original problem) into two sub-arrays (sub-problems).</li> <li>Sub-problems are independent: Each sub-array can be sorted independently (sub-problems can be solved independently).</li> <li>Solutions to sub-problems can be merged: Two ordered sub-arrays (solutions to the sub-problems) can be merged into one ordered array (solution to the original problem).</li> </ol>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1212-improving-efficiency-through-divide-and-conquer","title":"12.1.2 \u00a0 Improving efficiency through divide and conquer","text":"<p>Divide and conquer can not only effectively solve algorithm problems but often also improve algorithm efficiency. In sorting algorithms, quicksort, merge sort, and heap sort are faster than selection, bubble, and insertion sorts because they apply the divide and conquer strategy.</p> <p>Then, we may ask: Why can divide and conquer improve algorithm efficiency, and what is the underlying logic? In other words, why are the steps of decomposing a large problem into multiple sub-problems, solving the sub-problems, and merging the solutions of the sub-problems into the solution of the original problem more efficient than directly solving the original problem? This question can be discussed from the aspects of the number of operations and parallel computation.</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1-optimization-of-operation-count","title":"1. \u00a0 Optimization of operation count","text":"<p>Taking \"bubble sort\" as an example, it requires \\(O(n^2)\\) time to process an array of length \\(n\\). Suppose we divide the array from the midpoint into two sub-arrays as shown in Figure 12-2, then the division requires \\(O(n)\\) time, sorting each sub-array requires \\(O((n / 2)^2)\\) time, and merging the two sub-arrays requires \\(O(n)\\) time, with the total time complexity being:</p> \\[ O(n + (\\frac{n}{2})^2 \\times 2 + n) = O(\\frac{n^2}{2} + 2n) \\] <p></p> <p> Figure 12-2 \u00a0 Bubble sort before and after array partition </p> <p>Next, we calculate the following inequality, where the left and right sides are the total number of operations before and after the partition, respectively:</p> \\[ \\begin{aligned} n^2 &amp; &gt; \\frac{n^2}{2} + 2n \\newline n^2 - \\frac{n^2}{2} - 2n &amp; &gt; 0 \\newline n(n - 4) &amp; &gt; 0 \\end{aligned} \\] <p>This means that when \\(n &gt; 4\\), the number of operations after partitioning is fewer, and the sorting efficiency should be higher. Please note that the time complexity after partitioning is still quadratic \\(O(n^2)\\), but the constant factor in the complexity has decreased.</p> <p>Further, what if we keep dividing the sub-arrays from their midpoints into two sub-arrays until the sub-arrays have only one element left? This idea is actually \"merge sort,\" with a time complexity of \\(O(n \\log n)\\).</p> <p>Furthermore, what if we set several more partition points and evenly divide the original array into \\(k\\) sub-arrays? This situation is very similar to \"bucket sort,\" which is very suitable for sorting massive data, and theoretically, the time complexity can reach \\(O(n + k)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#2-optimization-through-parallel-computation","title":"2. \u00a0 Optimization through parallel computation","text":"<p>We know that the sub-problems generated by divide and conquer are independent of each other, thus they can usually be solved in parallel. This means that divide and conquer can not only reduce the algorithm's time complexity, but also facilitate parallel optimization by the operating system.</p> <p>Parallel optimization is especially effective in environments with multiple cores or processors, as the system can process multiple sub-problems simultaneously, making fuller use of computing resources and significantly reducing the overall runtime.</p> <p>For example, in the \"bucket sort\" shown in Figure 12-3, we distribute massive data evenly across various buckets, then the sorting tasks of all buckets can be distributed to different computing units, and the results are merged after completion.</p> <p></p> <p> Figure 12-3 \u00a0 Bucket sort's parallel computation </p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#1213-common-applications-of-divide-and-conquer","title":"12.1.3 \u00a0 Common applications of divide and conquer","text":"<p>On one hand, divide and conquer can be used to solve many classic algorithm problems.</p> <ul> <li>Finding the closest point pair: This algorithm first divides the set of points into two parts, then finds the closest point pair in each part, and finally finds the closest point pair that spans the two parts.</li> <li>Large integer multiplication: For example, the Karatsuba algorithm, which breaks down large integer multiplication into several smaller integer multiplications and additions.</li> <li>Matrix multiplication: For example, the Strassen algorithm, which decomposes large matrix multiplication into multiple small matrix multiplications and additions.</li> <li>Tower of Hanoi problem: The Tower of Hanoi problem can be solved recursively, a typical application of the divide and conquer strategy.</li> <li>Solving inverse pairs: In a sequence, if a number in front is greater than a number behind, these two numbers form an inverse pair. Solving the inverse pair problem can utilize the idea of divide and conquer, with the aid of merge sort.</li> </ul> <p>On the other hand, divide and conquer is very widely applied in the design of algorithms and data structures.</p> <ul> <li>Binary search: Binary search divides an ordered array from the midpoint index into two parts, then decides which half to exclude based on the comparison result between the target value and the middle element value, and performs the same binary operation in the remaining interval.</li> <li>Merge sort: Already introduced at the beginning of this section, no further elaboration is needed.</li> <li>Quicksort: Quicksort selects a pivot value, then divides the array into two sub-arrays, one with elements smaller than the pivot and the other with elements larger than the pivot, and then performs the same partitioning operation on these two parts until the sub-array has only one element.</li> <li>Bucket sort: The basic idea of bucket sort is to distribute data to multiple buckets, then sort the elements within each bucket, and finally retrieve the elements from the buckets in order to obtain an ordered array.</li> <li>Trees: For example, binary search trees, AVL trees, red-black trees, B-trees, B+ trees, etc., their operations such as search, insertion, and deletion can all be considered applications of the divide and conquer strategy.</li> <li>Heap: A heap is a special type of complete binary tree, whose various operations, such as insertion, deletion, and heapification, actually imply the idea of divide and conquer.</li> <li>Hash table: Although hash tables do not directly apply divide and conquer, some hash collision resolution solutions indirectly apply the divide and conquer strategy, for example, long lists in chained addressing being converted to red-black trees to improve query efficiency.</li> </ul> <p>It can be seen that divide and conquer is a subtly pervasive algorithmic idea, embedded within various algorithms and data structures.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/","title":"12.4 \u00a0 Tower of Hanoi Problem","text":"<p>In both merge sorting and building binary trees, we decompose the original problem into two subproblems, each half the size of the original problem. However, for the Tower of Hanoi, we adopt a different decomposition strategy.</p> <p>Question</p> <p>Given three pillars, denoted as <code>A</code>, <code>B</code>, and <code>C</code>. Initially, pillar <code>A</code> is stacked with \\(n\\) discs, arranged in order from top to bottom from smallest to largest. Our task is to move these \\(n\\) discs to pillar <code>C</code>, maintaining their original order (as shown in Figure 12-10). The following rules must be followed during the disc movement process:</p> <ol> <li>A disc can only be picked up from the top of a pillar and placed on top of another pillar.</li> <li>Only one disc can be moved at a time.</li> <li>A smaller disc must always be on top of a larger disc.</li> </ol> <p></p> <p> Figure 12-10 \u00a0 Example of the Tower of Hanoi </p> <p>We denote the Tower of Hanoi of size \\(i\\) as \\(f(i)\\). For example, \\(f(3)\\) represents the Tower of Hanoi of moving \\(3\\) discs from <code>A</code> to <code>C</code>.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#1-consider-the-base-case","title":"1. \u00a0 Consider the base case","text":"<p>As shown in Figure 12-11, for the problem \\(f(1)\\), i.e., when there is only one disc, we can directly move it from <code>A</code> to <code>C</code>.</p> &lt;1&gt;&lt;2&gt; <p></p> <p></p> <p> Figure 12-11 \u00a0 Solution for a problem of size 1 </p> <p>As shown in Figure 12-12, for the problem \\(f(2)\\), i.e., when there are two discs, since the smaller disc must always be above the larger disc, <code>B</code> is needed to assist in the movement.</p> <ol> <li>First, move the smaller disc from <code>A</code> to <code>B</code>.</li> <li>Then move the larger disc from <code>A</code> to <code>C</code>.</li> <li>Finally, move the smaller disc from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 12-12 \u00a0 Solution for a problem of size 2 </p> <p>The process of solving the problem \\(f(2)\\) can be summarized as: moving two discs from <code>A</code> to <code>C</code> with the help of <code>B</code>. Here, <code>C</code> is called the target pillar, and <code>B</code> is called the buffer pillar.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#2-decomposition-of-subproblems","title":"2. \u00a0 Decomposition of subproblems","text":"<p>For the problem \\(f(3)\\), i.e., when there are three discs, the situation becomes slightly more complicated.</p> <p>Since we already know the solutions to \\(f(1)\\) and \\(f(2)\\), we can think from a divide-and-conquer perspective and consider the two top discs on <code>A</code> as a unit, performing the steps shown in Figure 12-13. This way, the three discs are successfully moved from <code>A</code> to <code>C</code>.</p> <ol> <li>Let <code>B</code> be the target pillar and <code>C</code> the buffer pillar, and move the two discs from <code>A</code> to <code>B</code>.</li> <li>Move the remaining disc from <code>A</code> directly to <code>C</code>.</li> <li>Let <code>C</code> be the target pillar and <code>A</code> the buffer pillar, and move the two discs from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 12-13 \u00a0 Solution for a problem of size 3 </p> <p>Essentially, we divide the problem \\(f(3)\\) into two subproblems \\(f(2)\\) and one subproblem \\(f(1)\\). By solving these three subproblems in order, the original problem is resolved. This indicates that the subproblems are independent, and their solutions can be merged.</p> <p>From this, we can summarize the divide-and-conquer strategy for solving the Tower of Hanoi shown in Figure 12-14: divide the original problem \\(f(n)\\) into two subproblems \\(f(n-1)\\) and one subproblem \\(f(1)\\), and solve these three subproblems in the following order.</p> <ol> <li>Move \\(n-1\\) discs with the help of <code>C</code> from <code>A</code> to <code>B</code>.</li> <li>Move the remaining one disc directly from <code>A</code> to <code>C</code>.</li> <li>Move \\(n-1\\) discs with the help of <code>A</code> from <code>B</code> to <code>C</code>.</li> </ol> <p>For these two subproblems \\(f(n-1)\\), they can be recursively divided in the same manner until the smallest subproblem \\(f(1)\\) is reached. The solution to \\(f(1)\\) is already known and requires only one move.</p> <p></p> <p> Figure 12-14 \u00a0 Divide and conquer strategy for solving the Tower of Hanoi </p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#3-code-implementation","title":"3. \u00a0 Code implementation","text":"<p>In the code, we declare a recursive function <code>dfs(i, src, buf, tar)</code> whose role is to move the \\(i\\) discs on top of pillar <code>src</code> with the help of buffer pillar <code>buf</code> to the target pillar <code>tar</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig hanota.py<pre><code>def move(src: list[int], tar: list[int]):\n    \"\"\"\u79fb\u52a8\u4e00\u4e2a\u5706\u76d8\"\"\"\n    # \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    pan = src.pop()\n    # \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.append(pan)\n\ndef dfs(i: int, src: list[int], buf: list[int], tar: list[int]):\n    \"\"\"\u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i)\"\"\"\n    # \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if i == 1:\n        move(src, tar)\n        return\n    # \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf)\n    # \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar)\n    # \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar)\n\ndef solve_hanota(A: list[int], B: list[int], C: list[int]):\n    \"\"\"\u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898\"\"\"\n    n = len(A)\n    # \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C)\n</code></pre> hanota.cpp<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nvoid move(vector&lt;int&gt; &amp;src, vector&lt;int&gt; &amp;tar) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    int pan = src.back();\n    src.pop_back();\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.push_back(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nvoid dfs(int i, vector&lt;int&gt; &amp;src, vector&lt;int&gt; &amp;buf, vector&lt;int&gt; &amp;tar) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i == 1) {\n        move(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nvoid solveHanota(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B, vector&lt;int&gt; &amp;C) {\n    int n = A.size();\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.java<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nvoid move(List&lt;Integer&gt; src, List&lt;Integer&gt; tar) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    Integer pan = src.remove(src.size() - 1);\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.add(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nvoid dfs(int i, List&lt;Integer&gt; src, List&lt;Integer&gt; buf, List&lt;Integer&gt; tar) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i == 1) {\n        move(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nvoid solveHanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) {\n    int n = A.size();\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.cs<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nvoid Move(List&lt;int&gt; src, List&lt;int&gt; tar) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    int pan = src[^1];\n    src.RemoveAt(src.Count - 1);\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.Add(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nvoid DFS(int i, List&lt;int&gt; src, List&lt;int&gt; buf, List&lt;int&gt; tar) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i == 1) {\n        Move(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    DFS(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    Move(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    DFS(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nvoid SolveHanota(List&lt;int&gt; A, List&lt;int&gt; B, List&lt;int&gt; C) {\n    int n = A.Count;\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    DFS(n, A, B, C);\n}\n</code></pre> hanota.go<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfunc move(src, tar *list.List) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    pan := src.Back()\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.PushBack(pan.Value)\n    // \u79fb\u9664 src \u9876\u90e8\u5706\u76d8\n    src.Remove(pan)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfunc dfsHanota(i int, src, buf, tar *list.List) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if i == 1 {\n        move(src, tar)\n        return\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfsHanota(i-1, src, tar, buf)\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar)\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfsHanota(i-1, buf, src, tar)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfunc solveHanota(A, B, C *list.List) {\n    n := A.Len()\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfsHanota(n, A, B, C)\n}\n</code></pre> hanota.swift<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfunc move(src: inout [Int], tar: inout [Int]) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    let pan = src.popLast()!\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.append(pan)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfunc dfs(i: Int, src: inout [Int], buf: inout [Int], tar: inout [Int]) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if i == 1 {\n        move(src: &amp;src, tar: &amp;tar)\n        return\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i: i - 1, src: &amp;src, buf: &amp;tar, tar: &amp;buf)\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src: &amp;src, tar: &amp;tar)\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i: i - 1, src: &amp;buf, buf: &amp;src, tar: &amp;tar)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfunc solveHanota(A: inout [Int], B: inout [Int], C: inout [Int]) {\n    let n = A.count\n    // \u5217\u8868\u5c3e\u90e8\u662f\u67f1\u5b50\u9876\u90e8\n    // \u5c06 src \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(i: n, src: &amp;A, buf: &amp;B, tar: &amp;C)\n}\n</code></pre> hanota.js<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfunction move(src, tar) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    const pan = src.pop();\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.push(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfunction dfs(i, src, buf, tar) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i === 1) {\n        move(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfunction solveHanota(A, B, C) {\n    const n = A.length;\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.ts<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfunction move(src: number[], tar: number[]): void {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    const pan = src.pop();\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.push(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfunction dfs(i: number, src: number[], buf: number[], tar: number[]): void {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i === 1) {\n        move(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfunction solveHanota(A: number[], B: number[], C: number[]): void {\n    const n = A.length;\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.dart<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nvoid move(List&lt;int&gt; src, List&lt;int&gt; tar) {\n  // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n  int pan = src.removeLast();\n  // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n  tar.add(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nvoid dfs(int i, List&lt;int&gt; src, List&lt;int&gt; buf, List&lt;int&gt; tar) {\n  // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n  if (i == 1) {\n    move(src, tar);\n    return;\n  }\n  // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n  dfs(i - 1, src, tar, buf);\n  // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n  move(src, tar);\n  // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n  dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nvoid solveHanota(List&lt;int&gt; A, List&lt;int&gt; B, List&lt;int&gt; C) {\n  int n = A.length;\n  // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n  dfs(n, A, B, C);\n}\n</code></pre> hanota.rs<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfn move_pan(src: &amp;mut Vec&lt;i32&gt;, tar: &amp;mut Vec&lt;i32&gt;) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    let pan = src.remove(src.len() - 1);\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.push(pan);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfn dfs(i: i32, src: &amp;mut Vec&lt;i32&gt;, buf: &amp;mut Vec&lt;i32&gt;, tar: &amp;mut Vec&lt;i32&gt;) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if i == 1 {\n        move_pan(src, tar);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move_pan(src, tar);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfn solve_hanota(A: &amp;mut Vec&lt;i32&gt;, B: &amp;mut Vec&lt;i32&gt;, C: &amp;mut Vec&lt;i32&gt;) {\n    let n = A.len() as i32;\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C);\n}\n</code></pre> hanota.c<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nvoid move(int *src, int *srcSize, int *tar, int *tarSize) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    int pan = src[*srcSize - 1];\n    src[*srcSize - 1] = 0;\n    (*srcSize)--;\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar[*tarSize] = pan;\n    (*tarSize)++;\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nvoid dfs(int i, int *src, int *srcSize, int *buf, int *bufSize, int *tar, int *tarSize) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i == 1) {\n        move(src, srcSize, tar, tarSize);\n        return;\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, srcSize, tar, tarSize, buf, bufSize);\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, srcSize, tar, tarSize);\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, bufSize, src, srcSize, tar, tarSize);\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nvoid solveHanota(int *A, int *ASize, int *B, int *BSize, int *C, int *CSize) {\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(*ASize, A, ASize, B, BSize, C, CSize);\n}\n</code></pre> hanota.kt<pre><code>/* \u79fb\u52a8\u4e00\u4e2a\u5706\u76d8 */\nfun move(src: MutableList&lt;Int&gt;, tar: MutableList&lt;Int&gt;) {\n    // \u4ece src \u9876\u90e8\u62ff\u51fa\u4e00\u4e2a\u5706\u76d8\n    val pan = src.removeAt(src.size - 1)\n    // \u5c06\u5706\u76d8\u653e\u5165 tar \u9876\u90e8\n    tar.add(pan)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 f(i) */\nfun dfs(i: Int, src: MutableList&lt;Int&gt;, buf: MutableList&lt;Int&gt;, tar: MutableList&lt;Int&gt;) {\n    // \u82e5 src \u53ea\u5269\u4e0b\u4e00\u4e2a\u5706\u76d8\uff0c\u5219\u76f4\u63a5\u5c06\u5176\u79fb\u5230 tar\n    if (i == 1) {\n        move(src, tar)\n        return\n    }\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 src \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 tar \u79fb\u5230 buf\n    dfs(i - 1, src, tar, buf)\n    // \u5b50\u95ee\u9898 f(1) \uff1a\u5c06 src \u5269\u4f59\u4e00\u4e2a\u5706\u76d8\u79fb\u5230 tar\n    move(src, tar)\n    // \u5b50\u95ee\u9898 f(i-1) \uff1a\u5c06 buf \u9876\u90e8 i-1 \u4e2a\u5706\u76d8\u501f\u52a9 src \u79fb\u5230 tar\n    dfs(i - 1, buf, src, tar)\n}\n\n/* \u6c42\u89e3\u6c49\u8bfa\u5854\u95ee\u9898 */\nfun solveHanota(A: MutableList&lt;Int&gt;, B: MutableList&lt;Int&gt;, C: MutableList&lt;Int&gt;) {\n    val n = A.size\n    // \u5c06 A \u9876\u90e8 n \u4e2a\u5706\u76d8\u501f\u52a9 B \u79fb\u5230 C\n    dfs(n, A, B, C)\n}\n</code></pre> hanota.rb<pre><code>[class]{}-[func]{move}\n\n[class]{}-[func]{dfs}\n\n[class]{}-[func]{solve_hanota}\n</code></pre> hanota.zig<pre><code>[class]{}-[func]{move}\n\n[class]{}-[func]{dfs}\n\n[class]{}-[func]{solveHanota}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 12-15, the Tower of Hanoi forms a recursive tree with a height of \\(n\\), each node representing a subproblem, corresponding to an open <code>dfs()</code> function, thus the time complexity is \\(O(2^n)\\), and the space complexity is \\(O(n)\\).</p> <p></p> <p> Figure 12-15 \u00a0 Recursive tree of the Tower of Hanoi </p> <p>Quote</p> <p>The Tower of Hanoi originates from an ancient legend. In a temple in ancient India, monks had three tall diamond pillars and \\(64\\) differently sized golden discs. The monks continuously moved the discs, believing that when the last disc is correctly placed, the world would end.</p> <p>However, even if the monks moved a disc every second, it would take about \\(2^{64} \\approx 1.84\u00d710^{19}\\) seconds, approximately 585 billion years, far exceeding current estimates of the age of the universe. Thus, if the legend is true, we probably do not need to worry about the world ending.</p>"},{"location":"chapter_divide_and_conquer/summary/","title":"12.5 \u00a0 Summary","text":"<ul> <li>Divide and conquer is a common algorithm design strategy, which includes dividing (partitioning) and conquering (merging) two stages, usually implemented based on recursion.</li> <li>The basis for judging whether it is a divide and conquer algorithm problem includes: whether the problem can be decomposed, whether the subproblems are independent, and whether the subproblems can be merged.</li> <li>Merge sort is a typical application of the divide and conquer strategy, which recursively divides the array into two equal-length subarrays until only one element remains, and then starts merging layer by layer to complete the sorting.</li> <li>Introducing the divide and conquer strategy can often improve algorithm efficiency. On one hand, the divide and conquer strategy reduces the number of operations; on the other hand, it is conducive to parallel optimization of the system after division.</li> <li>Divide and conquer can solve many algorithm problems and is widely used in data structure and algorithm design, where its presence is ubiquitous.</li> <li>Compared to brute force search, adaptive search is more efficient. Search algorithms with a time complexity of \\(O(\\log n)\\) are usually based on the divide and conquer strategy.</li> <li>Binary search is another typical application of the divide and conquer strategy, which does not include the step of merging the solutions of subproblems. We can implement binary search through recursive divide and conquer.</li> <li>In the problem of constructing binary trees, building the tree (original problem) can be divided into building the left and right subtree (subproblems), which can be achieved by partitioning the index intervals of the preorder and inorder traversals.</li> <li>In the Tower of Hanoi problem, a problem of size \\(n\\) can be divided into two subproblems of size \\(n-1\\) and one subproblem of size \\(1\\). By solving these three subproblems in sequence, the original problem is consequently resolved.</li> </ul>"},{"location":"chapter_dynamic_programming/","title":"Chapter 14. \u00a0 Dynamic programming","text":"<p>Abstract</p> <p>Streams merge into rivers, and rivers merge into the sea.</p> <p>Dynamic programming combines the solutions of small problems to solve bigger problems, step by step leading us to the solution.</p>"},{"location":"chapter_dynamic_programming/#chapter-contents","title":"Chapter contents","text":"<ul> <li>14.1 \u00a0 Introduction to dynamic programming</li> <li>14.2 \u00a0 Characteristics of DP problems</li> <li>14.3 \u00a0 DP problem-solving approach\u00b6</li> <li>14.4 \u00a0 0-1 Knapsack problem</li> <li>14.5 \u00a0 Unbounded knapsack problem</li> <li>14.6 \u00a0 Edit distance problem</li> <li>14.7 \u00a0 Summary</li> </ul>"},{"location":"chapter_dynamic_programming/dp_problem_features/","title":"14.2 \u00a0 Characteristics of dynamic programming problems","text":"<p>In the previous section, we learned how dynamic programming solves the original problem by decomposing it into subproblems. In fact, subproblem decomposition is a general algorithmic approach, with different emphases in divide and conquer, dynamic programming, and backtracking.</p> <ul> <li>Divide and conquer algorithms recursively divide the original problem into multiple independent subproblems until the smallest subproblems are reached, and combine the solutions of the subproblems during backtracking to ultimately obtain the solution to the original problem.</li> <li>Dynamic programming also decomposes the problem recursively, but the main difference from divide and conquer algorithms is that the subproblems in dynamic programming are interdependent, and many overlapping subproblems will appear during the decomposition process.</li> <li>Backtracking algorithms exhaust all possible solutions through trial and error and avoid unnecessary search branches by pruning. The solution to the original problem consists of a series of decision steps, and we can consider each sub-sequence before each decision step as a subproblem.</li> </ul> <p>In fact, dynamic programming is commonly used to solve optimization problems, which not only include overlapping subproblems but also have two other major characteristics: optimal substructure and statelessness.</p>"},{"location":"chapter_dynamic_programming/dp_problem_features/#1421-optimal-substructure","title":"14.2.1 \u00a0 Optimal substructure","text":"<p>We make a slight modification to the stair climbing problem to make it more suitable to demonstrate the concept of optimal substructure.</p> <p>Minimum cost of climbing stairs</p> <p>Given a staircase, you can step up 1 or 2 steps at a time, and each step on the staircase has a non-negative integer representing the cost you need to pay at that step. Given a non-negative integer array \\(cost\\), where \\(cost[i]\\) represents the cost you need to pay at the \\(i\\)-th step, \\(cost[0]\\) is the ground (starting point). What is the minimum cost required to reach the top?</p> <p>As shown in Figure 14-6, if the costs of the 1<sup>st</sup>, 2<sup>nd</sup>, and 3<sup>rd</sup> steps are \\(1\\), \\(10\\), and \\(1\\) respectively, then the minimum cost to climb to the 3<sup>rd</sup> step from the ground is \\(2\\).</p> <p></p> <p> Figure 14-6 \u00a0 Minimum cost to climb to the 3rd step </p> <p>Let \\(dp[i]\\) be the cumulative cost of climbing to the \\(i\\)-th step. Since the \\(i\\)-th step can only come from the \\(i-1\\) or \\(i-2\\) step, \\(dp[i]\\) can only be either \\(dp[i-1] + cost[i]\\) or \\(dp[i-2] + cost[i]\\). To minimize the cost, we should choose the smaller of the two:</p> \\[ dp[i] = \\min(dp[i-1], dp[i-2]) + cost[i] \\] <p>This leads us to the meaning of optimal substructure: The optimal solution to the original problem is constructed from the optimal solutions of subproblems.</p> <p>This problem obviously has optimal substructure: we select the better one from the optimal solutions of the two subproblems, \\(dp[i-1]\\) and \\(dp[i-2]\\), and use it to construct the optimal solution for the original problem \\(dp[i]\\).</p> <p>So, does the stair climbing problem from the previous section have optimal substructure? Its goal is to solve for the number of solutions, which seems to be a counting problem, but if we ask in another way: \"Solve for the maximum number of solutions\". We surprisingly find that although the problem has changed, the optimal substructure has emerged: the maximum number of solutions at the \\(n\\)-th step equals the sum of the maximum number of solutions at the \\(n-1\\) and \\(n-2\\) steps. Thus, the interpretation of optimal substructure is quite flexible and will have different meanings in different problems.</p> <p>According to the state transition equation, and the initial states \\(dp[1] = cost[1]\\) and \\(dp[2] = cost[2]\\), we can obtain the dynamic programming code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_cost_climbing_stairs_dp.py<pre><code>def min_cost_climbing_stairs_dp(cost: list[int]) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(cost) - 1\n    if n == 1 or n == 2:\n        return cost[n]\n    # \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp = [0] * (n + 1)\n    # \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1], dp[2] = cost[1], cost[2]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in range(3, n + 1):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    return dp[n]\n</code></pre> min_cost_climbing_stairs_dp.cpp<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDP(vector&lt;int&gt; &amp;cost) {\n    int n = cost.size() - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    vector&lt;int&gt; dp(n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.java<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDP(int[] cost) {\n    int n = cost.length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[] dp = new int[n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.cs<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nint MinCostClimbingStairsDP(int[] cost) {\n    int n = cost.Length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[] dp = new int[n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = Math.Min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.go<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc minCostClimbingStairsDP(cost []int) int {\n    n := len(cost) - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    min := func(a, b int) int {\n        if a &lt; b {\n            return a\n        }\n        return b\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp := make([]int, n+1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i := 3; i &lt;= n; i++ {\n        dp[i] = min(dp[i-1], dp[i-2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.swift<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc minCostClimbingStairsDP(cost: [Int]) -&gt; Int {\n    let n = cost.count - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = Array(repeating: 0, count: n + 1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3 ... n {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.js<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction minCostClimbingStairsDP(cost) {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = new Array(n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.ts<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction minCostClimbingStairsDP(cost: Array&lt;number&gt;): number {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = new Array(n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.dart<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDP(List&lt;int&gt; cost) {\n  int n = cost.length - 1;\n  if (n == 1 || n == 2) return cost[n];\n  // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n  List&lt;int&gt; dp = List.filled(n + 1, 0);\n  // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n  dp[1] = cost[1];\n  dp[2] = cost[2];\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n  }\n  return dp[n];\n}\n</code></pre> min_cost_climbing_stairs_dp.rs<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfn min_cost_climbing_stairs_dp(cost: &amp;[i32]) -&gt; i32 {\n    let n = cost.len() - 1;\n    if n == 1 || n == 2 {\n        return cost[n];\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    let mut dp = vec![-1; n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3..=n {\n        dp[i] = cmp::min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.c<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDP(int cost[], int costSize) {\n    int n = costSize - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int *dp = calloc(n + 1, sizeof(int));\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = myMin(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    int res = dp[n];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> min_cost_climbing_stairs_dp.kt<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212 */\nfun minCostClimbingStairsDP(cost: IntArray): Int {\n    val n = cost.size - 1\n    if (n == 1 || n == 2) return cost[n]\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    val dp = IntArray(n + 1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1]\n    dp[2] = cost[2]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (i in 3..n) {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    }\n    return dp[n]\n}\n</code></pre> min_cost_climbing_stairs_dp.rb<pre><code>[class]{}-[func]{min_cost_climbing_stairs_dp}\n</code></pre> min_cost_climbing_stairs_dp.zig<pre><code>// \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u52a8\u6001\u89c4\u5212\nfn minCostClimbingStairsDP(comptime cost: []i32) i32 {\n    comptime var n = cost.len - 1;\n    if (n == 1 or n == 2) {\n        return cost[n];\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = [_]i32{-1} ** (n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = cost[1];\n    dp[2] = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (3..n + 1) |i| {\n        dp[i] = @min(dp[i - 1], dp[i - 2]) + cost[i];\n    }\n    return dp[n];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-7 shows the dynamic programming process for the above code.</p> <p></p> <p> Figure 14-7 \u00a0 Dynamic programming process for minimum cost of climbing stairs </p> <p>This problem can also be space-optimized, compressing one dimension to zero, reducing the space complexity from \\(O(n)\\) to \\(O(1)\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_cost_climbing_stairs_dp.py<pre><code>def min_cost_climbing_stairs_dp_comp(cost: list[int]) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(cost) - 1\n    if n == 1 or n == 2:\n        return cost[n]\n    a, b = cost[1], cost[2]\n    for i in range(3, n + 1):\n        a, b = b, min(a, b) + cost[i]\n    return b\n</code></pre> min_cost_climbing_stairs_dp.cpp<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDPComp(vector&lt;int&gt; &amp;cost) {\n    int n = cost.size() - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.java<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDPComp(int[] cost) {\n    int n = cost.length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.cs<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint MinCostClimbingStairsDPComp(int[] cost) {\n    int n = cost.Length - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = Math.Min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.go<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc minCostClimbingStairsDPComp(cost []int) int {\n    n := len(cost) - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    min := func(a, b int) int {\n        if a &lt; b {\n            return a\n        }\n        return b\n    }\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    a, b := cost[1], cost[2]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i := 3; i &lt;= n; i++ {\n        tmp := b\n        b = min(a, tmp) + cost[i]\n        a = tmp\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.swift<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc minCostClimbingStairsDPComp(cost: [Int]) -&gt; Int {\n    let n = cost.count - 1\n    if n == 1 || n == 2 {\n        return cost[n]\n    }\n    var (a, b) = (cost[1], cost[2])\n    for i in 3 ... n {\n        (a, b) = (b, min(a, b) + cost[i])\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.js<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction minCostClimbingStairsDPComp(cost) {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    let a = cost[1],\n        b = cost[2];\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.ts<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction minCostClimbingStairsDPComp(cost: Array&lt;number&gt;): number {\n    const n = cost.length - 1;\n    if (n === 1 || n === 2) {\n        return cost[n];\n    }\n    let a = cost[1],\n        b = cost[2];\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = Math.min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.dart<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDPComp(List&lt;int&gt; cost) {\n  int n = cost.length - 1;\n  if (n == 1 || n == 2) return cost[n];\n  int a = cost[1], b = cost[2];\n  for (int i = 3; i &lt;= n; i++) {\n    int tmp = b;\n    b = min(a, tmp) + cost[i];\n    a = tmp;\n  }\n  return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.rs<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn min_cost_climbing_stairs_dp_comp(cost: &amp;[i32]) -&gt; i32 {\n    let n = cost.len() - 1;\n    if n == 1 || n == 2 {\n        return cost[n];\n    };\n    let (mut a, mut b) = (cost[1], cost[2]);\n    for i in 3..=n {\n        let tmp = b;\n        b = cmp::min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    b\n}\n</code></pre> min_cost_climbing_stairs_dp.c<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minCostClimbingStairsDPComp(int cost[], int costSize) {\n    int n = costSize - 1;\n    if (n == 1 || n == 2)\n        return cost[n];\n    int a = cost[1], b = cost[2];\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = myMin(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> min_cost_climbing_stairs_dp.kt<pre><code>/* \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun minCostClimbingStairsDPComp(cost: IntArray): Int {\n    val n = cost.size - 1\n    if (n == 1 || n == 2) return cost[n]\n    var a = cost[1]\n    var b = cost[2]\n    for (i in 3..n) {\n        val tmp = b\n        b = min(a, tmp) + cost[i]\n        a = tmp\n    }\n    return b\n}\n</code></pre> min_cost_climbing_stairs_dp.rb<pre><code>[class]{}-[func]{min_cost_climbing_stairs_dp_comp}\n</code></pre> min_cost_climbing_stairs_dp.zig<pre><code>// \u722c\u697c\u68af\u6700\u5c0f\u4ee3\u4ef7\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn minCostClimbingStairsDPComp(cost: []i32) i32 {\n    var n = cost.len - 1;\n    if (n == 1 or n == 2) {\n        return cost[n];\n    }\n    var a = cost[1];\n    var b = cost[2];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (3..n + 1) |i| {\n        var tmp = b;\n        b = @min(a, tmp) + cost[i];\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/dp_problem_features/#1422-statelessness","title":"14.2.2 \u00a0 Statelessness","text":"<p>Statelessness is one of the important characteristics that make dynamic programming effective in solving problems. Its definition is: Given a certain state, its future development is only related to the current state and unrelated to all past states experienced.</p> <p>Taking the stair climbing problem as an example, given state \\(i\\), it will develop into states \\(i+1\\) and \\(i+2\\), corresponding to jumping 1 step and 2 steps respectively. When making these two choices, we do not need to consider the states before state \\(i\\), as they do not affect the future of state \\(i\\).</p> <p>However, if we add a constraint to the stair climbing problem, the situation changes.</p> <p>Stair climbing with constraints</p> <p>Given a staircase with \\(n\\) steps, you can go up 1 or 2 steps each time, but you cannot jump 1 step twice in a row. How many ways are there to climb to the top?</p> <p>As shown in Figure 14-8, there are only 2 feasible options for climbing to the 3<sup>rd</sup> step, among which the option of jumping 1 step three times in a row does not meet the constraint condition and is therefore discarded.</p> <p></p> <p> Figure 14-8 \u00a0 Number of feasible options for climbing to the 3rd step with constraints </p> <p>In this problem, if the last round was a jump of 1 step, then the next round must be a jump of 2 steps. This means that the next step choice cannot be independently determined by the current state (current stair step), but also depends on the previous state (last round's stair step).</p> <p>It is not difficult to find that this problem no longer satisfies statelessness, and the state transition equation \\(dp[i] = dp[i-1] + dp[i-2]\\) also fails, because \\(dp[i-1]\\) represents this round's jump of 1 step, but it includes many \"last round was a jump of 1 step\" options, which, to meet the constraint, cannot be directly included in \\(dp[i]\\).</p> <p>For this, we need to expand the state definition: State \\([i, j]\\) represents being on the \\(i\\)-th step and the last round was a jump of \\(j\\) steps, where \\(j \\in \\{1, 2\\}\\). This state definition effectively distinguishes whether the last round was a jump of 1 step or 2 steps, and we can judge accordingly where the current state came from.</p> <ul> <li>When the last round was a jump of 1 step, the round before last could only choose to jump 2 steps, that is, \\(dp[i, 1]\\) can only be transferred from \\(dp[i-1, 2]\\).</li> <li>When the last round was a jump of 2 steps, the round before last could choose to jump 1 step or 2 steps, that is, \\(dp[i, 2]\\) can be transferred from \\(dp[i-2, 1]\\) or \\(dp[i-2, 2]\\).</li> </ul> <p>As shown in Figure 14-9, \\(dp[i, j]\\) represents the number of solutions for state \\([i, j]\\). At this point, the state transition equation is:</p> \\[ \\begin{cases} dp[i, 1] = dp[i-1, 2] \\\\ dp[i, 2] = dp[i-2, 1] + dp[i-2, 2] \\end{cases} \\] <p></p> <p> Figure 14-9 \u00a0 Recursive relationship considering constraints </p> <p>In the end, returning \\(dp[n, 1] + dp[n, 2]\\) will do, the sum of the two representing the total number of solutions for climbing to the \\(n\\)-th step:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_constraint_dp.py<pre><code>def climbing_stairs_constraint_dp(n: int) -&gt; int:\n    \"\"\"\u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    if n == 1 or n == 2:\n        return 1\n    # \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp = [[0] * 3 for _ in range(n + 1)]\n    # \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1], dp[1][2] = 1, 0\n    dp[2][1], dp[2][2] = 0, 1\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in range(3, n + 1):\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    return dp[n][1] + dp[n][2]\n</code></pre> climbing_stairs_constraint_dp.cpp<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3, 0));\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.java<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[][] dp = new int[n + 1][3];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.cs<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint ClimbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[,] dp = new int[n + 1, 3];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1, 1] = 1;\n    dp[1, 2] = 0;\n    dp[2, 1] = 0;\n    dp[2, 2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i, 1] = dp[i - 1, 2];\n        dp[i, 2] = dp[i - 2, 1] + dp[i - 2, 2];\n    }\n    return dp[n, 1] + dp[n, 2];\n}\n</code></pre> climbing_stairs_constraint_dp.go<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsConstraintDP(n int) int {\n    if n == 1 || n == 2 {\n        return 1\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp := make([][3]int, n+1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i := 3; i &lt;= n; i++ {\n        dp[i][1] = dp[i-1][2]\n        dp[i][2] = dp[i-2][1] + dp[i-2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.swift<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsConstraintDP(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return 1\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = Array(repeating: Array(repeating: 0, count: 3), count: n + 1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3 ... n {\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.js<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsConstraintDP(n) {\n    if (n === 1 || n === 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = Array.from(new Array(n + 1), () =&gt; new Array(3));\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.ts<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsConstraintDP(n: number): number {\n    if (n === 1 || n === 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = Array.from({ length: n + 1 }, () =&gt; new Array(3));\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.dart<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsConstraintDP(int n) {\n  if (n == 1 || n == 2) {\n    return 1;\n  }\n  // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(3, 0));\n  // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n  dp[1][1] = 1;\n  dp[1][2] = 0;\n  dp[2][1] = 0;\n  dp[2][2] = 1;\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i][1] = dp[i - 1][2];\n    dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n  }\n  return dp[n][1] + dp[n][2];\n}\n</code></pre> climbing_stairs_constraint_dp.rs<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfn climbing_stairs_constraint_dp(n: usize) -&gt; i32 {\n    if n == 1 || n == 2 {\n        return 1;\n    };\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    let mut dp = vec![vec![-1; 3]; n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3..=n {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.c<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsConstraintDP(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(3, sizeof(int));\n    }\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    int res = dp[n][1] + dp[n][2];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> climbing_stairs_constraint_dp.kt<pre><code>/* \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfun climbingStairsConstraintDP(n: Int): Int {\n    if (n == 1 || n == 2) {\n        return 1\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    val dp = Array(n + 1) { IntArray(3) }\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1\n    dp[1][2] = 0\n    dp[2][1] = 0\n    dp[2][2] = 1\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (i in 3..n) {\n        dp[i][1] = dp[i - 1][2]\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2]\n    }\n    return dp[n][1] + dp[n][2]\n}\n</code></pre> climbing_stairs_constraint_dp.rb<pre><code>[class]{}-[func]{climbing_stairs_constraint_dp}\n</code></pre> climbing_stairs_constraint_dp.zig<pre><code>// \u5e26\u7ea6\u675f\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212\nfn climbingStairsConstraintDP(comptime n: usize) i32 {\n    if (n == 1 or n == 2) {\n        return 1;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = [_][3]i32{ [_]i32{ -1, -1, -1 } } ** (n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1][1] = 1;\n    dp[1][2] = 0;\n    dp[2][1] = 0;\n    dp[2][2] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (3..n + 1) |i| {\n        dp[i][1] = dp[i - 1][2];\n        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n    }\n    return dp[n][1] + dp[n][2];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>In the above cases, since we only need to consider the previous state, we can still meet the statelessness by expanding the state definition. However, some problems have very serious \"state effects\".</p> <p>Stair climbing with obstacle generation</p> <p>Given a staircase with \\(n\\) steps, you can go up 1 or 2 steps each time. It is stipulated that when climbing to the \\(i\\)-th step, the system automatically places an obstacle on the \\(2i\\)-th step, and thereafter all rounds are not allowed to jump to the \\(2i\\)-th step. For example, if the first two rounds jump to the 2<sup>nd</sup> and 3<sup>rd</sup> steps, then later you cannot jump to the 4<sup>th</sup> and 6<sup>th</sup> steps. How many ways are there to climb to the top?</p> <p>In this problem, the next jump depends on all past states, as each jump places obstacles on higher steps, affecting future jumps. For such problems, dynamic programming often struggles to solve.</p> <p>In fact, many complex combinatorial optimization problems (such as the traveling salesman problem) do not satisfy statelessness. For these kinds of problems, we usually choose to use other methods, such as heuristic search, genetic algorithms, reinforcement learning, etc., to obtain usable local optimal solutions within a limited time.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/","title":"14.3 \u00a0 Dynamic programming problem-solving approach","text":"<p>The last two sections introduced the main characteristics of dynamic programming problems. Next, let's explore two more practical issues together.</p> <ol> <li>How to determine whether a problem is a dynamic programming problem?</li> <li>What are the complete steps to solve a dynamic programming problem?</li> </ol>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1431-problem-determination","title":"14.3.1 \u00a0 Problem determination","text":"<p>Generally speaking, if a problem contains overlapping subproblems, optimal substructure, and exhibits no aftereffects, it is usually suitable for dynamic programming solutions. However, it is often difficult to directly extract these characteristics from the problem description. Therefore, we usually relax the conditions and first observe whether the problem is suitable for resolution using backtracking (exhaustive search).</p> <p>Problems suitable for backtracking usually fit the \"decision tree model\", which can be described using a tree structure, where each node represents a decision, and each path represents a sequence of decisions.</p> <p>In other words, if the problem contains explicit decision concepts, and the solution is produced through a series of decisions, then it fits the decision tree model and can usually be solved using backtracking.</p> <p>On this basis, there are some \"bonus points\" for determining dynamic programming problems.</p> <ul> <li>The problem contains descriptions of maximization (minimization) or finding the most (least) optimal solution.</li> <li>The problem's states can be represented using a list, multi-dimensional matrix, or tree, and a state has a recursive relationship with its surrounding states.</li> </ul> <p>Correspondingly, there are also some \"penalty points\".</p> <ul> <li>The goal of the problem is to find all possible solutions, not just the optimal solution.</li> <li>The problem description has obvious characteristics of permutations and combinations, requiring the return of specific multiple solutions.</li> </ul> <p>If a problem fits the decision tree model and has relatively obvious \"bonus points\", we can assume it is a dynamic programming problem and verify it during the solution process.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1432-problem-solving-steps","title":"14.3.2 \u00a0 Problem-solving steps","text":"<p>The dynamic programming problem-solving process varies with the nature and difficulty of the problem but generally follows these steps: describe decisions, define states, establish a \\(dp\\) table, derive state transition equations, and determine boundary conditions, etc.</p> <p>To illustrate the problem-solving steps more vividly, we use a classic problem, \"Minimum Path Sum\", as an example.</p> <p>Question</p> <p>Given an \\(n \\times m\\) two-dimensional grid <code>grid</code>, each cell in the grid contains a non-negative integer representing the cost of that cell. The robot starts from the top-left cell and can only move down or right at each step until it reaches the bottom-right cell. Return the minimum path sum from the top-left to the bottom-right.</p> <p>Figure 14-10 shows an example, where the given grid's minimum path sum is \\(13\\).</p> <p></p> <p> Figure 14-10 \u00a0 Minimum Path Sum Example Data </p> <p>First step: Think about each round of decisions, define the state, and thereby obtain the \\(dp\\) table</p> <p>Each round of decisions in this problem is to move one step down or right from the current cell. Suppose the row and column indices of the current cell are \\([i, j]\\), then after moving down or right, the indices become \\([i+1, j]\\) or \\([i, j+1]\\). Therefore, the state should include two variables: the row index and the column index, denoted as \\([i, j]\\).</p> <p>The state \\([i, j]\\) corresponds to the subproblem: the minimum path sum from the starting point \\([0, 0]\\) to \\([i, j]\\), denoted as \\(dp[i, j]\\).</p> <p>Thus, we obtain the two-dimensional \\(dp\\) matrix shown in Figure 14-11, whose size is the same as the input grid \\(grid\\).</p> <p></p> <p> Figure 14-11 \u00a0 State definition and DP table </p> <p>Note</p> <p>Dynamic programming and backtracking can be described as a sequence of decisions, while a state consists of all decision variables. It should include all variables that describe the progress of solving the problem, containing enough information to derive the next state.</p> <p>Each state corresponds to a subproblem, and we define a \\(dp\\) table to store the solutions to all subproblems. Each independent variable of the state is a dimension of the \\(dp\\) table. Essentially, the \\(dp\\) table is a mapping between states and solutions to subproblems.</p> <p>Second step: Identify the optimal substructure, then derive the state transition equation</p> <p>For the state \\([i, j]\\), it can only be derived from the cell above \\([i-1, j]\\) or the cell to the left \\([i, j-1]\\). Therefore, the optimal substructure is: the minimum path sum to reach \\([i, j]\\) is determined by the smaller of the minimum path sums of \\([i, j-1]\\) and \\([i-1, j]\\).</p> <p>Based on the above analysis, the state transition equation shown in Figure 14-12 can be derived:</p> \\[ dp[i, j] = \\min(dp[i-1, j], dp[i, j-1]) + grid[i, j] \\] <p></p> <p> Figure 14-12 \u00a0 Optimal substructure and state transition equation </p> <p>Note</p> <p>Based on the defined \\(dp\\) table, think about the relationship between the original problem and the subproblems, and find out how to construct the optimal solution to the original problem from the optimal solutions to the subproblems, i.e., the optimal substructure.</p> <p>Once we have identified the optimal substructure, we can use it to build the state transition equation.</p> <p>Third step: Determine boundary conditions and state transition order</p> <p>In this problem, the states in the first row can only come from the states to their left, and the states in the first column can only come from the states above them, so the first row \\(i = 0\\) and the first column \\(j = 0\\) are the boundary conditions.</p> <p>As shown in Figure 14-13, since each cell is derived from the cell to its left and the cell above it, we use loops to traverse the matrix, the outer loop iterating over the rows and the inner loop iterating over the columns.</p> <p></p> <p> Figure 14-13 \u00a0 Boundary conditions and state transition order </p> <p>Note</p> <p>Boundary conditions are used in dynamic programming to initialize the \\(dp\\) table, and in search to prune.</p> <p>The core of the state transition order is to ensure that when calculating the solution to the current problem, all the smaller subproblems it depends on have already been correctly calculated.</p> <p>Based on the above analysis, we can directly write the dynamic programming code. However, the decomposition of subproblems is a top-down approach, so implementing it in the order of \"brute-force search \u2192 memoized search \u2192 dynamic programming\" is more in line with habitual thinking.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#1-method-1-brute-force-search","title":"1. \u00a0 Method 1: Brute-force search","text":"<p>Start searching from the state \\([i, j]\\), constantly decomposing it into smaller states \\([i-1, j]\\) and \\([i, j-1]\\). The recursive function includes the following elements.</p> <ul> <li>Recursive parameter: state \\([i, j]\\).</li> <li>Return value: the minimum path sum from \\([0, 0]\\) to \\([i, j]\\) \\(dp[i, j]\\).</li> <li>Termination condition: when \\(i = 0\\) and \\(j = 0\\), return the cost \\(grid[0, 0]\\).</li> <li>Pruning: when \\(i &lt; 0\\) or \\(j &lt; 0\\) index out of bounds, return the cost \\(+\\infty\\), representing infeasibility.</li> </ul> <p>Implementation code as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_path_sum.py<pre><code>def min_path_sum_dfs(grid: list[list[int]], i: int, j: int) -&gt; int:\n    \"\"\"\u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22\"\"\"\n    # \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 and j == 0:\n        return grid[0][0]\n    # \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 or j &lt; 0:\n        return inf\n    # \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    up = min_path_sum_dfs(grid, i - 1, j)\n    left = min_path_sum_dfs(grid, i, j - 1)\n    # \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return min(left, up) + grid[i][j]\n</code></pre> min_path_sum.cpp<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nint minPathSumDFS(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;\n}\n</code></pre> min_path_sum.java<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nint minPathSumDFS(int[][] grid, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Integer.MAX_VALUE;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.cs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nint MinPathSumDFS(int[][] grid, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return int.MaxValue;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = MinPathSumDFS(grid, i - 1, j);\n    int left = MinPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return Math.Min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.go<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfunc minPathSumDFS(grid [][]int, i, j int) int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return math.MaxInt\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    up := minPathSumDFS(grid, i-1, j)\n    left := minPathSumDFS(grid, i, j-1)\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return int(math.Min(float64(left), float64(up))) + grid[i][j]\n}\n</code></pre> min_path_sum.swift<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfunc minPathSumDFS(grid: [[Int]], i: Int, j: Int) -&gt; Int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0, j == 0 {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return .max\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    let up = minPathSumDFS(grid: grid, i: i - 1, j: j)\n    let left = minPathSumDFS(grid: grid, i: i, j: j - 1)\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return min(left, up) + grid[i][j]\n}\n</code></pre> min_path_sum.js<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfunction minPathSumDFS(grid, i, j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    const up = minPathSumDFS(grid, i - 1, j);\n    const left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.ts<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfunction minPathSumDFS(\n    grid: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    j: number\n): number {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i === 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    const up = minPathSumDFS(grid, i - 1, j);\n    const left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return Math.min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.dart<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nint minPathSumDFS(List&lt;List&lt;int&gt;&gt; grid, int i, int j) {\n  // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n  if (i == 0 &amp;&amp; j == 0) {\n    return grid[0][0];\n  }\n  // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n  if (i &lt; 0 || j &lt; 0) {\n    // \u5728 Dart \u4e2d\uff0cint \u7c7b\u578b\u662f\u56fa\u5b9a\u8303\u56f4\u7684\u6574\u6570\uff0c\u4e0d\u5b58\u5728\u8868\u793a\u201c\u65e0\u7a77\u5927\u201d\u7684\u503c\n    return BigInt.from(2).pow(31).toInt();\n  }\n  // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n  int up = minPathSumDFS(grid, i - 1, j);\n  int left = minPathSumDFS(grid, i, j - 1);\n  // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n  return min(left, up) + grid[i][j];\n}\n</code></pre> min_path_sum.rs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfn min_path_sum_dfs(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, i: i32, j: i32) -&gt; i32 {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return i32::MAX;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    let up = min_path_sum_dfs(grid, i - 1, j);\n    let left = min_path_sum_dfs(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    std::cmp::min(left, up) + grid[i as usize][j as usize]\n}\n</code></pre> min_path_sum.c<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nint minPathSumDFS(int grid[MAX_SIZE][MAX_SIZE], int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFS(grid, i - 1, j);\n    int left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX;\n}\n</code></pre> min_path_sum.kt<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22 */\nfun minPathSumDFS(grid: Array&lt;IntArray&gt;, i: Int, j: Int): Int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Int.MAX_VALUE\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    val up = minPathSumDFS(grid, i - 1, j)\n    val left = minPathSumDFS(grid, i, j - 1)\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return min(left, up) + grid[i][j]\n}\n</code></pre> min_path_sum.rb<pre><code>[class]{}-[func]{min_path_sum_dfs}\n</code></pre> min_path_sum.zig<pre><code>// \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u66b4\u529b\u641c\u7d22\nfn minPathSumDFS(grid: anytype, i: i32, j: i32) i32 {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 and j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 or j &lt; 0) {\n        return std.math.maxInt(i32);\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    var up = minPathSumDFS(grid, i - 1, j);\n    var left = minPathSumDFS(grid, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    return @min(left, up) + grid[@as(usize, @intCast(i))][@as(usize, @intCast(j))];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-14 shows the recursive tree rooted at \\(dp[2, 1]\\), which includes some overlapping subproblems, the number of which increases sharply as the size of the grid <code>grid</code> increases.</p> <p>Essentially, the reason for overlapping subproblems is: there are multiple paths to reach a certain cell from the top-left corner.</p> <p></p> <p> Figure 14-14 \u00a0 Brute-force search recursive tree </p> <p>Each state has two choices, down and right, so the total number of steps from the top-left corner to the bottom-right corner is \\(m + n - 2\\), so the worst-case time complexity is \\(O(2^{m + n})\\). Please note that this calculation method does not consider the situation near the grid edge, where there is only one choice left when reaching the network edge, so the actual number of paths will be less.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#2-method-2-memoized-search","title":"2. \u00a0 Method 2: Memoized search","text":"<p>We introduce a memo list <code>mem</code> of the same size as the grid <code>grid</code>, used to record the solutions to various subproblems, and prune overlapping subproblems:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_path_sum.py<pre><code>def min_path_sum_dfs_mem(\n    grid: list[list[int]], mem: list[list[int]], i: int, j: int\n) -&gt; int:\n    \"\"\"\u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\"\"\"\n    # \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 and j == 0:\n        return grid[0][0]\n    # \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 or j &lt; 0:\n        return inf\n    # \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][j] != -1:\n        return mem[i][j]\n    # \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    up = min_path_sum_dfs_mem(grid, mem, i - 1, j)\n    left = min_path_sum_dfs_mem(grid, mem, i, j - 1)\n    # \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n</code></pre> min_path_sum.cpp<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint minPathSumDFSMem(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;mem, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;\n    return mem[i][j];\n}\n</code></pre> min_path_sum.java<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Integer.MAX_VALUE;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.cs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint MinPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return int.MaxValue;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = MinPathSumDFSMem(grid, mem, i - 1, j);\n    int left = MinPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = Math.Min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.go<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc minPathSumDFSMem(grid, mem [][]int, i, j int) int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return math.MaxInt\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][j] != -1 {\n        return mem[i][j]\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    up := minPathSumDFSMem(grid, mem, i-1, j)\n    left := minPathSumDFSMem(grid, mem, i, j-1)\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = int(math.Min(float64(left), float64(up))) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.swift<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc minPathSumDFSMem(grid: [[Int]], mem: inout [[Int]], i: Int, j: Int) -&gt; Int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0, j == 0 {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return .max\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][j] != -1 {\n        return mem[i][j]\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    let up = minPathSumDFSMem(grid: grid, mem: &amp;mem, i: i - 1, j: j)\n    let left = minPathSumDFSMem(grid: grid, mem: &amp;mem, i: i, j: j - 1)\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.js<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction minPathSumDFSMem(grid, mem, i, j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] !== -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    const up = minPathSumDFSMem(grid, mem, i - 1, j);\n    const left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.ts<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction minPathSumDFSMem(\n    grid: Array&lt;Array&lt;number&gt;&gt;,\n    mem: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    j: number\n): number {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i === 0 &amp;&amp; j === 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Infinity;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    const up = minPathSumDFSMem(grid, mem, i - 1, j);\n    const left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = Math.min(left, up) + grid[i][j];\n    return mem[i][j];\n}\n</code></pre> min_path_sum.dart<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint minPathSumDFSMem(List&lt;List&lt;int&gt;&gt; grid, List&lt;List&lt;int&gt;&gt; mem, int i, int j) {\n  // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n  if (i == 0 &amp;&amp; j == 0) {\n    return grid[0][0];\n  }\n  // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n  if (i &lt; 0 || j &lt; 0) {\n    // \u5728 Dart \u4e2d\uff0cint \u7c7b\u578b\u662f\u56fa\u5b9a\u8303\u56f4\u7684\u6574\u6570\uff0c\u4e0d\u5b58\u5728\u8868\u793a\u201c\u65e0\u7a77\u5927\u201d\u7684\u503c\n    return BigInt.from(2).pow(31).toInt();\n  }\n  // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n  if (mem[i][j] != -1) {\n    return mem[i][j];\n  }\n  // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n  int up = minPathSumDFSMem(grid, mem, i - 1, j);\n  int left = minPathSumDFSMem(grid, mem, i, j - 1);\n  // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n  mem[i][j] = min(left, up) + grid[i][j];\n  return mem[i][j];\n}\n</code></pre> min_path_sum.rs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfn min_path_sum_dfs_mem(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;, mem: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, i: i32, j: i32) -&gt; i32 {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if i == 0 &amp;&amp; j == 0 {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if i &lt; 0 || j &lt; 0 {\n        return i32::MAX;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i as usize][j as usize] != -1 {\n        return mem[i as usize][j as usize];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    let up = min_path_sum_dfs_mem(grid, mem, i - 1, j);\n    let left = min_path_sum_dfs_mem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i as usize][j as usize] = std::cmp::min(left, up) + grid[i as usize][j as usize];\n    mem[i as usize][j as usize]\n}\n</code></pre> min_path_sum.c<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint minPathSumDFSMem(int grid[MAX_SIZE][MAX_SIZE], int mem[MAX_SIZE][MAX_SIZE], int i, int j) {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return INT_MAX;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j];\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    int up = minPathSumDFSMem(grid, mem, i - 1, j);\n    int left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX;\n    return mem[i][j];\n}\n</code></pre> min_path_sum.kt<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfun minPathSumDFSMem(\n    grid: Array&lt;IntArray&gt;,\n    mem: Array&lt;IntArray&gt;,\n    i: Int,\n    j: Int\n): Int {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 &amp;&amp; j == 0) {\n        return grid[0][0]\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 || j &lt; 0) {\n        return Int.MAX_VALUE\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][j] != -1) {\n        return mem[i][j]\n    }\n    // \u5de6\u8fb9\u548c\u4e0a\u8fb9\u5355\u5143\u683c\u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    val up = minPathSumDFSMem(grid, mem, i - 1, j)\n    val left = minPathSumDFSMem(grid, mem, i, j - 1)\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[i][j] = min(left, up) + grid[i][j]\n    return mem[i][j]\n}\n</code></pre> min_path_sum.rb<pre><code>[class]{}-[func]{min_path_sum_dfs_mem}\n</code></pre> min_path_sum.zig<pre><code>// \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\nfn minPathSumDFSMem(grid: anytype, mem: anytype, i: i32, j: i32) i32 {\n    // \u82e5\u4e3a\u5de6\u4e0a\u89d2\u5355\u5143\u683c\uff0c\u5219\u7ec8\u6b62\u641c\u7d22\n    if (i == 0 and j == 0) {\n        return grid[0][0];\n    }\n    // \u82e5\u884c\u5217\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de +\u221e \u4ee3\u4ef7\n    if (i &lt; 0 or j &lt; 0) {\n        return std.math.maxInt(i32);\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[@as(usize, @intCast(i))][@as(usize, @intCast(j))] != -1) {\n        return mem[@as(usize, @intCast(i))][@as(usize, @intCast(j))];\n    }\n    // \u8ba1\u7b97\u4ece\u5de6\u4e0a\u89d2\u5230 (i-1, j) \u548c (i, j-1) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    var up = minPathSumDFSMem(grid, mem, i - 1, j);\n    var left = minPathSumDFSMem(grid, mem, i, j - 1);\n    // \u8fd4\u56de\u4ece\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u5de6\u4e0a\u89d2\u5230 (i, j) \u7684\u6700\u5c0f\u8def\u5f84\u4ee3\u4ef7\n    mem[@as(usize, @intCast(i))][@as(usize, @intCast(j))] = @min(left, up) + grid[@as(usize, @intCast(i))][@as(usize, @intCast(j))];\n    return mem[@as(usize, @intCast(i))][@as(usize, @intCast(j))];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 14-15, after introducing memoization, all subproblem solutions only need to be calculated once, so the time complexity depends on the total number of states, i.e., the grid size \\(O(nm)\\).</p> <p></p> <p> Figure 14-15 \u00a0 Memoized search recursive tree </p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#3-method-3-dynamic-programming","title":"3. \u00a0 Method 3: Dynamic programming","text":"<p>Implement the dynamic programming solution iteratively, code as shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_path_sum.py<pre><code>def min_path_sum_dp(grid: list[list[int]]) -&gt; int:\n    \"\"\"\u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n, m = len(grid), len(grid[0])\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n    return dp[n - 1][m - 1]\n</code></pre> min_path_sum.cpp<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nint minPathSumDP(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size(), m = grid[0].size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m));\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.java<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nint minPathSumDP(int[][] grid) {\n    int n = grid.length, m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[][] dp = new int[n][m];\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.cs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nint MinPathSumDP(int[][] grid) {\n    int n = grid.Length, m = grid[0].Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[,] dp = new int[n, m];\n    dp[0, 0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt; m; j++) {\n        dp[0, j] = dp[0, j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (int i = 1; i &lt; n; i++) {\n        dp[i, 0] = dp[i - 1, 0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i, j] = Math.Min(dp[i, j - 1], dp[i - 1, j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1, m - 1];\n}\n</code></pre> min_path_sum.go<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc minPathSumDP(grid [][]int) int {\n    n, m := len(grid), len(grid[0])\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([][]int, n)\n    for i := 0; i &lt; n; i++ {\n        dp[i] = make([]int, m)\n    }\n    dp[0][0] = grid[0][0]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j := 1; j &lt; m; j++ {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for i := 1; i &lt; n; i++ {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            dp[i][j] = int(math.Min(float64(dp[i][j-1]), float64(dp[i-1][j]))) + grid[i][j]\n        }\n    }\n    return dp[n-1][m-1]\n}\n</code></pre> min_path_sum.swift<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc minPathSumDP(grid: [[Int]]) -&gt; Int {\n    let n = grid.count\n    let m = grid[0].count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: Array(repeating: 0, count: m), count: n)\n    dp[0][0] = grid[0][0]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in 1 ..&lt; m {\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for i in 1 ..&lt; n {\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1 ..&lt; n {\n        for j in 1 ..&lt; m {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.js<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction minPathSumDP(grid) {\n    const n = grid.length,\n        m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n }, () =&gt;\n        Array.from({ length: m }, () =&gt; 0)\n    );\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (let j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (let i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt; n; i++) {\n        for (let j = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.ts<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction minPathSumDP(grid: Array&lt;Array&lt;number&gt;&gt;): number {\n    const n = grid.length,\n        m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n }, () =&gt;\n        Array.from({ length: m }, () =&gt; 0)\n    );\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (let j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (let i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt; n; i++) {\n        for (let j: number = 1; j &lt; m; j++) {\n            dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.dart<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nint minPathSumDP(List&lt;List&lt;int&gt;&gt; grid) {\n  int n = grid.length, m = grid[0].length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n, (i) =&gt; List.filled(m, 0));\n  dp[0][0] = grid[0][0];\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n  for (int j = 1; j &lt; m; j++) {\n    dp[0][j] = dp[0][j - 1] + grid[0][j];\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n  for (int i = 1; i &lt; n; i++) {\n    dp[i][0] = dp[i - 1][0] + grid[i][0];\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n  for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; m; j++) {\n      dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n    }\n  }\n  return dp[n - 1][m - 1];\n}\n</code></pre> min_path_sum.rs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfn min_path_sum_dp(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let (n, m) = (grid.len(), grid[0].len());\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![vec![0; m]; n];\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in 1..m {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1..n {\n        for j in 1..m {\n            dp[i][j] = std::cmp::min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.c<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nint minPathSumDP(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {\n    // \u521d\u59cb\u5316 dp \u8868\n    int **dp = malloc(n * sizeof(int *));\n    for (int i = 0; i &lt; n; i++) {\n        dp[i] = calloc(m, sizeof(int));\n    }\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt; m; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (int i = 1; i &lt; n; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 1; j &lt; m; j++) {\n            dp[i][j] = myMin(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    int res = dp[n - 1][m - 1];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt; n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> min_path_sum.kt<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212 */\nfun minPathSumDP(grid: Array&lt;IntArray&gt;): Int {\n    val n = grid.size\n    val m = grid[0].size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = Array(n) { IntArray(m) }\n    dp[0][0] = grid[0][0]\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (j in 1..&lt;m) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (i in 1..&lt;n) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (i in 1..&lt;n) {\n        for (j in 1..&lt;m) {\n            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n</code></pre> min_path_sum.rb<pre><code>[class]{}-[func]{min_path_sum_dp}\n</code></pre> min_path_sum.zig<pre><code>// \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u52a8\u6001\u89c4\u5212\nfn minPathSumDP(comptime grid: anytype) i32 {\n    comptime var n = grid.len;\n    comptime var m = grid[0].len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_][m]i32{[_]i32{0} ** m} ** n;\n    dp[0][0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (1..m) |j| {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    for (1..n) |i| {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (1..n) |i| {\n        for (1..m) |j| {\n            dp[i][j] = @min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n        }\n    }\n    return dp[n - 1][m - 1];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-16 show the state transition process of the minimum path sum, traversing the entire grid, thus the time complexity is \\(O(nm)\\).</p> <p>The array <code>dp</code> is of size \\(n \\times m\\), therefore the space complexity is \\(O(nm)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-16 \u00a0 Dynamic programming process of minimum path sum </p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#4-space-optimization","title":"4. \u00a0 Space optimization","text":"<p>Since each cell is only related to the cell to its left and above, we can use a single-row array to implement the \\(dp\\) table.</p> <p>Please note, since the array <code>dp</code> can only represent the state of one row, we cannot initialize the first column state in advance, but update it as we traverse each row:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig min_path_sum.py<pre><code>def min_path_sum_dp_comp(grid: list[list[int]]) -&gt; int:\n    \"\"\"\u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n, m = len(grid), len(grid[0])\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [0] * m\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0]\n    for j in range(1, m):\n        dp[j] = dp[j - 1] + grid[0][j]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in range(1, n):\n        # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0]\n        # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in range(1, m):\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n    return dp[m - 1]\n</code></pre> min_path_sum.cpp<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minPathSumDPComp(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    int n = grid.size(), m = grid[0].size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;int&gt; dp(m);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.java<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minPathSumDPComp(int[][] grid) {\n    int n = grid.length, m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[m];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.cs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint MinPathSumDPComp(int[][] grid) {\n    int n = grid.Length, m = grid[0].Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[m];\n    dp[0] = grid[0][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = Math.Min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.go<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc minPathSumDPComp(grid [][]int) int {\n    n, m := len(grid), len(grid[0])\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([]int, m)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0]\n    for j := 1; j &lt; m; j++ {\n        dp[j] = dp[j-1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i := 1; i &lt; n; i++ {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0]\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j := 1; j &lt; m; j++ {\n            dp[j] = int(math.Min(float64(dp[j-1]), float64(dp[j]))) + grid[i][j]\n        }\n    }\n    return dp[m-1]\n}\n</code></pre> min_path_sum.swift<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc minPathSumDPComp(grid: [[Int]]) -&gt; Int {\n    let n = grid.count\n    let m = grid[0].count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: 0, count: m)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0]\n    for j in 1 ..&lt; m {\n        dp[j] = dp[j - 1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in 1 ..&lt; n {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0]\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in 1 ..&lt; m {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n        }\n    }\n    return dp[m - 1]\n}\n</code></pre> min_path_sum.js<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction minPathSumDPComp(grid) {\n    const n = grid.length,\n        m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = new Array(m);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (let j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (let i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (let j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.ts<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction minPathSumDPComp(grid: Array&lt;Array&lt;number&gt;&gt;): number {\n    const n = grid.length,\n        m = grid[0].length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = new Array(m);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (let j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (let i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (let j = 1; j &lt; m; j++) {\n            dp[j] = Math.min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> min_path_sum.dart<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minPathSumDPComp(List&lt;List&lt;int&gt;&gt; grid) {\n  int n = grid.length, m = grid[0].length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;int&gt; dp = List.filled(m, 0);\n  dp[0] = grid[0][0];\n  for (int j = 1; j &lt; m; j++) {\n    dp[j] = dp[j - 1] + grid[0][j];\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n  for (int i = 1; i &lt; n; i++) {\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    dp[0] = dp[0] + grid[i][0];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n    for (int j = 1; j &lt; m; j++) {\n      dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];\n    }\n  }\n  return dp[m - 1];\n}\n</code></pre> min_path_sum.rs<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn min_path_sum_dp_comp(grid: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\n    let (n, m) = (grid.len(), grid[0].len());\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![0; m];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for j in 1..m {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in 1..n {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in 1..m {\n            dp[j] = std::cmp::min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    dp[m - 1]\n}\n</code></pre> min_path_sum.c<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint minPathSumDPComp(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {\n    // \u521d\u59cb\u5316 dp \u8868\n    int *dp = calloc(m, sizeof(int));\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (int j = 1; j &lt; m; j++) {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt; n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt; m; j++) {\n            dp[j] = myMin(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    int res = dp[m - 1];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> min_path_sum.kt<pre><code>/* \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun minPathSumDPComp(grid: Array&lt;IntArray&gt;): Int {\n    val n = grid.size\n    val m = grid[0].size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = IntArray(m)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0]\n    for (j in 1..&lt;m) {\n        dp[j] = dp[j - 1] + grid[0][j]\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (i in 1..&lt;n) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0]\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (j in 1..&lt;m) {\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n        }\n    }\n    return dp[m - 1]\n}\n</code></pre> min_path_sum.rb<pre><code>[class]{}-[func]{min_path_sum_dp_comp}\n</code></pre> min_path_sum.zig<pre><code>// \u6700\u5c0f\u8def\u5f84\u548c\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn minPathSumDPComp(comptime grid: anytype) i32 {\n    comptime var n = grid.len;\n    comptime var m = grid[0].len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_]i32{0} ** m;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    dp[0] = grid[0][0];\n    for (1..m) |j| {\n        dp[j] = dp[j - 1] + grid[0][j];\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (1..n) |i| {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        dp[0] = dp[0] + grid[i][0];\n        for (1..m) |j| {\n            dp[j] = @min(dp[j - 1], dp[j]) + grid[i][j];\n        }\n    }\n    return dp[m - 1];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/","title":"14.6 \u00a0 Edit distance problem","text":"<p>Edit distance, also known as Levenshtein distance, refers to the minimum number of modifications required to transform one string into another, commonly used in information retrieval and natural language processing to measure the similarity between two sequences.</p> <p>Question</p> <p>Given two strings \\(s\\) and \\(t\\), return the minimum number of edits required to transform \\(s\\) into \\(t\\).</p> <p>You can perform three types of edits on a string: insert a character, delete a character, or replace a character with any other character.</p> <p>As shown in Figure 14-27, transforming <code>kitten</code> into <code>sitting</code> requires 3 edits, including 2 replacements and 1 insertion; transforming <code>hello</code> into <code>algo</code> requires 3 steps, including 2 replacements and 1 deletion.</p> <p></p> <p> Figure 14-27 \u00a0 Example data of edit distance </p> <p>The edit distance problem can naturally be explained with a decision tree model. Strings correspond to tree nodes, and a round of decision (an edit operation) corresponds to an edge of the tree.</p> <p>As shown in Figure 14-28, with unrestricted operations, each node can derive many edges, each corresponding to one operation, meaning there are many possible paths to transform <code>hello</code> into <code>algo</code>.</p> <p>From the perspective of the decision tree, the goal of this problem is to find the shortest path between the node <code>hello</code> and the node <code>algo</code>.</p> <p></p> <p> Figure 14-28 \u00a0 Edit distance problem represented based on decision tree model </p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#1-dynamic-programming-approach","title":"1. \u00a0 Dynamic programming approach","text":"<p>Step one: Think about each round of decision, define the state, thus obtaining the \\(dp\\) table</p> <p>Each round of decision involves performing one edit operation on string \\(s\\).</p> <p>We aim to gradually reduce the problem size during the edit process, which enables us to construct subproblems. Let the lengths of strings \\(s\\) and \\(t\\) be \\(n\\) and \\(m\\), respectively. We first consider the tail characters of both strings \\(s[n-1]\\) and \\(t[m-1]\\).</p> <ul> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are the same, we can skip them and directly consider \\(s[n-2]\\) and \\(t[m-2]\\).</li> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are different, we need to perform one edit on \\(s\\) (insert, delete, replace) so that the tail characters of the two strings match, allowing us to skip them and consider a smaller-scale problem.</li> </ul> <p>Thus, each round of decision (edit operation) in string \\(s\\) changes the remaining characters in \\(s\\) and \\(t\\) to be matched. Therefore, the state is the \\(i\\)-th and \\(j\\)-th characters currently considered in \\(s\\) and \\(t\\), denoted as \\([i, j]\\).</p> <p>State \\([i, j]\\) corresponds to the subproblem: The minimum number of edits required to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\).</p> <p>From this, we obtain a two-dimensional \\(dp\\) table of size \\((i+1) \\times (j+1)\\).</p> <p>Step two: Identify the optimal substructure and then derive the state transition equation</p> <p>Consider the subproblem \\(dp[i, j]\\), whose corresponding tail characters of the two strings are \\(s[i-1]\\) and \\(t[j-1]\\), which can be divided into three scenarios as shown in Figure 14-29.</p> <ol> <li>Add \\(t[j-1]\\) after \\(s[i-1]\\), then the remaining subproblem is \\(dp[i, j-1]\\).</li> <li>Delete \\(s[i-1]\\), then the remaining subproblem is \\(dp[i-1, j]\\).</li> <li>Replace \\(s[i-1]\\) with \\(t[j-1]\\), then the remaining subproblem is \\(dp[i-1, j-1]\\).</li> </ol> <p></p> <p> Figure 14-29 \u00a0 State transition of edit distance </p> <p>Based on the analysis above, we can determine the optimal substructure: The minimum number of edits for \\(dp[i, j]\\) is the minimum among \\(dp[i, j-1]\\), \\(dp[i-1, j]\\), and \\(dp[i-1, j-1]\\), plus the edit step \\(1\\). The corresponding state transition equation is:</p> \\[ dp[i, j] = \\min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1 \\] <p>Please note, when \\(s[i-1]\\) and \\(t[j-1]\\) are the same, no edit is required for the current character, in which case the state transition equation is:</p> \\[ dp[i, j] = dp[i-1, j-1] \\] <p>Step three: Determine the boundary conditions and the order of state transitions</p> <p>When both strings are empty, the number of edits is \\(0\\), i.e., \\(dp[0, 0] = 0\\). When \\(s\\) is empty but \\(t\\) is not, the minimum number of edits equals the length of \\(t\\), that is, the first row \\(dp[0, j] = j\\). When \\(s\\) is not empty but \\(t\\) is, the minimum number of edits equals the length of \\(s\\), that is, the first column \\(dp[i, 0] = i\\).</p> <p>Observing the state transition equation, solving \\(dp[i, j]\\) depends on the solutions to the left, above, and upper left, so a double loop can be used to traverse the entire \\(dp\\) table in the correct order.</p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig edit_distance.py<pre><code>def edit_distance_dp(s: str, t: str) -&gt; int:\n    \"\"\"\u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n, m = len(s), len(t)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for i in range(1, n + 1):\n        dp[i][0] = i\n    for j in range(1, m + 1):\n        dp[0][j] = j\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t[j - 1]:\n                # \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1\n    return dp[n][m]\n</code></pre> edit_distance.cpp<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nint editDistanceDP(string s, string t) {\n    int n = s.length(), m = t.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.java<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nint editDistanceDP(String s, String t) {\n    int n = s.length(), m = t.length();\n    int[][] dp = new int[n + 1][m + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.cs<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nint EditDistanceDP(string s, string t) {\n    int n = s.Length, m = t.Length;\n    int[,] dp = new int[n + 1, m + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i, 0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0, j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i, j] = dp[i - 1, j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i, j] = Math.Min(Math.Min(dp[i, j - 1], dp[i - 1, j]), dp[i - 1, j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n, m];\n}\n</code></pre> edit_distance.go<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc editDistanceDP(s string, t string) int {\n    n := len(s)\n    m := len(t)\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, m+1)\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for i := 1; i &lt;= n; i++ {\n        dp[i][0] = i\n    }\n    for j := 1; j &lt;= m; j++ {\n        dp[0][j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j &lt;= m; j++ {\n            if s[i-1] == t[j-1] {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = MinInt(MinInt(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.swift<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc editDistanceDP(s: String, t: String) -&gt; Int {\n    let n = s.utf8CString.count\n    let m = t.utf8CString.count\n    var dp = Array(repeating: Array(repeating: 0, count: m + 1), count: n + 1)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for i in 1 ... n {\n        dp[i][0] = i\n    }\n    for j in 1 ... m {\n        dp[0][j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1 ... n {\n        for j in 1 ... m {\n            if s.utf8CString[i - 1] == t.utf8CString[j - 1] {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1]\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.js<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction editDistanceDP(s, t) {\n    const n = s.length,\n        m = t.length;\n    const dp = Array.from({ length: n + 1 }, () =&gt; new Array(m + 1).fill(0));\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] =\n                    Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.ts<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction editDistanceDP(s: string, t: string): number {\n    const n = s.length,\n        m = t.length;\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: m + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] =\n                    Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> edit_distance.dart<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nint editDistanceDP(String s, String t) {\n  int n = s.length, m = t.length;\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (_) =&gt; List.filled(m + 1, 0));\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n  for (int i = 1; i &lt;= n; i++) {\n    dp[i][0] = i;\n  }\n  for (int j = 1; j &lt;= m; j++) {\n    dp[0][j] = j;\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n      if (s[i - 1] == t[j - 1]) {\n        // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n        dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n      }\n    }\n  }\n  return dp[n][m];\n}\n</code></pre> edit_distance.rs<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfn edit_distance_dp(s: &amp;str, t: &amp;str) -&gt; i32 {\n    let (n, m) = (s.len(), t.len());\n    let mut dp = vec![vec![0; m + 1]; n + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for i in 1..=n {\n        dp[i][0] = i as i32;\n    }\n    for j in 1..m {\n        dp[0][j] = j as i32;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1..=n {\n        for j in 1..=m {\n            if s.chars().nth(i - 1) == t.chars().nth(j - 1) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] =\n                    std::cmp::min(std::cmp::min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    dp[n][m]\n}\n</code></pre> edit_distance.c<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nint editDistanceDP(char *s, char *t, int n, int m) {\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(m + 1, sizeof(int));\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = myMin(myMin(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    int res = dp[n][m];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> edit_distance.kt<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212 */\nfun editDistanceDP(s: String, t: String): Int {\n    val n = s.length\n    val m = t.length\n    val dp = Array(n + 1) { IntArray(m + 1) }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (i in 1..n) {\n        dp[i][0] = i\n    }\n    for (j in 1..m) {\n        dp[0][j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (i in 1..n) {\n        for (j in 1..m) {\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1]\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1\n            }\n        }\n    }\n    return dp[n][m]\n}\n</code></pre> edit_distance.rb<pre><code>[class]{}-[func]{edit_distance_dp}\n</code></pre> edit_distance.zig<pre><code>// \u7f16\u8f91\u8ddd\u79bb\uff1a\u52a8\u6001\u89c4\u5212\nfn editDistanceDP(comptime s: []const u8, comptime t: []const u8) i32 {\n    comptime var n = s.len;\n    comptime var m = t.len;\n    var dp = [_][m + 1]i32{[_]i32{0} ** (m + 1)} ** (n + 1);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (1..n + 1) |i| {\n        dp[i][0] = @intCast(i);\n    }\n    for (1..m + 1) |j| {\n        dp[0][j] = @intCast(j);\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (1..n + 1) |i| {\n        for (1..m + 1) |j| {\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[i][j] = @min(@min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 14-30, the process of state transition in the edit distance problem is very similar to that in the knapsack problem, which can be seen as filling a two-dimensional grid.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-30 \u00a0 Dynamic programming process of edit distance </p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#3-space-optimization","title":"3. \u00a0 Space optimization","text":"<p>Since \\(dp[i, j]\\) is derived from the solutions above \\(dp[i-1, j]\\), to the left \\(dp[i, j-1]\\), and to the upper left \\(dp[i-1, j-1]\\), and direct traversal will lose the upper left solution \\(dp[i-1, j-1]\\), and reverse traversal cannot build \\(dp[i, j-1]\\) in advance, therefore, both traversal orders are not feasible.</p> <p>For this reason, we can use a variable <code>leftup</code> to temporarily store the solution from the upper left \\(dp[i-1, j-1]\\), thus only needing to consider the solutions to the left and above. This situation is similar to the unbounded knapsack problem, allowing for direct traversal. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig edit_distance.py<pre><code>def edit_distance_dp_comp(s: str, t: str) -&gt; int:\n    \"\"\"\u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n, m = len(s), len(t)\n    dp = [0] * (m + 1)\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in range(1, m + 1):\n        dp[j] = j\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in range(1, n + 1):\n        # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        leftup = dp[0]  # \u6682\u5b58 dp[i-1, j-1]\n        dp[0] += 1\n        # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in range(1, m + 1):\n            temp = dp[j]\n            if s[i - 1] == t[j - 1]:\n                # \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup\n            else:\n                # \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = min(dp[j - 1], dp[j], leftup) + 1\n            leftup = temp  # \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n    return dp[m]\n</code></pre> edit_distance.cpp<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint editDistanceDPComp(string s, string t) {\n    int n = s.length(), m = t.length();\n    vector&lt;int&gt; dp(m + 1, 0);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        int leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.java<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint editDistanceDPComp(String s, String t) {\n    int n = s.length(), m = t.length();\n    int[] dp = new int[m + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        int leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = Math.min(Math.min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.cs<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint EditDistanceDPComp(string s, string t) {\n    int n = s.Length, m = t.Length;\n    int[] dp = new int[m + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        int leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = Math.Min(Math.Min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.go<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc editDistanceDPComp(s string, t string) int {\n    n := len(s)\n    m := len(t)\n    dp := make([]int, m+1)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j := 1; j &lt;= m; j++ {\n        dp[j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i := 1; i &lt;= n; i++ {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        leftUp := dp[0] // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j := 1; j &lt;= m; j++ {\n            temp := dp[j]\n            if s[i-1] == t[j-1] {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftUp\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = MinInt(MinInt(dp[j-1], dp[j]), leftUp) + 1\n            }\n            leftUp = temp // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.swift<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc editDistanceDPComp(s: String, t: String) -&gt; Int {\n    let n = s.utf8CString.count\n    let m = t.utf8CString.count\n    var dp = Array(repeating: 0, count: m + 1)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in 1 ... m {\n        dp[j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in 1 ... n {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        var leftup = dp[0] // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in 1 ... m {\n            let temp = dp[j]\n            if s.utf8CString[i - 1] == t.utf8CString[j - 1] {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1\n            }\n            leftup = temp // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.js<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction editDistanceDPComp(s, t) {\n    const n = s.length,\n        m = t.length;\n    const dp = new Array(m + 1).fill(0);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (let j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (let i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        let leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (let j = 1; j &lt;= m; j++) {\n            const temp = dp[j];\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = Math.min(dp[j - 1], dp[j], leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.ts<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction editDistanceDPComp(s: string, t: string): number {\n    const n = s.length,\n        m = t.length;\n    const dp = new Array(m + 1).fill(0);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (let j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (let i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        let leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (let j = 1; j &lt;= m; j++) {\n            const temp = dp[j];\n            if (s.charAt(i - 1) === t.charAt(j - 1)) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = Math.min(dp[j - 1], dp[j], leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> edit_distance.dart<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint editDistanceDPComp(String s, String t) {\n  int n = s.length, m = t.length;\n  List&lt;int&gt; dp = List.filled(m + 1, 0);\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n  for (int j = 1; j &lt;= m; j++) {\n    dp[j] = j;\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n  for (int i = 1; i &lt;= n; i++) {\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n    int leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n    dp[0] = i;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n    for (int j = 1; j &lt;= m; j++) {\n      int temp = dp[j];\n      if (s[i - 1] == t[j - 1]) {\n        // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n        dp[j] = leftup;\n      } else {\n        // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n        dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1;\n      }\n      leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n    }\n  }\n  return dp[m];\n}\n</code></pre> edit_distance.rs<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn edit_distance_dp_comp(s: &amp;str, t: &amp;str) -&gt; i32 {\n    let (n, m) = (s.len(), t.len());\n    let mut dp = vec![0; m + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for j in 1..m {\n        dp[j] = j as i32;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for i in 1..=n {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        let mut leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i as i32;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for j in 1..=m {\n            let temp = dp[j];\n            if s.chars().nth(i - 1) == t.chars().nth(j - 1) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = std::cmp::min(std::cmp::min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    dp[m]\n}\n</code></pre> edit_distance.c<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint editDistanceDPComp(char *s, char *t, int n, int m) {\n    int *dp = calloc(m + 1, sizeof(int));\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (int j = 1; j &lt;= m; j++) {\n        dp[j] = j;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (int i = 1; i &lt;= n; i++) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        int leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i;\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (int j = 1; j &lt;= m; j++) {\n            int temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = myMin(myMin(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    int res = dp[m];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> edit_distance.kt<pre><code>/* \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun editDistanceDPComp(s: String, t: String): Int {\n    val n = s.length\n    val m = t.length\n    val dp = IntArray(m + 1)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (j in 1..m) {\n        dp[j] = j\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (i in 1..n) {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        var leftup = dp[0] // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = i\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (j in 1..m) {\n            val temp = dp[j]\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1\n            }\n            leftup = temp // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m]\n}\n</code></pre> edit_distance.rb<pre><code>[class]{}-[func]{edit_distance_dp_comp}\n</code></pre> edit_distance.zig<pre><code>// \u7f16\u8f91\u8ddd\u79bb\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn editDistanceDPComp(comptime s: []const u8, comptime t: []const u8) i32 {\n    comptime var n = s.len;\n    comptime var m = t.len;\n    var dp = [_]i32{0} ** (m + 1);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\n    for (1..m + 1) |j| {\n        dp[j] = @intCast(j);\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\n    for (1..n + 1) |i| {\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u5217\n        var leftup = dp[0]; // \u6682\u5b58 dp[i-1, j-1]\n        dp[0] = @intCast(i);\n        // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u5217\n        for (1..m + 1) |j| {\n            var temp = dp[j];\n            if (s[i - 1] == t[j - 1]) {\n                // \u82e5\u4e24\u5b57\u7b26\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8df3\u8fc7\u6b64\u4e24\u5b57\u7b26\n                dp[j] = leftup;\n            } else {\n                // \u6700\u5c11\u7f16\u8f91\u6b65\u6570 = \u63d2\u5165\u3001\u5220\u9664\u3001\u66ff\u6362\u8fd9\u4e09\u79cd\u64cd\u4f5c\u7684\u6700\u5c11\u7f16\u8f91\u6b65\u6570 + 1\n                dp[j] = @min(@min(dp[j - 1], dp[j]), leftup) + 1;\n            }\n            leftup = temp; // \u66f4\u65b0\u4e3a\u4e0b\u4e00\u8f6e\u7684 dp[i-1, j-1]\n        }\n    }\n    return dp[m];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/","title":"14.1 \u00a0 Introduction to dynamic programming","text":"<p>Dynamic programming is an important algorithmic paradigm that decomposes a problem into a series of smaller subproblems, and stores the solutions of these subproblems to avoid redundant computations, thereby significantly improving time efficiency.</p> <p>In this section, we start with a classic problem, first presenting its brute force backtracking solution, observing the overlapping subproblems contained within, and then gradually deriving a more efficient dynamic programming solution.</p> <p>Climbing stairs</p> <p>Given a staircase with \\(n\\) steps, where you can climb \\(1\\) or \\(2\\) steps at a time, how many different ways are there to reach the top?</p> <p>As shown in Figure 14-1, there are \\(3\\) ways to reach the top of a \\(3\\)-step staircase.</p> <p></p> <p> Figure 14-1 \u00a0 Number of ways to reach the 3rd step </p> <p>The goal of this problem is to determine the number of ways, considering using backtracking to exhaust all possibilities. Specifically, imagine climbing stairs as a multi-round choice process: starting from the ground, choosing to go up \\(1\\) or \\(2\\) steps each round, adding one to the count of ways upon reaching the top of the stairs, and pruning the process when exceeding the top. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_backtrack.py<pre><code>def backtrack(choices: list[int], state: int, n: int, res: list[int]) -&gt; int:\n    \"\"\"\u56de\u6eaf\"\"\"\n    # \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if state == n:\n        res[0] += 1\n    # \u904d\u5386\u6240\u6709\u9009\u62e9\n    for choice in choices:\n        # \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if state + choice &gt; n:\n            continue\n        # \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res)\n        # \u56de\u9000\n\ndef climbing_stairs_backtrack(n: int) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\uff1a\u56de\u6eaf\"\"\"\n    choices = [1, 2]  # \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    state = 0  # \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    res = [0]  # \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res)\n    return res[0]\n</code></pre> climbing_stairs_backtrack.cpp<pre><code>/* \u56de\u6eaf */\nvoid backtrack(vector&lt;int&gt; &amp;choices, int state, int n, vector&lt;int&gt; &amp;res) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n)\n        res[0]++;\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (auto &amp;choice : choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n)\n            continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nint climbingStairsBacktrack(int n) {\n    vector&lt;int&gt; choices = {1, 2}; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    int state = 0;                // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    vector&lt;int&gt; res = {0};        // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res);\n    return res[0];\n}\n</code></pre> climbing_stairs_backtrack.java<pre><code>/* \u56de\u6eaf */\nvoid backtrack(List&lt;Integer&gt; choices, int state, int n, List&lt;Integer&gt; res) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n)\n        res.set(0, res.get(0) + 1);\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (Integer choice : choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n)\n            continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nint climbingStairsBacktrack(int n) {\n    List&lt;Integer&gt; choices = Arrays.asList(1, 2); // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    int state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    res.add(0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.cs<pre><code>/* \u56de\u6eaf */\nvoid Backtrack(List&lt;int&gt; choices, int state, int n, List&lt;int&gt; res) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n)\n        res[0]++;\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    foreach (int choice in choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n)\n            continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        Backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nint ClimbingStairsBacktrack(int n) {\n    List&lt;int&gt; choices = [1, 2]; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    int state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    List&lt;int&gt; res = [0]; // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    Backtrack(choices, state, n, res);\n    return res[0];\n}\n</code></pre> climbing_stairs_backtrack.go<pre><code>/* \u56de\u6eaf */\nfunc backtrack(choices []int, state, n int, res []int) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if state == n {\n        res[0] = res[0] + 1\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for _, choice := range choices {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if state+choice &gt; n {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state+choice, n, res)\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfunc climbingStairsBacktrack(n int) int {\n    // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    choices := []int{1, 2}\n    // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    state := 0\n    res := make([]int, 1)\n    // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    res[0] = 0\n    backtrack(choices, state, n, res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.swift<pre><code>/* \u56de\u6eaf */\nfunc backtrack(choices: [Int], state: Int, n: Int, res: inout [Int]) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if state == n {\n        res[0] += 1\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for choice in choices {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if state + choice &gt; n {\n            continue\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices: choices, state: state + choice, n: n, res: &amp;res)\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfunc climbingStairsBacktrack(n: Int) -&gt; Int {\n    let choices = [1, 2] // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    let state = 0 // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    var res: [Int] = []\n    res.append(0) // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices: choices, state: state, n: n, res: &amp;res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.js<pre><code>/* \u56de\u6eaf */\nfunction backtrack(choices, state, n, res) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state === n) res.set(0, res.get(0) + 1);\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (const choice of choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n) continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfunction climbingStairsBacktrack(n) {\n    const choices = [1, 2]; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    const state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    const res = new Map();\n    res.set(0, 0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.ts<pre><code>/* \u56de\u6eaf */\nfunction backtrack(\n    choices: number[],\n    state: number,\n    n: number,\n    res: Map&lt;0, any&gt;\n): void {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state === n) res.set(0, res.get(0) + 1);\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (const choice of choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n) continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfunction climbingStairsBacktrack(n: number): number {\n    const choices = [1, 2]; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    const state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    const res = new Map();\n    res.set(0, 0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res);\n    return res.get(0);\n}\n</code></pre> climbing_stairs_backtrack.dart<pre><code>/* \u56de\u6eaf */\nvoid backtrack(List&lt;int&gt; choices, int state, int n, List&lt;int&gt; res) {\n  // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n  if (state == n) {\n    res[0]++;\n  }\n  // \u904d\u5386\u6240\u6709\u9009\u62e9\n  for (int choice in choices) {\n    // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n    if (state + choice &gt; n) continue;\n    // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n    backtrack(choices, state + choice, n, res);\n    // \u56de\u9000\n  }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nint climbingStairsBacktrack(int n) {\n  List&lt;int&gt; choices = [1, 2]; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n  int state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n  List&lt;int&gt; res = [];\n  res.add(0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n  backtrack(choices, state, n, res);\n  return res[0];\n}\n</code></pre> climbing_stairs_backtrack.rs<pre><code>/* \u56de\u6eaf */\nfn backtrack(choices: &amp;[i32], state: i32, n: i32, res: &amp;mut [i32]) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if state == n {\n        res[0] = res[0] + 1;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for &amp;choice in choices {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if state + choice &gt; n {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfn climbing_stairs_backtrack(n: usize) -&gt; i32 {\n    let choices = vec![1, 2]; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    let state = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    let mut res = Vec::new();\n    res.push(0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(&amp;choices, state, n as i32, &amp;mut res);\n    res[0]\n}\n</code></pre> climbing_stairs_backtrack.c<pre><code>/* \u56de\u6eaf */\nvoid backtrack(int *choices, int state, int n, int *res, int len) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n)\n        res[0]++;\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (int i = 0; i &lt; len; i++) {\n        int choice = choices[i];\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n)\n            continue;\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res, len);\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nint climbingStairsBacktrack(int n) {\n    int choices[2] = {1, 2}; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    int state = 0;           // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    int *res = (int *)malloc(sizeof(int));\n    *res = 0; // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    int len = sizeof(choices) / sizeof(int);\n    backtrack(choices, state, n, res, len);\n    int result = *res;\n    free(res);\n    return result;\n}\n</code></pre> climbing_stairs_backtrack.kt<pre><code>/* \u56de\u6eaf */\nfun backtrack(\n    choices: MutableList&lt;Int&gt;,\n    state: Int,\n    n: Int,\n    res: MutableList&lt;Int&gt;\n) {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n)\n        res[0] = res[0] + 1\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (choice in choices) {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n) continue\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res)\n        // \u56de\u9000\n    }\n}\n\n/* \u722c\u697c\u68af\uff1a\u56de\u6eaf */\nfun climbingStairsBacktrack(n: Int): Int {\n    val choices = mutableListOf(1, 2) // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    val state = 0 // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    val res = mutableListOf&lt;Int&gt;()\n    res.add(0) // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(choices, state, n, res)\n    return res[0]\n}\n</code></pre> climbing_stairs_backtrack.rb<pre><code>[class]{}-[func]{backtrack}\n\n[class]{}-[func]{climbing_stairs_backtrack}\n</code></pre> climbing_stairs_backtrack.zig<pre><code>// \u56de\u6eaf\nfn backtrack(choices: []i32, state: i32, n: i32, res: std.ArrayList(i32)) void {\n    // \u5f53\u722c\u5230\u7b2c n \u9636\u65f6\uff0c\u65b9\u6848\u6570\u91cf\u52a0 1\n    if (state == n) {\n        res.items[0] = res.items[0] + 1;\n    }\n    // \u904d\u5386\u6240\u6709\u9009\u62e9\n    for (choices) |choice| {\n        // \u526a\u679d\uff1a\u4e0d\u5141\u8bb8\u8d8a\u8fc7\u7b2c n \u9636\n        if (state + choice &gt; n) {\n            continue;\n        }\n        // \u5c1d\u8bd5\uff1a\u505a\u51fa\u9009\u62e9\uff0c\u66f4\u65b0\u72b6\u6001\n        backtrack(choices, state + choice, n, res);\n        // \u56de\u9000\n    }\n}\n\n// \u722c\u697c\u68af\uff1a\u56de\u6eaf\nfn climbingStairsBacktrack(n: usize) !i32 {\n    var choices = [_]i32{ 1, 2 }; // \u53ef\u9009\u62e9\u5411\u4e0a\u722c 1 \u9636\u6216 2 \u9636\n    var state: i32 = 0; // \u4ece\u7b2c 0 \u9636\u5f00\u59cb\u722c\n    var res = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer res.deinit();\n    try res.append(0); // \u4f7f\u7528 res[0] \u8bb0\u5f55\u65b9\u6848\u6570\u91cf\n    backtrack(&amp;choices, state, @intCast(n), res);\n    return res.items[0];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1411-method-1-brute-force-search","title":"14.1.1 \u00a0 Method 1: Brute force search","text":"<p>Backtracking algorithms do not explicitly decompose the problem but treat solving the problem as a series of decision steps, searching for all possible solutions through exploration and pruning.</p> <p>We can try to analyze this problem from the perspective of decomposition. Let \\(dp[i]\\) be the number of ways to reach the \\(i^{th}\\) step, then \\(dp[i]\\) is the original problem, and its subproblems include:</p> \\[ dp[i-1], dp[i-2], \\dots, dp[2], dp[1] \\] <p>Since each round can only advance \\(1\\) or \\(2\\) steps, when we stand on the \\(i^{th}\\) step, the previous round must have been either on the \\(i-1^{th}\\) or the \\(i-2^{th}\\) step. In other words, we can only step from the \\(i-1^{th}\\) or the \\(i-2^{th}\\) step to the \\(i^{th}\\) step.</p> <p>This leads to an important conclusion: the number of ways to reach the \\(i-1^{th}\\) step plus the number of ways to reach the \\(i-2^{th}\\) step equals the number of ways to reach the \\(i^{th}\\) step. The formula is as follows:</p> \\[ dp[i] = dp[i-1] + dp[i-2] \\] <p>This means that in the stair climbing problem, there is a recursive relationship between the subproblems, the solution to the original problem can be constructed from the solutions to the subproblems. Figure 14-2 shows this recursive relationship.</p> <p></p> <p> Figure 14-2 \u00a0 Recursive relationship of solution counts </p> <p>We can obtain the brute force search solution according to the recursive formula. Starting with \\(dp[n]\\), recursively decompose a larger problem into the sum of two smaller problems, until reaching the smallest subproblems \\(dp[1]\\) and \\(dp[2]\\) where the solutions are known, with \\(dp[1] = 1\\) and \\(dp[2] = 2\\), representing \\(1\\) and \\(2\\) ways to climb to the first and second steps, respectively.</p> <p>Observe the following code, which, like standard backtracking code, belongs to depth-first search but is more concise:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_dfs.py<pre><code>def dfs(i: int) -&gt; int:\n    \"\"\"\u641c\u7d22\"\"\"\n    # \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 or i == 2:\n        return i\n    # dp[i] = dp[i-1] + dp[i-2]\n    count = dfs(i - 1) + dfs(i - 2)\n    return count\n\ndef climbing_stairs_dfs(n: int) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\uff1a\u641c\u7d22\"\"\"\n    return dfs(n)\n</code></pre> climbing_stairs_dfs.cpp<pre><code>/* \u641c\u7d22 */\nint dfs(int i) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.java<pre><code>/* \u641c\u7d22 */\nint dfs(int i) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.cs<pre><code>/* \u641c\u7d22 */\nint DFS(int i) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = DFS(i - 1) + DFS(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nint ClimbingStairsDFS(int n) {\n    return DFS(n);\n}\n</code></pre> climbing_stairs_dfs.go<pre><code>/* \u641c\u7d22 */\nfunc dfs(i int) int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    count := dfs(i-1) + dfs(i-2)\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfunc climbingStairsDFS(n int) int {\n    return dfs(n)\n}\n</code></pre> climbing_stairs_dfs.swift<pre><code>/* \u641c\u7d22 */\nfunc dfs(i: Int) -&gt; Int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i: i - 1) + dfs(i: i - 2)\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfunc climbingStairsDFS(n: Int) -&gt; Int {\n    dfs(i: n)\n}\n</code></pre> climbing_stairs_dfs.js<pre><code>/* \u641c\u7d22 */\nfunction dfs(i) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i === 1 || i === 2) return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfunction climbingStairsDFS(n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.ts<pre><code>/* \u641c\u7d22 */\nfunction dfs(i: number): number {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i === 1 || i === 2) return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfunction climbingStairsDFS(n: number): number {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.dart<pre><code>/* \u641c\u7d22 */\nint dfs(int i) {\n  // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n  if (i == 1 || i == 2) return i;\n  // dp[i] = dp[i-1] + dp[i-2]\n  int count = dfs(i - 1) + dfs(i - 2);\n  return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nint climbingStairsDFS(int n) {\n  return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.rs<pre><code>/* \u641c\u7d22 */\nfn dfs(i: usize) -&gt; i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i as i32;\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i - 1) + dfs(i - 2);\n    count\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfn climbing_stairs_dfs(n: usize) -&gt; i32 {\n    dfs(n)\n}\n</code></pre> climbing_stairs_dfs.c<pre><code>/* \u641c\u7d22 */\nint dfs(int i) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nint climbingStairsDFS(int n) {\n    return dfs(n);\n}\n</code></pre> climbing_stairs_dfs.kt<pre><code>/* \u641c\u7d22 */\nfun dfs(i: Int): Int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2) return i\n    // dp[i] = dp[i-1] + dp[i-2]\n    val count = dfs(i - 1) + dfs(i - 2)\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u641c\u7d22 */\nfun climbingStairsDFS(n: Int): Int {\n    return dfs(n)\n}\n</code></pre> climbing_stairs_dfs.rb<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{climbing_stairs_dfs}\n</code></pre> climbing_stairs_dfs.zig<pre><code>// \u641c\u7d22\nfn dfs(i: usize) i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 or i == 2) {\n        return @intCast(i);\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    var count = dfs(i - 1) + dfs(i - 2);\n    return count;\n}\n\n// \u722c\u697c\u68af\uff1a\u641c\u7d22\nfn climbingStairsDFS(comptime n: usize) i32 {\n    return dfs(n);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-3 shows the recursive tree formed by brute force search. For the problem \\(dp[n]\\), the depth of its recursive tree is \\(n\\), with a time complexity of \\(O(2^n)\\). Exponential order represents explosive growth, and entering a long wait if a relatively large \\(n\\) is input.</p> <p></p> <p> Figure 14-3 \u00a0 Recursive tree for climbing stairs </p> <p>Observing Figure 14-3, the exponential time complexity is caused by 'overlapping subproblems'. For example, \\(dp[9]\\) is decomposed into \\(dp[8]\\) and \\(dp[7]\\), \\(dp[8]\\) into \\(dp[7]\\) and \\(dp[6]\\), both containing the subproblem \\(dp[7]\\).</p> <p>Thus, subproblems include even smaller overlapping subproblems, endlessly. A vast majority of computational resources are wasted on these overlapping subproblems.</p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1412-method-2-memoized-search","title":"14.1.2 \u00a0 Method 2: Memoized search","text":"<p>To enhance algorithm efficiency, we hope that all overlapping subproblems are calculated only once. For this purpose, we declare an array <code>mem</code> to record the solution of each subproblem, and prune overlapping subproblems during the search process.</p> <ol> <li>When \\(dp[i]\\) is calculated for the first time, we record it in <code>mem[i]</code> for later use.</li> <li>When \\(dp[i]\\) needs to be calculated again, we can directly retrieve the result from <code>mem[i]</code>, thus avoiding redundant calculations of that subproblem.</li> </ol> <p>The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_dfs_mem.py<pre><code>def dfs(i: int, mem: list[int]) -&gt; int:\n    \"\"\"\u8bb0\u5fc6\u5316\u641c\u7d22\"\"\"\n    # \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 or i == 2:\n        return i\n    # \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if mem[i] != -1:\n        return mem[i]\n    # dp[i] = dp[i-1] + dp[i-2]\n    count = dfs(i - 1, mem) + dfs(i - 2, mem)\n    # \u8bb0\u5f55 dp[i]\n    mem[i] = count\n    return count\n\ndef climbing_stairs_dfs_mem(n: int) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\"\"\"\n    # mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    mem = [-1] * (n + 1)\n    return dfs(n, mem)\n</code></pre> climbing_stairs_dfs_mem.cpp<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nint dfs(int i, vector&lt;int&gt; &amp;mem) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint climbingStairsDFSMem(int n) {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    vector&lt;int&gt; mem(n + 1, -1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.java<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nint dfs(int i, int[] mem) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint climbingStairsDFSMem(int n) {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    int[] mem = new int[n + 1];\n    Arrays.fill(mem, -1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.cs<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nint DFS(int i, int[] mem) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = DFS(i - 1, mem) + DFS(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint ClimbingStairsDFSMem(int n) {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    int[] mem = new int[n + 1];\n    Array.Fill(mem, -1);\n    return DFS(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.go<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc dfsMem(i int, mem []int) int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i\n    }\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if mem[i] != -1 {\n        return mem[i]\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    count := dfsMem(i-1, mem) + dfsMem(i-2, mem)\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc climbingStairsDFSMem(n int) int {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    mem := make([]int, n+1)\n    for i := range mem {\n        mem[i] = -1\n    }\n    return dfsMem(n, mem)\n}\n</code></pre> climbing_stairs_dfs_mem.swift<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc dfs(i: Int, mem: inout [Int]) -&gt; Int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i\n    }\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if mem[i] != -1 {\n        return mem[i]\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i: i - 1, mem: &amp;mem) + dfs(i: i - 2, mem: &amp;mem)\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc climbingStairsDFSMem(n: Int) -&gt; Int {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    var mem = Array(repeating: -1, count: n + 1)\n    return dfs(i: n, mem: &amp;mem)\n}\n</code></pre> climbing_stairs_dfs_mem.js<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction dfs(i, mem) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i === 1 || i === 2) return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1) return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction climbingStairsDFSMem(n) {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    const mem = new Array(n + 1).fill(-1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.ts<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction dfs(i: number, mem: number[]): number {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i === 1 || i === 2) return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1) return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    const count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction climbingStairsDFSMem(n: number): number {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    const mem = new Array(n + 1).fill(-1);\n    return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.dart<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nint dfs(int i, List&lt;int&gt; mem) {\n  // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n  if (i == 1 || i == 2) return i;\n  // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n  if (mem[i] != -1) return mem[i];\n  // dp[i] = dp[i-1] + dp[i-2]\n  int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n  // \u8bb0\u5f55 dp[i]\n  mem[i] = count;\n  return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint climbingStairsDFSMem(int n) {\n  // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n  List&lt;int&gt; mem = List.filled(n + 1, -1);\n  return dfs(n, mem);\n}\n</code></pre> climbing_stairs_dfs_mem.rs<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfn dfs(i: usize, mem: &amp;mut [i32]) -&gt; i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if i == 1 || i == 2 {\n        return i as i32;\n    }\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if mem[i] != -1 {\n        return mem[i];\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    let count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    count\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfn climbing_stairs_dfs_mem(n: usize) -&gt; i32 {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    let mut mem = vec![-1; n + 1];\n    dfs(n, &amp;mut mem)\n}\n</code></pre> climbing_stairs_dfs_mem.c<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nint dfs(int i, int *mem) {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2)\n        return i;\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1)\n        return mem[i];\n    // dp[i] = dp[i-1] + dp[i-2]\n    int count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint climbingStairsDFSMem(int n) {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    int *mem = (int *)malloc((n + 1) * sizeof(int));\n    for (int i = 0; i &lt;= n; i++) {\n        mem[i] = -1;\n    }\n    int result = dfs(n, mem);\n    free(mem);\n    return result;\n}\n</code></pre> climbing_stairs_dfs_mem.kt<pre><code>/* \u8bb0\u5fc6\u5316\u641c\u7d22 */\nfun dfs(i: Int, mem: IntArray): Int {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 || i == 2) return i\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1) return mem[i]\n    // dp[i] = dp[i-1] + dp[i-2]\n    val count = dfs(i - 1, mem) + dfs(i - 2, mem)\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count\n    return count\n}\n\n/* \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfun climbingStairsDFSMem(n: Int): Int {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    val mem = IntArray(n + 1)\n    mem.fill(-1)\n    return dfs(n, mem)\n}\n</code></pre> climbing_stairs_dfs_mem.rb<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{climbing_stairs_dfs_mem}\n</code></pre> climbing_stairs_dfs_mem.zig<pre><code>// \u8bb0\u5fc6\u5316\u641c\u7d22\nfn dfs(i: usize, mem: []i32) i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (i == 1 or i == 2) {\n        return @intCast(i);\n    }\n    // \u82e5\u5b58\u5728\u8bb0\u5f55 dp[i] \uff0c\u5219\u76f4\u63a5\u8fd4\u56de\u4e4b\n    if (mem[i] != -1) {\n        return mem[i];\n    }\n    // dp[i] = dp[i-1] + dp[i-2]\n    var count = dfs(i - 1, mem) + dfs(i - 2, mem);\n    // \u8bb0\u5f55 dp[i]\n    mem[i] = count;\n    return count;\n}\n\n// \u722c\u697c\u68af\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\nfn climbingStairsDFSMem(comptime n: usize) i32 {\n    // mem[i] \u8bb0\u5f55\u722c\u5230\u7b2c i \u9636\u7684\u65b9\u6848\u603b\u6570\uff0c-1 \u4ee3\u8868\u65e0\u8bb0\u5f55\n    var mem = [_]i32{ -1 } ** (n + 1);\n    return dfs(n, &amp;mem);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Observe Figure 14-4, after memoization, all overlapping subproblems need to be calculated only once, optimizing the time complexity to \\(O(n)\\), which is a significant leap.</p> <p></p> <p> Figure 14-4 \u00a0 Recursive tree with memoized search </p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1413-method-3-dynamic-programming","title":"14.1.3 \u00a0 Method 3: Dynamic programming","text":"<p>Memoized search is a 'top-down' method: we start with the original problem (root node), recursively decompose larger subproblems into smaller ones until the solutions to the smallest known subproblems (leaf nodes) are reached. Subsequently, by backtracking, we collect the solutions of the subproblems, constructing the solution to the original problem.</p> <p>On the contrary, dynamic programming is a 'bottom-up' method: starting with the solutions to the smallest subproblems, iteratively construct the solutions to larger subproblems until the original problem is solved.</p> <p>Since dynamic programming does not include a backtracking process, it only requires looping iteration to implement, without needing recursion. In the following code, we initialize an array <code>dp</code> to store the solutions to the subproblems, serving the same recording function as the array <code>mem</code> in memoized search:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_dp.py<pre><code>def climbing_stairs_dp(n: int) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    if n == 1 or n == 2:\n        return n\n    # \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp = [0] * (n + 1)\n    # \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1], dp[2] = 1, 2\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n</code></pre> climbing_stairs_dp.cpp<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    vector&lt;int&gt; dp(n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.java<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[] dp = new int[n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.cs<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint ClimbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int[] dp = new int[n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.go<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsDP(n int) int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    dp := make([]int, n+1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1\n    dp[2] = 2\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i := 3; i &lt;= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.swift<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsDP(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = Array(repeating: 0, count: n + 1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1\n    dp[2] = 2\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3 ... n {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.js<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsDP(n) {\n    if (n === 1 || n === 2) return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = new Array(n + 1).fill(-1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.ts<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsDP(n: number): number {\n    if (n === 1 || n === 2) return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    const dp = new Array(n + 1).fill(-1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (let i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> climbing_stairs_dp.dart<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDP(int n) {\n  if (n == 1 || n == 2) return n;\n  // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n  List&lt;int&gt; dp = List.filled(n + 1, 0);\n  // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n  dp[1] = 1;\n  dp[2] = 2;\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n  for (int i = 3; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}\n</code></pre> climbing_stairs_dp.rs<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfn climbing_stairs_dp(n: usize) -&gt; i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if n == 1 || n == 2 {\n        return n as i32;\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    let mut dp = vec![-1; n + 1];\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i in 3..=n {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    dp[n]\n}\n</code></pre> climbing_stairs_dp.c<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDP(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    int *dp = (int *)malloc((n + 1) * sizeof(int));\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (int i = 3; i &lt;= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    int result = dp[n];\n    free(dp);\n    return result;\n}\n</code></pre> climbing_stairs_dp.kt<pre><code>/* \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212 */\nfun climbingStairsDP(n: Int): Int {\n    if (n == 1 || n == 2) return n\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    val dp = IntArray(n + 1)\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1\n    dp[2] = 2\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (i in 3..n) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n</code></pre> climbing_stairs_dp.rb<pre><code>[class]{}-[func]{climbing_stairs_dp}\n</code></pre> climbing_stairs_dp.zig<pre><code>// \u722c\u697c\u68af\uff1a\u52a8\u6001\u89c4\u5212\nfn climbingStairsDP(comptime n: usize) i32 {\n    // \u5df2\u77e5 dp[1] \u548c dp[2] \uff0c\u8fd4\u56de\u4e4b\n    if (n == 1 or n == 2) {\n        return @intCast(n);\n    }\n    // \u521d\u59cb\u5316 dp \u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5b50\u95ee\u9898\u7684\u89e3\n    var dp = [_]i32{-1} ** (n + 1);\n    // \u521d\u59cb\u72b6\u6001\uff1a\u9884\u8bbe\u6700\u5c0f\u5b50\u95ee\u9898\u7684\u89e3\n    dp[1] = 1;\n    dp[2] = 2;\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for (3..n + 1) |i| {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-5 simulates the execution process of the above code.</p> <p></p> <p> Figure 14-5 \u00a0 Dynamic programming process for climbing stairs </p> <p>Like the backtracking algorithm, dynamic programming also uses the concept of \"states\" to represent specific stages in problem solving, each state corresponding to a subproblem and its local optimal solution. For example, the state of the climbing stairs problem is defined as the current step number \\(i\\).</p> <p>Based on the above content, we can summarize the commonly used terminology in dynamic programming.</p> <ul> <li>The array <code>dp</code> is referred to as the DP table, with \\(dp[i]\\) representing the solution to the subproblem corresponding to state \\(i\\).</li> <li>The states corresponding to the smallest subproblems (steps \\(1\\) and \\(2\\)) are called initial states.</li> <li>The recursive formula \\(dp[i] = dp[i-1] + dp[i-2]\\) is called the state transition equation.</li> </ul>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#1414-space-optimization","title":"14.1.4 \u00a0 Space optimization","text":"<p>Observant readers may have noticed that since \\(dp[i]\\) is only related to \\(dp[i-1]\\) and \\(dp[i-2]\\), we do not need to use an array <code>dp</code> to store the solutions to all subproblems, but can simply use two variables to progress iteratively. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig climbing_stairs_dp.py<pre><code>def climbing_stairs_dp_comp(n: int) -&gt; int:\n    \"\"\"\u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    if n == 1 or n == 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b\n</code></pre> climbing_stairs_dp.cpp<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.java<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.cs<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint ClimbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.go<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsDPComp(n int) int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    a, b := 1, 2\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u4ece\u8f83\u5c0f\u5b50\u95ee\u9898\u9010\u6b65\u6c42\u89e3\u8f83\u5927\u5b50\u95ee\u9898\n    for i := 3; i &lt;= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.swift<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc climbingStairsDPComp(n: Int) -&gt; Int {\n    if n == 1 || n == 2 {\n        return n\n    }\n    var a = 1\n    var b = 2\n    for _ in 3 ... n {\n        (a, b) = (b, a + b)\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.js<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsDPComp(n) {\n    if (n === 1 || n === 2) return n;\n    let a = 1,\n        b = 2;\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.ts<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction climbingStairsDPComp(n: number): number {\n    if (n === 1 || n === 2) return n;\n    let a = 1,\n        b = 2;\n    for (let i = 3; i &lt;= n; i++) {\n        const tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.dart<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDPComp(int n) {\n  if (n == 1 || n == 2) return n;\n  int a = 1, b = 2;\n  for (int i = 3; i &lt;= n; i++) {\n    int tmp = b;\n    b = a + b;\n    a = tmp;\n  }\n  return b;\n}\n</code></pre> climbing_stairs_dp.rs<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn climbing_stairs_dp_comp(n: usize) -&gt; i32 {\n    if n == 1 || n == 2 {\n        return n as i32;\n    }\n    let (mut a, mut b) = (1, 2);\n    for _ in 3..=n {\n        let tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    b\n}\n</code></pre> climbing_stairs_dp.c<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint climbingStairsDPComp(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int a = 1, b = 2;\n    for (int i = 3; i &lt;= n; i++) {\n        int tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> climbing_stairs_dp.kt<pre><code>/* \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun climbingStairsDPComp(n: Int): Int {\n    if (n == 1 || n == 2) return n\n    var a = 1\n    var b = 2\n    for (i in 3..n) {\n        val temp = b\n        b += a\n        a = temp\n    }\n    return b\n}\n</code></pre> climbing_stairs_dp.rb<pre><code>[class]{}-[func]{climbing_stairs_dp_comp}\n</code></pre> climbing_stairs_dp.zig<pre><code>// \u722c\u697c\u68af\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn climbingStairsDPComp(comptime n: usize) i32 {\n    if (n == 1 or n == 2) {\n        return @intCast(n);\n    }\n    var a: i32 = 1;\n    var b: i32 = 2;\n    for (3..n + 1) |_| {\n        var tmp = b;\n        b = a + b;\n        a = tmp;\n    }\n    return b;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Observing the above code, since the space occupied by the array <code>dp</code> is eliminated, the space complexity is reduced from \\(O(n)\\) to \\(O(1)\\).</p> <p>In dynamic programming problems, the current state is often only related to a limited number of previous states, allowing us to retain only the necessary states and save memory space by \"dimension reduction\". This space optimization technique is known as 'rolling variable' or 'rolling array'.</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/","title":"14.4 \u00a0 0-1 Knapsack problem","text":"<p>The knapsack problem is an excellent introductory problem for dynamic programming and is the most common type of problem in dynamic programming. It has many variants, such as the 0-1 knapsack problem, the unbounded knapsack problem, and the multiple knapsack problem, etc.</p> <p>In this section, we will first solve the most common 0-1 knapsack problem.</p> <p>Question</p> <p>Given \\(n\\) items, the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with a capacity of \\(cap\\). Each item can be chosen only once. What is the maximum value of items that can be placed in the knapsack under the capacity limit?</p> <p>Observe Figure 14-17, since the item number \\(i\\) starts counting from 1, and the array index starts from 0, thus the weight of item \\(i\\) corresponds to \\(wgt[i-1]\\) and the value corresponds to \\(val[i-1]\\).</p> <p></p> <p> Figure 14-17 \u00a0 Example data of the 0-1 knapsack </p> <p>We can consider the 0-1 knapsack problem as a process consisting of \\(n\\) rounds of decisions, where for each item there are two decisions: not to put it in or to put it in, thus the problem fits the decision tree model.</p> <p>The objective of this problem is to \"maximize the value of the items that can be put in the knapsack under the limited capacity,\" thus it is more likely a dynamic programming problem.</p> <p>First step: Think about each round of decisions, define states, thereby obtaining the \\(dp\\) table</p> <p>For each item, if not put into the knapsack, the capacity remains unchanged; if put in, the capacity is reduced. From this, the state definition can be obtained: the current item number \\(i\\) and knapsack capacity \\(c\\), denoted as \\([i, c]\\).</p> <p>State \\([i, c]\\) corresponds to the sub-problem: the maximum value of the first \\(i\\) items in a knapsack of capacity \\(c\\), denoted as \\(dp[i, c]\\).</p> <p>The solution we are looking for is \\(dp[n, cap]\\), so we need a two-dimensional \\(dp\\) table of size \\((n+1) \\times (cap+1)\\).</p> <p>Second step: Identify the optimal substructure, then derive the state transition equation</p> <p>After making the decision for item \\(i\\), what remains is the sub-problem of decisions for the first \\(i-1\\) items, which can be divided into two cases.</p> <ul> <li>Not putting item \\(i\\): The knapsack capacity remains unchanged, state changes to \\([i-1, c]\\).</li> <li>Putting item \\(i\\): The knapsack capacity decreases by \\(wgt[i-1]\\), and the value increases by \\(val[i-1]\\), state changes to \\([i-1, c-wgt[i-1]]\\).</li> </ul> <p>The above analysis reveals the optimal substructure of this problem: the maximum value \\(dp[i, c]\\) is equal to the larger value of the two schemes of not putting item \\(i\\) and putting item \\(i\\). From this, the state transition equation can be derived:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1]) \\] <p>It is important to note that if the current item's weight \\(wgt[i - 1]\\) exceeds the remaining knapsack capacity \\(c\\), then the only option is not to put it in the knapsack.</p> <p>Third step: Determine the boundary conditions and the order of state transitions</p> <p>When there are no items or the knapsack capacity is \\(0\\), the maximum value is \\(0\\), i.e., the first column \\(dp[i, 0]\\) and the first row \\(dp[0, c]\\) are both equal to \\(0\\).</p> <p>The current state \\([i, c]\\) transitions from the state directly above \\([i-1, c]\\) and the state to the upper left \\([i-1, c-wgt[i-1]]\\), thus, the entire \\(dp\\) table is traversed in order through two layers of loops.</p> <p>Following the above analysis, we will next implement the solutions in the order of brute force search, memoized search, and dynamic programming.</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#1-method-one-brute-force-search","title":"1. \u00a0 Method one: Brute force search","text":"<p>The search code includes the following elements.</p> <ul> <li>Recursive parameters: State \\([i, c]\\).</li> <li>Return value: Solution to the sub-problem \\(dp[i, c]\\).</li> <li>Termination condition: When the item number is out of bounds \\(i = 0\\) or the remaining capacity of the knapsack is \\(0\\), terminate the recursion and return the value \\(0\\).</li> <li>Pruning: If the current item's weight exceeds the remaining capacity of the knapsack, the only option is not to put it in the knapsack.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig knapsack.py<pre><code>def knapsack_dfs(wgt: list[int], val: list[int], i: int, c: int) -&gt; int:\n    \"\"\"0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22\"\"\"\n    # \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 or c == 0:\n        return 0\n    # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c:\n        return knapsack_dfs(wgt, val, i - 1, c)\n    # \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    no = knapsack_dfs(wgt, val, i - 1, c)\n    yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]\n    # \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return max(no, yes)\n</code></pre> knapsack.cpp<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nint knapsackDFS(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return max(no, yes);\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nint knapsackDFS(int[] wgt, int[] val, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nint KnapsackDFS(int[] weight, int[] val, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (weight[i - 1] &gt; c) {\n        return KnapsackDFS(weight, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = KnapsackDFS(weight, val, i - 1, c);\n    int yes = KnapsackDFS(weight, val, i - 1, c - weight[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return Math.Max(no, yes);\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfunc knapsackDFS(wgt, val []int, i, c int) int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i-1] &gt; c {\n        return knapsackDFS(wgt, val, i-1, c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    no := knapsackDFS(wgt, val, i-1, c)\n    yes := knapsackDFS(wgt, val, i-1, c-wgt[i-1]) + val[i-1]\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return int(math.Max(float64(no), float64(yes)))\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfunc knapsackDFS(wgt: [Int], val: [Int], i: Int, c: Int) -&gt; Int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c {\n        return knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    let no = knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c)\n    let yes = knapsackDFS(wgt: wgt, val: val, i: i - 1, c: c - wgt[i - 1]) + val[i - 1]\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return max(no, yes)\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfunction knapsackDFS(wgt, val, i, c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    const no = knapsackDFS(wgt, val, i - 1, c);\n    const yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfunction knapsackDFS(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    i: number,\n    c: number\n): number {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    const no = knapsackDFS(wgt, val, i - 1, c);\n    const yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return Math.max(no, yes);\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nint knapsackDFS(List&lt;int&gt; wgt, List&lt;int&gt; val, int i, int c) {\n  // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n  if (i == 0 || c == 0) {\n    return 0;\n  }\n  // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n  if (wgt[i - 1] &gt; c) {\n    return knapsackDFS(wgt, val, i - 1, c);\n  }\n  // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n  int no = knapsackDFS(wgt, val, i - 1, c);\n  int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n  // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n  return max(no, yes);\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfn knapsack_dfs(wgt: &amp;[i32], val: &amp;[i32], i: usize, c: usize) -&gt; i32 {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c as i32 {\n        return knapsack_dfs(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    let no = knapsack_dfs(wgt, val, i - 1, c);\n    let yes = knapsack_dfs(wgt, val, i - 1, c - wgt[i - 1] as usize) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    std::cmp::max(no, yes)\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nint knapsackDFS(int wgt[], int val[], int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFS(wgt, val, i - 1, c);\n    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return myMax(no, yes);\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22 */\nfun knapsackDFS(\n    wgt: IntArray,\n    _val: IntArray,\n    i: Int,\n    c: Int\n): Int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, _val, i - 1, c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    val no = knapsackDFS(wgt, _val, i - 1, c)\n    val yes = knapsackDFS(wgt, _val, i - 1, c - wgt[i - 1]) + _val[i - 1]\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return max(no, yes)\n}\n</code></pre> knapsack.rb<pre><code>[class]{}-[func]{knapsack_dfs}\n</code></pre> knapsack.zig<pre><code>// 0-1 \u80cc\u5305\uff1a\u66b4\u529b\u641c\u7d22\nfn knapsackDFS(wgt: []i32, val: []i32, i: usize, c: usize) i32 {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 or c == 0) {\n        return 0;\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFS(wgt, val, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    var no = knapsackDFS(wgt, val, i - 1, c);\n    var yes = knapsackDFS(wgt, val, i - 1, c - @as(usize, @intCast(wgt[i - 1]))) + val[i - 1];\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    return @max(no, yes);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 14-18, since each item generates two search branches of not selecting and selecting, the time complexity is \\(O(2^n)\\).</p> <p>Observing the recursive tree, it is easy to see that there are overlapping sub-problems, such as \\(dp[1, 10]\\), etc. When there are many items and the knapsack capacity is large, especially when there are many items of the same weight, the number of overlapping sub-problems will increase significantly.</p> <p></p> <p> Figure 14-18 \u00a0 The brute force search recursive tree of the 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#2-method-two-memoized-search","title":"2. \u00a0 Method two: Memoized search","text":"<p>To ensure that overlapping sub-problems are only calculated once, we use a memoization list <code>mem</code> to record the solutions to sub-problems, where <code>mem[i][c]</code> corresponds to \\(dp[i, c]\\).</p> <p>After introducing memoization, the time complexity depends on the number of sub-problems, which is \\(O(n \\times cap)\\). The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig knapsack.py<pre><code>def knapsack_dfs_mem(\n    wgt: list[int], val: list[int], mem: list[list[int]], i: int, c: int\n) -&gt; int:\n    \"\"\"0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\"\"\"\n    # \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 or c == 0:\n        return 0\n    # \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][c] != -1:\n        return mem[i][c]\n    # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c:\n        return knapsack_dfs_mem(wgt, val, mem, i - 1, c)\n    # \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    no = knapsack_dfs_mem(wgt, val, mem, i - 1, c)\n    yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1]\n    # \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint knapsackDFSMem(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, vector&lt;vector&lt;int&gt;&gt; &amp;mem, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint knapsackDFSMem(int[] wgt, int[] val, int[][] mem, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint KnapsackDFSMem(int[] weight, int[] val, int[][] mem, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (weight[i - 1] &gt; c) {\n        return KnapsackDFSMem(weight, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = KnapsackDFSMem(weight, val, mem, i - 1, c);\n    int yes = KnapsackDFSMem(weight, val, mem, i - 1, c - weight[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = Math.Max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc knapsackDFSMem(wgt, val []int, mem [][]int, i, c int) int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][c] != -1 {\n        return mem[i][c]\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i-1] &gt; c {\n        return knapsackDFSMem(wgt, val, mem, i-1, c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    no := knapsackDFSMem(wgt, val, mem, i-1, c)\n    yes := knapsackDFSMem(wgt, val, mem, i-1, c-wgt[i-1]) + val[i-1]\n    // \u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = int(math.Max(float64(no), float64(yes)))\n    return mem[i][c]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunc knapsackDFSMem(wgt: [Int], val: [Int], mem: inout [[Int]], i: Int, c: Int) -&gt; Int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][c] != -1 {\n        return mem[i][c]\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c {\n        return knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    let no = knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c)\n    let yes = knapsackDFSMem(wgt: wgt, val: val, mem: &amp;mem, i: i - 1, c: c - wgt[i - 1]) + val[i - 1]\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction knapsackDFSMem(wgt, val, mem, i, c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] !== -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    const no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    const yes =\n        knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfunction knapsackDFSMem(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    mem: Array&lt;Array&lt;number&gt;&gt;,\n    i: number,\n    c: number\n): number {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i === 0 || c === 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] !== -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    const no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    const yes =\n        knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = Math.max(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint knapsackDFSMem(\n  List&lt;int&gt; wgt,\n  List&lt;int&gt; val,\n  List&lt;List&lt;int&gt;&gt; mem,\n  int i,\n  int c,\n) {\n  // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n  if (i == 0 || c == 0) {\n    return 0;\n  }\n  // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n  if (mem[i][c] != -1) {\n    return mem[i][c];\n  }\n  // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n  if (wgt[i - 1] &gt; c) {\n    return knapsackDFSMem(wgt, val, mem, i - 1, c);\n  }\n  // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n  int no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n  int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n  // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n  mem[i][c] = max(no, yes);\n  return mem[i][c];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfn knapsack_dfs_mem(wgt: &amp;[i32], val: &amp;[i32], mem: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, i: usize, c: usize) -&gt; i32 {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if i == 0 || c == 0 {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if mem[i][c] != -1 {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if wgt[i - 1] &gt; c as i32 {\n        return knapsack_dfs_mem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    let no = knapsack_dfs_mem(wgt, val, mem, i - 1, c);\n    let yes = knapsack_dfs_mem(wgt, val, mem, i - 1, c - wgt[i - 1] as usize) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = std::cmp::max(no, yes);\n    mem[i][c]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nint knapsackDFSMem(int wgt[], int val[], int memCols, int **mem, int i, int c) {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, memCols, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    int no = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c);\n    int yes = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c - wgt[i - 1]) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = myMax(no, yes);\n    return mem[i][c];\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22 */\nfun knapsackDFSMem(\n    wgt: IntArray,\n    _val: IntArray,\n    mem: Array&lt;IntArray&gt;,\n    i: Int,\n    c: Int\n): Int {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 || c == 0) {\n        return 0\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c]\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, _val, mem, i - 1, c)\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    val no = knapsackDFSMem(wgt, _val, mem, i - 1, c)\n    val yes = knapsackDFSMem(wgt, _val, mem, i - 1, c - wgt[i - 1]) + _val[i - 1]\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = max(no, yes)\n    return mem[i][c]\n}\n</code></pre> knapsack.rb<pre><code>[class]{}-[func]{knapsack_dfs_mem}\n</code></pre> knapsack.zig<pre><code>// 0-1 \u80cc\u5305\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\nfn knapsackDFSMem(wgt: []i32, val: []i32, mem: anytype, i: usize, c: usize) i32 {\n    // \u82e5\u5df2\u9009\u5b8c\u6240\u6709\u7269\u54c1\u6216\u80cc\u5305\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u5219\u8fd4\u56de\u4ef7\u503c 0\n    if (i == 0 or c == 0) {\n        return 0;\n    }\n    // \u82e5\u5df2\u6709\u8bb0\u5f55\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (mem[i][c] != -1) {\n        return mem[i][c];\n    }\n    // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u53ea\u80fd\u9009\u62e9\u4e0d\u653e\u5165\u80cc\u5305\n    if (wgt[i - 1] &gt; c) {\n        return knapsackDFSMem(wgt, val, mem, i - 1, c);\n    }\n    // \u8ba1\u7b97\u4e0d\u653e\u5165\u548c\u653e\u5165\u7269\u54c1 i \u7684\u6700\u5927\u4ef7\u503c\n    var no = knapsackDFSMem(wgt, val, mem, i - 1, c);\n    var yes = knapsackDFSMem(wgt, val, mem, i - 1, c - @as(usize, @intCast(wgt[i - 1]))) + val[i - 1];\n    // \u8bb0\u5f55\u5e76\u8fd4\u56de\u4e24\u79cd\u65b9\u6848\u4e2d\u4ef7\u503c\u66f4\u5927\u7684\u90a3\u4e00\u4e2a\n    mem[i][c] = @max(no, yes);\n    return mem[i][c];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-19 shows the search branches that are pruned in memoized search.</p> <p></p> <p> Figure 14-19 \u00a0 The memoized search recursive tree of the 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#3-method-three-dynamic-programming","title":"3. \u00a0 Method three: Dynamic programming","text":"<p>Dynamic programming essentially involves filling the \\(dp\\) table during the state transition, the code is shown in Figure 14-20:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig knapsack.py<pre><code>def knapsack_dp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(wgt)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [[0] * (cap + 1) for _ in range(n + 1)]\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])\n    return dp[n][cap]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint knapsackDP(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(cap + 1, 0));\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint knapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[][] dp = new int[n + 1][cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint KnapsackDP(int[] weight, int[] val, int cap) {\n    int n = weight.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[,] dp = new int[n + 1, cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (weight[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i, c] = dp[i - 1, c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i, c] = Math.Max(dp[i - 1, c - weight[i - 1]] + val[i - 1], dp[i - 1, c]);\n            }\n        }\n    }\n    return dp[n, cap];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc knapsackDP(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, cap+1)\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i-1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = int(math.Max(float64(dp[i-1][c]), float64(dp[i-1][c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc knapsackDP(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: Array(repeating: 0, count: cap + 1), count: n + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction knapsackDP(wgt, val, cap) {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array(n + 1)\n        .fill(0)\n        .map(() =&gt; Array(cap + 1).fill(0));\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction knapsackDP(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint knapsackDP(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(cap + 1, 0));\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n        dp[i][c] = dp[i - 1][c];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n        dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[n][cap];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfn knapsack_dp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![vec![0; cap + 1]; n + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = std::cmp::max(\n                    dp[i - 1][c],\n                    dp[i - 1][c - wgt[i - 1] as usize] + val[i - 1],\n                );\n            }\n        }\n    }\n    dp[n][cap]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint knapsackDP(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(cap + 1, sizeof(int));\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = myMax(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[n][cap];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfun knapsackDP(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = Array(n + 1) { IntArray(cap + 1) }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> knapsack.rb<pre><code>[class]{}-[func]{knapsack_dp}\n</code></pre> knapsack.zig<pre><code>// 0-1 \u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212\nfn knapsackDP(comptime wgt: []i32, val: []i32, comptime cap: usize) i32 {\n    comptime var n = wgt.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_][cap + 1]i32{[_]i32{0} ** (cap + 1)} ** (n + 1);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..cap + 1) |c| {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = @max(dp[i - 1][c], dp[i - 1][c - @as(usize, @intCast(wgt[i - 1]))] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in the figures below, both the time complexity and space complexity are determined by the size of the array <code>dp</code>, i.e., \\(O(n \\times cap)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-20 \u00a0 The dynamic programming process of the 0-1 knapsack problem </p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#4-space-optimization","title":"4. \u00a0 Space optimization","text":"<p>Since each state is only related to the state in the row above it, we can use two arrays to roll forward, reducing the space complexity from \\(O(n^2)\\) to \\(O(n)\\).</p> <p>Further thinking, can we use just one array to achieve space optimization? It can be observed that each state is transferred from the cell directly above or from the upper left cell. If there is only one array, when starting to traverse the \\(i\\)-th row, that array still stores the state of row \\(i-1\\).</p> <ul> <li>If using normal order traversal, then when traversing to \\(dp[i, j]\\), the values from the upper left \\(dp[i-1, 1]\\) ~ \\(dp[i-1, j-1]\\) may have already been overwritten, thus the correct state transition result cannot be obtained.</li> <li>If using reverse order traversal, there will be no overwriting problem, and the state transition can be conducted correctly.</li> </ul> <p>The figures below show the transition process from row \\(i = 1\\) to row \\(i = 2\\) in a single array. Please think about the differences between normal order traversal and reverse order traversal.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-21 \u00a0 The space-optimized dynamic programming process of the 0-1 knapsack </p> <p>In the code implementation, we only need to delete the first dimension \\(i\\) of the array <code>dp</code> and change the inner loop to reverse traversal:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig knapsack.py<pre><code>def knapsack_dp_comp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(wgt)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [0] * (cap + 1)\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        # \u5012\u5e8f\u904d\u5386\n        for c in range(cap, 0, -1):\n            if wgt[i - 1] &gt; c:\n                # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n    return dp[cap]\n</code></pre> knapsack.cpp<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint knapsackDPComp(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;int&gt; dp(cap + 1, 0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.java<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint knapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.cs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint KnapsackDPComp(int[] weight, int[] val, int cap) {\n    int n = weight.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (int c = cap; c &gt; 0; c--) {\n            if (weight[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.Max(dp[c], dp[c - weight[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.go<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc knapsackDPComp(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([]int, cap+1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        // \u5012\u5e8f\u904d\u5386\n        for c := cap; c &gt;= 1; c-- {\n            if wgt[i-1] &lt;= c {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = int(math.Max(float64(dp[c]), float64(dp[c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.swift<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc knapsackDPComp(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: 0, count: cap + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        // \u5012\u5e8f\u904d\u5386\n        for c in (1 ... cap).reversed() {\n            if wgt[i - 1] &lt;= c {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.js<pre><code>/* 0-1 \u80cc\u5305\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction knapsackDPComp(wgt, val, cap) {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array(cap + 1).fill(0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (let c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.ts<pre><code>/* 0-1 \u80cc\u5305\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction knapsackDPComp(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array(cap + 1).fill(0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (let c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> knapsack.dart<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint knapsackDPComp(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;int&gt; dp = List.filled(cap + 1, 0);\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    // \u5012\u5e8f\u904d\u5386\n    for (int c = cap; c &gt;= 1; c--) {\n      if (wgt[i - 1] &lt;= c) {\n        // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n        dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[cap];\n}\n</code></pre> knapsack.rs<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn knapsack_dp_comp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![0; cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        // \u5012\u5e8f\u904d\u5386\n        for c in (1..=cap).rev() {\n            if wgt[i - 1] &lt;= c as i32 {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = std::cmp::max(dp[c], dp[c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    dp[cap]\n}\n</code></pre> knapsack.c<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint knapsackDPComp(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int *dp = calloc(cap + 1, sizeof(int));\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        // \u5012\u5e8f\u904d\u5386\n        for (int c = cap; c &gt;= 1; c--) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = myMax(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[cap];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> knapsack.kt<pre><code>/* 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun knapsackDPComp(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = IntArray(cap + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        // \u5012\u5e8f\u904d\u5386\n        for (c in cap downTo 1) {\n            if (wgt[i - 1] &lt;= c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> knapsack.rb<pre><code>[class]{}-[func]{knapsack_dp_comp}\n</code></pre> knapsack.zig<pre><code>// 0-1 \u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn knapsackDPComp(wgt: []i32, val: []i32, comptime cap: usize) i32 {\n    var n = wgt.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_]i32{0} ** (cap + 1);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        // \u5012\u5e8f\u904d\u5386\n        var c = cap;\n        while (c &gt; 0) : (c -= 1) {\n            if (wgt[i - 1] &lt; c) {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = @max(dp[c], dp[c - @as(usize, @intCast(wgt[i - 1]))] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/summary/","title":"14.7 \u00a0 Summary","text":"<ul> <li>Dynamic programming decomposes problems and improves computational efficiency by avoiding redundant computations through storing solutions of subproblems.</li> <li>Without considering time, all dynamic programming problems can be solved using backtracking (brute force search), but the recursion tree has many overlapping subproblems, resulting in very low efficiency. By introducing a memorization list, it's possible to store solutions of all computed subproblems, ensuring that overlapping subproblems are only computed once.</li> <li>Memorization search is a top-down recursive solution, whereas dynamic programming corresponds to a bottom-up iterative approach, akin to \"filling out a table.\" Since the current state only depends on certain local states, we can eliminate one dimension of the dp table to reduce space complexity.</li> <li>Decomposition of subproblems is a universal algorithmic approach, differing in characteristics among divide and conquer, dynamic programming, and backtracking.</li> <li>Dynamic programming problems have three main characteristics: overlapping subproblems, optimal substructure, and no aftereffects.</li> <li>If the optimal solution of the original problem can be constructed from the optimal solutions of its subproblems, it has an optimal substructure.</li> <li>No aftereffects mean that the future development of a state depends only on the current state and not on all past states experienced. Many combinatorial optimization problems do not have this property and cannot be quickly solved using dynamic programming.</li> </ul> <p>Knapsack problem</p> <ul> <li>The knapsack problem is one of the most typical dynamic programming problems, with variants including the 0-1 knapsack, unbounded knapsack, and multiple knapsacks.</li> <li>The state definition of the 0-1 knapsack is the maximum value in a knapsack of capacity \\(c\\) with the first \\(i\\) items. Based on decisions not to include or to include an item in the knapsack, optimal substructures can be identified and state transition equations constructed. In space optimization, since each state depends on the state directly above and to the upper left, the list should be traversed in reverse order to avoid overwriting the upper left state.</li> <li>In the unbounded knapsack problem, there is no limit on the number of each kind of item that can be chosen, thus the state transition for including items differs from the 0-1 knapsack. Since the state depends on the state directly above and to the left, space optimization should involve forward traversal.</li> <li>The coin change problem is a variant of the unbounded knapsack problem, shifting from seeking the \u201cmaximum\u201d value to seeking the \u201cminimum\u201d number of coins, thus the state transition equation should change \\(\\max()\\) to \\(\\min()\\). From pursuing \u201cnot exceeding\u201d the capacity of the knapsack to seeking exactly the target amount, thus use \\(amt + 1\\) to represent the invalid solution of \u201cunable to make up the target amount.\u201d</li> <li>Coin Change Problem II shifts from seeking the \u201cminimum number of coins\u201d to seeking the \u201cnumber of coin combinations,\u201d changing the state transition equation accordingly from \\(\\min()\\) to summation operator.</li> </ul> <p>Edit distance problem</p> <ul> <li>Edit distance (Levenshtein distance) measures the similarity between two strings, defined as the minimum number of editing steps needed to change one string into another, with editing operations including adding, deleting, or replacing.</li> <li>The state definition for the edit distance problem is the minimum number of editing steps needed to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\). When \\(s[i] \\ne t[j]\\), there are three decisions: add, delete, replace, each with their corresponding residual subproblems. From this, optimal substructures can be identified, and state transition equations built. When \\(s[i] = t[j]\\), no editing of the current character is necessary.</li> <li>In edit distance, the state depends on the state directly above, to the left, and to the upper left. Therefore, after space optimization, neither forward nor reverse traversal can correctly perform state transitions. To address this, we use a variable to temporarily store the upper left state, making it equivalent to the situation in the unbounded knapsack problem, allowing for forward traversal after space optimization.</li> </ul>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/","title":"14.5 \u00a0 Unbounded knapsack problem","text":"<p>In this section, we first solve another common knapsack problem: the unbounded knapsack, and then explore a special case of it: the coin change problem.</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1451-unbounded-knapsack-problem","title":"14.5.1 \u00a0 Unbounded knapsack problem","text":"<p>Question</p> <p>Given \\(n\\) items, where the weight of the \\(i^{th}\\) item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a backpack with a capacity of \\(cap\\). Each item can be selected multiple times. What is the maximum value of the items that can be put into the backpack without exceeding its capacity? See the example below.</p> <p></p> <p> Figure 14-22 \u00a0 Example data for the unbounded knapsack problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach","title":"1. \u00a0 Dynamic programming approach","text":"<p>The unbounded knapsack problem is very similar to the 0-1 knapsack problem, the only difference being that there is no limit on the number of times an item can be chosen.</p> <ul> <li>In the 0-1 knapsack problem, there is only one of each item, so after placing item \\(i\\) into the backpack, you can only choose from the previous \\(i-1\\) items.</li> <li>In the unbounded knapsack problem, the quantity of each item is unlimited, so after placing item \\(i\\) in the backpack, you can still choose from the previous \\(i\\) items.</li> </ul> <p>Under the rules of the unbounded knapsack problem, the state \\([i, c]\\) can change in two ways.</p> <ul> <li>Not putting item \\(i\\) in: As with the 0-1 knapsack problem, transition to \\([i-1, c]\\).</li> <li>Putting item \\(i\\) in: Unlike the 0-1 knapsack problem, transition to \\([i, c-wgt[i-1]]\\).</li> </ul> <p>The state transition equation thus becomes:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1]) \\]"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"<p>Comparing the code for the two problems, the state transition changes from \\(i-1\\) to \\(i\\), the rest is completely identical:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig unbounded_knapsack.py<pre><code>def unbounded_knapsack_dp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"\u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(wgt)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [[0] * (cap + 1) for _ in range(n + 1)]\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1])\n    return dp[n][cap]\n</code></pre> unbounded_knapsack.cpp<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDP(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(cap + 1, 0));\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.java<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[][] dp = new int[n + 1][cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.cs<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint UnboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n    int n = wgt.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[,] dp = new int[n + 1, cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i, c] = dp[i - 1, c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i, c] = Math.Max(dp[i - 1, c], dp[i, c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n, cap];\n}\n</code></pre> unbounded_knapsack.go<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc unboundedKnapsackDP(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, cap+1)\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i-1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = int(math.Max(float64(dp[i-1][c]), float64(dp[i][c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.swift<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc unboundedKnapsackDP(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: Array(repeating: 0, count: cap + 1), count: n + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.js<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction unboundedKnapsackDP(wgt, val, cap) {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.ts<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction unboundedKnapsackDP(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: cap + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = Math.max(\n                    dp[i - 1][c],\n                    dp[i][c - wgt[i - 1]] + val[i - 1]\n                );\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.dart<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDP(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(cap + 1, 0));\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n        dp[i][c] = dp[i - 1][c];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n        dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.rs<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfn unbounded_knapsack_dp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![vec![0; cap + 1]; n + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = std::cmp::max(dp[i - 1][c], dp[i][c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> unbounded_knapsack.c<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDP(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(cap + 1, sizeof(int));\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = myMax(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[n][cap];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    return res;\n}\n</code></pre> unbounded_knapsack.kt<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212 */\nfun unboundedKnapsackDP(wgt: IntArray, _val: IntArray, cap: Int): Int {\n    val n = wgt.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = Array(n + 1) { IntArray(cap + 1) }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[n][cap]\n}\n</code></pre> unbounded_knapsack.rb<pre><code>[class]{}-[func]{unbounded_knapsack_dp}\n</code></pre> unbounded_knapsack.zig<pre><code>// \u5b8c\u5168\u80cc\u5305\uff1a\u52a8\u6001\u89c4\u5212\nfn unboundedKnapsackDP(comptime wgt: []i32, val: []i32, comptime cap: usize) i32 {\n    comptime var n = wgt.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_][cap + 1]i32{[_]i32{0} ** (cap + 1)} ** (n + 1);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..cap + 1) |c| {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[i][c] = dp[i - 1][c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[i][c] = @max(dp[i - 1][c], dp[i][c - @as(usize, @intCast(wgt[i - 1]))] + val[i - 1]);\n            }\n        }\n    }\n    return dp[n][cap];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization","title":"3. \u00a0 Space optimization","text":"<p>Since the current state comes from the state to the left and above, the space-optimized solution should perform a forward traversal for each row in the \\(dp\\) table.</p> <p>This traversal order is the opposite of that for the 0-1 knapsack. Please refer to Figure 14-23 to understand the difference.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-23 \u00a0 Dynamic programming process for the unbounded knapsack problem after space optimization </p> <p>The code implementation is quite simple, just remove the first dimension of the array <code>dp</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig unbounded_knapsack.py<pre><code>def unbounded_knapsack_dp_comp(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"\u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(wgt)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [0] * (cap + 1)\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        # \u6b63\u5e8f\u904d\u5386\n        for c in range(1, cap + 1):\n            if wgt[i - 1] &gt; c:\n                # \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n    return dp[cap]\n</code></pre> unbounded_knapsack.cpp<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDPComp(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    int n = wgt.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;int&gt; dp(cap + 1, 0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.java<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.cs<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint UnboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n    int n = wgt.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.Max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.go<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc unboundedKnapsackDPComp(wgt, val []int, cap int) int {\n    n := len(wgt)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([]int, cap+1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        for c := 1; c &lt;= cap; c++ {\n            if wgt[i-1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = int(math.Max(float64(dp[c]), float64(dp[c-wgt[i-1]]+val[i-1])))\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.swift<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc unboundedKnapsackDPComp(wgt: [Int], val: [Int], cap: Int) -&gt; Int {\n    let n = wgt.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: 0, count: cap + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for c in 1 ... cap {\n            if wgt[i - 1] &gt; c {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.js<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction unboundedKnapsackDPComp(wgt, val, cap) {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: cap + 1 }, () =&gt; 0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.ts<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction unboundedKnapsackDPComp(\n    wgt: Array&lt;number&gt;,\n    val: Array&lt;number&gt;,\n    cap: number\n): number {\n    const n = wgt.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: cap + 1 }, () =&gt; 0);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> unbounded_knapsack.dart<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDPComp(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  int n = wgt.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;int&gt; dp = List.filled(cap + 1, 0);\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int c = 1; c &lt;= cap; c++) {\n      if (wgt[i - 1] &gt; c) {\n        // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n        dp[c] = dp[c];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n        dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n      }\n    }\n  }\n  return dp[cap];\n}\n</code></pre> unbounded_knapsack.rs<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn unbounded_knapsack_dp_comp(wgt: &amp;[i32], val: &amp;[i32], cap: usize) -&gt; i32 {\n    let n = wgt.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![0; cap + 1];\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for c in 1..=cap {\n            if wgt[i - 1] &gt; c as i32 {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = std::cmp::max(dp[c], dp[c - wgt[i - 1] as usize] + val[i - 1]);\n            }\n        }\n    }\n    dp[cap]\n}\n</code></pre> unbounded_knapsack.c<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint unboundedKnapsackDPComp(int wgt[], int val[], int cap, int wgtSize) {\n    int n = wgtSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int *dp = calloc(cap + 1, sizeof(int));\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int c = 1; c &lt;= cap; c++) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = myMax(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n            }\n        }\n    }\n    int res = dp[cap];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> unbounded_knapsack.kt<pre><code>/* \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun unboundedKnapsackDPComp(\n    wgt: IntArray,\n    _val: IntArray,\n    cap: Int\n): Int {\n    val n = wgt.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = IntArray(cap + 1)\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (c in 1..cap) {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + _val[i - 1])\n            }\n        }\n    }\n    return dp[cap]\n}\n</code></pre> unbounded_knapsack.rb<pre><code>[class]{}-[func]{unbounded_knapsack_dp_comp}\n</code></pre> unbounded_knapsack.zig<pre><code>// \u5b8c\u5168\u80cc\u5305\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn unboundedKnapsackDPComp(comptime wgt: []i32, val: []i32, comptime cap: usize) i32 {\n    comptime var n = wgt.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_]i32{0} ** (cap + 1);\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..cap + 1) |c| {\n            if (wgt[i - 1] &gt; c) {\n                // \u82e5\u8d85\u8fc7\u80cc\u5305\u5bb9\u91cf\uff0c\u5219\u4e0d\u9009\u7269\u54c1 i\n                dp[c] = dp[c];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u7269\u54c1 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5927\u503c\n                dp[c] = @max(dp[c], dp[c - @as(usize, @intCast(wgt[i - 1]))] + val[i - 1]);\n            }\n        }\n    }\n    return dp[cap];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1452-coin-change-problem","title":"14.5.2 \u00a0 Coin change problem","text":"<p>The knapsack problem is a representative of a large class of dynamic programming problems and has many variants, such as the coin change problem.</p> <p>Question</p> <p>Given \\(n\\) types of coins, the denomination of the \\(i^{th}\\) type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times. What is the minimum number of coins needed to make up the target amount? If it is impossible to make up the target amount, return \\(-1\\). See the example below.</p> <p></p> <p> Figure 14-24 \u00a0 Example data for the coin change problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach_1","title":"1. \u00a0 Dynamic programming approach","text":"<p>The coin change can be seen as a special case of the unbounded knapsack problem, sharing the following similarities and differences.</p> <ul> <li>The two problems can be converted into each other: \"item\" corresponds to \"coin\", \"item weight\" corresponds to \"coin denomination\", and \"backpack capacity\" corresponds to \"target amount\".</li> <li>The optimization goals are opposite: the unbounded knapsack problem aims to maximize the value of items, while the coin change problem aims to minimize the number of coins.</li> <li>The unbounded knapsack problem seeks solutions \"not exceeding\" the backpack capacity, while the coin change seeks solutions that \"exactly\" make up the target amount.</li> </ul> <p>First step: Think through each round's decision-making, define the state, and thus derive the \\(dp\\) table</p> <p>The state \\([i, a]\\) corresponds to the sub-problem: the minimum number of coins that can make up the amount \\(a\\) using the first \\(i\\) types of coins, denoted as \\(dp[i, a]\\).</p> <p>The two-dimensional \\(dp\\) table is of size \\((n+1) \\times (amt+1)\\).</p> <p>Second step: Identify the optimal substructure and derive the state transition equation</p> <p>This problem differs from the unbounded knapsack problem in two aspects of the state transition equation.</p> <ul> <li>This problem seeks the minimum, so the operator \\(\\max()\\) needs to be changed to \\(\\min()\\).</li> <li>The optimization is focused on the number of coins, so simply add \\(+1\\) when a coin is chosen.</li> </ul> \\[ dp[i, a] = \\min(dp[i-1, a], dp[i, a - coins[i-1]] + 1) \\] <p>Third step: Define boundary conditions and state transition order</p> <p>When the target amount is \\(0\\), the minimum number of coins needed to make it up is \\(0\\), so all \\(dp[i, 0]\\) in the first column are \\(0\\).</p> <p>When there are no coins, it is impossible to make up any amount &gt;0, which is an invalid solution. To allow the \\(\\min()\\) function in the state transition equation to recognize and filter out invalid solutions, consider using \\(+\\infty\\) to represent them, i.e., set all \\(dp[0, a]\\) in the first row to \\(+\\infty\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation_1","title":"2. \u00a0 Code implementation","text":"<p>Most programming languages do not provide a \\(+\\infty\\) variable, only the maximum value of an integer <code>int</code> can be used as a substitute. This can lead to overflow: the \\(+1\\) operation in the state transition equation may overflow.</p> <p>For this reason, we use the number \\(amt + 1\\) to represent an invalid solution, because the maximum number of coins needed to make up \\(amt\\) is at most \\(amt\\). Before returning the result, check if \\(dp[n, amt]\\) equals \\(amt + 1\\), and if so, return \\(-1\\), indicating that the target amount cannot be made up. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig coin_change.py<pre><code>def coin_change_dp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"\u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(coins)\n    MAX = amt + 1\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [[0] * (amt + 1) for _ in range(n + 1)]\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for a in range(1, amt + 1):\n        dp[0][a] = MAX\n    # \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in range(1, n + 1):\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n    return dp[n][amt] if dp[n][amt] != MAX else -1\n</code></pre> coin_change.cpp<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeDP(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amt + 1, 0));\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.java<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeDP(int[] coins, int amt) {\n    int n = coins.length;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[][] dp = new int[n + 1][amt + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.cs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nint CoinChangeDP(int[] coins, int amt) {\n    int n = coins.Length;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[,] dp = new int[n + 1, amt + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0, a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i, a] = dp[i - 1, a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i, a] = Math.Min(dp[i - 1, a], dp[i, a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n, amt] != MAX ? dp[n, amt] : -1;\n}\n</code></pre> coin_change.go<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeDP(coins []int, amt int) int {\n    n := len(coins)\n    max := amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, amt+1)\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for a := 1; a &lt;= amt; a++ {\n        dp[0][a] = max\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i := 1; i &lt;= n; i++ {\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i-1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = int(math.Min(float64(dp[i-1][a]), float64(dp[i][a-coins[i-1]]+1)))\n            }\n        }\n    }\n    if dp[n][amt] != max {\n        return dp[n][amt]\n    }\n    return -1\n}\n</code></pre> coin_change.swift<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeDP(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    let MAX = amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: Array(repeating: 0, count: amt + 1), count: n + 1)\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for a in 1 ... amt {\n        dp[0][a] = MAX\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return dp[n][amt] != MAX ? dp[n][amt] : -1\n}\n</code></pre> coin_change.js<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeDP(coins, amt) {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (let a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] !== MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.ts<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeDP(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (let a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[n][amt] !== MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.dart<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeDP(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  int MAX = amt + 1;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(amt + 1, 0));\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n  for (int a = 1; a &lt;= amt; a++) {\n    dp[0][a] = MAX;\n  }\n  // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n        dp[i][a] = dp[i - 1][a];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n        dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n      }\n    }\n  }\n  return dp[n][amt] != MAX ? dp[n][amt] : -1;\n}\n</code></pre> coin_change.rs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfn coin_change_dp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    let max = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![vec![0; amt + 1]; n + 1];\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for a in 1..=amt {\n        dp[0][a] = max;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = std::cmp::min(dp[i - 1][a], dp[i][a - coins[i - 1] as usize] + 1);\n            }\n        }\n    }\n    if dp[n][amt] != max {\n        return dp[n][amt] as i32;\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change.c<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeDP(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(amt + 1, sizeof(int));\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (int a = 1; a &lt;= amt; a++) {\n        dp[0][a] = MAX;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = myMin(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    int res = dp[n][amt] != MAX ? dp[n][amt] : -1;\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> coin_change.kt<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfun coinChangeDP(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    val MAX = amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = Array(n + 1) { IntArray(amt + 1) }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (a in 1..amt) {\n        dp[0][a] = MAX\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return if (dp[n][amt] != MAX) dp[n][amt] else -1\n}\n</code></pre> coin_change.rb<pre><code>[class]{}-[func]{coin_change_dp}\n</code></pre> coin_change.zig<pre><code>// \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212\nfn coinChangeDP(comptime coins: []i32, comptime amt: usize) i32 {\n    comptime var n = coins.len;\n    comptime var max = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_][amt + 1]i32{[_]i32{0} ** (amt + 1)} ** (n + 1);\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u9996\u884c\u9996\u5217\n    for (1..amt + 1) |a| {\n        dp[0][a] = max;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for (1..n + 1) |i| {\n        for (1..amt + 1) |a| {\n            if (coins[i - 1] &gt; @as(i32, @intCast(a))) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = @min(dp[i - 1][a], dp[i][a - @as(usize, @intCast(coins[i - 1]))] + 1);\n            }\n        }\n    }\n    if (dp[n][amt] != max) {\n        return @intCast(dp[n][amt]);\n    } else {\n        return -1;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Figure 14-25 show the dynamic programming process for the coin change problem, which is very similar to the unbounded knapsack problem.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 14-25 \u00a0 Dynamic programming process for the coin change problem </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization_1","title":"3. \u00a0 Space optimization","text":"<p>The space optimization for the coin change problem is handled in the same way as for the unbounded knapsack problem:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig coin_change.py<pre><code>def coin_change_dp_comp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"\u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(coins)\n    MAX = amt + 1\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [MAX] * (amt + 1)\n    dp[0] = 0\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        # \u6b63\u5e8f\u904d\u5386\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n    return dp[amt] if dp[amt] != MAX else -1\n</code></pre> coin_change.cpp<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeDPComp(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;int&gt; dp(amt + 1, MAX);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.java<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeDPComp(int[] coins, int amt) {\n    int n = coins.length;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[amt + 1];\n    Arrays.fill(dp, MAX);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.cs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint CoinChangeDPComp(int[] coins, int amt) {\n    int n = coins.Length;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[amt + 1];\n    Array.Fill(dp, MAX);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = Math.Min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.go<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeDPComp(coins []int, amt int) int {\n    n := len(coins)\n    max := amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([]int, amt+1)\n    for i := 1; i &lt;= amt; i++ {\n        dp[i] = max\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        // \u6b63\u5e8f\u904d\u5386\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = int(math.Min(float64(dp[a]), float64(dp[a-coins[i-1]]+1)))\n            }\n        }\n    }\n    if dp[amt] != max {\n        return dp[amt]\n    }\n    return -1\n}\n</code></pre> coin_change.swift<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeDPComp(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    let MAX = amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: MAX, count: amt + 1)\n    dp[0] = 0\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return dp[amt] != MAX ? dp[amt] : -1\n}\n</code></pre> coin_change.js<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeDPComp(coins, amt) {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: amt + 1 }, () =&gt; MAX);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] !== MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.ts<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeDPComp(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    const MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: amt + 1 }, () =&gt; MAX);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return dp[amt] !== MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.dart<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeDPComp(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  int MAX = amt + 1;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;int&gt; dp = List.filled(amt + 1, MAX);\n  dp[0] = 0;\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n        dp[a] = dp[a];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n        dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);\n      }\n    }\n  }\n  return dp[amt] != MAX ? dp[amt] : -1;\n}\n</code></pre> coin_change.rs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn coin_change_dp_comp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    let max = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![0; amt + 1];\n    dp.fill(max);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = std::cmp::min(dp[a], dp[a - coins[i - 1] as usize] + 1);\n            }\n        }\n    }\n    if dp[amt] != max {\n        return dp[amt] as i32;\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change.c<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeDPComp(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    int MAX = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    int *dp = malloc((amt + 1) * sizeof(int));\n    for (int j = 1; j &lt;= amt; j++) {\n        dp[j] = MAX;\n    } \n    dp[0] = 0;\n\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = myMin(dp[a], dp[a - coins[i - 1]] + 1);\n            }\n        }\n    }\n    int res = dp[amt] != MAX ? dp[amt] : -1;\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> coin_change.kt<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun coinChangeDPComp(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    val MAX = amt + 1\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = IntArray(amt + 1)\n    dp.fill(MAX)\n    dp[0] = 0\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1)\n            }\n        }\n    }\n    return if (dp[amt] != MAX) dp[amt] else -1\n}\n</code></pre> coin_change.rb<pre><code>[class]{}-[func]{coin_change_dp_comp}\n</code></pre> coin_change.zig<pre><code>// \u96f6\u94b1\u5151\u6362\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn coinChangeDPComp(comptime coins: []i32, comptime amt: usize) i32 {\n    comptime var n = coins.len;\n    comptime var max = amt + 1;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_]i32{0} ** (amt + 1);\n    @memset(&amp;dp, max);\n    dp[0] = 0;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..amt + 1) |a| {\n            if (coins[i - 1] &gt; @as(i32, @intCast(a))) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = @min(dp[a], dp[a - @as(usize, @intCast(coins[i - 1]))] + 1);\n            }\n        }\n    }\n    if (dp[amt] != max) {\n        return @intCast(dp[amt]);\n    } else {\n        return -1;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1453-coin-change-problem-ii","title":"14.5.3 \u00a0 Coin change problem II","text":"<p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i^{th}\\) type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times, ask how many combinations of coins can make up the target amount. See the example below.</p> <p></p> <p> Figure 14-26 \u00a0 Example data for Coin Change Problem II </p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#1-dynamic-programming-approach_2","title":"1. \u00a0 Dynamic programming approach","text":"<p>Compared to the previous problem, the goal of this problem is to determine the number of combinations, so the sub-problem becomes: the number of combinations that can make up amount \\(a\\) using the first \\(i\\) types of coins. The \\(dp\\) table remains a two-dimensional matrix of size \\((n+1) \\times (amt + 1)\\).</p> <p>The number of combinations for the current state is the sum of the combinations from not selecting the current coin and selecting the current coin. The state transition equation is:</p> \\[ dp[i, a] = dp[i-1, a] + dp[i, a - coins[i-1]] \\] <p>When the target amount is \\(0\\), no coins are needed to make up the target amount, so all \\(dp[i, 0]\\) in the first column should be initialized to \\(1\\). When there are no coins, it is impossible to make up any amount &gt;0, so all \\(dp[0, a]\\) in the first row should be set to \\(0\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#2-code-implementation_2","title":"2. \u00a0 Code implementation","text":"PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig coin_change_ii.py<pre><code>def coin_change_ii_dp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"\u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(coins)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [[0] * (amt + 1) for _ in range(n + 1)]\n    # \u521d\u59cb\u5316\u9996\u5217\n    for i in range(n + 1):\n        dp[i][0] = 1\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n    return dp[n][amt]\n</code></pre> coin_change_ii.cpp<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDP(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amt + 1, 0));\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.java<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDP(int[] coins, int amt) {\n    int n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[][] dp = new int[n + 1][amt + 1];\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.cs<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nint CoinChangeIIDP(int[] coins, int amt) {\n    int n = coins.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[,] dp = new int[n + 1, amt + 1];\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i, 0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i, a] = dp[i - 1, a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i, a] = dp[i - 1, a] + dp[i, a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n, amt];\n}\n</code></pre> coin_change_ii.go<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeIIDP(coins []int, amt int) int {\n    n := len(coins)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([][]int, n+1)\n    for i := 0; i &lt;= n; i++ {\n        dp[i] = make([]int, amt+1)\n    }\n    // \u521d\u59cb\u5316\u9996\u5217\n    for i := 0; i &lt;= n; i++ {\n        dp[i][0] = 1\n    }\n    // \u72b6\u6001\u8f6c\u79fb\uff1a\u5176\u4f59\u884c\u548c\u5217\n    for i := 1; i &lt;= n; i++ {\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i-1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i-1][a] + dp[i][a-coins[i-1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.swift<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeIIDP(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: Array(repeating: 0, count: amt + 1), count: n + 1)\n    // \u521d\u59cb\u5316\u9996\u5217\n    for i in 0 ... n {\n        dp[i][0] = 1\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.js<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeIIDP(coins, amt) {\n    const n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (let i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.ts<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeIIDP(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: n + 1 }, () =&gt;\n        Array.from({ length: amt + 1 }, () =&gt; 0)\n    );\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (let i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> coin_change_ii.dart<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDP(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;List&lt;int&gt;&gt; dp = List.generate(n + 1, (index) =&gt; List.filled(amt + 1, 0));\n  // \u521d\u59cb\u5316\u9996\u5217\n  for (int i = 0; i &lt;= n; i++) {\n    dp[i][0] = 1;\n  }\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n        dp[i][a] = dp[i - 1][a];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n        dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n      }\n    }\n  }\n  return dp[n][amt];\n}\n</code></pre> coin_change_ii.rs<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfn coin_change_ii_dp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![vec![0; amt + 1]; n + 1];\n    // \u521d\u59cb\u5316\u9996\u5217\n    for i in 0..=n {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1] as usize];\n            }\n        }\n    }\n    dp[n][amt]\n}\n</code></pre> coin_change_ii.c<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDP(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int **dp = malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i] = calloc(amt + 1, sizeof(int));\n    }\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n            }\n        }\n    }\n    int res = dp[n][amt];\n    // \u91ca\u653e\u5185\u5b58\n    for (int i = 0; i &lt;= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return res;\n}\n</code></pre> coin_change_ii.kt<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212 */\nfun coinChangeIIDP(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = Array(n + 1) { IntArray(amt + 1) }\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (i in 0..n) {\n        dp[i][0] = 1\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[n][amt]\n}\n</code></pre> coin_change_ii.rb<pre><code>[class]{}-[func]{coin_change_ii_dp}\n</code></pre> coin_change_ii.zig<pre><code>// \u96f6\u94b1\u5151\u6362 II\uff1a\u52a8\u6001\u89c4\u5212\nfn coinChangeIIDP(comptime coins: []i32, comptime amt: usize) i32 {\n    comptime var n = coins.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_][amt + 1]i32{[_]i32{0} ** (amt + 1)} ** (n + 1);\n    // \u521d\u59cb\u5316\u9996\u5217\n    for (0..n + 1) |i| {\n        dp[i][0] = 1;\n    }\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..amt + 1) |a| {\n            if (coins[i - 1] &gt; @as(i32, @intCast(a))) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[i][a] = dp[i - 1][a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[i][a] = dp[i - 1][a] + dp[i][a - @as(usize, @intCast(coins[i - 1]))];\n            }\n        }\n    }\n    return dp[n][amt];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#3-space-optimization_2","title":"3. \u00a0 Space optimization","text":"<p>The space optimization approach is the same, just remove the coin dimension:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig coin_change_ii.py<pre><code>def coin_change_ii_dp_comp(coins: list[int], amt: int) -&gt; int:\n    \"\"\"\u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\"\"\"\n    n = len(coins)\n    # \u521d\u59cb\u5316 dp \u8868\n    dp = [0] * (amt + 1)\n    dp[0] = 1\n    # \u72b6\u6001\u8f6c\u79fb\n    for i in range(1, n + 1):\n        # \u6b63\u5e8f\u904d\u5386\n        for a in range(1, amt + 1):\n            if coins[i - 1] &gt; a:\n                # \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            else:\n                # \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n    return dp[amt]\n</code></pre> coin_change_ii.cpp<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDPComp(vector&lt;int&gt; &amp;coins, int amt) {\n    int n = coins.size();\n    // \u521d\u59cb\u5316 dp \u8868\n    vector&lt;int&gt; dp(amt + 1, 0);\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.java<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDPComp(int[] coins, int amt) {\n    int n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[amt + 1];\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.cs<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint CoinChangeIIDPComp(int[] coins, int amt) {\n    int n = coins.Length;\n    // \u521d\u59cb\u5316 dp \u8868\n    int[] dp = new int[amt + 1];\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.go<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeIIDPComp(coins []int, amt int) int {\n    n := len(coins)\n    // \u521d\u59cb\u5316 dp \u8868\n    dp := make([]int, amt+1)\n    dp[0] = 1\n    // \u72b6\u6001\u8f6c\u79fb\n    for i := 1; i &lt;= n; i++ {\n        // \u6b63\u5e8f\u904d\u5386\n        for a := 1; a &lt;= amt; a++ {\n            if coins[i-1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a-coins[i-1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.swift<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunc coinChangeIIDPComp(coins: [Int], amt: Int) -&gt; Int {\n    let n = coins.count\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = Array(repeating: 0, count: amt + 1)\n    dp[0] = 1\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1 ... n {\n        for a in 1 ... amt {\n            if coins[i - 1] &gt; a {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.js<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeIIDPComp(coins, amt) {\n    const n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: amt + 1 }, () =&gt; 0);\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.ts<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u72b6\u6001\u538b\u7f29\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfunction coinChangeIIDPComp(coins: Array&lt;number&gt;, amt: number): number {\n    const n = coins.length;\n    // \u521d\u59cb\u5316 dp \u8868\n    const dp = Array.from({ length: amt + 1 }, () =&gt; 0);\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (let i = 1; i &lt;= n; i++) {\n        for (let a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> coin_change_ii.dart<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDPComp(List&lt;int&gt; coins, int amt) {\n  int n = coins.length;\n  // \u521d\u59cb\u5316 dp \u8868\n  List&lt;int&gt; dp = List.filled(amt + 1, 0);\n  dp[0] = 1;\n  // \u72b6\u6001\u8f6c\u79fb\n  for (int i = 1; i &lt;= n; i++) {\n    for (int a = 1; a &lt;= amt; a++) {\n      if (coins[i - 1] &gt; a) {\n        // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n        dp[a] = dp[a];\n      } else {\n        // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n        dp[a] = dp[a] + dp[a - coins[i - 1]];\n      }\n    }\n  }\n  return dp[amt];\n}\n</code></pre> coin_change_ii.rs<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfn coin_change_ii_dp_comp(coins: &amp;[i32], amt: usize) -&gt; i32 {\n    let n = coins.len();\n    // \u521d\u59cb\u5316 dp \u8868\n    let mut dp = vec![0; amt + 1];\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for i in 1..=n {\n        for a in 1..=amt {\n            if coins[i - 1] &gt; a as i32 {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1] as usize];\n            }\n        }\n    }\n    dp[amt]\n}\n</code></pre> coin_change_ii.c<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nint coinChangeIIDPComp(int coins[], int amt, int coinsSize) {\n    int n = coinsSize;\n    // \u521d\u59cb\u5316 dp \u8868\n    int *dp = calloc(amt + 1, sizeof(int));\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (int i = 1; i &lt;= n; i++) {\n        for (int a = 1; a &lt;= amt; a++) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]];\n            }\n        }\n    }\n    int res = dp[amt];\n    // \u91ca\u653e\u5185\u5b58\n    free(dp);\n    return res;\n}\n</code></pre> coin_change_ii.kt<pre><code>/* \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212 */\nfun coinChangeIIDPComp(coins: IntArray, amt: Int): Int {\n    val n = coins.size\n    // \u521d\u59cb\u5316 dp \u8868\n    val dp = IntArray(amt + 1)\n    dp[0] = 1\n    // \u72b6\u6001\u8f6c\u79fb\n    for (i in 1..n) {\n        for (a in 1..amt) {\n            if (coins[i - 1] &gt; a) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a]\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u4e4b\u548c\n                dp[a] = dp[a] + dp[a - coins[i - 1]]\n            }\n        }\n    }\n    return dp[amt]\n}\n</code></pre> coin_change_ii.rb<pre><code>[class]{}-[func]{coin_change_ii_dp_comp}\n</code></pre> coin_change_ii.zig<pre><code>// \u96f6\u94b1\u5151\u6362 II\uff1a\u7a7a\u95f4\u4f18\u5316\u540e\u7684\u52a8\u6001\u89c4\u5212\nfn coinChangeIIDPComp(comptime coins: []i32, comptime amt: usize) i32 {\n    comptime var n = coins.len;\n    // \u521d\u59cb\u5316 dp \u8868\n    var dp = [_]i32{0} ** (amt + 1);\n    dp[0] = 1;\n    // \u72b6\u6001\u8f6c\u79fb\n    for (1..n + 1) |i| {\n        for (1..amt + 1) |a| {\n            if (coins[i - 1] &gt; @as(i32, @intCast(a))) {\n                // \u82e5\u8d85\u8fc7\u76ee\u6807\u91d1\u989d\uff0c\u5219\u4e0d\u9009\u786c\u5e01 i\n                dp[a] = dp[a];\n            } else {\n                // \u4e0d\u9009\u548c\u9009\u786c\u5e01 i \u8fd9\u4e24\u79cd\u65b9\u6848\u7684\u8f83\u5c0f\u503c\n                dp[a] = dp[a] + dp[a - @as(usize, @intCast(coins[i - 1]))];\n            }\n        }\n    }\n    return dp[amt];\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_graph/","title":"Chapter 9. \u00a0 Graph","text":"<p>Abstract</p> <p>In the journey of life, we are like individual nodes, connected by countless invisible edges.</p> <p>Each encounter and parting leaves a distinctive imprint on this vast network graph.</p>"},{"location":"chapter_graph/#chapter-contents","title":"Chapter contents","text":"<ul> <li>9.1 \u00a0 Graph</li> <li>9.2 \u00a0 Basic graph operations</li> <li>9.3 \u00a0 Graph traversal</li> <li>9.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_graph/graph/","title":"9.1 \u00a0 Graph","text":"<p>A graph is a type of nonlinear data structure, consisting of vertices and edges. A graph \\(G\\) can be abstractly represented as a collection of a set of vertices \\(V\\) and a set of edges \\(E\\). The following example shows a graph containing 5 vertices and 7 edges.</p> \\[ \\begin{aligned} V &amp; = \\{ 1, 2, 3, 4, 5 \\} \\newline E &amp; = \\{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \\} \\newline G &amp; = \\{ V, E \\} \\newline \\end{aligned} \\] <p>If vertices are viewed as nodes and edges as references (pointers) connecting the nodes, graphs can be seen as a data structure that extends from linked lists. As shown in Figure 9-1, compared to linear relationships (linked lists) and divide-and-conquer relationships (trees), network relationships (graphs) are more complex due to their higher degree of freedom.</p> <p></p> <p> Figure 9-1 \u00a0 Relationship between linked lists, trees, and graphs </p>"},{"location":"chapter_graph/graph/#911-common-types-of-graphs","title":"9.1.1 \u00a0 Common types of graphs","text":"<p>Based on whether edges have direction, graphs can be divided into undirected graphs and directed graphs, as shown in Figure 9-2.</p> <ul> <li>In undirected graphs, edges represent a \"bidirectional\" connection between two vertices, for example, the \"friendship\" in WeChat or QQ.</li> <li>In directed graphs, edges have directionality, that is, the edges \\(A \\rightarrow B\\) and \\(A \\leftarrow B\\) are independent of each other, for example, the \"follow\" and \"be followed\" relationship on Weibo or TikTok.</li> </ul> <p></p> <p> Figure 9-2 \u00a0 Directed and undirected graphs </p> <p>Based on whether all vertices are connected, graphs can be divided into connected graphs and disconnected graphs, as shown in Figure 9-3.</p> <ul> <li>For connected graphs, it is possible to reach any other vertex starting from a certain vertex.</li> <li>For disconnected graphs, there is at least one vertex that cannot be reached from a certain starting vertex.</li> </ul> <p></p> <p> Figure 9-3 \u00a0 Connected and disconnected graphs </p> <p>We can also add a weight variable to edges, resulting in weighted graphs as shown in Figure 9-4. For example, in mobile games like \"Honor of Kings\", the system calculates the \"closeness\" between players based on shared gaming time, and this closeness network can be represented with a weighted graph.</p> <p></p> <p> Figure 9-4 \u00a0 Weighted and unweighted graphs </p> <p>Graph data structures include the following commonly used terms.</p> <ul> <li>Adjacency: When there is an edge connecting two vertices, these two vertices are said to be \"adjacent\". In Figure 9-4, the adjacent vertices of vertex 1 are vertices 2, 3, and 5.</li> <li>Path: The sequence of edges passed from vertex A to vertex B is called a path from A to B. In Figure 9-4, the edge sequence 1-5-2-4 is a path from vertex 1 to vertex 4.</li> <li>Degree: The number of edges a vertex has. For directed graphs, in-degree refers to how many edges point to the vertex, and out-degree refers to how many edges point out from the vertex.</li> </ul>"},{"location":"chapter_graph/graph/#912-representation-of-graphs","title":"9.1.2 \u00a0 Representation of graphs","text":"<p>Common representations of graphs include \"adjacency matrices\" and \"adjacency lists\". The following examples use undirected graphs.</p>"},{"location":"chapter_graph/graph/#1-adjacency-matrix","title":"1. \u00a0 Adjacency matrix","text":"<p>Let the number of vertices in the graph be \\(n\\), the adjacency matrix uses an \\(n \\times n\\) matrix to represent the graph, where each row (column) represents a vertex, and the matrix elements represent edges, with \\(1\\) or \\(0\\) indicating whether there is an edge between two vertices.</p> <p>As shown in Figure 9-5, let the adjacency matrix be \\(M\\), and the list of vertices be \\(V\\), then the matrix element \\(M[i, j] = 1\\) indicates there is an edge between vertex \\(V[i]\\) and vertex \\(V[j]\\), conversely \\(M[i, j] = 0\\) indicates there is no edge between the two vertices.</p> <p></p> <p> Figure 9-5 \u00a0 Representation of a graph with an adjacency matrix </p> <p>Adjacency matrices have the following characteristics.</p> <ul> <li>A vertex cannot be connected to itself, so the elements on the main diagonal of the adjacency matrix are meaningless.</li> <li>For undirected graphs, edges in both directions are equivalent, thus the adjacency matrix is symmetric about the main diagonal.</li> <li>By replacing the elements of the adjacency matrix from \\(1\\) and \\(0\\) to weights, it can represent weighted graphs.</li> </ul> <p>When representing graphs with adjacency matrices, it is possible to directly access matrix elements to obtain edges, thus operations of addition, deletion, lookup, and modification are very efficient, all with a time complexity of \\(O(1)\\). However, the space complexity of the matrix is \\(O(n^2)\\), which consumes more memory.</p>"},{"location":"chapter_graph/graph/#2-adjacency-list","title":"2. \u00a0 Adjacency list","text":"<p>The adjacency list uses \\(n\\) linked lists to represent the graph, with each linked list node representing a vertex. The \\(i\\)-th linked list corresponds to vertex \\(i\\) and contains all adjacent vertices (vertices connected to that vertex). Figure 9-6 shows an example of a graph stored using an adjacency list.</p> <p></p> <p> Figure 9-6 \u00a0 Representation of a graph with an adjacency list </p> <p>The adjacency list only stores actual edges, and the total number of edges is often much less than \\(n^2\\), making it more space-efficient. However, finding edges in the adjacency list requires traversing the linked list, so its time efficiency is not as good as that of the adjacency matrix.</p> <p>Observing Figure 9-6, the structure of the adjacency list is very similar to the \"chaining\" in hash tables, hence we can use similar methods to optimize efficiency. For example, when the linked list is long, it can be transformed into an AVL tree or red-black tree, thus optimizing the time efficiency from \\(O(n)\\) to \\(O(\\log n)\\); the linked list can also be transformed into a hash table, thus reducing the time complexity to \\(O(1)\\).</p>"},{"location":"chapter_graph/graph/#913-common-applications-of-graphs","title":"9.1.3 \u00a0 Common applications of graphs","text":"<p>As shown in Table 9-1, many real-world systems can be modeled with graphs, and corresponding problems can be reduced to graph computing problems.</p> <p> Table 9-1 \u00a0 Common graphs in real life </p> Vertices Edges Graph Computing Problem Social Networks Users Friendships Potential Friend Recommendations Subway Lines Stations Connectivity Between Stations Shortest Route Recommendations Solar System Celestial Bodies Gravitational Forces Between Celestial Bodies Planetary Orbit Calculations"},{"location":"chapter_graph/graph_operations/","title":"9.2 \u00a0 Basic operations on graphs","text":"<p>The basic operations on graphs can be divided into operations on \"edges\" and operations on \"vertices\". Under the two representation methods of \"adjacency matrix\" and \"adjacency list\", the implementation methods are different.</p>"},{"location":"chapter_graph/graph_operations/#921-implementation-based-on-adjacency-matrix","title":"9.2.1 \u00a0 Implementation based on adjacency matrix","text":"<p>Given an undirected graph with \\(n\\) vertices, the various operations are implemented as shown in Figure 9-7.</p> <ul> <li>Adding or removing an edge: Directly modify the specified edge in the adjacency matrix, using \\(O(1)\\) time. Since it is an undirected graph, it is necessary to update the edges in both directions simultaneously.</li> <li>Adding a vertex: Add a row and a column at the end of the adjacency matrix and fill them all with \\(0\\)s, using \\(O(n)\\) time.</li> <li>Removing a vertex: Delete a row and a column in the adjacency matrix. The worst case is when the first row and column are removed, requiring \\((n-1)^2\\) elements to be \"moved up and to the left\", thus using \\(O(n^2)\\) time.</li> <li>Initialization: Pass in \\(n\\) vertices, initialize a vertex list <code>vertices</code> of length \\(n\\), using \\(O(n)\\) time; initialize an \\(n \\times n\\) size adjacency matrix <code>adjMat</code>, using \\(O(n^2)\\) time.</li> </ul> Initialize adjacency matrixAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-7 \u00a0 Initialization, adding and removing edges, adding and removing vertices in adjacency matrix </p> <p>Below is the implementation code for graphs represented using an adjacency matrix:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig graph_adjacency_matrix.py<pre><code>class GraphAdjMat:\n    \"\"\"\u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b\"\"\"\n\n    def __init__(self, vertices: list[int], edges: list[list[int]]):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        # \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n        self.vertices: list[int] = []\n        # \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n        self.adj_mat: list[list[int]] = []\n        # \u6dfb\u52a0\u9876\u70b9\n        for val in vertices:\n            self.add_vertex(val)\n        # \u6dfb\u52a0\u8fb9\n        # \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for e in edges:\n            self.add_edge(e[0], e[1])\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u9876\u70b9\u6570\u91cf\"\"\"\n        return len(self.vertices)\n\n    def add_vertex(self, val: int):\n        \"\"\"\u6dfb\u52a0\u9876\u70b9\"\"\"\n        n = self.size()\n        # \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        self.vertices.append(val)\n        # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        new_row = [0] * n\n        self.adj_mat.append(new_row)\n        # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for row in self.adj_mat:\n            row.append(0)\n\n    def remove_vertex(self, index: int):\n        \"\"\"\u5220\u9664\u9876\u70b9\"\"\"\n        if index &gt;= self.size():\n            raise IndexError()\n        # \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        self.vertices.pop(index)\n        # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        self.adj_mat.pop(index)\n        # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for row in self.adj_mat:\n            row.pop(index)\n\n    def add_edge(self, i: int, j: int):\n        \"\"\"\u6dfb\u52a0\u8fb9\"\"\"\n        # \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        # \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &lt; 0 or j &lt; 0 or i &gt;= self.size() or j &gt;= self.size() or i == j:\n            raise IndexError()\n        # \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        self.adj_mat[i][j] = 1\n        self.adj_mat[j][i] = 1\n\n    def remove_edge(self, i: int, j: int):\n        \"\"\"\u5220\u9664\u8fb9\"\"\"\n        # \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        # \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &lt; 0 or j &lt; 0 or i &gt;= self.size() or j &gt;= self.size() or i == j:\n            raise IndexError()\n        self.adj_mat[i][j] = 0\n        self.adj_mat[j][i] = 0\n\n    def print(self):\n        \"\"\"\u6253\u5370\u90bb\u63a5\u77e9\u9635\"\"\"\n        print(\"\u9876\u70b9\u5217\u8868 =\", self.vertices)\n        print(\"\u90bb\u63a5\u77e9\u9635 =\")\n        print_matrix(self.adj_mat)\n</code></pre> graph_adjacency_matrix.cpp<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    vector&lt;int&gt; vertices;       // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    vector&lt;vector&lt;int&gt;&gt; adjMat; // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    GraphAdjMat(const vector&lt;int&gt; &amp;vertices, const vector&lt;vector&lt;int&gt;&gt; &amp;edges) {\n        // \u6dfb\u52a0\u9876\u70b9\n        for (int val : vertices) {\n            addVertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for (const vector&lt;int&gt; &amp;edge : edges) {\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    int size() const {\n        return vertices.size();\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    void addVertex(int val) {\n        int n = size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        vertices.push_back(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        adjMat.emplace_back(vector&lt;int&gt;(n, 0));\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for (vector&lt;int&gt; &amp;row : adjMat) {\n            row.push_back(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    void removeVertex(int index) {\n        if (index &gt;= size()) {\n            throw out_of_range(\"\u9876\u70b9\u4e0d\u5b58\u5728\");\n        }\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        vertices.erase(vertices.begin() + index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        adjMat.erase(adjMat.begin() + index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for (vector&lt;int&gt; &amp;row : adjMat) {\n            row.erase(row.begin() + index);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    void addEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n            throw out_of_range(\"\u9876\u70b9\u4e0d\u5b58\u5728\");\n        }\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        adjMat[i][j] = 1;\n        adjMat[j][i] = 1;\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    void removeEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n            throw out_of_range(\"\u9876\u70b9\u4e0d\u5b58\u5728\");\n        }\n        adjMat[i][j] = 0;\n        adjMat[j][i] = 0;\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    void print() {\n        cout &lt;&lt; \"\u9876\u70b9\u5217\u8868 = \";\n        printVector(vertices);\n        cout &lt;&lt; \"\u90bb\u63a5\u77e9\u9635 =\" &lt;&lt; endl;\n        printVectorMatrix(adjMat);\n    }\n};\n</code></pre> graph_adjacency_matrix.java<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    List&lt;Integer&gt; vertices; // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    List&lt;List&lt;Integer&gt;&gt; adjMat; // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public GraphAdjMat(int[] vertices, int[][] edges) {\n        this.vertices = new ArrayList&lt;&gt;();\n        this.adjMat = new ArrayList&lt;&gt;();\n        // \u6dfb\u52a0\u9876\u70b9\n        for (int val : vertices) {\n            addVertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for (int[] e : edges) {\n            addEdge(e[0], e[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    public int size() {\n        return vertices.size();\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    public void addVertex(int val) {\n        int n = size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        vertices.add(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(n);\n        for (int j = 0; j &lt; n; j++) {\n            newRow.add(0);\n        }\n        adjMat.add(newRow);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for (List&lt;Integer&gt; row : adjMat) {\n            row.add(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    public void removeVertex(int index) {\n        if (index &gt;= size())\n            throw new IndexOutOfBoundsException();\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        vertices.remove(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        adjMat.remove(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for (List&lt;Integer&gt; row : adjMat) {\n            row.remove(index);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    public void addEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw new IndexOutOfBoundsException();\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        adjMat.get(i).set(j, 1);\n        adjMat.get(j).set(i, 1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    public void removeEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw new IndexOutOfBoundsException();\n        adjMat.get(i).set(j, 0);\n        adjMat.get(j).set(i, 0);\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    public void print() {\n        System.out.print(\"\u9876\u70b9\u5217\u8868 = \");\n        System.out.println(vertices);\n        System.out.println(\"\u90bb\u63a5\u77e9\u9635 =\");\n        PrintUtil.printMatrix(adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.cs<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    List&lt;int&gt; vertices;     // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    List&lt;List&lt;int&gt;&gt; adjMat; // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u51fd\u6570 */\n    public GraphAdjMat(int[] vertices, int[][] edges) {\n        this.vertices = [];\n        this.adjMat = [];\n        // \u6dfb\u52a0\u9876\u70b9\n        foreach (int val in vertices) {\n            AddVertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        foreach (int[] e in edges) {\n            AddEdge(e[0], e[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    int Size() {\n        return vertices.Count;\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    public void AddVertex(int val) {\n        int n = Size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        vertices.Add(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        List&lt;int&gt; newRow = new(n);\n        for (int j = 0; j &lt; n; j++) {\n            newRow.Add(0);\n        }\n        adjMat.Add(newRow);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        foreach (List&lt;int&gt; row in adjMat) {\n            row.Add(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    public void RemoveVertex(int index) {\n        if (index &gt;= Size())\n            throw new IndexOutOfRangeException();\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        vertices.RemoveAt(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        adjMat.RemoveAt(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        foreach (List&lt;int&gt; row in adjMat) {\n            row.RemoveAt(index);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    public void AddEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= Size() || j &gt;= Size() || i == j)\n            throw new IndexOutOfRangeException();\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        adjMat[i][j] = 1;\n        adjMat[j][i] = 1;\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    public void RemoveEdge(int i, int j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= Size() || j &gt;= Size() || i == j)\n            throw new IndexOutOfRangeException();\n        adjMat[i][j] = 0;\n        adjMat[j][i] = 0;\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    public void Print() {\n        Console.Write(\"\u9876\u70b9\u5217\u8868 = \");\n        PrintUtil.PrintList(vertices);\n        Console.WriteLine(\"\u90bb\u63a5\u77e9\u9635 =\");\n        PrintUtil.PrintMatrix(adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.go<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\ntype graphAdjMat struct {\n    // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    vertices []int\n    // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    adjMat [][]int\n}\n\n/* \u6784\u9020\u51fd\u6570 */\nfunc newGraphAdjMat(vertices []int, edges [][]int) *graphAdjMat {\n    // \u6dfb\u52a0\u9876\u70b9\n    n := len(vertices)\n    adjMat := make([][]int, n)\n    for i := range adjMat {\n        adjMat[i] = make([]int, n)\n    }\n    // \u521d\u59cb\u5316\u56fe\n    g := &amp;graphAdjMat{\n        vertices: vertices,\n        adjMat:   adjMat,\n    }\n    // \u6dfb\u52a0\u8fb9\n    // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    for i := range edges {\n        g.addEdge(edges[i][0], edges[i][1])\n    }\n    return g\n}\n\n/* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\nfunc (g *graphAdjMat) size() int {\n    return len(g.vertices)\n}\n\n/* \u6dfb\u52a0\u9876\u70b9 */\nfunc (g *graphAdjMat) addVertex(val int) {\n    n := g.size()\n    // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n    g.vertices = append(g.vertices, val)\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n    newRow := make([]int, n)\n    g.adjMat = append(g.adjMat, newRow)\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n    for i := range g.adjMat {\n        g.adjMat[i] = append(g.adjMat[i], 0)\n    }\n}\n\n/* \u5220\u9664\u9876\u70b9 */\nfunc (g *graphAdjMat) removeVertex(index int) {\n    if index &gt;= g.size() {\n        return\n    }\n    // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n    g.vertices = append(g.vertices[:index], g.vertices[index+1:]...)\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n    g.adjMat = append(g.adjMat[:index], g.adjMat[index+1:]...)\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n    for i := range g.adjMat {\n        g.adjMat[i] = append(g.adjMat[i][:index], g.adjMat[i][index+1:]...)\n    }\n}\n\n/* \u6dfb\u52a0\u8fb9 */\n// \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\nfunc (g *graphAdjMat) addEdge(i, j int) {\n    // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if i &lt; 0 || j &lt; 0 || i &gt;= g.size() || j &gt;= g.size() || i == j {\n        fmt.Errorf(\"%s\", \"Index Out Of Bounds Exception\")\n    }\n    // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n    g.adjMat[i][j] = 1\n    g.adjMat[j][i] = 1\n}\n\n/* \u5220\u9664\u8fb9 */\n// \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\nfunc (g *graphAdjMat) removeEdge(i, j int) {\n    // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if i &lt; 0 || j &lt; 0 || i &gt;= g.size() || j &gt;= g.size() || i == j {\n        fmt.Errorf(\"%s\", \"Index Out Of Bounds Exception\")\n    }\n    g.adjMat[i][j] = 0\n    g.adjMat[j][i] = 0\n}\n\n/* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\nfunc (g *graphAdjMat) print() {\n    fmt.Printf(\"\\t\u9876\u70b9\u5217\u8868 = %v\\n\", g.vertices)\n    fmt.Printf(\"\\t\u90bb\u63a5\u77e9\u9635 = \\n\")\n    for i := range g.adjMat {\n        fmt.Printf(\"\\t\\t\\t%v\\n\", g.adjMat[i])\n    }\n}\n</code></pre> graph_adjacency_matrix.swift<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    private var vertices: [Int] // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    private var adjMat: [[Int]] // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init(vertices: [Int], edges: [[Int]]) {\n        self.vertices = []\n        adjMat = []\n        // \u6dfb\u52a0\u9876\u70b9\n        for val in vertices {\n            addVertex(val: val)\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for e in edges {\n            addEdge(i: e[0], j: e[1])\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    func size() -&gt; Int {\n        vertices.count\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    func addVertex(val: Int) {\n        let n = size()\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        vertices.append(val)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        let newRow = Array(repeating: 0, count: n)\n        adjMat.append(newRow)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for i in adjMat.indices {\n            adjMat[i].append(0)\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    func removeVertex(index: Int) {\n        if index &gt;= size() {\n            fatalError(\"\u8d8a\u754c\")\n        }\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        vertices.remove(at: index)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        adjMat.remove(at: index)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for i in adjMat.indices {\n            adjMat[i].remove(at: index)\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    func addEdge(i: Int, j: Int) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j {\n            fatalError(\"\u8d8a\u754c\")\n        }\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        adjMat[i][j] = 1\n        adjMat[j][i] = 1\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    func removeEdge(i: Int, j: Int) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j {\n            fatalError(\"\u8d8a\u754c\")\n        }\n        adjMat[i][j] = 0\n        adjMat[j][i] = 0\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    func print() {\n        Swift.print(\"\u9876\u70b9\u5217\u8868 = \", terminator: \"\")\n        Swift.print(vertices)\n        Swift.print(\"\u90bb\u63a5\u77e9\u9635 =\")\n        PrintUtil.printMatrix(matrix: adjMat)\n    }\n}\n</code></pre> graph_adjacency_matrix.js<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    vertices; // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    adjMat; // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u51fd\u6570 */\n    constructor(vertices, edges) {\n        this.vertices = [];\n        this.adjMat = [];\n        // \u6dfb\u52a0\u9876\u70b9\n        for (const val of vertices) {\n            this.addVertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for (const e of edges) {\n            this.addEdge(e[0], e[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    size() {\n        return this.vertices.length;\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    addVertex(val) {\n        const n = this.size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        this.vertices.push(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        const newRow = [];\n        for (let j = 0; j &lt; n; j++) {\n            newRow.push(0);\n        }\n        this.adjMat.push(newRow);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for (const row of this.adjMat) {\n            row.push(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    removeVertex(index) {\n        if (index &gt;= this.size()) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        this.vertices.splice(index, 1);\n\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        this.adjMat.splice(index, 1);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for (const row of this.adjMat) {\n            row.splice(index, 1);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    addEdge(i, j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) === (j, i)\n        this.adjMat[i][j] = 1;\n        this.adjMat[j][i] = 1;\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    removeEdge(i, j) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        this.adjMat[i][j] = 0;\n        this.adjMat[j][i] = 0;\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    print() {\n        console.log('\u9876\u70b9\u5217\u8868 = ', this.vertices);\n        console.log('\u90bb\u63a5\u77e9\u9635 =', this.adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.ts<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n    vertices: number[]; // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    adjMat: number[][]; // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u51fd\u6570 */\n    constructor(vertices: number[], edges: number[][]) {\n        this.vertices = [];\n        this.adjMat = [];\n        // \u6dfb\u52a0\u9876\u70b9\n        for (const val of vertices) {\n            this.addVertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for (const e of edges) {\n            this.addEdge(e[0], e[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    size(): number {\n        return this.vertices.length;\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    addVertex(val: number): void {\n        const n: number = this.size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        this.vertices.push(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        const newRow: number[] = [];\n        for (let j: number = 0; j &lt; n; j++) {\n            newRow.push(0);\n        }\n        this.adjMat.push(newRow);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for (const row of this.adjMat) {\n            row.push(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    removeVertex(index: number): void {\n        if (index &gt;= this.size()) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        this.vertices.splice(index, 1);\n\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        this.adjMat.splice(index, 1);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for (const row of this.adjMat) {\n            row.splice(index, 1);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    addEdge(i: number, j: number): void {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) === (j, i)\n        this.adjMat[i][j] = 1;\n        this.adjMat[j][i] = 1;\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    removeEdge(i: number, j: number): void {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= this.size() || j &gt;= this.size() || i === j) {\n            throw new RangeError('Index Out Of Bounds Exception');\n        }\n        this.adjMat[i][j] = 0;\n        this.adjMat[j][i] = 0;\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    print(): void {\n        console.log('\u9876\u70b9\u5217\u8868 = ', this.vertices);\n        console.log('\u90bb\u63a5\u77e9\u9635 =', this.adjMat);\n    }\n}\n</code></pre> graph_adjacency_matrix.dart<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat {\n  List&lt;int&gt; vertices = []; // \u9876\u70b9\u5143\u7d20\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n  List&lt;List&lt;int&gt;&gt; adjMat = []; //\u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  GraphAdjMat(List&lt;int&gt; vertices, List&lt;List&lt;int&gt;&gt; edges) {\n    this.vertices = [];\n    this.adjMat = [];\n    // \u6dfb\u52a0\u9876\u70b9\n    for (int val in vertices) {\n      addVertex(val);\n    }\n    // \u6dfb\u52a0\u8fb9\n    // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    for (List&lt;int&gt; e in edges) {\n      addEdge(e[0], e[1]);\n    }\n  }\n\n  /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n  int size() {\n    return vertices.length;\n  }\n\n  /* \u6dfb\u52a0\u9876\u70b9 */\n  void addVertex(int val) {\n    int n = size();\n    // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n    vertices.add(val);\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n    List&lt;int&gt; newRow = List.filled(n, 0, growable: true);\n    adjMat.add(newRow);\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n    for (List&lt;int&gt; row in adjMat) {\n      row.add(0);\n    }\n  }\n\n  /* \u5220\u9664\u9876\u70b9 */\n  void removeVertex(int index) {\n    if (index &gt;= size()) {\n      throw IndexError;\n    }\n    // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n    vertices.removeAt(index);\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n    adjMat.removeAt(index);\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n    for (List&lt;int&gt; row in adjMat) {\n      row.removeAt(index);\n    }\n  }\n\n  /* \u6dfb\u52a0\u8fb9 */\n  // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n  void addEdge(int i, int j) {\n    // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n      throw IndexError;\n    }\n    // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n    adjMat[i][j] = 1;\n    adjMat[j][i] = 1;\n  }\n\n  /* \u5220\u9664\u8fb9 */\n  // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n  void removeEdge(int i, int j) {\n    // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j) {\n      throw IndexError;\n    }\n    adjMat[i][j] = 0;\n    adjMat[j][i] = 0;\n  }\n\n  /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n  void printAdjMat() {\n    print(\"\u9876\u70b9\u5217\u8868 = $vertices\");\n    print(\"\u90bb\u63a5\u77e9\u9635 = \");\n    printMatrix(adjMat);\n  }\n}\n</code></pre> graph_adjacency_matrix.rs<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b\u578b */\npub struct GraphAdjMat {\n    // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    pub vertices: Vec&lt;i32&gt;,\n    // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    pub adj_mat: Vec&lt;Vec&lt;i32&gt;&gt;,\n}\n\nimpl GraphAdjMat {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    pub fn new(vertices: Vec&lt;i32&gt;, edges: Vec&lt;[usize; 2]&gt;) -&gt; Self {\n        let mut graph = GraphAdjMat {\n            vertices: vec![],\n            adj_mat: vec![],\n        };\n        // \u6dfb\u52a0\u9876\u70b9\n        for val in vertices {\n            graph.add_vertex(val);\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for edge in edges {\n            graph.add_edge(edge[0], edge[1])\n        }\n\n        graph\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    pub fn size(&amp;self) -&gt; usize {\n        self.vertices.len()\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    pub fn add_vertex(&amp;mut self, val: i32) {\n        let n = self.size();\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        self.vertices.push(val);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        self.adj_mat.push(vec![0; n]);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for row in &amp;mut self.adj_mat {\n            row.push(0);\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    pub fn remove_vertex(&amp;mut self, index: usize) {\n        if index &gt;= self.size() {\n            panic!(\"index error\")\n        }\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        self.vertices.remove(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        self.adj_mat.remove(index);\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for row in &amp;mut self.adj_mat {\n            row.remove(index);\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    pub fn add_edge(&amp;mut self, i: usize, j: usize) {\n        // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &gt;= self.size() || j &gt;= self.size() || i == j {\n            panic!(\"index error\")\n        }\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        self.adj_mat[i][j] = 1;\n        self.adj_mat[j][i] = 1;\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    pub fn remove_edge(&amp;mut self, i: usize, j: usize) {\n        // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if i &gt;= self.size() || j &gt;= self.size() || i == j {\n            panic!(\"index error\")\n        }\n        self.adj_mat[i][j] = 0;\n        self.adj_mat[j][i] = 0;\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    pub fn print(&amp;self) {\n        println!(\"\u9876\u70b9\u5217\u8868 = {:?}\", self.vertices);\n        println!(\"\u90bb\u63a5\u77e9\u9635 =\");\n        println!(\"[\");\n        for row in &amp;self.adj_mat {\n            println!(\"  {:?},\", row);\n        }\n        println!(\"]\")\n    }\n}\n</code></pre> graph_adjacency_matrix.c<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7ed3\u6784\u4f53 */\ntypedef struct {\n    int vertices[MAX_SIZE];\n    int adjMat[MAX_SIZE][MAX_SIZE];\n    int size;\n} GraphAdjMat;\n\n/* \u6784\u9020\u51fd\u6570 */\nGraphAdjMat *newGraphAdjMat() {\n    GraphAdjMat *graph = (GraphAdjMat *)malloc(sizeof(GraphAdjMat));\n    graph-&gt;size = 0;\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        for (int j = 0; j &lt; MAX_SIZE; j++) {\n            graph-&gt;adjMat[i][j] = 0;\n        }\n    }\n    return graph;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delGraphAdjMat(GraphAdjMat *graph) {\n    free(graph);\n}\n\n/* \u6dfb\u52a0\u9876\u70b9 */\nvoid addVertex(GraphAdjMat *graph, int val) {\n    if (graph-&gt;size == MAX_SIZE) {\n        fprintf(stderr, \"\u56fe\u7684\u9876\u70b9\u6570\u91cf\u5df2\u8fbe\u6700\u5927\u503c\\n\");\n        return;\n    }\n    // \u6dfb\u52a0\u7b2c n \u4e2a\u9876\u70b9\uff0c\u5e76\u5c06\u7b2c n \u884c\u548c\u5217\u7f6e\u96f6\n    int n = graph-&gt;size;\n    graph-&gt;vertices[n] = val;\n    for (int i = 0; i &lt;= n; i++) {\n        graph-&gt;adjMat[n][i] = graph-&gt;adjMat[i][n] = 0;\n    }\n    graph-&gt;size++;\n}\n\n/* \u5220\u9664\u9876\u70b9 */\nvoid removeVertex(GraphAdjMat *graph, int index) {\n    if (index &lt; 0 || index &gt;= graph-&gt;size) {\n        fprintf(stderr, \"\u9876\u70b9\u7d22\u5f15\u8d8a\u754c\\n\");\n        return;\n    }\n    // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n    for (int i = index; i &lt; graph-&gt;size - 1; i++) {\n        graph-&gt;vertices[i] = graph-&gt;vertices[i + 1];\n    }\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n    for (int i = index; i &lt; graph-&gt;size - 1; i++) {\n        for (int j = 0; j &lt; graph-&gt;size; j++) {\n            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i + 1][j];\n        }\n    }\n    // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        for (int j = index; j &lt; graph-&gt;size - 1; j++) {\n            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i][j + 1];\n        }\n    }\n    graph-&gt;size--;\n}\n\n/* \u6dfb\u52a0\u8fb9 */\n// \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\nvoid addEdge(GraphAdjMat *graph, int i, int j) {\n    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {\n        fprintf(stderr, \"\u8fb9\u7d22\u5f15\u8d8a\u754c\u6216\u76f8\u7b49\\n\");\n        return;\n    }\n    graph-&gt;adjMat[i][j] = 1;\n    graph-&gt;adjMat[j][i] = 1;\n}\n\n/* \u5220\u9664\u8fb9 */\n// \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\nvoid removeEdge(GraphAdjMat *graph, int i, int j) {\n    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {\n        fprintf(stderr, \"\u8fb9\u7d22\u5f15\u8d8a\u754c\u6216\u76f8\u7b49\\n\");\n        return;\n    }\n    graph-&gt;adjMat[i][j] = 0;\n    graph-&gt;adjMat[j][i] = 0;\n}\n\n/* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\nvoid printGraphAdjMat(GraphAdjMat *graph) {\n    printf(\"\u9876\u70b9\u5217\u8868 = \");\n    printArray(graph-&gt;vertices, graph-&gt;size);\n    printf(\"\u90bb\u63a5\u77e9\u9635 =\\n\");\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        printArray(graph-&gt;adjMat[i], graph-&gt;size);\n    }\n}\n</code></pre> graph_adjacency_matrix.kt<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjMat(vertices: IntArray, edges: Array&lt;IntArray&gt;) {\n    val vertices = mutableListOf&lt;Int&gt;() // \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    val adjMat = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() // \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init {\n        // \u6dfb\u52a0\u9876\u70b9\n        for (vertex in vertices) {\n            addVertex(vertex)\n        }\n        // \u6dfb\u52a0\u8fb9\n        // \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n        for (edge in edges) {\n            addEdge(edge[0], edge[1])\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    fun size(): Int {\n        return vertices.size\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    fun addVertex(_val: Int) {\n        val n = size()\n        // \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n        vertices.add(_val)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n        val newRow = mutableListOf&lt;Int&gt;()\n        for (j in 0..&lt;n) {\n            newRow.add(0)\n        }\n        adjMat.add(newRow)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n        for (row in adjMat) {\n            row.add(0)\n        }\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    fun removeVertex(index: Int) {\n        if (index &gt;= size())\n            throw IndexOutOfBoundsException()\n        // \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n        vertices.removeAt(index)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n        adjMat.removeAt(index)\n        // \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n        for (row in adjMat) {\n            row.removeAt(index)\n        }\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    fun addEdge(i: Int, j: Int) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw IndexOutOfBoundsException()\n        // \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n        adjMat[i][j] = 1\n        adjMat[j][i] = 1\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    // \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    fun removeEdge(i: Int, j: Int) {\n        // \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n        if (i &lt; 0 || j &lt; 0 || i &gt;= size() || j &gt;= size() || i == j)\n            throw IndexOutOfBoundsException()\n        adjMat[i][j] = 0\n        adjMat[j][i] = 0\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u77e9\u9635 */\n    fun print() {\n        print(\"\u9876\u70b9\u5217\u8868 = \")\n        println(vertices)\n        println(\"\u90bb\u63a5\u77e9\u9635 =\")\n        printMatrix(adjMat)\n    }\n}\n</code></pre> graph_adjacency_matrix.rb<pre><code>### \u57fa\u4e8e\u90bb\u63a5\u77e9\u9635\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b ###\nclass GraphAdjMat\n  def initialize(vertices, edges)\n    ### \u6784\u9020\u65b9\u6cd5 ###\n    # \u9876\u70b9\u5217\u8868\uff0c\u5143\u7d20\u4ee3\u8868\u201c\u9876\u70b9\u503c\u201d\uff0c\u7d22\u5f15\u4ee3\u8868\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    @vertices = []\n    # \u90bb\u63a5\u77e9\u9635\uff0c\u884c\u5217\u7d22\u5f15\u5bf9\u5e94\u201c\u9876\u70b9\u7d22\u5f15\u201d\n    @adj_mat = []\n    # \u6dfb\u52a0\u9876\u70b9\n    vertices.each { |val| add_vertex(val) }\n    # \u6dfb\u52a0\u8fb9\n    # \u8bf7\u6ce8\u610f\uff0cedges \u5143\u7d20\u4ee3\u8868\u9876\u70b9\u7d22\u5f15\uff0c\u5373\u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    edges.each { |e| add_edge(e[0], e[1]) }\n  end\n\n  ### \u83b7\u53d6\u9876\u70b9\u6570\u91cf ###\n  def size\n    @vertices.length\n  end\n\n  ### \u6dfb\u52a0\u9876\u70b9 ###\n  def add_vertex(val)\n    n = size\n    # \u5411\u9876\u70b9\u5217\u8868\u4e2d\u6dfb\u52a0\u65b0\u9876\u70b9\u7684\u503c\n    @vertices &lt;&lt; val\n    # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u884c\n    new_row = Array.new(n, 0)\n    @adj_mat &lt;&lt; new_row\n    # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u6dfb\u52a0\u4e00\u5217\n    @adj_mat.each { |row| row &lt;&lt; 0 }\n  end\n\n  ### \u5220\u9664\u9876\u70b9 ###\n  def remove_vertex(index)\n    raise IndexError if index &gt;= size\n\n    # \u5728\u9876\u70b9\u5217\u8868\u4e2d\u79fb\u9664\u7d22\u5f15 index \u7684\u9876\u70b9\n    @vertices.delete_at(index)\n    # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u884c\n    @adj_mat.delete_at(index)\n    # \u5728\u90bb\u63a5\u77e9\u9635\u4e2d\u5220\u9664\u7d22\u5f15 index \u7684\u5217\n    @adj_mat.each { |row| row.delete_at(index) }\n  end\n\n  ### \u6dfb\u52a0\u8fb9 ###\n  def add_edge(i, j)\n    # \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    # \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if i &lt; 0 || j &lt; 0 || i &gt;= size || j &gt;= size || i == j\n      raise IndexError\n    end\n    # \u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u90bb\u63a5\u77e9\u9635\u5173\u4e8e\u4e3b\u5bf9\u89d2\u7ebf\u5bf9\u79f0\uff0c\u5373\u6ee1\u8db3 (i, j) == (j, i)\n    @adj_mat[i][j] = 1\n    @adj_mat[j][i] = 1\n  end\n\n  ### \u5220\u9664\u8fb9 ###\n  def remove_edge(i, j)\n    # \u53c2\u6570 i, j \u5bf9\u5e94 vertices \u5143\u7d20\u7d22\u5f15\n    # \u7d22\u5f15\u8d8a\u754c\u4e0e\u76f8\u7b49\u5904\u7406\n    if i &lt; 0 || j &lt; 0 || i &gt;= size || j &gt;= size || i == j\n      raise IndexError\n    end\n    @adj_mat[i][j] = 0\n    @adj_mat[j][i] = 0\n  end\n\n  ### \u6253\u5370\u90bb\u63a5\u77e9\u9635 ###\n  def __print__\n    puts \"\u9876\u70b9\u5217\u8868 = #{@vertices}\"\n    puts '\u90bb\u63a5\u77e9\u9635 ='\n    print_matrix(@adj_mat)\n  end\nend\n</code></pre> graph_adjacency_matrix.zig<pre><code>[class]{GraphAdjMat}-[func]{}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_graph/graph_operations/#922-implementation-based-on-adjacency-list","title":"9.2.2 \u00a0 Implementation based on adjacency list","text":"<p>Given an undirected graph with a total of \\(n\\) vertices and \\(m\\) edges, the various operations can be implemented as shown in Figure 9-8.</p> <ul> <li>Adding an edge: Simply add the edge at the end of the corresponding vertex's linked list, using \\(O(1)\\) time. Because it is an undirected graph, it is necessary to add edges in both directions simultaneously.</li> <li>Removing an edge: Find and remove the specified edge in the corresponding vertex's linked list, using \\(O(m)\\) time. In an undirected graph, it is necessary to remove edges in both directions simultaneously.</li> <li>Adding a vertex: Add a linked list in the adjacency list and make the new vertex the head node of the list, using \\(O(1)\\) time.</li> <li>Removing a vertex: It is necessary to traverse the entire adjacency list, removing all edges that include the specified vertex, using \\(O(n + m)\\) time.</li> <li>Initialization: Create \\(n\\) vertices and \\(2m\\) edges in the adjacency list, using \\(O(n + m)\\) time.</li> </ul> Initialize adjacency listAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-8 \u00a0 Initialization, adding and removing edges, adding and removing vertices in adjacency list </p> <p>Below is the adjacency list code implementation. Compared to the above diagram, the actual code has the following differences.</p> <ul> <li>For convenience in adding and removing vertices, and to simplify the code, we use lists (dynamic arrays) instead of linked lists.</li> <li>Use a hash table to store the adjacency list, <code>key</code> being the vertex instance, <code>value</code> being the list (linked list) of adjacent vertices of that vertex.</li> </ul> <p>Additionally, we use the <code>Vertex</code> class to represent vertices in the adjacency list. The reason for this is: if, like with the adjacency matrix, list indexes were used to distinguish different vertices, then suppose you want to delete the vertex at index \\(i\\), you would need to traverse the entire adjacency list and decrement all indexes greater than \\(i\\) by \\(1\\), which is very inefficient. However, if each vertex is a unique <code>Vertex</code> instance, then deleting a vertex does not require any changes to other vertices.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig graph_adjacency_list.py<pre><code>class GraphAdjList:\n    \"\"\"\u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b\"\"\"\n\n    def __init__(self, edges: list[list[Vertex]]):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        # \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        self.adj_list = dict[Vertex, list[Vertex]]()\n        # \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for edge in edges:\n            self.add_vertex(edge[0])\n            self.add_vertex(edge[1])\n            self.add_edge(edge[0], edge[1])\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u9876\u70b9\u6570\u91cf\"\"\"\n        return len(self.adj_list)\n\n    def add_edge(self, vet1: Vertex, vet2: Vertex):\n        \"\"\"\u6dfb\u52a0\u8fb9\"\"\"\n        if vet1 not in self.adj_list or vet2 not in self.adj_list or vet1 == vet2:\n            raise ValueError()\n        # \u6dfb\u52a0\u8fb9 vet1 - vet2\n        self.adj_list[vet1].append(vet2)\n        self.adj_list[vet2].append(vet1)\n\n    def remove_edge(self, vet1: Vertex, vet2: Vertex):\n        \"\"\"\u5220\u9664\u8fb9\"\"\"\n        if vet1 not in self.adj_list or vet2 not in self.adj_list or vet1 == vet2:\n            raise ValueError()\n        # \u5220\u9664\u8fb9 vet1 - vet2\n        self.adj_list[vet1].remove(vet2)\n        self.adj_list[vet2].remove(vet1)\n\n    def add_vertex(self, vet: Vertex):\n        \"\"\"\u6dfb\u52a0\u9876\u70b9\"\"\"\n        if vet in self.adj_list:\n            return\n        # \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        self.adj_list[vet] = []\n\n    def remove_vertex(self, vet: Vertex):\n        \"\"\"\u5220\u9664\u9876\u70b9\"\"\"\n        if vet not in self.adj_list:\n            raise ValueError()\n        # \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        self.adj_list.pop(vet)\n        # \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for vertex in self.adj_list:\n            if vet in self.adj_list[vertex]:\n                self.adj_list[vertex].remove(vet)\n\n    def print(self):\n        \"\"\"\u6253\u5370\u90bb\u63a5\u8868\"\"\"\n        print(\"\u90bb\u63a5\u8868 =\")\n        for vertex in self.adj_list:\n            tmp = [v.val for v in self.adj_list[vertex]]\n            print(f\"{vertex.val}: {tmp},\")\n</code></pre> graph_adjacency_list.cpp<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n  public:\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    unordered_map&lt;Vertex *, vector&lt;Vertex *&gt;&gt; adjList;\n\n    /* \u5728 vector \u4e2d\u5220\u9664\u6307\u5b9a\u8282\u70b9 */\n    void remove(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet) {\n        for (int i = 0; i &lt; vec.size(); i++) {\n            if (vec[i] == vet) {\n                vec.erase(vec.begin() + i);\n                break;\n            }\n        }\n    }\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    GraphAdjList(const vector&lt;vector&lt;Vertex *&gt;&gt; &amp;edges) {\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for (const vector&lt;Vertex *&gt; &amp;edge : edges) {\n            addVertex(edge[0]);\n            addVertex(edge[1]);\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    int size() {\n        return adjList.size();\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    void addEdge(Vertex *vet1, Vertex *vet2) {\n        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)\n            throw invalid_argument(\"\u4e0d\u5b58\u5728\u9876\u70b9\");\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        adjList[vet1].push_back(vet2);\n        adjList[vet2].push_back(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    void removeEdge(Vertex *vet1, Vertex *vet2) {\n        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)\n            throw invalid_argument(\"\u4e0d\u5b58\u5728\u9876\u70b9\");\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        remove(adjList[vet1], vet2);\n        remove(adjList[vet2], vet1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    void addVertex(Vertex *vet) {\n        if (adjList.count(vet))\n            return;\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        adjList[vet] = vector&lt;Vertex *&gt;();\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    void removeVertex(Vertex *vet) {\n        if (!adjList.count(vet))\n            throw invalid_argument(\"\u4e0d\u5b58\u5728\u9876\u70b9\");\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        adjList.erase(vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for (auto &amp;adj : adjList) {\n            remove(adj.second, vet);\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    void print() {\n        cout &lt;&lt; \"\u90bb\u63a5\u8868 =\" &lt;&lt; endl;\n        for (auto &amp;adj : adjList) {\n            const auto &amp;key = adj.first;\n            const auto &amp;vec = adj.second;\n            cout &lt;&lt; key-&gt;val &lt;&lt; \": \";\n            printVector(vetsToVals(vec));\n        }\n    }\n};\n</code></pre> graph_adjacency_list.java<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public GraphAdjList(Vertex[][] edges) {\n        this.adjList = new HashMap&lt;&gt;();\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for (Vertex[] edge : edges) {\n            addVertex(edge[0]);\n            addVertex(edge[1]);\n            addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    public int size() {\n        return adjList.size();\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    public void addEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw new IllegalArgumentException();\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        adjList.get(vet1).add(vet2);\n        adjList.get(vet2).add(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    public void removeEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw new IllegalArgumentException();\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        adjList.get(vet1).remove(vet2);\n        adjList.get(vet2).remove(vet1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    public void addVertex(Vertex vet) {\n        if (adjList.containsKey(vet))\n            return;\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        adjList.put(vet, new ArrayList&lt;&gt;());\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    public void removeVertex(Vertex vet) {\n        if (!adjList.containsKey(vet))\n            throw new IllegalArgumentException();\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        adjList.remove(vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for (List&lt;Vertex&gt; list : adjList.values()) {\n            list.remove(vet);\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    public void print() {\n        System.out.println(\"\u90bb\u63a5\u8868 =\");\n        for (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) {\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for (Vertex vertex : pair.getValue())\n                tmp.add(vertex.val);\n            System.out.println(pair.getKey().val + \": \" + tmp + \",\");\n        }\n    }\n}\n</code></pre> graph_adjacency_list.cs<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    public Dictionary&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    /* \u6784\u9020\u51fd\u6570 */\n    public GraphAdjList(Vertex[][] edges) {\n        adjList = [];\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        foreach (Vertex[] edge in edges) {\n            AddVertex(edge[0]);\n            AddVertex(edge[1]);\n            AddEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    int Size() {\n        return adjList.Count;\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    public void AddEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.ContainsKey(vet1) || !adjList.ContainsKey(vet2) || vet1 == vet2)\n            throw new InvalidOperationException();\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        adjList[vet1].Add(vet2);\n        adjList[vet2].Add(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    public void RemoveEdge(Vertex vet1, Vertex vet2) {\n        if (!adjList.ContainsKey(vet1) || !adjList.ContainsKey(vet2) || vet1 == vet2)\n            throw new InvalidOperationException();\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        adjList[vet1].Remove(vet2);\n        adjList[vet2].Remove(vet1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    public void AddVertex(Vertex vet) {\n        if (adjList.ContainsKey(vet))\n            return;\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        adjList.Add(vet, []);\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    public void RemoveVertex(Vertex vet) {\n        if (!adjList.ContainsKey(vet))\n            throw new InvalidOperationException();\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        adjList.Remove(vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        foreach (List&lt;Vertex&gt; list in adjList.Values) {\n            list.Remove(vet);\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    public void Print() {\n        Console.WriteLine(\"\u90bb\u63a5\u8868 =\");\n        foreach (KeyValuePair&lt;Vertex, List&lt;Vertex&gt;&gt; pair in adjList) {\n            List&lt;int&gt; tmp = [];\n            foreach (Vertex vertex in pair.Value)\n                tmp.Add(vertex.val);\n            Console.WriteLine(pair.Key.val + \": [\" + string.Join(\", \", tmp) + \"],\");\n        }\n    }\n}\n</code></pre> graph_adjacency_list.go<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\ntype graphAdjList struct {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    adjList map[Vertex][]Vertex\n}\n\n/* \u6784\u9020\u51fd\u6570 */\nfunc newGraphAdjList(edges [][]Vertex) *graphAdjList {\n    g := &amp;graphAdjList{\n        adjList: make(map[Vertex][]Vertex),\n    }\n    // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n    for _, edge := range edges {\n        g.addVertex(edge[0])\n        g.addVertex(edge[1])\n        g.addEdge(edge[0], edge[1])\n    }\n    return g\n}\n\n/* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\nfunc (g *graphAdjList) size() int {\n    return len(g.adjList)\n}\n\n/* \u6dfb\u52a0\u8fb9 */\nfunc (g *graphAdjList) addEdge(vet1 Vertex, vet2 Vertex) {\n    _, ok1 := g.adjList[vet1]\n    _, ok2 := g.adjList[vet2]\n    if !ok1 || !ok2 || vet1 == vet2 {\n        panic(\"error\")\n    }\n    // \u6dfb\u52a0\u8fb9 vet1 - vet2, \u6dfb\u52a0\u533f\u540d struct{},\n    g.adjList[vet1] = append(g.adjList[vet1], vet2)\n    g.adjList[vet2] = append(g.adjList[vet2], vet1)\n}\n\n/* \u5220\u9664\u8fb9 */\nfunc (g *graphAdjList) removeEdge(vet1 Vertex, vet2 Vertex) {\n    _, ok1 := g.adjList[vet1]\n    _, ok2 := g.adjList[vet2]\n    if !ok1 || !ok2 || vet1 == vet2 {\n        panic(\"error\")\n    }\n    // \u5220\u9664\u8fb9 vet1 - vet2\n    g.adjList[vet1] = DeleteSliceElms(g.adjList[vet1], vet2)\n    g.adjList[vet2] = DeleteSliceElms(g.adjList[vet2], vet1)\n}\n\n/* \u6dfb\u52a0\u9876\u70b9 */\nfunc (g *graphAdjList) addVertex(vet Vertex) {\n    _, ok := g.adjList[vet]\n    if ok {\n        return\n    }\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n    g.adjList[vet] = make([]Vertex, 0)\n}\n\n/* \u5220\u9664\u9876\u70b9 */\nfunc (g *graphAdjList) removeVertex(vet Vertex) {\n    _, ok := g.adjList[vet]\n    if !ok {\n        panic(\"error\")\n    }\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n    delete(g.adjList, vet)\n    // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n    for v, list := range g.adjList {\n        g.adjList[v] = DeleteSliceElms(list, vet)\n    }\n}\n\n/* \u6253\u5370\u90bb\u63a5\u8868 */\nfunc (g *graphAdjList) print() {\n    var builder strings.Builder\n    fmt.Printf(\"\u90bb\u63a5\u8868 = \\n\")\n    for k, v := range g.adjList {\n        builder.WriteString(\"\\t\\t\" + strconv.Itoa(k.Val) + \": \")\n        for _, vet := range v {\n            builder.WriteString(strconv.Itoa(vet.Val) + \" \")\n        }\n        fmt.Println(builder.String())\n        builder.Reset()\n    }\n}\n</code></pre> graph_adjacency_list.swift<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    public private(set) var adjList: [Vertex: [Vertex]]\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public init(edges: [[Vertex]]) {\n        adjList = [:]\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for edge in edges {\n            addVertex(vet: edge[0])\n            addVertex(vet: edge[1])\n            addEdge(vet1: edge[0], vet2: edge[1])\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    public func size() -&gt; Int {\n        adjList.count\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    public func addEdge(vet1: Vertex, vet2: Vertex) {\n        if adjList[vet1] == nil || adjList[vet2] == nil || vet1 == vet2 {\n            fatalError(\"\u53c2\u6570\u9519\u8bef\")\n        }\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        adjList[vet1]?.append(vet2)\n        adjList[vet2]?.append(vet1)\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    public func removeEdge(vet1: Vertex, vet2: Vertex) {\n        if adjList[vet1] == nil || adjList[vet2] == nil || vet1 == vet2 {\n            fatalError(\"\u53c2\u6570\u9519\u8bef\")\n        }\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        adjList[vet1]?.removeAll { $0 == vet2 }\n        adjList[vet2]?.removeAll { $0 == vet1 }\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    public func addVertex(vet: Vertex) {\n        if adjList[vet] != nil {\n            return\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        adjList[vet] = []\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    public func removeVertex(vet: Vertex) {\n        if adjList[vet] == nil {\n            fatalError(\"\u53c2\u6570\u9519\u8bef\")\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        adjList.removeValue(forKey: vet)\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for key in adjList.keys {\n            adjList[key]?.removeAll { $0 == vet }\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    public func print() {\n        Swift.print(\"\u90bb\u63a5\u8868 =\")\n        for (vertex, list) in adjList {\n            let list = list.map { $0.val }\n            Swift.print(\"\\(vertex.val): \\(list),\")\n        }\n    }\n}\n</code></pre> graph_adjacency_list.js<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    adjList;\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(edges) {\n        this.adjList = new Map();\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for (const edge of edges) {\n            this.addVertex(edge[0]);\n            this.addVertex(edge[1]);\n            this.addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    size() {\n        return this.adjList.size;\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    addEdge(vet1, vet2) {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        this.adjList.get(vet1).push(vet2);\n        this.adjList.get(vet2).push(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    removeEdge(vet1, vet2) {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        this.adjList.get(vet1).splice(this.adjList.get(vet1).indexOf(vet2), 1);\n        this.adjList.get(vet2).splice(this.adjList.get(vet2).indexOf(vet1), 1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    addVertex(vet) {\n        if (this.adjList.has(vet)) return;\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        this.adjList.set(vet, []);\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    removeVertex(vet) {\n        if (!this.adjList.has(vet)) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        this.adjList.delete(vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for (const set of this.adjList.values()) {\n            const index = set.indexOf(vet);\n            if (index &gt; -1) {\n                set.splice(index, 1);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    print() {\n        console.log('\u90bb\u63a5\u8868 =');\n        for (const [key, value] of this.adjList) {\n            const tmp = [];\n            for (const vertex of value) {\n                tmp.push(vertex.val);\n            }\n            console.log(key.val + ': ' + tmp.join());\n        }\n    }\n}\n</code></pre> graph_adjacency_list.ts<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    adjList: Map&lt;Vertex, Vertex[]&gt;;\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(edges: Vertex[][]) {\n        this.adjList = new Map();\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for (const edge of edges) {\n            this.addVertex(edge[0]);\n            this.addVertex(edge[1]);\n            this.addEdge(edge[0], edge[1]);\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    size(): number {\n        return this.adjList.size;\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    addEdge(vet1: Vertex, vet2: Vertex): void {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        this.adjList.get(vet1).push(vet2);\n        this.adjList.get(vet2).push(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    removeEdge(vet1: Vertex, vet2: Vertex): void {\n        if (\n            !this.adjList.has(vet1) ||\n            !this.adjList.has(vet2) ||\n            vet1 === vet2\n        ) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        this.adjList.get(vet1).splice(this.adjList.get(vet1).indexOf(vet2), 1);\n        this.adjList.get(vet2).splice(this.adjList.get(vet2).indexOf(vet1), 1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    addVertex(vet: Vertex): void {\n        if (this.adjList.has(vet)) return;\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        this.adjList.set(vet, []);\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    removeVertex(vet: Vertex): void {\n        if (!this.adjList.has(vet)) {\n            throw new Error('Illegal Argument Exception');\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        this.adjList.delete(vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for (const set of this.adjList.values()) {\n            const index: number = set.indexOf(vet);\n            if (index &gt; -1) {\n                set.splice(index, 1);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    print(): void {\n        console.log('\u90bb\u63a5\u8868 =');\n        for (const [key, value] of this.adjList.entries()) {\n            const tmp = [];\n            for (const vertex of value) {\n                tmp.push(vertex.val);\n            }\n            console.log(key.val + ': ' + tmp.join());\n        }\n    }\n}\n</code></pre> graph_adjacency_list.dart<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList {\n  // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList = {};\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  GraphAdjList(List&lt;List&lt;Vertex&gt;&gt; edges) {\n    for (List&lt;Vertex&gt; edge in edges) {\n      addVertex(edge[0]);\n      addVertex(edge[1]);\n      addEdge(edge[0], edge[1]);\n    }\n  }\n\n  /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n  int size() {\n    return adjList.length;\n  }\n\n  /* \u6dfb\u52a0\u8fb9 */\n  void addEdge(Vertex vet1, Vertex vet2) {\n    if (!adjList.containsKey(vet1) ||\n        !adjList.containsKey(vet2) ||\n        vet1 == vet2) {\n      throw ArgumentError;\n    }\n    // \u6dfb\u52a0\u8fb9 vet1 - vet2\n    adjList[vet1]!.add(vet2);\n    adjList[vet2]!.add(vet1);\n  }\n\n  /* \u5220\u9664\u8fb9 */\n  void removeEdge(Vertex vet1, Vertex vet2) {\n    if (!adjList.containsKey(vet1) ||\n        !adjList.containsKey(vet2) ||\n        vet1 == vet2) {\n      throw ArgumentError;\n    }\n    // \u5220\u9664\u8fb9 vet1 - vet2\n    adjList[vet1]!.remove(vet2);\n    adjList[vet2]!.remove(vet1);\n  }\n\n  /* \u6dfb\u52a0\u9876\u70b9 */\n  void addVertex(Vertex vet) {\n    if (adjList.containsKey(vet)) return;\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n    adjList[vet] = [];\n  }\n\n  /* \u5220\u9664\u9876\u70b9 */\n  void removeVertex(Vertex vet) {\n    if (!adjList.containsKey(vet)) {\n      throw ArgumentError;\n    }\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n    adjList.remove(vet);\n    // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n    adjList.forEach((key, value) {\n      value.remove(vet);\n    });\n  }\n\n  /* \u6253\u5370\u90bb\u63a5\u8868 */\n  void printAdjList() {\n    print(\"\u90bb\u63a5\u8868 =\");\n    adjList.forEach((key, value) {\n      List&lt;int&gt; tmp = [];\n      for (Vertex vertex in value) {\n        tmp.add(vertex.val);\n      }\n      print(\"${key.val}: $tmp,\");\n    });\n  }\n}\n</code></pre> graph_adjacency_list.rs<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b\u578b */\npub struct GraphAdjList {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    pub adj_list: HashMap&lt;Vertex, Vec&lt;Vertex&gt;&gt;,\n}\n\nimpl GraphAdjList {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    pub fn new(edges: Vec&lt;[Vertex; 2]&gt;) -&gt; Self {\n        let mut graph = GraphAdjList {\n            adj_list: HashMap::new(),\n        };\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for edge in edges {\n            graph.add_vertex(edge[0]);\n            graph.add_vertex(edge[1]);\n            graph.add_edge(edge[0], edge[1]);\n        }\n\n        graph\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    #[allow(unused)]\n    pub fn size(&amp;self) -&gt; usize {\n        self.adj_list.len()\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    pub fn add_edge(&amp;mut self, vet1: Vertex, vet2: Vertex) {\n        if !self.adj_list.contains_key(&amp;vet1) || !self.adj_list.contains_key(&amp;vet2) || vet1 == vet2\n        {\n            panic!(\"value error\");\n        }\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        self.adj_list.get_mut(&amp;vet1).unwrap().push(vet2);\n        self.adj_list.get_mut(&amp;vet2).unwrap().push(vet1);\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    #[allow(unused)]\n    pub fn remove_edge(&amp;mut self, vet1: Vertex, vet2: Vertex) {\n        if !self.adj_list.contains_key(&amp;vet1) || !self.adj_list.contains_key(&amp;vet2) || vet1 == vet2\n        {\n            panic!(\"value error\");\n        }\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        self.adj_list\n            .get_mut(&amp;vet1)\n            .unwrap()\n            .retain(|&amp;vet| vet != vet2);\n        self.adj_list\n            .get_mut(&amp;vet2)\n            .unwrap()\n            .retain(|&amp;vet| vet != vet1);\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    pub fn add_vertex(&amp;mut self, vet: Vertex) {\n        if self.adj_list.contains_key(&amp;vet) {\n            return;\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        self.adj_list.insert(vet, vec![]);\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    #[allow(unused)]\n    pub fn remove_vertex(&amp;mut self, vet: Vertex) {\n        if !self.adj_list.contains_key(&amp;vet) {\n            panic!(\"value error\");\n        }\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        self.adj_list.remove(&amp;vet);\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for list in self.adj_list.values_mut() {\n            list.retain(|&amp;v| v != vet);\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    pub fn print(&amp;self) {\n        println!(\"\u90bb\u63a5\u8868 =\");\n        for (vertex, list) in &amp;self.adj_list {\n            let list = list.iter().map(|vertex| vertex.val).collect::&lt;Vec&lt;i32&gt;&gt;();\n            println!(\"{}: {:?},\", vertex.val, list);\n        }\n    }\n}\n</code></pre> graph_adjacency_list.c<pre><code>/* \u8282\u70b9\u7ed3\u6784\u4f53 */\ntypedef struct AdjListNode {\n    Vertex *vertex;           // \u9876\u70b9\n    struct AdjListNode *next; // \u540e\u7ee7\u8282\u70b9\n} AdjListNode;\n\n/* \u67e5\u627e\u9876\u70b9\u5bf9\u5e94\u7684\u8282\u70b9 */\nAdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i]-&gt;vertex == vet) {\n            return graph-&gt;heads[i];\n        }\n    }\n    return NULL;\n}\n\n/* \u6dfb\u52a0\u8fb9\u8f85\u52a9\u51fd\u6570 */\nvoid addEdgeHelper(AdjListNode *head, Vertex *vet) {\n    AdjListNode *node = (AdjListNode *)malloc(sizeof(AdjListNode));\n    node-&gt;vertex = vet;\n    // \u5934\u63d2\u6cd5\n    node-&gt;next = head-&gt;next;\n    head-&gt;next = node;\n}\n\n/* \u5220\u9664\u8fb9\u8f85\u52a9\u51fd\u6570 */\nvoid removeEdgeHelper(AdjListNode *head, Vertex *vet) {\n    AdjListNode *pre = head;\n    AdjListNode *cur = head-&gt;next;\n    // \u5728\u94fe\u8868\u4e2d\u641c\u7d22 vet \u5bf9\u5e94\u8282\u70b9\n    while (cur != NULL &amp;&amp; cur-&gt;vertex != vet) {\n        pre = cur;\n        cur = cur-&gt;next;\n    }\n    if (cur == NULL)\n        return;\n    // \u5c06 vet \u5bf9\u5e94\u8282\u70b9\u4ece\u94fe\u8868\u4e2d\u5220\u9664\n    pre-&gt;next = cur-&gt;next;\n    // \u91ca\u653e\u5185\u5b58\n    free(cur);\n}\n\n/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\ntypedef struct {\n    AdjListNode *heads[MAX_SIZE]; // \u8282\u70b9\u6570\u7ec4\n    int size;                     // \u8282\u70b9\u6570\u91cf\n} GraphAdjList;\n\n/* \u6784\u9020\u51fd\u6570 */\nGraphAdjList *newGraphAdjList() {\n    GraphAdjList *graph = (GraphAdjList *)malloc(sizeof(GraphAdjList));\n    if (!graph) {\n        return NULL;\n    }\n    graph-&gt;size = 0;\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        graph-&gt;heads[i] = NULL;\n    }\n    return graph;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delGraphAdjList(GraphAdjList *graph) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        AdjListNode *cur = graph-&gt;heads[i];\n        while (cur != NULL) {\n            AdjListNode *next = cur-&gt;next;\n            if (cur != graph-&gt;heads[i]) {\n                free(cur);\n            }\n            cur = next;\n        }\n        free(graph-&gt;heads[i]-&gt;vertex);\n        free(graph-&gt;heads[i]);\n    }\n    free(graph);\n}\n\n/* \u67e5\u627e\u9876\u70b9\u5bf9\u5e94\u7684\u8282\u70b9 */\nAdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i]-&gt;vertex == vet) {\n            return graph-&gt;heads[i];\n        }\n    }\n    return NULL;\n}\n\n/* \u6dfb\u52a0\u8fb9 */\nvoid addEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {\n    AdjListNode *head1 = findNode(graph, vet1);\n    AdjListNode *head2 = findNode(graph, vet2);\n    assert(head1 != NULL &amp;&amp; head2 != NULL &amp;&amp; head1 != head2);\n    // \u6dfb\u52a0\u8fb9 vet1 - vet2\n    addEdgeHelper(head1, vet2);\n    addEdgeHelper(head2, vet1);\n}\n\n/* \u5220\u9664\u8fb9 */\nvoid removeEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {\n    AdjListNode *head1 = findNode(graph, vet1);\n    AdjListNode *head2 = findNode(graph, vet2);\n    assert(head1 != NULL &amp;&amp; head2 != NULL);\n    // \u5220\u9664\u8fb9 vet1 - vet2\n    removeEdgeHelper(head1, head2-&gt;vertex);\n    removeEdgeHelper(head2, head1-&gt;vertex);\n}\n\n/* \u6dfb\u52a0\u9876\u70b9 */\nvoid addVertex(GraphAdjList *graph, Vertex *vet) {\n    assert(graph != NULL &amp;&amp; graph-&gt;size &lt; MAX_SIZE);\n    AdjListNode *head = (AdjListNode *)malloc(sizeof(AdjListNode));\n    head-&gt;vertex = vet;\n    head-&gt;next = NULL;\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n    graph-&gt;heads[graph-&gt;size++] = head;\n}\n\n/* \u5220\u9664\u9876\u70b9 */\nvoid removeVertex(GraphAdjList *graph, Vertex *vet) {\n    AdjListNode *node = findNode(graph, vet);\n    assert(node != NULL);\n    // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n    AdjListNode *cur = node, *pre = NULL;\n    while (cur) {\n        pre = cur;\n        cur = cur-&gt;next;\n        free(pre);\n    }\n    // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n    for (int i = 0; i &lt; graph-&gt;size; i++) {\n        cur = graph-&gt;heads[i];\n        pre = NULL;\n        while (cur) {\n            pre = cur;\n            cur = cur-&gt;next;\n            if (cur &amp;&amp; cur-&gt;vertex == vet) {\n                pre-&gt;next = cur-&gt;next;\n                free(cur);\n                break;\n            }\n        }\n    }\n    // \u5c06\u8be5\u9876\u70b9\u4e4b\u540e\u7684\u9876\u70b9\u5411\u524d\u79fb\u52a8\uff0c\u4ee5\u586b\u8865\u7a7a\u7f3a\n    int i;\n    for (i = 0; i &lt; graph-&gt;size; i++) {\n        if (graph-&gt;heads[i] == node)\n            break;\n    }\n    for (int j = i; j &lt; graph-&gt;size - 1; j++) {\n        graph-&gt;heads[j] = graph-&gt;heads[j + 1];\n    }\n    graph-&gt;size--;\n    free(vet);\n}\n</code></pre> graph_adjacency_list.kt<pre><code>/* \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b */\nclass GraphAdjList(edges: Array&lt;Array&lt;Vertex?&gt;&gt;) {\n    // \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    val adjList = HashMap&lt;Vertex, MutableList&lt;Vertex&gt;&gt;()\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init {\n        // \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n        for (edge in edges) {\n            addVertex(edge[0]!!)\n            addVertex(edge[1]!!)\n            addEdge(edge[0]!!, edge[1]!!)\n        }\n    }\n\n    /* \u83b7\u53d6\u9876\u70b9\u6570\u91cf */\n    fun size(): Int {\n        return adjList.size\n    }\n\n    /* \u6dfb\u52a0\u8fb9 */\n    fun addEdge(vet1: Vertex, vet2: Vertex) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw IllegalArgumentException()\n        // \u6dfb\u52a0\u8fb9 vet1 - vet2\n        adjList[vet1]?.add(vet2)\n        adjList[vet2]?.add(vet1)\n    }\n\n    /* \u5220\u9664\u8fb9 */\n    fun removeEdge(vet1: Vertex, vet2: Vertex) {\n        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)\n            throw IllegalArgumentException()\n        // \u5220\u9664\u8fb9 vet1 - vet2\n        adjList[vet1]?.remove(vet2)\n        adjList[vet2]?.remove(vet1)\n    }\n\n    /* \u6dfb\u52a0\u9876\u70b9 */\n    fun addVertex(vet: Vertex) {\n        if (adjList.containsKey(vet))\n            return\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n        adjList[vet] = mutableListOf()\n    }\n\n    /* \u5220\u9664\u9876\u70b9 */\n    fun removeVertex(vet: Vertex) {\n        if (!adjList.containsKey(vet))\n            throw IllegalArgumentException()\n        // \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n        adjList.remove(vet)\n        // \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n        for (list in adjList.values) {\n            list.remove(vet)\n        }\n    }\n\n    /* \u6253\u5370\u90bb\u63a5\u8868 */\n    fun print() {\n        println(\"\u90bb\u63a5\u8868 =\")\n        for (pair in adjList.entries) {\n            val tmp = mutableListOf&lt;Int&gt;()\n            for (vertex in pair.value) {\n                tmp.add(vertex._val)\n            }\n            println(\"${pair.key._val}: $tmp,\")\n        }\n    }\n}\n</code></pre> graph_adjacency_list.rb<pre><code>### \u57fa\u4e8e\u90bb\u63a5\u8868\u5b9e\u73b0\u7684\u65e0\u5411\u56fe\u7c7b ###\nclass GraphAdjList\n  attr_reader :adj_list\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize(edges)\n    # \u90bb\u63a5\u8868\uff0ckey\uff1a\u9876\u70b9\uff0cvalue\uff1a\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    @adj_list = {}\n    # \u6dfb\u52a0\u6240\u6709\u9876\u70b9\u548c\u8fb9\n    for edge in edges\n      add_vertex(edge[0])\n      add_vertex(edge[1])\n      add_edge(edge[0], edge[1])\n    end\n  end\n\n  ### \u83b7\u53d6\u9876\u70b9\u6570\u91cf ###\n  def size\n    @adj_list.length\n  end\n\n  ### \u6dfb\u52a0\u8fb9 ###\n  def add_edge(vet1, vet2)\n    raise ArgumentError if !@adj_list.include?(vet1) || !@adj_list.include?(vet2)\n\n    @adj_list[vet1] &lt;&lt; vet2\n    @adj_list[vet2] &lt;&lt; vet1\n  end\n\n  ### \u5220\u9664\u8fb9 ###\n  def remove_edge(vet1, vet2)\n    raise ArgumentError if !@adj_list.include?(vet1) || !@adj_list.include?(vet2)\n\n    # \u5220\u9664\u8fb9 vet1 - vet2\n    @adj_list[vet1].delete(vet2)\n    @adj_list[vet2].delete(vet1)\n  end\n\n  ### \u6dfb\u52a0\u9876\u70b9 ###\n  def add_vertex(vet)\n    return if @adj_list.include?(vet)\n\n    # \u5728\u90bb\u63a5\u8868\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u94fe\u8868\n    @adj_list[vet] = []\n  end\n\n  ### \u5220\u9664\u9876\u70b9 ###\n  def remove_vertex(vet)\n    raise ArgumentError unless @adj_list.include?(vet)\n\n    # \u5728\u90bb\u63a5\u8868\u4e2d\u5220\u9664\u9876\u70b9 vet \u5bf9\u5e94\u7684\u94fe\u8868\n    @adj_list.delete(vet)\n    # \u904d\u5386\u5176\u4ed6\u9876\u70b9\u7684\u94fe\u8868\uff0c\u5220\u9664\u6240\u6709\u5305\u542b vet \u7684\u8fb9\n    for vertex in @adj_list\n      @adj_list[vertex.first].delete(vet) if @adj_list[vertex.first].include?(vet)\n    end\n  end\n\n  ### \u6253\u5370\u90bb\u63a5\u8868 ###\n  def __print__\n    puts '\u90bb\u63a5\u8868 ='\n    for vertex in @adj_list\n      tmp = @adj_list[vertex.first].map { |v| v.val }\n      puts \"#{vertex.first.val}: #{tmp},\"\n    end\n  end\nend\n</code></pre> graph_adjacency_list.zig<pre><code>[class]{GraphAdjList}-[func]{}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_graph/graph_operations/#923-efficiency-comparison","title":"9.2.3 \u00a0 Efficiency comparison","text":"<p>Assuming there are \\(n\\) vertices and \\(m\\) edges in the graph, Table 9-2 compares the time efficiency and space efficiency of the adjacency matrix and adjacency list.</p> <p> Table 9-2 \u00a0 Comparison of adjacency matrix and adjacency list </p> Adjacency matrix Adjacency list (Linked list) Adjacency list (Hash table) Determine adjacency \\(O(1)\\) \\(O(m)\\) \\(O(1)\\) Add an edge \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Remove an edge \\(O(1)\\) \\(O(m)\\) \\(O(1)\\) Add a vertex \\(O(n)\\) \\(O(1)\\) \\(O(1)\\) Remove a vertex \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n)\\) Memory space usage \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n + m)\\) <p>Observing Table 9-2, it seems that the adjacency list (hash table) has the best time efficiency and space efficiency. However, in practice, operating on edges in the adjacency matrix is more efficient, requiring only a single array access or assignment operation. Overall, the adjacency matrix exemplifies the principle of \"space for time\", while the adjacency list exemplifies \"time for space\".</p>"},{"location":"chapter_graph/graph_traversal/","title":"9.3 \u00a0 Graph traversal","text":"<p>Trees represent a \"one-to-many\" relationship, while graphs have a higher degree of freedom and can represent any \"many-to-many\" relationship. Therefore, we can consider trees as a special case of graphs. Clearly, tree traversal operations are also a special case of graph traversal operations.</p> <p>Both graphs and trees require the application of search algorithms to implement traversal operations. Graph traversal can be divided into two types: Breadth-First Search (BFS) and Depth-First Search (DFS).</p>"},{"location":"chapter_graph/graph_traversal/#931-breadth-first-search","title":"9.3.1 \u00a0 Breadth-first search","text":"<p>Breadth-first search is a near-to-far traversal method, starting from a certain node, always prioritizing the visit to the nearest vertices and expanding outwards layer by layer. As shown in Figure 9-9, starting from the top left vertex, first traverse all adjacent vertices of that vertex, then traverse all adjacent vertices of the next vertex, and so on, until all vertices have been visited.</p> <p></p> <p> Figure 9-9 \u00a0 Breadth-first traversal of a graph </p>"},{"location":"chapter_graph/graph_traversal/#1-algorithm-implementation","title":"1. \u00a0 Algorithm implementation","text":"<p>BFS is usually implemented with the help of a queue, as shown in the code below. The queue has a \"first in, first out\" property, which aligns with the BFS idea of traversing \"from near to far\".</p> <ol> <li>Add the starting vertex <code>startVet</code> to the queue and start the loop.</li> <li>In each iteration of the loop, pop the vertex at the front of the queue and record it as visited, then add all adjacent vertices of that vertex to the back of the queue.</li> <li>Repeat step <code>2.</code> until all vertices have been visited.</li> </ol> <p>To prevent revisiting vertices, we use a hash table <code>visited</code> to record which nodes have been visited.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig graph_bfs.py<pre><code>def graph_bfs(graph: GraphAdjList, start_vet: Vertex) -&gt; list[Vertex]:\n    \"\"\"\u5e7f\u5ea6\u4f18\u5148\u904d\u5386\"\"\"\n    # \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    # \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    res = []\n    # \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    visited = set[Vertex]([start_vet])\n    # \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    que = deque[Vertex]([start_vet])\n    # \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while len(que) &gt; 0:\n        vet = que.popleft()  # \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.append(vet)  # \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        # \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for adj_vet in graph.adj_list[vet]:\n            if adj_vet in visited:\n                continue  # \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            que.append(adj_vet)  # \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.add(adj_vet)  # \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    # \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res\n</code></pre> graph_bfs.cpp<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nvector&lt;Vertex *&gt; graphBFS(GraphAdjList &amp;graph, Vertex *startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    vector&lt;Vertex *&gt; res;\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    unordered_set&lt;Vertex *&gt; visited = {startVet};\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    queue&lt;Vertex *&gt; que;\n    que.push(startVet);\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (!que.empty()) {\n        Vertex *vet = que.front();\n        que.pop();          // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.push_back(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for (auto adjVet : graph.adjList[vet]) {\n            if (visited.count(adjVet))\n                continue;            // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            que.push(adjVet);        // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.emplace(adjVet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res;\n}\n</code></pre> graph_bfs.java<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nList&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n    visited.add(startVet);\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;();\n    que.offer(startVet);\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (!que.isEmpty()) {\n        Vertex vet = que.poll(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.add(vet);            // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for (Vertex adjVet : graph.adjList.get(vet)) {\n            if (visited.contains(adjVet))\n                continue;        // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            que.offer(adjVet);   // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.add(adjVet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res;\n}\n</code></pre> graph_bfs.cs<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nList&lt;Vertex&gt; GraphBFS(GraphAdjList graph, Vertex startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    List&lt;Vertex&gt; res = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    HashSet&lt;Vertex&gt; visited = [startVet];\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    Queue&lt;Vertex&gt; que = new();\n    que.Enqueue(startVet);\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (que.Count &gt; 0) {\n        Vertex vet = que.Dequeue(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.Add(vet);               // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        foreach (Vertex adjVet in graph.adjList[vet]) {\n            if (visited.Contains(adjVet)) {\n                continue;          // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            }\n            que.Enqueue(adjVet);   // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.Add(adjVet);   // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res;\n}\n</code></pre> graph_bfs.go<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunc graphBFS(g *graphAdjList, startVet Vertex) []Vertex {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    res := make([]Vertex, 0)\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    visited := make(map[Vertex]struct{})\n    visited[startVet] = struct{}{}\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS, \u4f7f\u7528\u5207\u7247\u6a21\u62df\u961f\u5217\n    queue := make([]Vertex, 0)\n    queue = append(queue, startVet)\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    for len(queue) &gt; 0 {\n        // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        vet := queue[0]\n        queue = queue[1:]\n        // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        res = append(res, vet)\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for _, adjVet := range g.adjList[vet] {\n            _, isExist := visited[adjVet]\n            // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            if !isExist {\n                queue = append(queue, adjVet)\n                visited[adjVet] = struct{}{}\n            }\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res\n}\n</code></pre> graph_bfs.swift<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunc graphBFS(graph: GraphAdjList, startVet: Vertex) -&gt; [Vertex] {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    var res: [Vertex] = []\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    var visited: Set&lt;Vertex&gt; = [startVet]\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    var que: [Vertex] = [startVet]\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while !que.isEmpty {\n        let vet = que.removeFirst() // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.append(vet) // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for adjVet in graph.adjList[vet] ?? [] {\n            if visited.contains(adjVet) {\n                continue // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            }\n            que.append(adjVet) // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.insert(adjVet) // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res\n}\n</code></pre> graph_bfs.js<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunction graphBFS(graph, startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    const res = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    const visited = new Set();\n    visited.add(startVet);\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    const que = [startVet];\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (que.length) {\n        const vet = que.shift(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for (const adjVet of graph.adjList.get(vet) ?? []) {\n            if (visited.has(adjVet)) {\n                continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            }\n            que.push(adjVet); // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.add(adjVet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res;\n}\n</code></pre> graph_bfs.ts<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunction graphBFS(graph: GraphAdjList, startVet: Vertex): Vertex[] {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    const res: Vertex[] = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    const visited: Set&lt;Vertex&gt; = new Set();\n    visited.add(startVet);\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    const que = [startVet];\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (que.length) {\n        const vet = que.shift(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for (const adjVet of graph.adjList.get(vet) ?? []) {\n            if (visited.has(adjVet)) {\n                continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            }\n            que.push(adjVet); // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\n            visited.add(adjVet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res;\n}\n</code></pre> graph_bfs.dart<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\nList&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) {\n  // \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n  List&lt;Vertex&gt; res = [];\n  // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n  Set&lt;Vertex&gt; visited = {};\n  visited.add(startVet);\n  // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n  Queue&lt;Vertex&gt; que = Queue();\n  que.add(startVet);\n  // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n  while (que.isNotEmpty) {\n    Vertex vet = que.removeFirst(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n    res.add(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (Vertex adjVet in graph.adjList[vet]!) {\n      if (visited.contains(adjVet)) {\n        continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n      }\n      que.add(adjVet); // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n      visited.add(adjVet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    }\n  }\n  // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n  return res;\n}\n</code></pre> graph_bfs.rs<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfn graph_bfs(graph: GraphAdjList, start_vet: Vertex) -&gt; Vec&lt;Vertex&gt; {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    let mut res = vec![];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    let mut visited = HashSet::new();\n    visited.insert(start_vet);\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    let mut que = VecDeque::new();\n    que.push_back(start_vet);\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while !que.is_empty() {\n        let vet = que.pop_front().unwrap(); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        if let Some(adj_vets) = graph.adj_list.get(&amp;vet) {\n            for &amp;adj_vet in adj_vets {\n                if visited.contains(&amp;adj_vet) {\n                    continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n                }\n                que.push_back(adj_vet); // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n                visited.insert(adj_vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n            }\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    res\n}\n</code></pre> graph_bfs.c<pre><code>/* \u8282\u70b9\u961f\u5217\u7ed3\u6784\u4f53 */\ntypedef struct {\n    Vertex *vertices[MAX_SIZE];\n    int front, rear, size;\n} Queue;\n\n/* \u6784\u9020\u51fd\u6570 */\nQueue *newQueue() {\n    Queue *q = (Queue *)malloc(sizeof(Queue));\n    q-&gt;front = q-&gt;rear = q-&gt;size = 0;\n    return q;\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nint isEmpty(Queue *q) {\n    return q-&gt;size == 0;\n}\n\n/* \u5165\u961f\u64cd\u4f5c */\nvoid enqueue(Queue *q, Vertex *vet) {\n    q-&gt;vertices[q-&gt;rear] = vet;\n    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;\n    q-&gt;size++;\n}\n\n/* \u51fa\u961f\u64cd\u4f5c */\nVertex *dequeue(Queue *q) {\n    Vertex *vet = q-&gt;vertices[q-&gt;front];\n    q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;\n    q-&gt;size--;\n    return vet;\n}\n\n/* \u68c0\u67e5\u9876\u70b9\u662f\u5426\u5df2\u88ab\u8bbf\u95ee */\nint isVisited(Vertex **visited, int size, Vertex *vet) {\n    // \u904d\u5386\u67e5\u627e\u8282\u70b9\uff0c\u4f7f\u7528 O(n) \u65f6\u95f4\n    for (int i = 0; i &lt; size; i++) {\n        if (visited[i] == vet)\n            return 1;\n    }\n    return 0;\n}\n\n/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nvoid graphBFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize, Vertex **visited, int *visitedSize) {\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    Queue *queue = newQueue();\n    enqueue(queue, startVet);\n    visited[(*visitedSize)++] = startVet;\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (!isEmpty(queue)) {\n        Vertex *vet = dequeue(queue); // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res[(*resSize)++] = vet;      // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        AdjListNode *node = findNode(graph, vet);\n        while (node != NULL) {\n            // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            if (!isVisited(visited, *visitedSize, node-&gt;vertex)) {\n                enqueue(queue, node-&gt;vertex);             // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n                visited[(*visitedSize)++] = node-&gt;vertex; // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n            }\n            node = node-&gt;next;\n        }\n    }\n    // \u91ca\u653e\u5185\u5b58\n    free(queue);\n}\n</code></pre> graph_bfs.kt<pre><code>/* \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfun graphBFS(graph: GraphAdjList, startVet: Vertex): MutableList&lt;Vertex?&gt; {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    val res = mutableListOf&lt;Vertex?&gt;()\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    val visited = HashSet&lt;Vertex&gt;()\n    visited.add(startVet)\n    // \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n    val que = LinkedList&lt;Vertex&gt;()\n    que.offer(startVet)\n    // \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n    while (!que.isEmpty()) {\n        val vet = que.poll() // \u961f\u9996\u9876\u70b9\u51fa\u961f\n        res.add(vet)         // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n        // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n        for (adjVet in graph.adjList[vet]!!) {\n            if (visited.contains(adjVet))\n                continue        // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            que.offer(adjVet)   // \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n            visited.add(adjVet) // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n        }\n    }\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res\n}\n</code></pre> graph_bfs.rb<pre><code>### \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 ###\ndef graph_bfs(graph, start_vet)\n  # \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  # \u9876\u70b9\u904d\u5386\u5e8f\u5217\n  res = []\n  # \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n  visited = Set.new([start_vet])\n  # \u961f\u5217\u7528\u4e8e\u5b9e\u73b0 BFS\n  que = [start_vet]\n  # \u4ee5\u9876\u70b9 vet \u4e3a\u8d77\u70b9\uff0c\u5faa\u73af\u76f4\u81f3\u8bbf\u95ee\u5b8c\u6240\u6709\u9876\u70b9\n  while que.length &gt; 0\n    vet = que.shift # \u961f\u9996\u9876\u70b9\u51fa\u961f\n    res &lt;&lt; vet # \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    # \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for adj_vet in graph.adj_list[vet]\n      next if visited.include?(adj_vet) # \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n      que &lt;&lt; adj_vet # \u53ea\u5165\u961f\u672a\u8bbf\u95ee\u7684\u9876\u70b9\n      visited.add(adj_vet) # \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    end\n  end\n  # \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n  res\nend\n</code></pre> graph_bfs.zig<pre><code>[class]{}-[func]{graphBFS}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The code is relatively abstract, it is suggested to compare with Figure 9-10 to deepen the understanding.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-10 \u00a0 Steps of breadth-first search of a graph </p> <p>Is the sequence of breadth-first traversal unique?</p> <p>Not unique. Breadth-first traversal only requires traversing in a \"from near to far\" order, and the traversal order of multiple vertices at the same distance can be arbitrarily shuffled. For example, in Figure 9-10, the visitation order of vertices \\(1\\) and \\(3\\) can be switched, as can the order of vertices \\(2\\), \\(4\\), and \\(6\\).</p>"},{"location":"chapter_graph/graph_traversal/#2-complexity-analysis","title":"2. \u00a0 Complexity analysis","text":"<p>Time complexity: All vertices will be enqueued and dequeued once, using \\(O(|V|)\\) time; in the process of traversing adjacent vertices, since it is an undirected graph, all edges will be visited \\(2\\) times, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The maximum number of vertices in list <code>res</code>, hash table <code>visited</code>, and queue <code>que</code> is \\(|V|\\), using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/graph_traversal/#932-depth-first-search","title":"9.3.2 \u00a0 Depth-first search","text":"<p>Depth-first search is a traversal method that prioritizes going as far as possible and then backtracks when no further paths are available. As shown in Figure 9-11, starting from the top left vertex, visit some adjacent vertex of the current vertex until no further path is available, then return and continue until all vertices are traversed.</p> <p></p> <p> Figure 9-11 \u00a0 Depth-first traversal of a graph </p>"},{"location":"chapter_graph/graph_traversal/#1-algorithm-implementation_1","title":"1. \u00a0 Algorithm implementation","text":"<p>This \"go as far as possible and then return\" algorithm paradigm is usually implemented based on recursion. Similar to breadth-first search, in depth-first search, we also need the help of a hash table <code>visited</code> to record the visited vertices to avoid revisiting.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig graph_dfs.py<pre><code>def dfs(graph: GraphAdjList, visited: set[Vertex], res: list[Vertex], vet: Vertex):\n    \"\"\"\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570\"\"\"\n    res.append(vet)  # \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.add(vet)  # \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    # \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for adjVet in graph.adj_list[vet]:\n        if adjVet in visited:\n            continue  # \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        # \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet)\n\ndef graph_dfs(graph: GraphAdjList, start_vet: Vertex) -&gt; list[Vertex]:\n    \"\"\"\u6df1\u5ea6\u4f18\u5148\u904d\u5386\"\"\"\n    # \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    # \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    res = []\n    # \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    visited = set[Vertex]()\n    dfs(graph, visited, res, start_vet)\n    return res\n</code></pre> graph_dfs.cpp<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nvoid dfs(GraphAdjList &amp;graph, unordered_set&lt;Vertex *&gt; &amp;visited, vector&lt;Vertex *&gt; &amp;res, Vertex *vet) {\n    res.push_back(vet);   // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.emplace(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (Vertex *adjVet : graph.adjList[vet]) {\n        if (visited.count(adjVet))\n            continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nvector&lt;Vertex *&gt; graphDFS(GraphAdjList &amp;graph, Vertex *startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    vector&lt;Vertex *&gt; res;\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    unordered_set&lt;Vertex *&gt; visited;\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.java<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nvoid dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) {\n    res.add(vet);     // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.add(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (Vertex adjVet : graph.adjList.get(vet)) {\n        if (visited.contains(adjVet))\n            continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nList&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.cs<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nvoid DFS(GraphAdjList graph, HashSet&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) {\n    res.Add(vet);     // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.Add(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    foreach (Vertex adjVet in graph.adjList[vet]) {\n        if (visited.Contains(adjVet)) {\n            continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9                             \n        }\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        DFS(graph, visited, res, adjVet);\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nList&lt;Vertex&gt; GraphDFS(GraphAdjList graph, Vertex startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    List&lt;Vertex&gt; res = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    HashSet&lt;Vertex&gt; visited = [];\n    DFS(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.go<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nfunc dfs(g *graphAdjList, visited map[Vertex]struct{}, res *[]Vertex, vet Vertex) {\n    // append \u64cd\u4f5c\u4f1a\u8fd4\u56de\u65b0\u7684\u7684\u5f15\u7528\uff0c\u5fc5\u987b\u8ba9\u539f\u5f15\u7528\u91cd\u65b0\u8d4b\u503c\u4e3a\u65b0slice\u7684\u5f15\u7528\n    *res = append(*res, vet)\n    visited[vet] = struct{}{}\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for _, adjVet := range g.adjList[vet] {\n        _, isExist := visited[adjVet]\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        if !isExist {\n            dfs(g, visited, res, adjVet)\n        }\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunc graphDFS(g *graphAdjList, startVet Vertex) []Vertex {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    res := make([]Vertex, 0)\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    visited := make(map[Vertex]struct{})\n    dfs(g, visited, &amp;res, startVet)\n    // \u8fd4\u56de\u9876\u70b9\u904d\u5386\u5e8f\u5217\n    return res\n}\n</code></pre> graph_dfs.swift<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nfunc dfs(graph: GraphAdjList, visited: inout Set&lt;Vertex&gt;, res: inout [Vertex], vet: Vertex) {\n    res.append(vet) // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.insert(vet) // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for adjVet in graph.adjList[vet] ?? [] {\n        if visited.contains(adjVet) {\n            continue // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        }\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph: graph, visited: &amp;visited, res: &amp;res, vet: adjVet)\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunc graphDFS(graph: GraphAdjList, startVet: Vertex) -&gt; [Vertex] {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    var res: [Vertex] = []\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    var visited: Set&lt;Vertex&gt; = []\n    dfs(graph: graph, visited: &amp;visited, res: &amp;res, vet: startVet)\n    return res\n}\n</code></pre> graph_dfs.js<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunction dfs(graph, visited, res, vet) {\n    res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.add(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (const adjVet of graph.adjList.get(vet)) {\n        if (visited.has(adjVet)) {\n            continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        }\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunction graphDFS(graph, startVet) {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    const res = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    const visited = new Set();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.ts<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nfunction dfs(\n    graph: GraphAdjList,\n    visited: Set&lt;Vertex&gt;,\n    res: Vertex[],\n    vet: Vertex\n): void {\n    res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.add(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (const adjVet of graph.adjList.get(vet)) {\n        if (visited.has(adjVet)) {\n            continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        }\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet);\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfunction graphDFS(graph: GraphAdjList, startVet: Vertex): Vertex[] {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    const res: Vertex[] = [];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    const visited: Set&lt;Vertex&gt; = new Set();\n    dfs(graph, visited, res, startVet);\n    return res;\n}\n</code></pre> graph_dfs.dart<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nvoid dfs(\n  GraphAdjList graph,\n  Set&lt;Vertex&gt; visited,\n  List&lt;Vertex&gt; res,\n  Vertex vet,\n) {\n  res.add(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n  visited.add(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n  // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  for (Vertex adjVet in graph.adjList[vet]!) {\n    if (visited.contains(adjVet)) {\n      continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n    }\n    // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n    dfs(graph, visited, res, adjVet);\n  }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\nList&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) {\n  // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n  List&lt;Vertex&gt; res = [];\n  // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n  Set&lt;Vertex&gt; visited = {};\n  dfs(graph, visited, res, startVet);\n  return res;\n}\n</code></pre> graph_dfs.rs<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nfn dfs(graph: &amp;GraphAdjList, visited: &amp;mut HashSet&lt;Vertex&gt;, res: &amp;mut Vec&lt;Vertex&gt;, vet: Vertex) {\n    res.push(vet); // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.insert(vet); // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n                         // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    if let Some(adj_vets) = graph.adj_list.get(&amp;vet) {\n        for &amp;adj_vet in adj_vets {\n            if visited.contains(&amp;adj_vet) {\n                continue; // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n            }\n            // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n            dfs(graph, visited, res, adj_vet);\n        }\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfn graph_dfs(graph: GraphAdjList, start_vet: Vertex) -&gt; Vec&lt;Vertex&gt; {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    let mut res = vec![];\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    let mut visited = HashSet::new();\n    dfs(&amp;graph, &amp;mut visited, &amp;mut res, start_vet);\n\n    res\n}\n</code></pre> graph_dfs.c<pre><code>/* \u68c0\u67e5\u9876\u70b9\u662f\u5426\u5df2\u88ab\u8bbf\u95ee */\nint isVisited(Vertex **res, int size, Vertex *vet) {\n    // \u904d\u5386\u67e5\u627e\u8282\u70b9\uff0c\u4f7f\u7528 O(n) \u65f6\u95f4\n    for (int i = 0; i &lt; size; i++) {\n        if (res[i] == vet) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nvoid dfs(GraphAdjList *graph, Vertex **res, int *resSize, Vertex *vet) {\n    // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    res[(*resSize)++] = vet;\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    AdjListNode *node = findNode(graph, vet);\n    while (node != NULL) {\n        // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        if (!isVisited(res, *resSize, node-&gt;vertex)) {\n            // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n            dfs(graph, res, resSize, node-&gt;vertex);\n        }\n        node = node-&gt;next;\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nvoid graphDFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize) {\n    dfs(graph, res, resSize, startVet);\n}\n</code></pre> graph_dfs.kt<pre><code>/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 */\nfun dfs(\n    graph: GraphAdjList,\n    visited: MutableSet&lt;Vertex?&gt;,\n    res: MutableList&lt;Vertex?&gt;,\n    vet: Vertex?\n) {\n    res.add(vet)     // \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n    visited.add(vet) // \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n    // \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n    for (adjVet in graph.adjList[vet]!!) {\n        if (visited.contains(adjVet))\n            continue  // \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n        // \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n        dfs(graph, visited, res, adjVet)\n    }\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n// \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\nfun graphDFS(graph: GraphAdjList, startVet: Vertex?): MutableList&lt;Vertex?&gt; {\n    // \u9876\u70b9\u904d\u5386\u5e8f\u5217\n    val res = mutableListOf&lt;Vertex?&gt;()\n    // \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n    val visited = HashSet&lt;Vertex?&gt;()\n    dfs(graph, visited, res, startVet)\n    return res\n}\n</code></pre> graph_dfs.rb<pre><code>### \u6df1\u5ea6\u4f18\u5148\u904d\u5386\u8f85\u52a9\u51fd\u6570 ###\ndef dfs(graph, visited, res, vet)\n  res &lt;&lt; vet # \u8bb0\u5f55\u8bbf\u95ee\u9876\u70b9\n  visited.add(vet) # \u6807\u8bb0\u8be5\u9876\u70b9\u5df2\u88ab\u8bbf\u95ee\n  # \u904d\u5386\u8be5\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  for adj_vet in graph.adj_list[vet]\n    next if visited.include?(adj_vet) # \u8df3\u8fc7\u5df2\u88ab\u8bbf\u95ee\u7684\u9876\u70b9\n    # \u9012\u5f52\u8bbf\u95ee\u90bb\u63a5\u9876\u70b9\n    dfs(graph, visited, res, adj_vet)\n  end\nend\n\n### \u6df1\u5ea6\u4f18\u5148\u904d\u5386 ###\ndef graph_dfs(graph, start_vet)\n  # \u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u4ee5\u4fbf\u83b7\u53d6\u6307\u5b9a\u9876\u70b9\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\n  # \u9876\u70b9\u904d\u5386\u5e8f\u5217\n  res = []\n  # \u54c8\u5e0c\u96c6\u5408\uff0c\u7528\u4e8e\u8bb0\u5f55\u5df2\u88ab\u8bbf\u95ee\u8fc7\u7684\u9876\u70b9\n  visited = Set.new\n  dfs(graph, visited, res, start_vet)\n  res\nend\n</code></pre> graph_dfs.zig<pre><code>[class]{}-[func]{dfs}\n\n[class]{}-[func]{graphDFS}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The algorithm process of depth-first search is shown in Figure 9-12.</p> <ul> <li>Dashed lines represent downward recursion, indicating that a new recursive method has been initiated to visit a new vertex.</li> <li>Curved dashed lines represent upward backtracking, indicating that this recursive method has returned to the position where this method was initiated.</li> </ul> <p>To deepen the understanding, it is suggested to combine Figure 9-12 with the code to simulate (or draw) the entire DFS process in your mind, including when each recursive method is initiated and when it returns.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 9-12 \u00a0 Steps of depth-first search of a graph </p> <p>Is the sequence of depth-first traversal unique?</p> <p>Similar to breadth-first traversal, the order of the depth-first traversal sequence is also not unique. Given a certain vertex, exploring in any direction first is possible, that is, the order of adjacent vertices can be arbitrarily shuffled, all being part of depth-first traversal.</p> <p>Taking tree traversal as an example, \"root \\(\\rightarrow\\) left \\(\\rightarrow\\) right\", \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\", \"left \\(\\rightarrow\\) right \\(\\rightarrow\\) root\" correspond to preorder, inorder, and postorder traversals, respectively. They showcase three types of traversal priorities, yet all three are considered depth-first traversal.</p>"},{"location":"chapter_graph/graph_traversal/#2-complexity-analysis_1","title":"2. \u00a0 Complexity analysis","text":"<p>Time complexity: All vertices will be visited once, using \\(O(|V|)\\) time; all edges will be visited twice, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The maximum number of vertices in list <code>res</code>, hash table <code>visited</code> is \\(|V|\\), and the maximum recursion depth is \\(|V|\\), therefore using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/summary/","title":"9.4 \u00a0 Summary","text":""},{"location":"chapter_graph/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>A graph consists of vertices and edges and can be represented as a set comprising a group of vertices and a group of edges.</li> <li>Compared to linear relationships (linked lists) and divide-and-conquer relationships (trees), network relationships (graphs) have a higher degree of freedom and are therefore more complex.</li> <li>The edges of a directed graph have directionality, any vertex in a connected graph is reachable, and each edge in a weighted graph contains a weight variable.</li> <li>Adjacency matrices use matrices to represent graphs, with each row (column) representing a vertex and matrix elements representing edges, using \\(1\\) or \\(0\\) to indicate the presence or absence of an edge between two vertices. Adjacency matrices are highly efficient for add, delete, find, and modify operations, but they consume more space.</li> <li>Adjacency lists use multiple linked lists to represent graphs, with the \\(i^{th}\\) list corresponding to vertex \\(i\\), containing all its adjacent vertices. Adjacency lists save more space compared to adjacency matrices, but since it is necessary to traverse the list to find edges, their time efficiency is lower.</li> <li>When the linked lists in the adjacency list are too long, they can be converted into red-black trees or hash tables to improve query efficiency.</li> <li>From the perspective of algorithmic thinking, adjacency matrices embody the principle of \"space for time,\" while adjacency lists embody \"time for space.\"</li> <li>Graphs can be used to model various real systems, such as social networks, subway routes, etc.</li> <li>A tree is a special case of a graph, and tree traversal is also a special case of graph traversal.</li> <li>Breadth-first traversal of a graph is a search method that expands layer by layer from near to far, usually implemented with a queue.</li> <li>Depth-first traversal of a graph is a search method that prefers to go as deep as possible and backtracks when no further paths are available, often based on recursion.</li> </ul>"},{"location":"chapter_graph/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is a path defined as a sequence of vertices or a sequence of edges?</p> <p>Definitions vary between different language versions on Wikipedia: the English version defines a path as \"a sequence of edges,\" while the Chinese version defines it as \"a sequence of vertices.\" Here is the original text from the English version: In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices.</p> <p>In this document, a path is considered a sequence of edges, rather than a sequence of vertices. This is because there might be multiple edges connecting two vertices, in which case each edge corresponds to a path.</p> <p>Q: In a disconnected graph, are there points that cannot be traversed to?</p> <p>In a disconnected graph, starting from a certain vertex, there is at least one vertex that cannot be reached. Traversing a disconnected graph requires setting multiple starting points to traverse all connected components of the graph.</p> <p>Q: In an adjacency list, does the order of \"all vertices connected to that vertex\" matter?</p> <p>It can be in any order. However, in practical applications, it might be necessary to sort according to certain rules, such as the order in which vertices are added, or the order of vertex values, etc., to facilitate the quick search for vertices with certain extremal values.</p>"},{"location":"chapter_greedy/","title":"Chapter 15. \u00a0 Greedy","text":"<p>Abstract</p> <p>Sunflowers turn towards the sun, always seeking the greatest possible growth for themselves.</p> <p>Greedy strategy guides to the best answer step by step through rounds of simple choices.</p>"},{"location":"chapter_greedy/#chapter-contents","title":"Chapter contents","text":"<ul> <li>15.1 \u00a0 Greedy algorithms</li> <li>15.2 \u00a0 Fractional knapsack problem</li> <li>15.3 \u00a0 Maximum capacity problem</li> <li>15.4 \u00a0 Maximum product cutting problem</li> <li>15.5 \u00a0 Summary</li> </ul>"},{"location":"chapter_greedy/fractional_knapsack_problem/","title":"15.2 \u00a0 Fractional knapsack problem","text":"<p>Question</p> <p>Given \\(n\\) items, the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with a capacity of \\(cap\\). Each item can be chosen only once, but a part of the item can be selected, with its value calculated based on the proportion of the weight chosen, what is the maximum value of the items in the knapsack under the limited capacity? An example is shown in Figure 15-3.</p> <p></p> <p> Figure 15-3 \u00a0 Example data of the fractional knapsack problem </p> <p>The fractional knapsack problem is very similar overall to the 0-1 knapsack problem, involving the current item \\(i\\) and capacity \\(c\\), aiming to maximize the value within the limited capacity of the knapsack.</p> <p>The difference is that, in this problem, only a part of an item can be chosen. As shown in Figure 15-4, we can arbitrarily split the items and calculate the corresponding value based on the weight proportion.</p> <ol> <li>For item \\(i\\), its value per unit weight is \\(val[i-1] / wgt[i-1]\\), referred to as the unit value.</li> <li>Suppose we put a part of item \\(i\\) with weight \\(w\\) into the knapsack, then the value added to the knapsack is \\(w \\times val[i-1] / wgt[i-1]\\).</li> </ol> <p></p> <p> Figure 15-4 \u00a0 Value per unit weight of the item </p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#1-greedy-strategy-determination","title":"1. \u00a0 Greedy strategy determination","text":"<p>Maximizing the total value of the items in the knapsack essentially means maximizing the value per unit weight. From this, the greedy strategy shown in Figure 15-5 can be deduced.</p> <ol> <li>Sort the items by their unit value from high to low.</li> <li>Iterate over all items, greedily choosing the item with the highest unit value in each round.</li> <li>If the remaining capacity of the knapsack is insufficient, use part of the current item to fill the knapsack.</li> </ol> <p></p> <p> Figure 15-5 \u00a0 Greedy strategy of the fractional knapsack problem </p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"<p>We have created an <code>Item</code> class in order to sort the items by their unit value. We loop and make greedy choices until the knapsack is full, then exit and return the solution:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig fractional_knapsack.py<pre><code>class Item:\n    \"\"\"\u7269\u54c1\"\"\"\n\n    def __init__(self, w: int, v: int):\n        self.w = w  # \u7269\u54c1\u91cd\u91cf\n        self.v = v  # \u7269\u54c1\u4ef7\u503c\n\ndef fractional_knapsack(wgt: list[int], val: list[int], cap: int) -&gt; int:\n    \"\"\"\u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3\"\"\"\n    # \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    items = [Item(w, v) for w, v in zip(wgt, val)]\n    # \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sort(key=lambda item: item.v / item.w, reverse=True)\n    # \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    res = 0\n    for item in items:\n        if item.w &lt;= cap:\n            # \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v\n            cap -= item.w\n        else:\n            # \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (item.v / item.w) * cap\n            # \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break\n    return res\n</code></pre> fractional_knapsack.cpp<pre><code>/* \u7269\u54c1 */\nclass Item {\n  public:\n    int w; // \u7269\u54c1\u91cd\u91cf\n    int v; // \u7269\u54c1\u4ef7\u503c\n\n    Item(int w, int v) : w(w), v(v) {\n    }\n};\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\ndouble fractionalKnapsack(vector&lt;int&gt; &amp;wgt, vector&lt;int&gt; &amp;val, int cap) {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    vector&lt;Item&gt; items;\n    for (int i = 0; i &lt; wgt.size(); i++) {\n        items.push_back(Item(wgt[i], val[i]));\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    sort(items.begin(), items.end(), [](Item &amp;a, Item &amp;b) { return (double)a.v / a.w &gt; (double)b.v / b.w; });\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    double res = 0;\n    for (auto &amp;item : items) {\n        if (item.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (double)item.v / item.w * cap;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.java<pre><code>/* \u7269\u54c1 */\nclass Item {\n    int w; // \u7269\u54c1\u91cd\u91cf\n    int v; // \u7269\u54c1\u4ef7\u503c\n\n    public Item(int w, int v) {\n        this.w = w;\n        this.v = v;\n    }\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\ndouble fractionalKnapsack(int[] wgt, int[] val, int cap) {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    Item[] items = new Item[wgt.length];\n    for (int i = 0; i &lt; wgt.length; i++) {\n        items[i] = new Item(wgt[i], val[i]);\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((double) item.v / item.w)));\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    double res = 0;\n    for (Item item : items) {\n        if (item.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (double) item.v / item.w * cap;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.cs<pre><code>/* \u7269\u54c1 */\nclass Item(int w, int v) {\n    public int w = w; // \u7269\u54c1\u91cd\u91cf\n    public int v = v; // \u7269\u54c1\u4ef7\u503c\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\ndouble FractionalKnapsack(int[] wgt, int[] val, int cap) {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    Item[] items = new Item[wgt.Length];\n    for (int i = 0; i &lt; wgt.Length; i++) {\n        items[i] = new Item(wgt[i], val[i]);\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    Array.Sort(items, (x, y) =&gt; (y.v / y.w).CompareTo(x.v / x.w));\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    double res = 0;\n    foreach (Item item in items) {\n        if (item.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (double)item.v / item.w * cap;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.go<pre><code>/* \u7269\u54c1 */\ntype Item struct {\n    w int // \u7269\u54c1\u91cd\u91cf\n    v int // \u7269\u54c1\u4ef7\u503c\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfunc fractionalKnapsack(wgt []int, val []int, cap int) float64 {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    items := make([]Item, len(wgt))\n    for i := 0; i &lt; len(wgt); i++ {\n        items[i] = Item{wgt[i], val[i]}\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    sort.Slice(items, func(i, j int) bool {\n        return float64(items[i].v)/float64(items[i].w) &gt; float64(items[j].v)/float64(items[j].w)\n    })\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    res := 0.0\n    for _, item := range items {\n        if item.w &lt;= cap {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += float64(item.v)\n            cap -= item.w\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += float64(item.v) / float64(item.w) * float64(cap)\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.swift<pre><code>/* \u7269\u54c1 */\nclass Item {\n    var w: Int // \u7269\u54c1\u91cd\u91cf\n    var v: Int // \u7269\u54c1\u4ef7\u503c\n\n    init(w: Int, v: Int) {\n        self.w = w\n        self.v = v\n    }\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfunc fractionalKnapsack(wgt: [Int], val: [Int], cap: Int) -&gt; Double {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    var items = zip(wgt, val).map { Item(w: $0, v: $1) }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sort { -(Double($0.v) / Double($0.w)) &lt; -(Double($1.v) / Double($1.w)) }\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    var res = 0.0\n    var cap = cap\n    for item in items {\n        if item.w &lt;= cap {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += Double(item.v)\n            cap -= item.w\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += Double(item.v) / Double(item.w) * Double(cap)\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.js<pre><code>/* \u7269\u54c1 */\nclass Item {\n    constructor(w, v) {\n        this.w = w; // \u7269\u54c1\u91cd\u91cf\n        this.v = v; // \u7269\u54c1\u4ef7\u503c\n    }\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfunction fractionalKnapsack(wgt, val, cap) {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    const items = wgt.map((w, i) =&gt; new Item(w, val[i]));\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sort((a, b) =&gt; b.v / b.w - a.v / a.w);\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    let res = 0;\n    for (const item of items) {\n        if (item.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (item.v / item.w) * cap;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.ts<pre><code>/* \u7269\u54c1 */\nclass Item {\n    w: number; // \u7269\u54c1\u91cd\u91cf\n    v: number; // \u7269\u54c1\u4ef7\u503c\n\n    constructor(w: number, v: number) {\n        this.w = w;\n        this.v = v;\n    }\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfunction fractionalKnapsack(wgt: number[], val: number[], cap: number): number {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    const items: Item[] = wgt.map((w, i) =&gt; new Item(w, val[i]));\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sort((a, b) =&gt; b.v / b.w - a.v / a.w);\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    let res = 0;\n    for (const item of items) {\n        if (item.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (item.v / item.w) * cap;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    return res;\n}\n</code></pre> fractional_knapsack.dart<pre><code>/* \u7269\u54c1 */\nclass Item {\n  int w; // \u7269\u54c1\u91cd\u91cf\n  int v; // \u7269\u54c1\u4ef7\u503c\n\n  Item(this.w, this.v);\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\ndouble fractionalKnapsack(List&lt;int&gt; wgt, List&lt;int&gt; val, int cap) {\n  // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n  List&lt;Item&gt; items = List.generate(wgt.length, (i) =&gt; Item(wgt[i], val[i]));\n  // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n  items.sort((a, b) =&gt; (b.v / b.w).compareTo(a.v / a.w));\n  // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n  double res = 0;\n  for (Item item in items) {\n    if (item.w &lt;= cap) {\n      // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n      res += item.v;\n      cap -= item.w;\n    } else {\n      // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n      res += item.v / item.w * cap;\n      // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n      break;\n    }\n  }\n  return res;\n}\n</code></pre> fractional_knapsack.rs<pre><code>/* \u7269\u54c1 */\nstruct Item {\n    w: i32, // \u7269\u54c1\u91cd\u91cf\n    v: i32, // \u7269\u54c1\u4ef7\u503c\n}\n\nimpl Item {\n    fn new(w: i32, v: i32) -&gt; Self {\n        Self { w, v }\n    }\n}\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfn fractional_knapsack(wgt: &amp;[i32], val: &amp;[i32], mut cap: i32) -&gt; f64 {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    let mut items = wgt\n        .iter()\n        .zip(val.iter())\n        .map(|(&amp;w, &amp;v)| Item::new(w, v))\n        .collect::&lt;Vec&lt;Item&gt;&gt;();\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sort_by(|a, b| {\n        (b.v as f64 / b.w as f64)\n            .partial_cmp(&amp;(a.v as f64 / a.w as f64))\n            .unwrap()\n    });\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    let mut res = 0.0;\n    for item in &amp;items {\n        if item.w &lt;= cap {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v as f64;\n            cap -= item.w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += item.v as f64 / item.w as f64 * cap as f64;\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    res\n}\n</code></pre> fractional_knapsack.c<pre><code>/* \u7269\u54c1 */\ntypedef struct {\n    int w; // \u7269\u54c1\u91cd\u91cf\n    int v; // \u7269\u54c1\u4ef7\u503c\n} Item;\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfloat fractionalKnapsack(int wgt[], int val[], int itemCount, int cap) {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    Item *items = malloc(sizeof(Item) * itemCount);\n    for (int i = 0; i &lt; itemCount; i++) {\n        items[i] = (Item){.w = wgt[i], .v = val[i]};\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    qsort(items, (size_t)itemCount, sizeof(Item), sortByValueDensity);\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    float res = 0.0;\n    for (int i = 0; i &lt; itemCount; i++) {\n        if (items[i].w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += items[i].v;\n            cap -= items[i].w;\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += (float)cap / items[i].w * items[i].v;\n            cap = 0;\n            break;\n        }\n    }\n    free(items);\n    return res;\n}\n</code></pre> fractional_knapsack.kt<pre><code>/* \u7269\u54c1 */\nclass Item(\n    val w: Int, // \u7269\u54c1\n    val v: Int  // \u7269\u54c1\u4ef7\u503c\n)\n\n/* \u5206\u6570\u80cc\u5305\uff1a\u8d2a\u5fc3 */\nfun fractionalKnapsack(wgt: IntArray, _val: IntArray, c: Int): Double {\n    // \u521b\u5efa\u7269\u54c1\u5217\u8868\uff0c\u5305\u542b\u4e24\u4e2a\u5c5e\u6027\uff1a\u91cd\u91cf\u3001\u4ef7\u503c\n    var cap = c\n    val items = arrayOfNulls&lt;Item&gt;(wgt.size)\n    for (i in wgt.indices) {\n        items[i] = Item(wgt[i], _val[i])\n    }\n    // \u6309\u7167\u5355\u4f4d\u4ef7\u503c item.v / item.w \u4ece\u9ad8\u5230\u4f4e\u8fdb\u884c\u6392\u5e8f\n    items.sortBy { item: Item? -&gt; -(item!!.v.toDouble() / item.w) }\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\n    var res = 0.0\n    for (item in items) {\n        if (item!!.w &lt;= cap) {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u5145\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u6574\u4e2a\u88c5\u8fdb\u80cc\u5305\n            res += item.v\n            cap -= item.w\n        } else {\n            // \u82e5\u5269\u4f59\u5bb9\u91cf\u4e0d\u8db3\uff0c\u5219\u5c06\u5f53\u524d\u7269\u54c1\u7684\u4e00\u90e8\u5206\u88c5\u8fdb\u80cc\u5305\n            res += item.v.toDouble() / item.w * cap\n            // \u5df2\u65e0\u5269\u4f59\u5bb9\u91cf\uff0c\u56e0\u6b64\u8df3\u51fa\u5faa\u73af\n            break\n        }\n    }\n    return res\n}\n</code></pre> fractional_knapsack.rb<pre><code>[class]{Item}-[func]{}\n\n[class]{}-[func]{fractional_knapsack}\n</code></pre> fractional_knapsack.zig<pre><code>[class]{Item}-[func]{}\n\n[class]{}-[func]{fractionalKnapsack}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Apart from sorting, in the worst case, the entire list of items needs to be traversed, hence the time complexity is \\(O(n)\\), where \\(n\\) is the number of items.</p> <p>Since an <code>Item</code> object list is initialized, the space complexity is \\(O(n)\\).</p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#3-correctness-proof","title":"3. \u00a0 Correctness proof","text":"<p>Using proof by contradiction. Suppose item \\(x\\) has the highest unit value, and some algorithm yields a maximum value <code>res</code>, but the solution does not include item \\(x\\).</p> <p>Now remove a unit weight of any item from the knapsack and replace it with a unit weight of item \\(x\\). Since the unit value of item \\(x\\) is the highest, the total value after replacement will definitely be greater than <code>res</code>. This contradicts the assumption that <code>res</code> is the optimal solution, proving that the optimal solution must include item \\(x\\).</p> <p>For other items in this solution, we can also construct the above contradiction. Overall, items with greater unit value are always better choices, proving that the greedy strategy is effective.</p> <p>As shown in Figure 15-6, if the item weight and unit value are viewed as the horizontal and vertical axes of a two-dimensional chart respectively, the fractional knapsack problem can be transformed into \"seeking the largest area enclosed within a limited horizontal axis range\". This analogy can help us understand the effectiveness of the greedy strategy from a geometric perspective.</p> <p></p> <p> Figure 15-6 \u00a0 Geometric representation of the fractional knapsack problem </p>"},{"location":"chapter_greedy/greedy_algorithm/","title":"15.1 \u00a0 Greedy algorithms","text":"<p>Greedy algorithm is a common algorithm for solving optimization problems, which fundamentally involves making the seemingly best choice at each decision-making stage of the problem, i.e., greedily making locally optimal decisions in hopes of finding a globally optimal solution. Greedy algorithms are concise and efficient, and are widely used in many practical problems.</p> <p>Greedy algorithms and dynamic programming are both commonly used to solve optimization problems. They share some similarities, such as relying on the property of optimal substructure, but they operate differently.</p> <ul> <li>Dynamic programming considers all previous decisions at the current decision stage and uses solutions to past subproblems to construct solutions for the current subproblem.</li> <li>Greedy algorithms do not consider past decisions; instead, they proceed with greedy choices, continually narrowing the scope of the problem until it is solved.</li> </ul> <p>Let's first understand the working principle of the greedy algorithm through the example of \"coin change,\" which has been introduced in the \"Complete Knapsack Problem\" chapter. I believe you are already familiar with it.</p> <p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i\\)th type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\), with each type of coin available indefinitely, what is the minimum number of coins needed to make up the target amount? If it is not possible to make up the target amount, return \\(-1\\).</p> <p>The greedy strategy adopted in this problem is shown in Figure 15-1. Given the target amount, we greedily choose the coin that is closest to and not greater than it, repeatedly following this step until the target amount is met.</p> <p></p> <p> Figure 15-1 \u00a0 Greedy strategy for coin change </p> <p>The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig coin_change_greedy.py<pre><code>def coin_change_greedy(coins: list[int], amt: int) -&gt; int:\n    \"\"\"\u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3\"\"\"\n    # \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    i = len(coins) - 1\n    count = 0\n    # \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while amt &gt; 0:\n        # \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while i &gt; 0 and coins[i] &gt; amt:\n            i -= 1\n        # \u9009\u62e9 coins[i]\n        amt -= coins[i]\n        count += 1\n    # \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return count if amt == 0 else -1\n</code></pre> coin_change_greedy.cpp<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nint coinChangeGreedy(vector&lt;int&gt; &amp;coins, int amt) {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    int i = coins.size() - 1;\n    int count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.java<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nint coinChangeGreedy(int[] coins, int amt) {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    int i = coins.length - 1;\n    int count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.cs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nint CoinChangeGreedy(int[] coins, int amt) {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    int i = coins.Length - 1;\n    int count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.go<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfunc coinChangeGreedy(coins []int, amt int) int {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    i := len(coins) - 1\n    count := 0\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    for amt &gt; 0 {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        for i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i--\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i]\n        count++\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    if amt != 0 {\n        return -1\n    }\n    return count\n}\n</code></pre> coin_change_greedy.swift<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfunc coinChangeGreedy(coins: [Int], amt: Int) -&gt; Int {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    var i = coins.count - 1\n    var count = 0\n    var amt = amt\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while amt &gt; 0 {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i -= 1\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i]\n        count += 1\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt == 0 ? count : -1\n}\n</code></pre> coin_change_greedy.js<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfunction coinChangeGreedy(coins, amt) {\n    // \u5047\u8bbe coins \u6570\u7ec4\u6709\u5e8f\n    let i = coins.length - 1;\n    let count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt === 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.ts<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfunction coinChangeGreedy(coins: number[], amt: number): number {\n    // \u5047\u8bbe coins \u6570\u7ec4\u6709\u5e8f\n    let i = coins.length - 1;\n    let count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt === 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.dart<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nint coinChangeGreedy(List&lt;int&gt; coins, int amt) {\n  // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n  int i = coins.length - 1;\n  int count = 0;\n  // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n  while (amt &gt; 0) {\n    // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n    while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n      i--;\n    }\n    // \u9009\u62e9 coins[i]\n    amt -= coins[i];\n    count++;\n  }\n  // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n  return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.rs<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfn coin_change_greedy(coins: &amp;[i32], mut amt: i32) -&gt; i32 {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    let mut i = coins.len() - 1;\n    let mut count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while amt &gt; 0 {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while i &gt; 0 &amp;&amp; coins[i] &gt; amt {\n            i -= 1;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count += 1;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    if amt == 0 {\n        count\n    } else {\n        -1\n    }\n}\n</code></pre> coin_change_greedy.c<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nint coinChangeGreedy(int *coins, int size, int amt) {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    int i = size - 1;\n    int count = 0;\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (amt &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {\n            i--;\n        }\n        // \u9009\u62e9 coins[i]\n        amt -= coins[i];\n        count++;\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return amt == 0 ? count : -1;\n}\n</code></pre> coin_change_greedy.kt<pre><code>/* \u96f6\u94b1\u5151\u6362\uff1a\u8d2a\u5fc3 */\nfun coinChangeGreedy(coins: IntArray, amt: Int): Int {\n    // \u5047\u8bbe coins \u5217\u8868\u6709\u5e8f\n    var am = amt\n    var i = coins.size - 1\n    var count = 0\n    // \u5faa\u73af\u8fdb\u884c\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u5230\u65e0\u5269\u4f59\u91d1\u989d\n    while (am &gt; 0) {\n        // \u627e\u5230\u5c0f\u4e8e\u4e14\u6700\u63a5\u8fd1\u5269\u4f59\u91d1\u989d\u7684\u786c\u5e01\n        while (i &gt; 0 &amp;&amp; coins[i] &gt; am) {\n            i--\n        }\n        // \u9009\u62e9 coins[i]\n        am -= coins[i]\n        count++\n    }\n    // \u82e5\u672a\u627e\u5230\u53ef\u884c\u65b9\u6848\uff0c\u5219\u8fd4\u56de -1\n    return if (am == 0) count else -1\n}\n</code></pre> coin_change_greedy.rb<pre><code>[class]{}-[func]{coin_change_greedy}\n</code></pre> coin_change_greedy.zig<pre><code>[class]{}-[func]{coinChangeGreedy}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>You might exclaim: So clean! The greedy algorithm solves the coin change problem in about ten lines of code.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1511-advantages-and-limitations-of-greedy-algorithms","title":"15.1.1 \u00a0 Advantages and limitations of greedy algorithms","text":"<p>Greedy algorithms are not only straightforward and simple to implement, but they are also usually very efficient. In the code above, if the smallest coin denomination is \\(\\min(coins)\\), the greedy choice loops at most \\(amt / \\min(coins)\\) times, giving a time complexity of \\(O(amt / \\min(coins))\\). This is an order of magnitude smaller than the time complexity of the dynamic programming solution, which is \\(O(n \\times amt)\\).</p> <p>However, for some combinations of coin denominations, greedy algorithms cannot find the optimal solution. Figure 15-2 provides two examples.</p> <ul> <li>Positive example \\(coins = [1, 5, 10, 20, 50, 100]\\): In this coin combination, given any \\(amt\\), the greedy algorithm can find the optimal solution.</li> <li>Negative example \\(coins = [1, 20, 50]\\): Suppose \\(amt = 60\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 10\\), totaling 11 coins, but dynamic programming can find the optimal solution of \\(20 + 20 + 20\\), needing only 3 coins.</li> <li>Negative example \\(coins = [1, 49, 50]\\): Suppose \\(amt = 98\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 48\\), totaling 49 coins, but dynamic programming can find the optimal solution of \\(49 + 49\\), needing only 2 coins.</li> </ul> <p></p> <p> Figure 15-2 \u00a0 Examples where greedy algorithms do not find the optimal solution </p> <p>This means that for the coin change problem, greedy algorithms cannot guarantee finding the globally optimal solution, and they might find a very poor solution. They are better suited for dynamic programming.</p> <p>Generally, the suitability of greedy algorithms falls into two categories.</p> <ol> <li>Guaranteed to find the optimal solution: In these cases, greedy algorithms are often the best choice, as they tend to be more efficient than backtracking or dynamic programming.</li> <li>Can find a near-optimal solution: Greedy algorithms are also applicable here. For many complex problems, finding the global optimal solution is very challenging, and being able to find a high-efficiency suboptimal solution is also very commendable.</li> </ol>"},{"location":"chapter_greedy/greedy_algorithm/#1512-characteristics-of-greedy-algorithms","title":"15.1.2 \u00a0 Characteristics of greedy algorithms","text":"<p>So, what kind of problems are suitable for solving with greedy algorithms? Or rather, under what conditions can greedy algorithms guarantee to find the optimal solution?</p> <p>Compared to dynamic programming, greedy algorithms have stricter usage conditions, focusing mainly on two properties of the problem.</p> <ul> <li>Greedy choice property: Only when the locally optimal choice can always lead to a globally optimal solution can greedy algorithms guarantee to obtain the optimal solution.</li> <li>Optimal substructure: The optimal solution to the original problem contains the optimal solutions to its subproblems.</li> </ul> <p>Optimal substructure has already been introduced in the \"Dynamic Programming\" chapter, so it is not discussed further here. It's important to note that some problems do not have an obvious optimal substructure, but can still be solved using greedy algorithms.</p> <p>We mainly explore the method for determining the greedy choice property. Although its description seems simple, in practice, proving the greedy choice property for many problems is not easy.</p> <p>For example, in the coin change problem, although we can easily cite counterexamples to disprove the greedy choice property, proving it is much more challenging. If asked, what conditions must a coin combination meet to be solvable using a greedy algorithm? We often have to rely on intuition or examples to provide an ambiguous answer, as it is difficult to provide a rigorous mathematical proof.</p> <p>Quote</p> <p>A paper presents an algorithm with a time complexity of \\(O(n^3)\\) for determining whether a coin combination can use a greedy algorithm to find the optimal solution for any amount.</p> <p>Pearson, D. A polynomial-time algorithm for the change-making problem[J]. Operations Research Letters, 2005, 33(3): 231-234.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1513-steps-for-solving-problems-with-greedy-algorithms","title":"15.1.3 \u00a0 Steps for solving problems with greedy algorithms","text":"<p>The problem-solving process for greedy problems can generally be divided into the following three steps.</p> <ol> <li>Problem analysis: Sort out and understand the characteristics of the problem, including state definition, optimization objectives, and constraints, etc. This step is also involved in backtracking and dynamic programming.</li> <li>Determine the greedy strategy: Determine how to make a greedy choice at each step. This strategy can reduce the scale of the problem at each step and eventually solve the entire problem.</li> <li>Proof of correctness: It is usually necessary to prove that the problem has both a greedy choice property and optimal substructure. This step may require mathematical proofs, such as induction or reductio ad absurdum.</li> </ol> <p>Determining the greedy strategy is the core step in solving the problem, but it may not be easy to implement, mainly for the following reasons.</p> <ul> <li>Greedy strategies vary greatly between different problems. For many problems, the greedy strategy is fairly straightforward, and we can come up with it through some general thinking and attempts. However, for some complex problems, the greedy strategy may be very elusive, which is a real test of individual problem-solving experience and algorithmic capability.</li> <li>Some greedy strategies are quite misleading. When we confidently design a greedy strategy, write the code, and submit it for testing, it is quite possible that some test cases will not pass. This is because the designed greedy strategy is only \"partially correct,\" as described above with the coin change example.</li> </ul> <p>To ensure accuracy, we should provide rigorous mathematical proofs for the greedy strategy, usually involving reductio ad absurdum or mathematical induction.</p> <p>However, proving correctness may not be an easy task. If we are at a loss, we usually choose to debug the code based on test cases, modifying and verifying the greedy strategy step by step.</p>"},{"location":"chapter_greedy/greedy_algorithm/#1514-typical-problems-solved-by-greedy-algorithms","title":"15.1.4 \u00a0 Typical problems solved by greedy algorithms","text":"<p>Greedy algorithms are often applied to optimization problems that satisfy the properties of greedy choice and optimal substructure. Below are some typical greedy algorithm problems.</p> <ul> <li>Coin change problem: In some coin combinations, the greedy algorithm always provides the optimal solution.</li> <li>Interval scheduling problem: Suppose you have several tasks, each of which takes place over a period of time. Your goal is to complete as many tasks as possible. If you always choose the task that ends the earliest, then the greedy algorithm can achieve the optimal solution.</li> <li>Fractional knapsack problem: Given a set of items and a carrying capacity, your goal is to select a set of items such that the total weight does not exceed the carrying capacity and the total value is maximized. If you always choose the item with the highest value-to-weight ratio (value / weight), the greedy algorithm can achieve the optimal solution in some cases.</li> <li>Stock trading problem: Given a set of historical stock prices, you can make multiple trades, but you cannot buy again until after you have sold if you already own stocks. The goal is to achieve the maximum profit.</li> <li>Huffman coding: Huffman coding is a greedy algorithm used for lossless data compression. By constructing a Huffman tree, it always merges the two nodes with the lowest frequency, resulting in a Huffman tree with the minimum weighted path length (coding length).</li> <li>Dijkstra's algorithm: It is a greedy algorithm for solving the shortest path problem from a given source vertex to all other vertices.</li> </ul>"},{"location":"chapter_greedy/max_capacity_problem/","title":"15.3 \u00a0 Maximum capacity problem","text":"<p>Question</p> <p>Input an array \\(ht\\), where each element represents the height of a vertical partition. Any two partitions in the array, along with the space between them, can form a container.</p> <p>The capacity of the container is the product of the height and the width (area), where the height is determined by the shorter partition, and the width is the difference in array indices between the two partitions.</p> <p>Please select two partitions in the array that maximize the container's capacity and return this maximum capacity. An example is shown in Figure 15-7.</p> <p></p> <p> Figure 15-7 \u00a0 Example data for the maximum capacity problem </p> <p>The container is formed by any two partitions, therefore the state of this problem is represented by the indices of the two partitions, denoted as \\([i, j]\\).</p> <p>According to the problem statement, the capacity equals the product of height and width, where the height is determined by the shorter partition, and the width is the difference in array indices between the two partitions. The formula for capacity \\(cap[i, j]\\) is:</p> \\[ cap[i, j] = \\min(ht[i], ht[j]) \\times (j - i) \\] <p>Assuming the length of the array is \\(n\\), the number of combinations of two partitions (total number of states) is \\(C_n^2 = \\frac{n(n - 1)}{2}\\). The most straightforward approach is to enumerate all possible states, resulting in a time complexity of \\(O(n^2)\\).</p>"},{"location":"chapter_greedy/max_capacity_problem/#1-determination-of-a-greedy-strategy","title":"1. \u00a0 Determination of a greedy strategy","text":"<p>There is a more efficient solution to this problem. As shown in Figure 15-8, we select a state \\([i, j]\\) where the indices \\(i &lt; j\\) and the height \\(ht[i] &lt; ht[j]\\), meaning \\(i\\) is the shorter partition, and \\(j\\) is the taller one.</p> <p></p> <p> Figure 15-8 \u00a0 Initial state </p> <p>As shown in Figure 15-9, if we move the taller partition \\(j\\) closer to the shorter partition \\(i\\), the capacity will definitely decrease.</p> <p>This is because when moving the taller partition \\(j\\), the width \\(j-i\\) definitely decreases; and since the height is determined by the shorter partition, the height can only remain the same (if \\(i\\) remains the shorter partition) or decrease (if the moved \\(j\\) becomes the shorter partition).</p> <p></p> <p> Figure 15-9 \u00a0 State after moving the taller partition inward </p> <p>Conversely, we can only possibly increase the capacity by moving the shorter partition \\(i\\) inward. Although the width will definitely decrease, the height may increase (if the moved shorter partition \\(i\\) becomes taller). For example, in Figure 15-10, the area increases after moving the shorter partition.</p> <p></p> <p> Figure 15-10 \u00a0 State after moving the shorter partition inward </p> <p>This leads us to the greedy strategy for this problem: initialize two pointers at the ends of the container, and in each round, move the pointer corresponding to the shorter partition inward until the two pointers meet.</p> <p>Figure 15-11 illustrate the execution of the greedy strategy.</p> <ol> <li>Initially, the pointers \\(i\\) and \\(j\\) are positioned at the ends of the array.</li> <li>Calculate the current state's capacity \\(cap[i, j]\\) and update the maximum capacity.</li> <li>Compare the heights of partitions \\(i\\) and \\(j\\), and move the shorter partition inward by one step.</li> <li>Repeat steps <code>2.</code> and <code>3.</code> until \\(i\\) and \\(j\\) meet.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 15-11 \u00a0 The greedy process for maximum capacity problem </p>"},{"location":"chapter_greedy/max_capacity_problem/#2-implementation","title":"2. \u00a0 Implementation","text":"<p>The code loops at most \\(n\\) times, thus the time complexity is \\(O(n)\\).</p> <p>The variables \\(i\\), \\(j\\), and \\(res\\) use a constant amount of extra space, thus the space complexity is \\(O(1)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig max_capacity.py<pre><code>def max_capacity(ht: list[int]) -&gt; int:\n    \"\"\"\u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3\"\"\"\n    # \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    i, j = 0, len(ht) - 1\n    # \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    res = 0\n    # \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while i &lt; j:\n        # \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        # \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if ht[i] &lt; ht[j]:\n            i += 1\n        else:\n            j -= 1\n    return res\n</code></pre> max_capacity.cpp<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nint maxCapacity(vector&lt;int&gt; &amp;ht) {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    int i = 0, j = ht.size() - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    int res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        int cap = min(ht[i], ht[j]) * (j - i);\n        res = max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.java<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nint maxCapacity(int[] ht) {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    int i = 0, j = ht.length - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    int res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        int cap = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.cs<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nint MaxCapacity(int[] ht) {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    int i = 0, j = ht.Length - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    int res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        int cap = Math.Min(ht[i], ht[j]) * (j - i);\n        res = Math.Max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.go<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfunc maxCapacity(ht []int) int {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    i, j := 0, len(ht)-1\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    res := 0\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    for i &lt; j {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        capacity := int(math.Min(float64(ht[i]), float64(ht[j]))) * (j - i)\n        res = int(math.Max(float64(res), float64(capacity)))\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if ht[i] &lt; ht[j] {\n            i++\n        } else {\n            j--\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.swift<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfunc maxCapacity(ht: [Int]) -&gt; Int {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    var i = ht.startIndex, j = ht.endIndex - 1\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    var res = 0\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while i &lt; j {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        let cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if ht[i] &lt; ht[j] {\n            i += 1\n        } else {\n            j -= 1\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.js<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfunction maxCapacity(ht) {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    let i = 0,\n        j = ht.length - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    let res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        const cap = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.ts<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfunction maxCapacity(ht: number[]): number {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    let i = 0,\n        j = ht.length - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    let res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        const cap: number = Math.min(ht[i], ht[j]) * (j - i);\n        res = Math.max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.dart<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nint maxCapacity(List&lt;int&gt; ht) {\n  // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n  int i = 0, j = ht.length - 1;\n  // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n  int res = 0;\n  // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n  while (i &lt; j) {\n    // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n    int cap = min(ht[i], ht[j]) * (j - i);\n    res = max(res, cap);\n    // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n    if (ht[i] &lt; ht[j]) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return res;\n}\n</code></pre> max_capacity.rs<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfn max_capacity(ht: &amp;[i32]) -&gt; i32 {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    let mut i = 0;\n    let mut j = ht.len() - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    let mut res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while i &lt; j {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        let cap = std::cmp::min(ht[i], ht[j]) * (j - i) as i32;\n        res = std::cmp::max(res, cap);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if ht[i] &lt; ht[j] {\n            i += 1;\n        } else {\n            j -= 1;\n        }\n    }\n    res\n}\n</code></pre> max_capacity.c<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nint maxCapacity(int ht[], int htLength) {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    int i = 0;\n    int j = htLength - 1;\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    int res = 0;\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        int capacity = myMin(ht[i], ht[j]) * (j - i);\n        res = myMax(res, capacity);\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return res;\n}\n</code></pre> max_capacity.kt<pre><code>/* \u6700\u5927\u5bb9\u91cf\uff1a\u8d2a\u5fc3 */\nfun maxCapacity(ht: IntArray): Int {\n    // \u521d\u59cb\u5316 i, j\uff0c\u4f7f\u5176\u5206\u5217\u6570\u7ec4\u4e24\u7aef\n    var i = 0\n    var j = ht.size - 1\n    // \u521d\u59cb\u6700\u5927\u5bb9\u91cf\u4e3a 0\n    var res = 0\n    // \u5faa\u73af\u8d2a\u5fc3\u9009\u62e9\uff0c\u76f4\u81f3\u4e24\u677f\u76f8\u9047\n    while (i &lt; j) {\n        // \u66f4\u65b0\u6700\u5927\u5bb9\u91cf\n        val cap = min(ht[i], ht[j]) * (j - i)\n        res = max(res, cap)\n        // \u5411\u5185\u79fb\u52a8\u77ed\u677f\n        if (ht[i] &lt; ht[j]) {\n            i++\n        } else {\n            j--\n        }\n    }\n    return res\n}\n</code></pre> max_capacity.rb<pre><code>[class]{}-[func]{max_capacity}\n</code></pre> max_capacity.zig<pre><code>[class]{}-[func]{maxCapacity}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_greedy/max_capacity_problem/#3-proof-of-correctness","title":"3. \u00a0 Proof of correctness","text":"<p>The reason why the greedy method is faster than enumeration is that each round of greedy selection \"skips\" some states.</p> <p>For example, under the state \\(cap[i, j]\\) where \\(i\\) is the shorter partition and \\(j\\) is the taller partition, greedily moving the shorter partition \\(i\\) inward by one step leads to the \"skipped\" states shown in Figure 15-12. This means that these states' capacities cannot be verified later.</p> \\[ cap[i, i+1], cap[i, i+2], \\dots, cap[i, j-2], cap[i, j-1] \\] <p></p> <p> Figure 15-12 \u00a0 States skipped by moving the shorter partition </p> <p>It is observed that these skipped states are actually all states where the taller partition \\(j\\) is moved inward. We have already proven that moving the taller partition inward will definitely decrease the capacity. Therefore, the skipped states cannot possibly be the optimal solution, and skipping them does not lead to missing the optimal solution.</p> <p>The analysis shows that the operation of moving the shorter partition is \"safe\", and the greedy strategy is effective.</p>"},{"location":"chapter_greedy/max_product_cutting_problem/","title":"15.4 \u00a0 Maximum product cutting problem","text":"<p>Question</p> <p>Given a positive integer \\(n\\), split it into at least two positive integers that sum up to \\(n\\), and find the maximum product of these integers, as illustrated below.</p> <p></p> <p> Figure 15-13 \u00a0 Definition of the maximum product cutting problem </p> <p>Assume we split \\(n\\) into \\(m\\) integer factors, where the \\(i\\)-th factor is denoted as \\(n_i\\), that is,</p> \\[ n = \\sum_{i=1}^{m}n_i \\] <p>The goal of this problem is to find the maximum product of all integer factors, namely,</p> \\[ \\max(\\prod_{i=1}^{m}n_i) \\] <p>We need to consider: How large should the number of splits \\(m\\) be, and what should each \\(n_i\\) be?</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#1-greedy-strategy-determination","title":"1. \u00a0 Greedy strategy determination","text":"<p>Experience suggests that the product of two integers is often greater than their sum. Suppose we split a factor of \\(2\\) from \\(n\\), then their product is \\(2(n-2)\\). Compare this product with \\(n\\):</p> \\[ \\begin{aligned} 2(n-2) &amp; \\geq n \\newline 2n - n - 4 &amp; \\geq 0 \\newline n &amp; \\geq 4 \\end{aligned} \\] <p>As shown in Figure 15-14, when \\(n \\geq 4\\), splitting out a \\(2\\) increases the product, which indicates that integers greater than or equal to \\(4\\) should be split.</p> <p>Greedy strategy one: If the splitting scheme includes factors \\(\\geq 4\\), they should be further split. The final split should only include factors \\(1\\), \\(2\\), and \\(3\\).</p> <p></p> <p> Figure 15-14 \u00a0 Product increase due to splitting </p> <p>Next, consider which factor is optimal. Among the factors \\(1\\), \\(2\\), and \\(3\\), clearly \\(1\\) is the worst, as \\(1 \\times (n-1) &lt; n\\) always holds, meaning splitting out \\(1\\) actually decreases the product.</p> <p>As shown in Figure 15-15, when \\(n = 6\\), \\(3 \\times 3 &gt; 2 \\times 2 \\times 2\\). This means splitting out \\(3\\) is better than splitting out \\(2\\).</p> <p>Greedy strategy two: In the splitting scheme, there should be at most two \\(2\\)s. Because three \\(2\\)s can always be replaced by two \\(3\\)s to obtain a higher product.</p> <p></p> <p> Figure 15-15 \u00a0 Optimal splitting factors </p> <p>From the above, the following greedy strategies can be derived.</p> <ol> <li>Input integer \\(n\\), continually split out factor \\(3\\) until the remainder is \\(0\\), \\(1\\), or \\(2\\).</li> <li>When the remainder is \\(0\\), it means \\(n\\) is a multiple of \\(3\\), so no further action is taken.</li> <li>When the remainder is \\(2\\), do not continue to split, keep it.</li> <li>When the remainder is \\(1\\), since \\(2 \\times 2 &gt; 1 \\times 3\\), the last \\(3\\) should be replaced with \\(2\\).</li> </ol>"},{"location":"chapter_greedy/max_product_cutting_problem/#2-code-implementation","title":"2. \u00a0 Code implementation","text":"<p>As shown in Figure 15-16, we do not need to use loops to split the integer but can use the floor division operation to get the number of \\(3\\)s, \\(a\\), and the modulo operation to get the remainder, \\(b\\), thus:</p> \\[ n = 3a + b \\] <p>Please note, for the boundary case where \\(n \\leq 3\\), a \\(1\\) must be split out, with a product of \\(1 \\times (n - 1)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig max_product_cutting.py<pre><code>def max_product_cutting(n: int) -&gt; int:\n    \"\"\"\u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3\"\"\"\n    # \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if n &lt;= 3:\n        return 1 * (n - 1)\n    # \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    a, b = n // 3, n % 3\n    if b == 1:\n        # \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return int(math.pow(3, a - 1)) * 2 * 2\n    if b == 2:\n        # \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return int(math.pow(3, a)) * 2\n    # \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return int(math.pow(3, a))\n</code></pre> max_product_cutting.cpp<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nint maxProductCutting(int n) {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return (int)pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return (int)pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return (int)pow(3, a);\n}\n</code></pre> max_product_cutting.java<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nint maxProductCutting(int n) {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return (int) Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return (int) Math.pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return (int) Math.pow(3, a);\n}\n</code></pre> max_product_cutting.cs<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nint MaxProductCutting(int n) {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return (int)Math.Pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return (int)Math.Pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return (int)Math.Pow(3, a);\n}\n</code></pre> max_product_cutting.go<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfunc maxProductCutting(n int) int {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1)\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    a := n / 3\n    b := n % 3\n    if b == 1 {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return int(math.Pow(3, float64(a-1))) * 2 * 2\n    }\n    if b == 2 {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return int(math.Pow(3, float64(a))) * 2\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return int(math.Pow(3, float64(a)))\n}\n</code></pre> max_product_cutting.swift<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfunc maxProductCutting(n: Int) -&gt; Int {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1)\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    let a = n / 3\n    let b = n % 3\n    if b == 1 {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return pow(3, a - 1) * 2 * 2\n    }\n    if b == 2 {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return pow(3, a) * 2\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return pow(3, a)\n}\n</code></pre> max_product_cutting.js<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfunction maxProductCutting(n) {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    let a = Math.floor(n / 3);\n    let b = n % 3;\n    if (b === 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b === 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return Math.pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return Math.pow(3, a);\n}\n</code></pre> max_product_cutting.ts<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfunction maxProductCutting(n: number): number {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    let a: number = Math.floor(n / 3);\n    let b: number = n % 3;\n    if (b === 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return Math.pow(3, a - 1) * 2 * 2;\n    }\n    if (b === 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return Math.pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return Math.pow(3, a);\n}\n</code></pre> max_product_cutting.dart<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nint maxProductCutting(int n) {\n  // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n  if (n &lt;= 3) {\n    return 1 * (n - 1);\n  }\n  // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n  int a = n ~/ 3;\n  int b = n % 3;\n  if (b == 1) {\n    // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n    return (pow(3, a - 1) * 2 * 2).toInt();\n  }\n  if (b == 2) {\n    // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return (pow(3, a) * 2).toInt();\n  }\n  // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n  return pow(3, a).toInt();\n}\n</code></pre> max_product_cutting.rs<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfn max_product_cutting(n: i32) -&gt; i32 {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if n &lt;= 3 {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    let a = n / 3;\n    let b = n % 3;\n    if b == 1 {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        3_i32.pow(a as u32 - 1) * 2 * 2\n    } else if b == 2 {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        3_i32.pow(a as u32) * 2\n    } else {\n        // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        3_i32.pow(a as u32)\n    }\n}\n</code></pre> max_product_cutting.c<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nint maxProductCutting(int n) {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1);\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    int a = n / 3;\n    int b = n % 3;\n    if (b == 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return pow(3, a - 1) * 2 * 2;\n    }\n    if (b == 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return pow(3, a) * 2;\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return pow(3, a);\n}\n</code></pre> max_product_cutting.kt<pre><code>/* \u6700\u5927\u5207\u5206\u4e58\u79ef\uff1a\u8d2a\u5fc3 */\nfun maxProductCutting(n: Int): Int {\n    // \u5f53 n &lt;= 3 \u65f6\uff0c\u5fc5\u987b\u5207\u5206\u51fa\u4e00\u4e2a 1\n    if (n &lt;= 3) {\n        return 1 * (n - 1)\n    }\n    // \u8d2a\u5fc3\u5730\u5207\u5206\u51fa 3 \uff0ca \u4e3a 3 \u7684\u4e2a\u6570\uff0cb \u4e3a\u4f59\u6570\n    val a = n / 3\n    val b = n % 3\n    if (b == 1) {\n        // \u5f53\u4f59\u6570\u4e3a 1 \u65f6\uff0c\u5c06\u4e00\u5bf9 1 * 3 \u8f6c\u5316\u4e3a 2 * 2\n        return 3.0.pow((a - 1)).toInt() * 2 * 2\n    }\n    if (b == 2) {\n        // \u5f53\u4f59\u6570\u4e3a 2 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n        return 3.0.pow(a).toInt() * 2 * 2\n    }\n    // \u5f53\u4f59\u6570\u4e3a 0 \u65f6\uff0c\u4e0d\u505a\u5904\u7406\n    return 3.0.pow(a).toInt()\n}\n</code></pre> max_product_cutting.rb<pre><code>[class]{}-[func]{max_product_cutting}\n</code></pre> max_product_cutting.zig<pre><code>[class]{}-[func]{maxProductCutting}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p></p> <p> Figure 15-16 \u00a0 Calculation method of the maximum product after cutting </p> <p>Time complexity depends on the implementation of the power operation in the programming language. For Python, the commonly used power calculation functions are three types:</p> <ul> <li>Both the operator <code>**</code> and the function <code>pow()</code> have a time complexity of \\(O(\\log\u2061 a)\\).</li> <li>The <code>math.pow()</code> function internally calls the C language library's <code>pow()</code> function, performing floating-point exponentiation, with a time complexity of \\(O(1)\\).</li> </ul> <p>Variables \\(a\\) and \\(b\\) use constant size of extra space, hence the space complexity is \\(O(1)\\).</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#3-correctness-proof","title":"3. \u00a0 Correctness proof","text":"<p>Using the proof by contradiction, only analyze cases where \\(n \\geq 3\\).</p> <ol> <li>All factors \\(\\leq 3\\): Assume the optimal splitting scheme includes a factor \\(x \\geq 4\\), then it can definitely be further split into \\(2(x-2)\\), obtaining a larger product. This contradicts the assumption.</li> <li>The splitting scheme does not contain \\(1\\): Assume the optimal splitting scheme includes a factor of \\(1\\), then it can definitely be merged into another factor to obtain a larger product. This contradicts the assumption.</li> <li>The splitting scheme contains at most two \\(2\\)s: Assume the optimal splitting scheme includes three \\(2\\)s, then they can definitely be replaced by two \\(3\\)s, achieving a higher product. This contradicts the assumption.</li> </ol>"},{"location":"chapter_greedy/summary/","title":"15.5 \u00a0 Summary","text":"<ul> <li>Greedy algorithms are often used to solve optimization problems, where the principle is to make locally optimal decisions at each decision stage in order to achieve a globally optimal solution.</li> <li>Greedy algorithms iteratively make one greedy choice after another, transforming the problem into a smaller sub-problem with each round, until the problem is resolved.</li> <li>Greedy algorithms are not only simple to implement but also have high problem-solving efficiency. Compared to dynamic programming, greedy algorithms generally have a lower time complexity.</li> <li>In the problem of coin change, greedy algorithms can guarantee the optimal solution for certain combinations of coins; for others, however, the greedy algorithm might find a very poor solution.</li> <li>Problems suitable for greedy algorithm solutions possess two main properties: greedy-choice property and optimal substructure. The greedy-choice property represents the effectiveness of the greedy strategy.</li> <li>For some complex problems, proving the greedy-choice property is not straightforward. Contrarily, proving the invalidity is often easier, such as with the coin change problem.</li> <li>Solving greedy problems mainly consists of three steps: problem analysis, determining the greedy strategy, and proving correctness. Among these, determining the greedy strategy is the key step, while proving correctness often poses the challenge.</li> <li>The fractional knapsack problem builds on the 0-1 knapsack problem by allowing the selection of a part of the items, hence it can be solved using a greedy algorithm. The correctness of the greedy strategy can be proved by contradiction.</li> <li>The maximum capacity problem can be solved using the exhaustive method, with a time complexity of \\(O(n^2)\\). By designing a greedy strategy, each round moves inwardly shortening the board, optimizing the time complexity to \\(O(n)\\).</li> <li>In the problem of maximum product after cutting, we deduce two greedy strategies: integers \\(\\geq 4\\) should continue to be cut, with the optimal cutting factor being \\(3\\). The code includes power operations, and the time complexity depends on the method of implementing power operations, generally being \\(O(1)\\) or \\(O(\\log n)\\).</li> </ul>"},{"location":"chapter_hashing/","title":"Chapter 6. \u00a0 Hash table","text":"<p>Abstract</p> <p>In the world of computing, a hash table is akin to an intelligent librarian.</p> <p>It understands how to compute index numbers, enabling swift retrieval of the desired book.</p>"},{"location":"chapter_hashing/#chapter-contents","title":"Chapter contents","text":"<ul> <li>6.1 \u00a0 Hash table</li> <li>6.2 \u00a0 Hash collision</li> <li>6.3 \u00a0 Hash algorithm</li> <li>6.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_hashing/hash_algorithm/","title":"6.3 \u00a0 Hash algorithms","text":"<p>The previous two sections introduced the working principle of hash tables and the methods to handle hash collisions. However, both open addressing and chaining can only ensure that the hash table functions normally when collisions occur, but cannot reduce the frequency of hash collisions.</p> <p>If hash collisions occur too frequently, the performance of the hash table will deteriorate drastically. As shown in Figure 6-8, for a chaining hash table, in the ideal case, the key-value pairs are evenly distributed across the buckets, achieving optimal query efficiency; in the worst case, all key-value pairs are stored in the same bucket, degrading the time complexity to \\(O(n)\\).</p> <p></p> <p> Figure 6-8 \u00a0 Ideal and worst cases of hash collisions </p> <p>The distribution of key-value pairs is determined by the hash function. Recalling the steps of calculating a hash function, first compute the hash value, then modulo it by the array length:</p> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Observing the above formula, when the hash table capacity <code>capacity</code> is fixed, the hash algorithm <code>hash()</code> determines the output value, thereby determining the distribution of key-value pairs in the hash table.</p> <p>This means that, to reduce the probability of hash collisions, we should focus on the design of the hash algorithm <code>hash()</code>.</p>"},{"location":"chapter_hashing/hash_algorithm/#631-goals-of-hash-algorithms","title":"6.3.1 \u00a0 Goals of hash algorithms","text":"<p>To achieve a \"fast and stable\" hash table data structure, hash algorithms should have the following characteristics:</p> <ul> <li>Determinism: For the same input, the hash algorithm should always produce the same output. Only then can the hash table be reliable.</li> <li>High efficiency: The process of computing the hash value should be fast enough. The smaller the computational overhead, the more practical the hash table.</li> <li>Uniform distribution: The hash algorithm should ensure that key-value pairs are evenly distributed in the hash table. The more uniform the distribution, the lower the probability of hash collisions.</li> </ul> <p>In fact, hash algorithms are not only used to implement hash tables but are also widely applied in other fields.</p> <ul> <li>Password storage: To protect the security of user passwords, systems usually do not store the plaintext passwords but rather the hash values of the passwords. When a user enters a password, the system calculates the hash value of the input and compares it with the stored hash value. If they match, the password is considered correct.</li> <li>Data integrity check: The data sender can calculate the hash value of the data and send it along; the receiver can recalculate the hash value of the received data and compare it with the received hash value. If they match, the data is considered intact.</li> </ul> <p>For cryptographic applications, to prevent reverse engineering such as deducing the original password from the hash value, hash algorithms need higher-level security features.</p> <ul> <li>Unidirectionality: It should be impossible to deduce any information about the input data from the hash value.</li> <li>Collision resistance: It should be extremely difficult to find two different inputs that produce the same hash value.</li> <li>Avalanche effect: Minor changes in the input should lead to significant and unpredictable changes in the output.</li> </ul> <p>Note that \"Uniform Distribution\" and \"Collision Resistance\" are two separate concepts. Satisfying uniform distribution does not necessarily mean collision resistance. For example, under random input <code>key</code>, the hash function <code>key % 100</code> can produce a uniformly distributed output. However, this hash algorithm is too simple, and all <code>key</code> with the same last two digits will have the same output, making it easy to deduce a usable <code>key</code> from the hash value, thereby cracking the password.</p>"},{"location":"chapter_hashing/hash_algorithm/#632-design-of-hash-algorithms","title":"6.3.2 \u00a0 Design of hash algorithms","text":"<p>The design of hash algorithms is a complex issue that requires consideration of many factors. However, for some less demanding scenarios, we can also design some simple hash algorithms.</p> <ul> <li>Additive hash: Add up the ASCII codes of each character in the input and use the total sum as the hash value.</li> <li>Multiplicative hash: Utilize the non-correlation of multiplication, multiplying each round by a constant, accumulating the ASCII codes of each character into the hash value.</li> <li>XOR hash: Accumulate the hash value by XORing each element of the input data.</li> <li>Rotating hash: Accumulate the ASCII code of each character into a hash value, performing a rotation operation on the hash value before each accumulation.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig simple_hash.py<pre><code>def add_hash(key: str) -&gt; int:\n    \"\"\"\u52a0\u6cd5\u54c8\u5e0c\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash += ord(c)\n    return hash % modulus\n\ndef mul_hash(key: str) -&gt; int:\n    \"\"\"\u4e58\u6cd5\u54c8\u5e0c\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash = 31 * hash + ord(c)\n    return hash % modulus\n\ndef xor_hash(key: str) -&gt; int:\n    \"\"\"\u5f02\u6216\u54c8\u5e0c\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash ^= ord(c)\n    return hash % modulus\n\ndef rot_hash(key: str) -&gt; int:\n    \"\"\"\u65cb\u8f6c\u54c8\u5e0c\"\"\"\n    hash = 0\n    modulus = 1000000007\n    for c in key:\n        hash = (hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ ord(c)\n    return hash % modulus\n</code></pre> simple_hash.cpp<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nint addHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = (hash + (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nint mulHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = (31 * hash + (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nint xorHash(string key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash ^= (int)c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nint rotHash(string key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (unsigned char c : key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (int)c) % MODULUS;\n    }\n    return (int)hash;\n}\n</code></pre> simple_hash.java<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nint addHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = (hash + (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nint mulHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = (31 * hash + (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nint xorHash(String key) {\n    int hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash ^= (int) c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nint rotHash(String key) {\n    long hash = 0;\n    final int MODULUS = 1000000007;\n    for (char c : key.toCharArray()) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (int) c) % MODULUS;\n    }\n    return (int) hash;\n}\n</code></pre> simple_hash.cs<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nint AddHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = (hash + c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nint MulHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = (31 * hash + c) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nint XorHash(string key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash ^= c;\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nint RotHash(string key) {\n    long hash = 0;\n    const int MODULUS = 1000000007;\n    foreach (char c in key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c) % MODULUS;\n    }\n    return (int)hash;\n}\n</code></pre> simple_hash.go<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfunc addHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = (hash + int64(b)) % modulus\n    }\n    return int(hash)\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfunc mulHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = (31*hash + int64(b)) % modulus\n    }\n    return int(hash)\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfunc xorHash(key string) int {\n    hash := 0\n    modulus := 1000000007\n    for _, b := range []byte(key) {\n        fmt.Println(int(b))\n        hash ^= int(b)\n        hash = (31*hash + int(b)) % modulus\n    }\n    return hash &amp; modulus\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfunc rotHash(key string) int {\n    var hash int64\n    var modulus int64\n\n    modulus = 1000000007\n    for _, b := range []byte(key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ int64(b)) % modulus\n    }\n    return int(hash)\n}\n</code></pre> simple_hash.swift<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfunc addHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = (hash + Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfunc mulHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = (31 * hash + Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfunc xorHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash ^= Int(scalar.value)\n        }\n    }\n    return hash &amp; MODULUS\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfunc rotHash(key: String) -&gt; Int {\n    var hash = 0\n    let MODULUS = 1_000_000_007\n    for c in key {\n        for scalar in c.unicodeScalars {\n            hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ Int(scalar.value)) % MODULUS\n        }\n    }\n    return hash\n}\n</code></pre> simple_hash.js<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfunction addHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfunction mulHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (31 * hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfunction xorHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash ^= c.charCodeAt(0);\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfunction rotHash(key) {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n</code></pre> simple_hash.ts<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfunction addHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfunction mulHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = (31 * hash + c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfunction xorHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash ^= c.charCodeAt(0);\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfunction rotHash(key: string): number {\n    let hash = 0;\n    const MODULUS = 1000000007;\n    for (const c of key) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.charCodeAt(0)) % MODULUS;\n    }\n    return hash;\n}\n</code></pre> simple_hash.dart<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nint addHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = (hash + key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nint mulHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = (31 * hash + key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nint xorHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash ^= key.codeUnitAt(i);\n  }\n  return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nint rotHash(String key) {\n  int hash = 0;\n  final int MODULUS = 1000000007;\n  for (int i = 0; i &lt; key.length; i++) {\n    hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ key.codeUnitAt(i)) % MODULUS;\n  }\n  return hash;\n}\n</code></pre> simple_hash.rs<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfn add_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = (hash + c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfn mul_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = (31 * hash + c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfn xor_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash ^= c as i64;\n    }\n\n    (hash &amp; MODULUS) as i32\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfn rot_hash(key: &amp;str) -&gt; i32 {\n    let mut hash = 0_i64;\n    const MODULUS: i64 = 1000000007;\n\n    for c in key.chars() {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c as i64) % MODULUS;\n    }\n\n    hash as i32\n}\n</code></pre> simple_hash.c<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nint addHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = (hash + (unsigned char)key[i]) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nint mulHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = (31 * hash + (unsigned char)key[i]) % MODULUS;\n    }\n    return (int)hash;\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nint xorHash(char *key) {\n    int hash = 0;\n    const int MODULUS = 1000000007;\n\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash ^= (unsigned char)key[i];\n    }\n    return hash &amp; MODULUS;\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nint rotHash(char *key) {\n    long long hash = 0;\n    const int MODULUS = 1000000007;\n    for (int i = 0; i &lt; strlen(key); i++) {\n        hash = ((hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ (unsigned char)key[i]) % MODULUS;\n    }\n\n    return (int)hash;\n}\n</code></pre> simple_hash.kt<pre><code>/* \u52a0\u6cd5\u54c8\u5e0c */\nfun addHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = (hash + c.code) % MODULUS\n    }\n    return hash.toInt()\n}\n\n/* \u4e58\u6cd5\u54c8\u5e0c */\nfun mulHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = (31 * hash + c.code) % MODULUS\n    }\n    return hash.toInt()\n}\n\n/* \u5f02\u6216\u54c8\u5e0c */\nfun xorHash(key: String): Int {\n    var hash = 0\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = hash xor c.code\n    }\n    return hash and MODULUS\n}\n\n/* \u65cb\u8f6c\u54c8\u5e0c */\nfun rotHash(key: String): Int {\n    var hash = 0L\n    val MODULUS = 1000000007\n    for (c in key.toCharArray()) {\n        hash = ((hash shl 4) xor (hash shr 28) xor c.code.toLong()) % MODULUS\n    }\n    return hash.toInt()\n}\n</code></pre> simple_hash.rb<pre><code>### \u52a0\u6cd5\u54c8\u5e0c ###\ndef add_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash += c.ord }\n\n  hash % modulus\nend\n\n### \u4e58\u6cd5\u54c8\u5e0c ###\ndef mul_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash = 31 * hash + c.ord }\n\n  hash % modulus\nend\n\n### \u5f02\u6216\u54c8\u5e0c ###\ndef xor_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash ^= c.ord }\n\n  hash % modulus\nend\n\n### \u65cb\u8f6c\u54c8\u5e0c ###\ndef rot_hash(key)\n  hash = 0\n  modulus = 1_000_000_007\n\n  key.each_char { |c| hash = (hash &lt;&lt; 4) ^ (hash &gt;&gt; 28) ^ c.ord }\n\n  hash % modulus\nend\n</code></pre> simple_hash.zig<pre><code>[class]{}-[func]{addHash}\n\n[class]{}-[func]{mulHash}\n\n[class]{}-[func]{xorHash}\n\n[class]{}-[func]{rotHash}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>It is observed that the last step of each hash algorithm is to take the modulus of the large prime number \\(1000000007\\) to ensure that the hash value is within an appropriate range. It is worth pondering why emphasis is placed on modulo a prime number, or what are the disadvantages of modulo a composite number? This is an interesting question.</p> <p>To conclude: Using a large prime number as the modulus can maximize the uniform distribution of hash values. Since a prime number does not share common factors with other numbers, it can reduce the periodic patterns caused by the modulo operation, thus avoiding hash collisions.</p> <p>For example, suppose we choose the composite number \\(9\\) as the modulus, which can be divided by \\(3\\), then all <code>key</code> divisible by \\(3\\) will be mapped to hash values \\(0\\), \\(3\\), \\(6\\).</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 9 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 0, 3, 6, 0, 3, 6, 0, 3, 6,\\dots \\} \\end{aligned} \\] <p>If the input <code>key</code> happens to have this kind of arithmetic sequence distribution, then the hash values will cluster, thereby exacerbating hash collisions. Now, suppose we replace <code>modulus</code> with the prime number \\(13\\), since there are no common factors between <code>key</code> and <code>modulus</code>, the uniformity of the output hash values will be significantly improved.</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 13 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 9, 12, 2, 5, 8, 11, 1, 4, 7, \\dots \\} \\end{aligned} \\] <p>It is worth noting that if the <code>key</code> is guaranteed to be randomly and uniformly distributed, then choosing a prime number or a composite number as the modulus can both produce uniformly distributed hash values. However, when the distribution of <code>key</code> has some periodicity, modulo a composite number is more likely to result in clustering.</p> <p>In summary, we usually choose a prime number as the modulus, and this prime number should be large enough to eliminate periodic patterns as much as possible, enhancing the robustness of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_algorithm/#633-common-hash-algorithms","title":"6.3.3 \u00a0 Common hash algorithms","text":"<p>It is not hard to see that the simple hash algorithms mentioned above are quite \"fragile\" and far from reaching the design goals of hash algorithms. For example, since addition and XOR obey the commutative law, additive hash and XOR hash cannot distinguish strings with the same content but in different order, which may exacerbate hash collisions and cause security issues.</p> <p>In practice, we usually use some standard hash algorithms, such as MD5, SHA-1, SHA-2, and SHA-3. They can map input data of any length to a fixed-length hash value.</p> <p>Over the past century, hash algorithms have been in a continuous process of upgrading and optimization. Some researchers strive to improve the performance of hash algorithms, while others, including hackers, are dedicated to finding security issues in hash algorithms. Table 6-2 shows hash algorithms commonly used in practical applications.</p> <ul> <li>MD5 and SHA-1 have been successfully attacked multiple times and are thus abandoned in various security applications.</li> <li>SHA-2 series, especially SHA-256, is one of the most secure hash algorithms to date, with no successful attacks reported, hence commonly used in various security applications and protocols.</li> <li>SHA-3 has lower implementation costs and higher computational efficiency compared to SHA-2, but its current usage coverage is not as extensive as the SHA-2 series.</li> </ul> <p> Table 6-2 \u00a0 Common hash algorithms </p> MD5 SHA-1 SHA-2 SHA-3 Release Year 1992 1995 2002 2008 Output Length 128 bit 160 bit 256/512 bit 224/256/384/512 bit Hash Collisions Frequent Frequent Rare Rare Security Level Low, has been successfully attacked Low, has been successfully attacked High High Applications Abandoned, still used for data integrity checks Abandoned Cryptocurrency transaction verification, digital signatures, etc. Can be used to replace SHA-2"},{"location":"chapter_hashing/hash_algorithm/#hash-values-in-data-structures","title":"Hash values in data structures","text":"<p>We know that the keys in a hash table can be of various data types such as integers, decimals, or strings. Programming languages usually provide built-in hash algorithms for these data types to calculate the bucket indices in the hash table. Taking Python as an example, we can use the <code>hash()</code> function to compute the hash values for various data types.</p> <ul> <li>The hash values of integers and booleans are their own values.</li> <li>The calculation of hash values for floating-point numbers and strings is more complex, and interested readers are encouraged to study this on their own.</li> <li>The hash value of a tuple is a combination of the hash values of each of its elements, resulting in a single hash value.</li> <li>The hash value of an object is generated based on its memory address. By overriding the hash method of an object, hash values can be generated based on content.</li> </ul> <p>Tip</p> <p>Be aware that the definition and methods of the built-in hash value calculation functions in different programming languages vary.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig built_in_hash.py<pre><code>num = 3\nhash_num = hash(num)\n# Hash value of integer 3 is 3\n\nbol = True\nhash_bol = hash(bol)\n# Hash value of boolean True is 1\n\ndec = 3.14159\nhash_dec = hash(dec)\n# Hash value of decimal 3.14159 is 326484311674566659\n\nstr = \"Hello \u7b97\u6cd5\"\nhash_str = hash(str)\n# Hash value of string \"Hello \u7b97\u6cd5\" is 4617003410720528961\n\ntup = (12836, \"\u5c0f\u54c8\")\nhash_tup = hash(tup)\n# Hash value of tuple (12836, '\u5c0f\u54c8') is 1029005403108185979\n\nobj = ListNode(0)\nhash_obj = hash(obj)\n# Hash value of ListNode object at 0x1058fd810 is 274267521\n</code></pre> built_in_hash.cpp<pre><code>int num = 3;\nsize_t hashNum = hash&lt;int&gt;()(num);\n// Hash value of integer 3 is 3\n\nbool bol = true;\nsize_t hashBol = hash&lt;bool&gt;()(bol);\n// Hash value of boolean 1 is 1\n\ndouble dec = 3.14159;\nsize_t hashDec = hash&lt;double&gt;()(dec);\n// Hash value of decimal 3.14159 is 4614256650576692846\n\nstring str = \"Hello \u7b97\u6cd5\";\nsize_t hashStr = hash&lt;string&gt;()(str);\n// Hash value of string \"Hello \u7b97\u6cd5\" is 15466937326284535026\n\n// In C++, built-in std::hash() only provides hash values for basic data types\n// Hash values for arrays and objects need to be implemented separately\n</code></pre> built_in_hash.java<pre><code>int num = 3;\nint hashNum = Integer.hashCode(num);\n// Hash value of integer 3 is 3\n\nboolean bol = true;\nint hashBol = Boolean.hashCode(bol);\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = Double.hashCode(dec);\n// Hash value of decimal 3.14159 is -1340954729\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -727081396\n\nObject[] arr = { 12836, \"\u5c0f\u54c8\" };\nint hashTup = Arrays.hashCode(arr);\n// Hash value of array [12836, \u5c0f\u54c8] is 1151158\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode();\n// Hash value of ListNode object utils.ListNode@7dc5e7b4 is 2110121908\n</code></pre> built_in_hash.cs<pre><code>int num = 3;\nint hashNum = num.GetHashCode();\n// Hash value of integer 3 is 3;\n\nbool bol = true;\nint hashBol = bol.GetHashCode();\n// Hash value of boolean true is 1;\n\ndouble dec = 3.14159;\nint hashDec = dec.GetHashCode();\n// Hash value of decimal 3.14159 is -1340954729;\n\nstring str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.GetHashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -586107568;\n\nobject[] arr = [12836, \"\u5c0f\u54c8\"];\nint hashTup = arr.GetHashCode();\n// Hash value of array [12836, \u5c0f\u54c8] is 42931033;\n\nListNode obj = new(0);\nint hashObj = obj.GetHashCode();\n// Hash value of ListNode object 0 is 39053774;\n</code></pre> built_in_hash.go<pre><code>// Go does not provide built-in hash code functions\n</code></pre> built_in_hash.swift<pre><code>let num = 3\nlet hashNum = num.hashValue\n// Hash value of integer 3 is 9047044699613009734\n\nlet bol = true\nlet hashBol = bol.hashValue\n// Hash value of boolean true is -4431640247352757451\n\nlet dec = 3.14159\nlet hashDec = dec.hashValue\n// Hash value of decimal 3.14159 is -2465384235396674631\n\nlet str = \"Hello \u7b97\u6cd5\"\nlet hashStr = str.hashValue\n// Hash value of string \"Hello \u7b97\u6cd5\" is -7850626797806988787\n\nlet arr = [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")]\nlet hashTup = arr.hashValue\n// Hash value of array [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")] is -2308633508154532996\n\nlet obj = ListNode(x: 0)\nlet hashObj = obj.hashValue\n// Hash value of ListNode object utils.ListNode is -2434780518035996159\n</code></pre> built_in_hash.js<pre><code>// JavaScript does not provide built-in hash code functions\n</code></pre> built_in_hash.ts<pre><code>// TypeScript does not provide built-in hash code functions\n</code></pre> built_in_hash.dart<pre><code>int num = 3;\nint hashNum = num.hashCode;\n// Hash value of integer 3 is 34803\n\nbool bol = true;\nint hashBol = bol.hashCode;\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = dec.hashCode;\n// Hash value of decimal 3.14159 is 2570631074981783\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode;\n// Hash value of string \"Hello \u7b97\u6cd5\" is 468167534\n\nList arr = [12836, \"\u5c0f\u54c8\"];\nint hashArr = arr.hashCode;\n// Hash value of array [12836, \u5c0f\u54c8] is 976512528\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode;\n// Hash value of ListNode object Instance of 'ListNode' is 1033450432\n</code></pre> built_in_hash.rs<pre><code>use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nlet num = 3;\nlet mut num_hasher = DefaultHasher::new();\nnum.hash(&amp;mut num_hasher);\nlet hash_num = num_hasher.finish();\n// Hash value of integer 3 is 568126464209439262\n\nlet bol = true;\nlet mut bol_hasher = DefaultHasher::new();\nbol.hash(&amp;mut bol_hasher);\nlet hash_bol = bol_hasher.finish();\n// Hash value of boolean true is 4952851536318644461\n\nlet dec: f32 = 3.14159;\nlet mut dec_hasher = DefaultHasher::new();\ndec.to_bits().hash(&amp;mut dec_hasher);\nlet hash_dec = dec_hasher.finish();\n// Hash value of decimal 3.14159 is 2566941990314602357\n\nlet str = \"Hello \u7b97\u6cd5\";\nlet mut str_hasher = DefaultHasher::new();\nstr.hash(&amp;mut str_hasher);\nlet hash_str = str_hasher.finish();\n// Hash value of string \"Hello \u7b97\u6cd5\" is 16092673739211250988\n\nlet arr = (&amp;12836, &amp;\"\u5c0f\u54c8\");\nlet mut tup_hasher = DefaultHasher::new();\narr.hash(&amp;mut tup_hasher);\nlet hash_tup = tup_hasher.finish();\n// Hash value of tuple (12836, \"\u5c0f\u54c8\") is 1885128010422702749\n\nlet node = ListNode::new(42);\nlet mut hasher = DefaultHasher::new();\nnode.borrow().val.hash(&amp;mut hasher);\nlet hash = hasher.finish();\n// Hash value of ListNode object RefCell { value: ListNode { val: 42, next: None } } is 15387811073369036852\n</code></pre> built_in_hash.c<pre><code>// C does not provide built-in hash code functions\n</code></pre> built_in_hash.kt<pre><code>\n</code></pre> built_in_hash.zig<pre><code>\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>In many programming languages, only immutable objects can serve as the <code>key</code> in a hash table. If we use a list (dynamic array) as a <code>key</code>, when the contents of the list change, its hash value also changes, and we would no longer be able to find the original <code>value</code> in the hash table.</p> <p>Although the member variables of a custom object (such as a linked list node) are mutable, it is hashable. This is because the hash value of an object is usually generated based on its memory address, and even if the contents of the object change, the memory address remains the same, so the hash value remains unchanged.</p> <p>You might have noticed that the hash values output in different consoles are different. This is because the Python interpreter adds a random salt to the string hash function each time it starts up. This approach effectively prevents HashDoS attacks and enhances the security of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_collision/","title":"6.2 \u00a0 Hash collision","text":"<p>As mentioned in the previous section, usually the input space of a hash function is much larger than its output space, making hash collisions theoretically inevitable. For example, if the input space consists of all integers and the output space is the size of the array capacity, multiple integers will inevitably map to the same bucket index.</p> <p>Hash collisions can lead to incorrect query results, severely affecting the usability of hash tables. To solve this problem, we expand the hash table whenever a hash collision occurs, until the collision is resolved. This method is simple and effective but inefficient due to the extensive data transfer and hash value computation involved in resizing the hash table. To improve efficiency, we can adopt the following strategies:</p> <ol> <li>Improve the data structure of the hash table, allowing it to function normally in the event of a hash collision.</li> <li>Only perform resizing when necessary, i.e., when hash collisions are severe.</li> </ol> <p>There are mainly two methods for improving the structure of hash tables: \"Separate Chaining\" and \"Open Addressing\".</p>"},{"location":"chapter_hashing/hash_collision/#621-separate-chaining","title":"6.2.1 \u00a0 Separate chaining","text":"<p>In the original hash table, each bucket can store only one key-value pair. Separate chaining transforms individual elements into a linked list, with key-value pairs as list nodes, storing all colliding key-value pairs in the same list. Figure 6-5 shows an example of a hash table with separate chaining.</p> <p></p> <p> Figure 6-5 \u00a0 Separate chaining hash table </p> <p>The operations of a hash table implemented with separate chaining have changed as follows:</p> <ul> <li>Querying elements: Input <code>key</code>, pass through the hash function to obtain the bucket index, access the head node of the list, then traverse the list and compare <code>key</code> to find the target key-value pair.</li> <li>Adding elements: First access the list head node via the hash function, then add the node (key-value pair) to the list.</li> <li>Deleting elements: Access the list head based on the hash function's result, then traverse the list to find and remove the target node.</li> </ul> <p>Separate chaining has the following limitations:</p> <ul> <li>Increased space usage: The linked list contains node pointers, which consume more memory space than arrays.</li> <li>Reduced query efficiency: Due to the need for linear traversal of the list to find the corresponding element.</li> </ul> <p>The code below provides a simple implementation of a separate chaining hash table, with two things to note:</p> <ul> <li>Lists (dynamic arrays) are used instead of linked lists for simplicity. In this setup, the hash table (array) contains multiple buckets, each of which is a list.</li> <li>This implementation includes a method for resizing the hash table. When the load factor exceeds \\(\\frac{2}{3}\\), we resize the hash table to twice its original size.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig hash_map_chaining.py<pre><code>class HashMapChaining:\n    \"\"\"\u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self.size = 0  # \u952e\u503c\u5bf9\u6570\u91cf\n        self.capacity = 4  # \u54c8\u5e0c\u8868\u5bb9\u91cf\n        self.load_thres = 2.0 / 3.0  # \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n        self.extend_ratio = 2  # \u6269\u5bb9\u500d\u6570\n        self.buckets = [[] for _ in range(self.capacity)]  # \u6876\u6570\u7ec4\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"\u54c8\u5e0c\u51fd\u6570\"\"\"\n        return key % self.capacity\n\n    def load_factor(self) -&gt; float:\n        \"\"\"\u8d1f\u8f7d\u56e0\u5b50\"\"\"\n        return self.size / self.capacity\n\n    def get(self, key: int) -&gt; str | None:\n        \"\"\"\u67e5\u8be2\u64cd\u4f5c\"\"\"\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for pair in bucket:\n            if pair.key == key:\n                return pair.val\n        # \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de None\n        return None\n\n    def put(self, key: int, val: str):\n        \"\"\"\u6dfb\u52a0\u64cd\u4f5c\"\"\"\n        # \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if self.load_factor() &gt; self.load_thres:\n            self.extend()\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for pair in bucket:\n            if pair.key == key:\n                pair.val = val\n                return\n        # \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        pair = Pair(key, val)\n        bucket.append(pair)\n        self.size += 1\n\n    def remove(self, key: int):\n        \"\"\"\u5220\u9664\u64cd\u4f5c\"\"\"\n        index = self.hash_func(key)\n        bucket = self.buckets[index]\n        # \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for pair in bucket:\n            if pair.key == key:\n                bucket.remove(pair)\n                self.size -= 1\n                break\n\n    def extend(self):\n        \"\"\"\u6269\u5bb9\u54c8\u5e0c\u8868\"\"\"\n        # \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        buckets = self.buckets\n        # \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        self.capacity *= self.extend_ratio\n        self.buckets = [[] for _ in range(self.capacity)]\n        self.size = 0\n        # \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for bucket in buckets:\n            for pair in bucket:\n                self.put(pair.key, pair.val)\n\n    def print(self):\n        \"\"\"\u6253\u5370\u54c8\u5e0c\u8868\"\"\"\n        for bucket in self.buckets:\n            res = []\n            for pair in bucket:\n                res.append(str(pair.key) + \" -&gt; \" + pair.val)\n            print(res)\n</code></pre> hash_map_chaining.cpp<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n  private:\n    int size;                       // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity;                   // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres;               // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio;                // \u6269\u5bb9\u500d\u6570\n    vector&lt;vector&lt;Pair *&gt;&gt; buckets; // \u6876\u6570\u7ec4\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) {\n        buckets.resize(capacity);\n    }\n\n    /* \u6790\u6784\u65b9\u6cd5 */\n    ~HashMapChaining() {\n        for (auto &amp;bucket : buckets) {\n            for (Pair *pair : bucket) {\n                // \u91ca\u653e\u5185\u5b58\n                delete pair;\n            }\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    double loadFactor() {\n        return (double)size / (double)capacity;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    string get(int key) {\n        int index = hashFunc(key);\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for (Pair *pair : buckets[index]) {\n            if (pair-&gt;key == key) {\n                return pair-&gt;val;\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    void put(int key, string val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for (Pair *pair : buckets[index]) {\n            if (pair-&gt;key == key) {\n                pair-&gt;val = val;\n                return;\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        buckets[index].push_back(new Pair(key, val));\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    void remove(int key) {\n        int index = hashFunc(key);\n        auto &amp;bucket = buckets[index];\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (int i = 0; i &lt; bucket.size(); i++) {\n            if (bucket[i]-&gt;key == key) {\n                Pair *tmp = bucket[i];\n                bucket.erase(bucket.begin() + i); // \u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n                delete tmp;                       // \u91ca\u653e\u5185\u5b58\n                size--;\n                return;\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    void extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets.clear();\n        buckets.resize(capacity);\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (auto &amp;bucket : bucketsTmp) {\n            for (Pair *pair : bucket) {\n                put(pair-&gt;key, pair-&gt;val);\n                // \u91ca\u653e\u5185\u5b58\n                delete pair;\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    void print() {\n        for (auto &amp;bucket : buckets) {\n            cout &lt;&lt; \"[\";\n            for (Pair *pair : bucket) {\n                cout &lt;&lt; pair-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; pair-&gt;val &lt;&lt; \", \";\n            }\n            cout &lt;&lt; \"]\\n\";\n        }\n    }\n};\n</code></pre> hash_map_chaining.java<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    int size; // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio; // \u6269\u5bb9\u500d\u6570\n    List&lt;List&lt;Pair&gt;&gt; buckets; // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public HashMapChaining() {\n        size = 0;\n        capacity = 4;\n        loadThres = 2.0 / 3.0;\n        extendRatio = 2;\n        buckets = new ArrayList&lt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.add(new ArrayList&lt;&gt;());\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    double loadFactor() {\n        return (double) size / capacity;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    String get(int key) {\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                return pair.val;\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    void put(int key, String val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        Pair pair = new Pair(key, val);\n        bucket.add(pair);\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    void remove(int key) {\n        int index = hashFunc(key);\n        List&lt;Pair&gt; bucket = buckets.get(index);\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (Pair pair : bucket) {\n            if (pair.key == key) {\n                bucket.remove(pair);\n                size--;\n                break;\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    void extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets = new ArrayList&lt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.add(new ArrayList&lt;&gt;());\n        }\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (List&lt;Pair&gt; bucket : bucketsTmp) {\n            for (Pair pair : bucket) {\n                put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    void print() {\n        for (List&lt;Pair&gt; bucket : buckets) {\n            List&lt;String&gt; res = new ArrayList&lt;&gt;();\n            for (Pair pair : bucket) {\n                res.add(pair.key + \" -&gt; \" + pair.val);\n            }\n            System.out.println(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.cs<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    int size; // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio; // \u6269\u5bb9\u500d\u6570\n    List&lt;List&lt;Pair&gt;&gt; buckets; // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public HashMapChaining() {\n        size = 0;\n        capacity = 4;\n        loadThres = 2.0 / 3.0;\n        extendRatio = 2;\n        buckets = new List&lt;List&lt;Pair&gt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.Add([]);\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int HashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    double LoadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public string? Get(int key) {\n        int index = HashFunc(key);\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        foreach (Pair pair in buckets[index]) {\n            if (pair.key == key) {\n                return pair.val;\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public void Put(int key, string val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (LoadFactor() &gt; loadThres) {\n            Extend();\n        }\n        int index = HashFunc(key);\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        foreach (Pair pair in buckets[index]) {\n            if (pair.key == key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        buckets[index].Add(new Pair(key, val));\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public void Remove(int key) {\n        int index = HashFunc(key);\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        foreach (Pair pair in buckets[index].ToList()) {\n            if (pair.key == key) {\n                buckets[index].Remove(pair);\n                size--;\n                break;\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    void Extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets = new List&lt;List&lt;Pair&gt;&gt;(capacity);\n        for (int i = 0; i &lt; capacity; i++) {\n            buckets.Add([]);\n        }\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        foreach (List&lt;Pair&gt; bucket in bucketsTmp) {\n            foreach (Pair pair in bucket) {\n                Put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public void Print() {\n        foreach (List&lt;Pair&gt; bucket in buckets) {\n            List&lt;string&gt; res = [];\n            foreach (Pair pair in bucket) {\n                res.Add(pair.key + \" -&gt; \" + pair.val);\n            }\n            foreach (string kv in res) {\n                Console.WriteLine(kv);\n            }\n        }\n    }\n}\n</code></pre> hash_map_chaining.go<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\ntype hashMapChaining struct {\n    size        int      // \u952e\u503c\u5bf9\u6570\u91cf\n    capacity    int      // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    loadThres   float64  // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    extendRatio int      // \u6269\u5bb9\u500d\u6570\n    buckets     [][]pair // \u6876\u6570\u7ec4\n}\n\n/* \u6784\u9020\u65b9\u6cd5 */\nfunc newHashMapChaining() *hashMapChaining {\n    buckets := make([][]pair, 4)\n    for i := 0; i &lt; 4; i++ {\n        buckets[i] = make([]pair, 0)\n    }\n    return &amp;hashMapChaining{\n        size:        0,\n        capacity:    4,\n        loadThres:   2.0 / 3.0,\n        extendRatio: 2,\n        buckets:     buckets,\n    }\n}\n\n/* \u54c8\u5e0c\u51fd\u6570 */\nfunc (m *hashMapChaining) hashFunc(key int) int {\n    return key % m.capacity\n}\n\n/* \u8d1f\u8f7d\u56e0\u5b50 */\nfunc (m *hashMapChaining) loadFactor() float64 {\n    return float64(m.size) / float64(m.capacity)\n}\n\n/* \u67e5\u8be2\u64cd\u4f5c */\nfunc (m *hashMapChaining) get(key int) string {\n    idx := m.hashFunc(key)\n    bucket := m.buckets[idx]\n    // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    for _, p := range bucket {\n        if p.key == key {\n            return p.val\n        }\n    }\n    // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    return \"\"\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nfunc (m *hashMapChaining) put(key int, val string) {\n    // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    if m.loadFactor() &gt; m.loadThres {\n        m.extend()\n    }\n    idx := m.hashFunc(key)\n    // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n    for i := range m.buckets[idx] {\n        if m.buckets[idx][i].key == key {\n            m.buckets[idx][i].val = val\n            return\n        }\n    }\n    // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n    p := pair{\n        key: key,\n        val: val,\n    }\n    m.buckets[idx] = append(m.buckets[idx], p)\n    m.size += 1\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nfunc (m *hashMapChaining) remove(key int) {\n    idx := m.hashFunc(key)\n    // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n    for i, p := range m.buckets[idx] {\n        if p.key == key {\n            // \u5207\u7247\u5220\u9664\n            m.buckets[idx] = append(m.buckets[idx][:i], m.buckets[idx][i+1:]...)\n            m.size -= 1\n            break\n        }\n    }\n}\n\n/* \u6269\u5bb9\u54c8\u5e0c\u8868 */\nfunc (m *hashMapChaining) extend() {\n    // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    tmpBuckets := make([][]pair, len(m.buckets))\n    for i := 0; i &lt; len(m.buckets); i++ {\n        tmpBuckets[i] = make([]pair, len(m.buckets[i]))\n        copy(tmpBuckets[i], m.buckets[i])\n    }\n    // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    m.capacity *= m.extendRatio\n    m.buckets = make([][]pair, m.capacity)\n    for i := 0; i &lt; m.capacity; i++ {\n        m.buckets[i] = make([]pair, 0)\n    }\n    m.size = 0\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for _, bucket := range tmpBuckets {\n        for _, p := range bucket {\n            m.put(p.key, p.val)\n        }\n    }\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nfunc (m *hashMapChaining) print() {\n    var builder strings.Builder\n\n    for _, bucket := range m.buckets {\n        builder.WriteString(\"[\")\n        for _, p := range bucket {\n            builder.WriteString(strconv.Itoa(p.key) + \" -&gt; \" + p.val + \" \")\n        }\n        builder.WriteString(\"]\")\n        fmt.Println(builder.String())\n        builder.Reset()\n    }\n}\n</code></pre> hash_map_chaining.swift<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    var size: Int // \u952e\u503c\u5bf9\u6570\u91cf\n    var capacity: Int // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    var loadThres: Double // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    var extendRatio: Int // \u6269\u5bb9\u500d\u6570\n    var buckets: [[Pair]] // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init() {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = Array(repeating: [], count: capacity)\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    func hashFunc(key: Int) -&gt; Int {\n        key % capacity\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    func loadFactor() -&gt; Double {\n        Double(size) / Double(capacity)\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    func get(key: Int) -&gt; String? {\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for pair in bucket {\n            if pair.key == key {\n                return pair.val\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de nil\n        return nil\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    func put(key: Int, val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if loadFactor() &gt; loadThres {\n            extend()\n        }\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for pair in bucket {\n            if pair.key == key {\n                pair.val = val\n                return\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        let pair = Pair(key: key, val: val)\n        buckets[index].append(pair)\n        size += 1\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    func remove(key: Int) {\n        let index = hashFunc(key: key)\n        let bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (pairIndex, pair) in bucket.enumerated() {\n            if pair.key == key {\n                buckets[index].remove(at: pairIndex)\n                size -= 1\n                break\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    func extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        let bucketsTmp = buckets\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio\n        buckets = Array(repeating: [], count: capacity)\n        size = 0\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for bucket in bucketsTmp {\n            for pair in bucket {\n                put(key: pair.key, val: pair.val)\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    func print() {\n        for bucket in buckets {\n            let res = bucket.map { \"\\($0.key) -&gt; \\($0.val)\" }\n            Swift.print(res)\n        }\n    }\n}\n</code></pre> hash_map_chaining.js<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    #size; // \u952e\u503c\u5bf9\u6570\u91cf\n    #capacity; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    #loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    #extendRatio; // \u6269\u5bb9\u500d\u6570\n    #buckets; // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.#size = 0;\n        this.#capacity = 4;\n        this.#loadThres = 2.0 / 3.0;\n        this.#extendRatio = 2;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    #hashFunc(key) {\n        return key % this.#capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    #loadFactor() {\n        return this.#size / this.#capacity;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    get(key) {\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                return pair.val;\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    put(key, val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        const pair = new Pair(key, val);\n        bucket.push(pair);\n        this.#size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    remove(key) {\n        const index = this.#hashFunc(key);\n        let bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (let i = 0; i &lt; bucket.length; i++) {\n            if (bucket[i].key === key) {\n                bucket.splice(i, 1);\n                this.#size--;\n                break;\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    #extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        const bucketsTmp = this.#buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n        this.#size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (const bucket of bucketsTmp) {\n            for (const pair of bucket) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    print() {\n        for (const bucket of this.#buckets) {\n            let res = [];\n            for (const pair of bucket) {\n                res.push(pair.key + ' -&gt; ' + pair.val);\n            }\n            console.log(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.ts<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    #size: number; // \u952e\u503c\u5bf9\u6570\u91cf\n    #capacity: number; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    #loadThres: number; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    #extendRatio: number; // \u6269\u5bb9\u500d\u6570\n    #buckets: Pair[][]; // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.#size = 0;\n        this.#capacity = 4;\n        this.#loadThres = 2.0 / 3.0;\n        this.#extendRatio = 2;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    #hashFunc(key: number): number {\n        return key % this.#capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    #loadFactor(): number {\n        return this.#size / this.#capacity;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    get(key: number): string | null {\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                return pair.val;\n            }\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    put(key: number, val: string): void {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        const index = this.#hashFunc(key);\n        const bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for (const pair of bucket) {\n            if (pair.key === key) {\n                pair.val = val;\n                return;\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        const pair = new Pair(key, val);\n        bucket.push(pair);\n        this.#size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    remove(key: number): void {\n        const index = this.#hashFunc(key);\n        let bucket = this.#buckets[index];\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (let i = 0; i &lt; bucket.length; i++) {\n            if (bucket[i].key === key) {\n                bucket.splice(i, 1);\n                this.#size--;\n                break;\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    #extend(): void {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        const bucketsTmp = this.#buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = new Array(this.#capacity).fill(null).map((x) =&gt; []);\n        this.#size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (const bucket of bucketsTmp) {\n            for (const pair of bucket) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    print(): void {\n        for (const bucket of this.#buckets) {\n            let res = [];\n            for (const pair of bucket) {\n                res.push(pair.key + ' -&gt; ' + pair.val);\n            }\n            console.log(res);\n        }\n    }\n}\n</code></pre> hash_map_chaining.dart<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n  late int size; // \u952e\u503c\u5bf9\u6570\u91cf\n  late int capacity; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n  late double loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n  late int extendRatio; // \u6269\u5bb9\u500d\u6570\n  late List&lt;List&lt;Pair&gt;&gt; buckets; // \u6876\u6570\u7ec4\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  HashMapChaining() {\n    size = 0;\n    capacity = 4;\n    loadThres = 2.0 / 3.0;\n    extendRatio = 2;\n    buckets = List.generate(capacity, (_) =&gt; []);\n  }\n\n  /* \u54c8\u5e0c\u51fd\u6570 */\n  int hashFunc(int key) {\n    return key % capacity;\n  }\n\n  /* \u8d1f\u8f7d\u56e0\u5b50 */\n  double loadFactor() {\n    return size / capacity;\n  }\n\n  /* \u67e5\u8be2\u64cd\u4f5c */\n  String? get(int key) {\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        return pair.val;\n      }\n    }\n    // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n    return null;\n  }\n\n  /* \u6dfb\u52a0\u64cd\u4f5c */\n  void put(int key, String val) {\n    // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    if (loadFactor() &gt; loadThres) {\n      extend();\n    }\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        pair.val = val;\n        return;\n      }\n    }\n    // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n    Pair pair = Pair(key, val);\n    bucket.add(pair);\n    size++;\n  }\n\n  /* \u5220\u9664\u64cd\u4f5c */\n  void remove(int key) {\n    int index = hashFunc(key);\n    List&lt;Pair&gt; bucket = buckets[index];\n    // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n    for (Pair pair in bucket) {\n      if (pair.key == key) {\n        bucket.remove(pair);\n        size--;\n        break;\n      }\n    }\n  }\n\n  /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n  void extend() {\n    // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    List&lt;List&lt;Pair&gt;&gt; bucketsTmp = buckets;\n    // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    capacity *= extendRatio;\n    buckets = List.generate(capacity, (_) =&gt; []);\n    size = 0;\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for (List&lt;Pair&gt; bucket in bucketsTmp) {\n      for (Pair pair in bucket) {\n        put(pair.key, pair.val);\n      }\n    }\n  }\n\n  /* \u6253\u5370\u54c8\u5e0c\u8868 */\n  void printHashMap() {\n    for (List&lt;Pair&gt; bucket in buckets) {\n      List&lt;String&gt; res = [];\n      for (Pair pair in bucket) {\n        res.add(\"${pair.key} -&gt; ${pair.val}\");\n      }\n      print(res);\n    }\n  }\n}\n</code></pre> hash_map_chaining.rs<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nstruct HashMapChaining {\n    size: i32,\n    capacity: i32,\n    load_thres: f32,\n    extend_ratio: i32,\n    buckets: Vec&lt;Vec&lt;Pair&gt;&gt;,\n}\n\nimpl HashMapChaining {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    fn new() -&gt; Self {\n        Self {\n            size: 0,\n            capacity: 4,\n            load_thres: 2.0 / 3.0,\n            extend_ratio: 2,\n            buckets: vec![vec![]; 4],\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        key as usize % self.capacity as usize\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    fn load_factor(&amp;self) -&gt; f32 {\n        self.size as f32 / self.capacity as f32\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    fn remove(&amp;mut self, key: i32) -&gt; Option&lt;String&gt; {\n        let index = self.hash_func(key);\n        let bucket = &amp;mut self.buckets[index];\n\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for i in 0..bucket.len() {\n            if bucket[i].key == key {\n                let pair = bucket.remove(i);\n                self.size -= 1;\n                return Some(pair.val);\n            }\n        }\n\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de None\n        None\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    fn extend(&amp;mut self) {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        let buckets_tmp = std::mem::replace(&amp;mut self.buckets, vec![]);\n\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        self.capacity *= self.extend_ratio;\n        self.buckets = vec![Vec::new(); self.capacity as usize];\n        self.size = 0;\n\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for bucket in buckets_tmp {\n            for pair in bucket {\n                self.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    fn print(&amp;self) {\n        for bucket in &amp;self.buckets {\n            let mut res = Vec::new();\n            for pair in bucket {\n                res.push(format!(\"{} -&gt; {}\", pair.key, pair.val));\n            }\n            println!(\"{:?}\", res);\n        }\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    fn put(&amp;mut self, key: i32, val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if self.load_factor() &gt; self.load_thres {\n            self.extend();\n        }\n\n        let index = self.hash_func(key);\n        let bucket = &amp;mut self.buckets[index];\n\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for pair in bucket {\n            if pair.key == key {\n                pair.val = val;\n                return;\n            }\n        }\n        let bucket = &amp;mut self.buckets[index];\n\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        let pair = Pair { key, val };\n        bucket.push(pair);\n        self.size += 1;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    fn get(&amp;self, key: i32) -&gt; Option&lt;&amp;str&gt; {\n        let index = self.hash_func(key);\n        let bucket = &amp;self.buckets[index];\n\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for pair in bucket {\n            if pair.key == key {\n                return Some(&amp;pair.val);\n            }\n        }\n\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de None\n        None\n    }\n}\n</code></pre> hash_map_chaining.c<pre><code>/* \u94fe\u8868\u8282\u70b9 */\ntypedef struct Node {\n    Pair *pair;\n    struct Node *next;\n} Node;\n\n/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\ntypedef struct {\n    int size;         // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity;     // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio;  // \u6269\u5bb9\u500d\u6570\n    Node **buckets;   // \u6876\u6570\u7ec4\n} HashMapChaining;\n\n/* \u6784\u9020\u51fd\u6570 */\nHashMapChaining *newHashMapChaining() {\n    HashMapChaining *hashMap = (HashMapChaining *)malloc(sizeof(HashMapChaining));\n    hashMap-&gt;size = 0;\n    hashMap-&gt;capacity = 4;\n    hashMap-&gt;loadThres = 2.0 / 3.0;\n    hashMap-&gt;extendRatio = 2;\n    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        hashMap-&gt;buckets[i] = NULL;\n    }\n    return hashMap;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delHashMapChaining(HashMapChaining *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Node *cur = hashMap-&gt;buckets[i];\n        while (cur) {\n            Node *tmp = cur;\n            cur = cur-&gt;next;\n            free(tmp-&gt;pair);\n            free(tmp);\n        }\n    }\n    free(hashMap-&gt;buckets);\n    free(hashMap);\n}\n\n/* \u54c8\u5e0c\u51fd\u6570 */\nint hashFunc(HashMapChaining *hashMap, int key) {\n    return key % hashMap-&gt;capacity;\n}\n\n/* \u8d1f\u8f7d\u56e0\u5b50 */\ndouble loadFactor(HashMapChaining *hashMap) {\n    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;\n}\n\n/* \u67e5\u8be2\u64cd\u4f5c */\nchar *get(HashMapChaining *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    Node *cur = hashMap-&gt;buckets[index];\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            return cur-&gt;pair-&gt;val;\n        }\n        cur = cur-&gt;next;\n    }\n    return \"\"; // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nvoid put(HashMapChaining *hashMap, int key, const char *val) {\n    // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {\n        extend(hashMap);\n    }\n    int index = hashFunc(hashMap, key);\n    // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n    Node *cur = hashMap-&gt;buckets[index];\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            strcpy(cur-&gt;pair-&gt;val, val); // \u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n            return;\n        }\n        cur = cur-&gt;next;\n    }\n    // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n    Pair *newPair = (Pair *)malloc(sizeof(Pair));\n    newPair-&gt;key = key;\n    strcpy(newPair-&gt;val, val);\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode-&gt;pair = newPair;\n    newNode-&gt;next = hashMap-&gt;buckets[index];\n    hashMap-&gt;buckets[index] = newNode;\n    hashMap-&gt;size++;\n}\n\n/* \u6269\u5bb9\u54c8\u5e0c\u8868 */\nvoid extend(HashMapChaining *hashMap) {\n    // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    int oldCapacity = hashMap-&gt;capacity;\n    Node **oldBuckets = hashMap-&gt;buckets;\n    // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;\n    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        hashMap-&gt;buckets[i] = NULL;\n    }\n    hashMap-&gt;size = 0;\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for (int i = 0; i &lt; oldCapacity; i++) {\n        Node *cur = oldBuckets[i];\n        while (cur) {\n            put(hashMap, cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);\n            Node *temp = cur;\n            cur = cur-&gt;next;\n            // \u91ca\u653e\u5185\u5b58\n            free(temp-&gt;pair);\n            free(temp);\n        }\n    }\n\n    free(oldBuckets);\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nvoid removeItem(HashMapChaining *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    Node *cur = hashMap-&gt;buckets[index];\n    Node *pre = NULL;\n    while (cur) {\n        if (cur-&gt;pair-&gt;key == key) {\n            // \u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n            if (pre) {\n                pre-&gt;next = cur-&gt;next;\n            } else {\n                hashMap-&gt;buckets[index] = cur-&gt;next;\n            }\n            // \u91ca\u653e\u5185\u5b58\n            free(cur-&gt;pair);\n            free(cur);\n            hashMap-&gt;size--;\n            return;\n        }\n        pre = cur;\n        cur = cur-&gt;next;\n    }\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nvoid print(HashMapChaining *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Node *cur = hashMap-&gt;buckets[i];\n        printf(\"[\");\n        while (cur) {\n            printf(\"%d -&gt; %s, \", cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);\n            cur = cur-&gt;next;\n        }\n        printf(\"]\\n\");\n    }\n}\n</code></pre> hash_map_chaining.kt<pre><code>/* \u94fe\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 */\nclass HashMapChaining {\n    var size: Int // \u952e\u503c\u5bf9\u6570\u91cf\n    var capacity: Int // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    val loadThres: Double // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    val extendRatio: Int // \u6269\u5bb9\u500d\u6570\n    var buckets: MutableList&lt;MutableList&lt;Pair&gt;&gt; // \u6876\u6570\u7ec4\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = mutableListOf()\n        for (i in 0..&lt;capacity) {\n            buckets.add(mutableListOf())\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fun hashFunc(key: Int): Int {\n        return key % capacity\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    fun loadFactor(): Double {\n        return (size / capacity).toDouble()\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    fun get(key: Int): String? {\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        for (pair in bucket) {\n            if (pair.key == key) return pair._val\n        }\n        // \u82e5\u672a\u627e\u5230 key \uff0c\u5219\u8fd4\u56de null\n        return null\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    fun put(key: Int, _val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend()\n        }\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n        for (pair in bucket) {\n            if (pair.key == key) {\n                pair._val = _val\n                return\n            }\n        }\n        // \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n        val pair = Pair(key, _val)\n        bucket.add(pair)\n        size++\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    fun remove(key: Int) {\n        val index = hashFunc(key)\n        val bucket = buckets[index]\n        // \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n        for (pair in bucket) {\n            if (pair.key == key) {\n                bucket.remove(pair)\n                size--\n                break\n            }\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    fun extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        val bucketsTmp = buckets\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio\n        // mutablelist \u65e0\u56fa\u5b9a\u5927\u5c0f\n        buckets = mutableListOf()\n        for (i in 0..&lt;capacity) {\n            buckets.add(mutableListOf())\n        }\n        size = 0\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (bucket in bucketsTmp) {\n            for (pair in bucket) {\n                put(pair.key, pair._val)\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    fun print() {\n        for (bucket in buckets) {\n            val res = mutableListOf&lt;String&gt;()\n            for (pair in bucket) {\n                val k = pair.key\n                val v = pair._val\n                res.add(\"$k -&gt; $v\")\n            }\n            println(res)\n        }\n    }\n}\n</code></pre> hash_map_chaining.rb<pre><code>### \u952e\u5f0f\u5730\u5740\u54c8\u5e0c\u8868 ###\nclass HashMapChaining\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @size = 0 # \u952e\u503c\u5bf9\u6570\u91cf\n    @capacity = 4 # \u54c8\u5e0c\u8868\u5bb9\u91cf\n    @load_thres = 2.0 / 3.0 # \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    @extend_ratio = 2 # \u6269\u5bb9\u500d\u6570\n    @buckets = Array.new(@capacity) { [] } # \u6876\u6570\u7ec4\n  end\n\n  ### \u54c8\u5e0c\u51fd\u6570 ###\n  def hash_func(key)\n    key % @capacity\n  end\n\n  ### \u8d1f\u8f7d\u56e0\u5b50 ###\n  def load_factor\n    @size / @capacity\n  end\n\n  ### \u67e5\u8be2\u64cd\u4f5c ###\n  def get(key)\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # \u904d\u5386\u6876\uff0c\u82e5\u627e\u5230 key \uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    for pair in bucket\n      return pair.val if pair.key == key\n    end\n    # \u82e5\u672a\u627e\u5230 key , \u5219\u8fd4\u56de nil\n    nil\n  end\n\n  ### \u6dfb\u52a0\u64cd\u4f5c ###\n  def put(key, val)\n    # \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    extend if load_factor &gt; @load_thres\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # \u904d\u5386\u6876\uff0c\u82e5\u9047\u5230\u6307\u5b9a key \uff0c\u5219\u66f4\u65b0\u5bf9\u5e94 val \u5e76\u8fd4\u56de\n    for pair in bucket\n      if pair.key == key\n        pair.val = val\n        return\n      end\n    end\n    # \u82e5\u65e0\u8be5 key \uff0c\u5219\u5c06\u952e\u503c\u5bf9\u6dfb\u52a0\u81f3\u5c3e\u90e8\n    pair = Pair.new(key, val)\n    bucket &lt;&lt; pair\n    @size += 1\n  end\n\n  ### \u5220\u9664\u64cd\u4f5c ###\n  def remove(key)\n    index = hash_func(key)\n    bucket = @buckets[index]\n    # \u904d\u5386\u6876\uff0c\u4ece\u4e2d\u5220\u9664\u952e\u503c\u5bf9\n    for pair in bucket\n      if pair.key == key\n        bucket.delete(pair)\n        @size -= 1\n        break\n      end\n    end\n  end\n\n  ### \u6269\u5bb9\u54c8\u5e0c\u8868 ###\n  def extend\n    # \u66ab\u5b58\u539f\u54c8\u5e0c\u8868\n    buckets = @buckets\n    # \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    @capacity *= @extend_ratio\n    @buckets = Array.new(@capacity) { [] }\n    @size = 0\n    # \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for bucket in buckets\n      for pair in bucket\n        put(pair.key, pair.val)\n      end\n    end\n  end\n\n  ### \u6253\u5370\u54c8\u5e0c\u8868 ###\n  def print\n    for bucket in @buckets\n      res = []\n      for pair in bucket\n        res &lt;&lt; \"#{pair.key} -&gt; #{pair.val}\"\n      end\n      pp res\n    end\n  end\nend\n</code></pre> hash_map_chaining.zig<pre><code>[class]{HashMapChaining}-[func]{}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>It's worth noting that when the list is very long, the query efficiency \\(O(n)\\) is poor. At this point, the list can be converted to an \"AVL tree\" or \"Red-Black tree\" to optimize the time complexity of the query operation to \\(O(\\log n)\\).</p>"},{"location":"chapter_hashing/hash_collision/#622-open-addressing","title":"6.2.2 \u00a0 Open addressing","text":"<p>Open addressing does not introduce additional data structures but uses \"multiple probes\" to handle hash collisions. The probing methods mainly include linear probing, quadratic probing, and double hashing.</p> <p>Let's use linear probing as an example to introduce the mechanism of open addressing hash tables.</p>"},{"location":"chapter_hashing/hash_collision/#1-linear-probing","title":"1. \u00a0 Linear probing","text":"<p>Linear probing uses a fixed-step linear search for probing, differing from ordinary hash tables.</p> <ul> <li>Inserting elements: Calculate the bucket index using the hash function. If the bucket already contains an element, linearly traverse forward from the conflict position (usually with a step size of \\(1\\)) until an empty bucket is found, then insert the element.</li> <li>Searching for elements: If a hash collision is found, use the same step size to linearly traverse forward until the corresponding element is found and return <code>value</code>; if an empty bucket is encountered, it means the target element is not in the hash table, so return <code>None</code>.</li> </ul> <p>Figure 6-6 shows the distribution of key-value pairs in an open addressing (linear probing) hash table. According to this hash function, keys with the same last two digits will be mapped to the same bucket. Through linear probing, they are stored consecutively in that bucket and the buckets below it.</p> <p></p> <p> Figure 6-6 \u00a0 Distribution of key-value pairs in open addressing (linear probing) hash table </p> <p>However, linear probing tends to create \"clustering\". Specifically, the longer a continuous position in the array is occupied, the more likely these positions are to encounter hash collisions, further promoting the growth of these clusters and eventually leading to deterioration in the efficiency of operations.</p> <p>It's important to note that we cannot directly delete elements in an open addressing hash table. Deleting an element creates an empty bucket <code>None</code> in the array. When searching for elements, if linear probing encounters this empty bucket, it will return, making the elements below this bucket inaccessible. The program may incorrectly assume these elements do not exist, as shown in Figure 6-7.</p> <p></p> <p> Figure 6-7 \u00a0 Query issues caused by deletion in open addressing </p> <p>To solve this problem, we can use a lazy deletion mechanism: instead of directly removing elements from the hash table, use a constant <code>TOMBSTONE</code> to mark the bucket. In this mechanism, both <code>None</code> and <code>TOMBSTONE</code> represent empty buckets and can hold key-value pairs. However, when linear probing encounters <code>TOMBSTONE</code>, it should continue traversing since there may still be key-value pairs below it.</p> <p>However, lazy deletion may accelerate the degradation of hash table performance. Every deletion operation produces a delete mark, and as <code>TOMBSTONE</code> increases, so does the search time, as linear probing may have to skip multiple <code>TOMBSTONE</code> to find the target element.</p> <p>Therefore, consider recording the index of the first <code>TOMBSTONE</code> encountered during linear probing and swapping the target element found with this <code>TOMBSTONE</code>. The advantage of this is that each time a query or addition is performed, the element is moved to a bucket closer to the ideal position (starting point of probing), thereby optimizing the query efficiency.</p> <p>The code below implements an open addressing (linear probing) hash table with lazy deletion. To make fuller use of the hash table space, we treat the hash table as a \"circular array,\" continuing to traverse from the beginning when the end of the array is passed.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig hash_map_open_addressing.py<pre><code>class HashMapOpenAddressing:\n    \"\"\"\u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self.size = 0  # \u952e\u503c\u5bf9\u6570\u91cf\n        self.capacity = 4  # \u54c8\u5e0c\u8868\u5bb9\u91cf\n        self.load_thres = 2.0 / 3.0  # \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n        self.extend_ratio = 2  # \u6269\u5bb9\u500d\u6570\n        self.buckets: list[Pair | None] = [None] * self.capacity  # \u6876\u6570\u7ec4\n        self.TOMBSTONE = Pair(-1, \"-1\")  # \u5220\u9664\u6807\u8bb0\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"\u54c8\u5e0c\u51fd\u6570\"\"\"\n        return key % self.capacity\n\n    def load_factor(self) -&gt; float:\n        \"\"\"\u8d1f\u8f7d\u56e0\u5b50\"\"\"\n        return self.size / self.capacity\n\n    def find_bucket(self, key: int) -&gt; int:\n        \"\"\"\u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\"\"\"\n        index = self.hash_func(key)\n        first_tombstone = -1\n        # \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while self.buckets[index] is not None:\n            # \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if self.buckets[index].key == key:\n                # \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if first_tombstone != -1:\n                    self.buckets[first_tombstone] = self.buckets[index]\n                    self.buckets[index] = self.TOMBSTONE\n                    return first_tombstone  # \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                return index  # \u8fd4\u56de\u6876\u7d22\u5f15\n            # \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if first_tombstone == -1 and self.buckets[index] is self.TOMBSTONE:\n                first_tombstone = index\n            # \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % self.capacity\n        # \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return index if first_tombstone == -1 else first_tombstone\n\n    def get(self, key: int) -&gt; str:\n        \"\"\"\u67e5\u8be2\u64cd\u4f5c\"\"\"\n        # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        index = self.find_bucket(key)\n        # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            return self.buckets[index].val\n        # \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de None\n        return None\n\n    def put(self, key: int, val: str):\n        \"\"\"\u6dfb\u52a0\u64cd\u4f5c\"\"\"\n        # \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if self.load_factor() &gt; self.load_thres:\n            self.extend()\n        # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        index = self.find_bucket(key)\n        # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            self.buckets[index].val = val\n            return\n        # \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        self.buckets[index] = Pair(key, val)\n        self.size += 1\n\n    def remove(self, key: int):\n        \"\"\"\u5220\u9664\u64cd\u4f5c\"\"\"\n        # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        index = self.find_bucket(key)\n        # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if self.buckets[index] not in [None, self.TOMBSTONE]:\n            self.buckets[index] = self.TOMBSTONE\n            self.size -= 1\n\n    def extend(self):\n        \"\"\"\u6269\u5bb9\u54c8\u5e0c\u8868\"\"\"\n        # \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        buckets_tmp = self.buckets\n        # \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        self.capacity *= self.extend_ratio\n        self.buckets = [None] * self.capacity\n        self.size = 0\n        # \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for pair in buckets_tmp:\n            if pair not in [None, self.TOMBSTONE]:\n                self.put(pair.key, pair.val)\n\n    def print(self):\n        \"\"\"\u6253\u5370\u54c8\u5e0c\u8868\"\"\"\n        for pair in self.buckets:\n            if pair is None:\n                print(\"None\")\n            elif pair is self.TOMBSTONE:\n                print(\"TOMBSTONE\")\n            else:\n                print(pair.key, \"-&gt;\", pair.val)\n</code></pre> hash_map_open_addressing.cpp<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n  private:\n    int size;                             // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity = 4;                     // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    const double loadThres = 2.0 / 3.0;     // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    const int extendRatio = 2;            // \u6269\u5bb9\u500d\u6570\n    vector&lt;Pair *&gt; buckets;               // \u6876\u6570\u7ec4\n    Pair *TOMBSTONE = new Pair(-1, \"-1\"); // \u5220\u9664\u6807\u8bb0\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    HashMapOpenAddressing() : size(0), buckets(capacity, nullptr) {\n    }\n\n    /* \u6790\u6784\u65b9\u6cd5 */\n    ~HashMapOpenAddressing() {\n        for (Pair *pair : buckets) {\n            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) {\n                delete pair;\n            }\n        }\n        delete TOMBSTONE;\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    double loadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    int findBucket(int key) {\n        int index = hashFunc(key);\n        int firstTombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (buckets[index] != nullptr) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (buckets[index]-&gt;key == key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    string get(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index]-&gt;val;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    void put(int key, string val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index]-&gt;val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    void remove(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (buckets[index] != nullptr &amp;&amp; buckets[index] != TOMBSTONE) {\n            delete buckets[index];\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    void extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        vector&lt;Pair *&gt; bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets = vector&lt;Pair *&gt;(capacity, nullptr);\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (Pair *pair : bucketsTmp) {\n            if (pair != nullptr &amp;&amp; pair != TOMBSTONE) {\n                put(pair-&gt;key, pair-&gt;val);\n                delete pair;\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    void print() {\n        for (Pair *pair : buckets) {\n            if (pair == nullptr) {\n                cout &lt;&lt; \"nullptr\" &lt;&lt; endl;\n            } else if (pair == TOMBSTONE) {\n                cout &lt;&lt; \"TOMBSTONE\" &lt;&lt; endl;\n            } else {\n                cout &lt;&lt; pair-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; pair-&gt;val &lt;&lt; endl;\n            }\n        }\n    }\n};\n</code></pre> hash_map_open_addressing.java<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    private int size; // \u952e\u503c\u5bf9\u6570\u91cf\n    private int capacity = 4; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    private final double loadThres = 2.0 / 3.0; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    private final int extendRatio = 2; // \u6269\u5bb9\u500d\u6570\n    private Pair[] buckets; // \u6876\u6570\u7ec4\n    private final Pair TOMBSTONE = new Pair(-1, \"-1\"); // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public HashMapOpenAddressing() {\n        size = 0;\n        buckets = new Pair[capacity];\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    private int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    private double loadFactor() {\n        return (double) size / capacity;\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    private int findBucket(int key) {\n        int index = hashFunc(key);\n        int firstTombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (buckets[index] != null) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (buckets[index].key == key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public String get(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index].val;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public void put(int key, String val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index].val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public void remove(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    private void extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        Pair[] bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets = new Pair[capacity];\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (Pair pair : bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public void print() {\n        for (Pair pair : buckets) {\n            if (pair == null) {\n                System.out.println(\"null\");\n            } else if (pair == TOMBSTONE) {\n                System.out.println(\"TOMBSTONE\");\n            } else {\n                System.out.println(pair.key + \" -&gt; \" + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.cs<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    int size; // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity = 4; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres = 2.0 / 3.0; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio = 2; // \u6269\u5bb9\u500d\u6570\n    Pair[] buckets; // \u6876\u6570\u7ec4\n    Pair TOMBSTONE = new(-1, \"-1\"); // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public HashMapOpenAddressing() {\n        size = 0;\n        buckets = new Pair[capacity];\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int HashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    double LoadFactor() {\n        return (double)size / capacity;\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    int FindBucket(int key) {\n        int index = HashFunc(key);\n        int firstTombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (buckets[index] != null) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (buckets[index].key == key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index];\n                    buckets[index] = TOMBSTONE;\n                    return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone == -1 ? index : firstTombstone;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public string? Get(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = FindBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index].val;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public void Put(int key, string val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (LoadFactor() &gt; loadThres) {\n            Extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = FindBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index].val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        buckets[index] = new Pair(key, val);\n        size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public void Remove(int key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        int index = FindBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE;\n            size--;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    void Extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        Pair[] bucketsTmp = buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio;\n        buckets = new Pair[capacity];\n        size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        foreach (Pair pair in bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                Put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public void Print() {\n        foreach (Pair pair in buckets) {\n            if (pair == null) {\n                Console.WriteLine(\"null\");\n            } else if (pair == TOMBSTONE) {\n                Console.WriteLine(\"TOMBSTONE\");\n            } else {\n                Console.WriteLine(pair.key + \" -&gt; \" + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.go<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\ntype hashMapOpenAddressing struct {\n    size        int     // \u952e\u503c\u5bf9\u6570\u91cf\n    capacity    int     // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    loadThres   float64 // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    extendRatio int     // \u6269\u5bb9\u500d\u6570\n    buckets     []*pair // \u6876\u6570\u7ec4\n    TOMBSTONE   *pair   // \u5220\u9664\u6807\u8bb0\n}\n\n/* \u6784\u9020\u65b9\u6cd5 */\nfunc newHashMapOpenAddressing() *hashMapOpenAddressing {\n    return &amp;hashMapOpenAddressing{\n        size:        0,\n        capacity:    4,\n        loadThres:   2.0 / 3.0,\n        extendRatio: 2,\n        buckets:     make([]*pair, 4),\n        TOMBSTONE:   &amp;pair{-1, \"-1\"},\n    }\n}\n\n/* \u54c8\u5e0c\u51fd\u6570 */\nfunc (h *hashMapOpenAddressing) hashFunc(key int) int {\n    return key % h.capacity // \u6839\u636e\u952e\u8ba1\u7b97\u54c8\u5e0c\u503c\n}\n\n/* \u8d1f\u8f7d\u56e0\u5b50 */\nfunc (h *hashMapOpenAddressing) loadFactor() float64 {\n    return float64(h.size) / float64(h.capacity) // \u8ba1\u7b97\u5f53\u524d\u8d1f\u8f7d\u56e0\u5b50\n}\n\n/* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\nfunc (h *hashMapOpenAddressing) findBucket(key int) int {\n    index := h.hashFunc(key) // \u83b7\u53d6\u521d\u59cb\u7d22\u5f15\n    firstTombstone := -1     // \u8bb0\u5f55\u9047\u5230\u7684\u7b2c\u4e00\u4e2aTOMBSTONE\u7684\u4f4d\u7f6e\n    for h.buckets[index] != nil {\n        if h.buckets[index].key == key {\n            if firstTombstone != -1 {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                h.buckets[firstTombstone] = h.buckets[index]\n                h.buckets[index] = h.TOMBSTONE\n                return firstTombstone // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n            }\n            return index // \u8fd4\u56de\u627e\u5230\u7684\u7d22\u5f15\n        }\n        if firstTombstone == -1 &amp;&amp; h.buckets[index] == h.TOMBSTONE {\n            firstTombstone = index // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\u7684\u4f4d\u7f6e\n        }\n        index = (index + 1) % h.capacity // \u7ebf\u6027\u63a2\u6d4b\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n    }\n    // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n    if firstTombstone != -1 {\n        return firstTombstone\n    }\n    return index\n}\n\n/* \u67e5\u8be2\u64cd\u4f5c */\nfunc (h *hashMapOpenAddressing) get(key int) string {\n    index := h.findBucket(key) // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    if h.buckets[index] != nil &amp;&amp; h.buckets[index] != h.TOMBSTONE {\n        return h.buckets[index].val // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    }\n    return \"\" // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de \"\"\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nfunc (h *hashMapOpenAddressing) put(key int, val string) {\n    if h.loadFactor() &gt; h.loadThres {\n        h.extend() // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    }\n    index := h.findBucket(key) // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    if h.buckets[index] == nil || h.buckets[index] == h.TOMBSTONE {\n        h.buckets[index] = &amp;pair{key, val} // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        h.size++\n    } else {\n        h.buckets[index].val = val // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val\n    }\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nfunc (h *hashMapOpenAddressing) remove(key int) {\n    index := h.findBucket(key) // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    if h.buckets[index] != nil &amp;&amp; h.buckets[index] != h.TOMBSTONE {\n        h.buckets[index] = h.TOMBSTONE // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        h.size--\n    }\n}\n\n/* \u6269\u5bb9\u54c8\u5e0c\u8868 */\nfunc (h *hashMapOpenAddressing) extend() {\n    oldBuckets := h.buckets               // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    h.capacity *= h.extendRatio           // \u66f4\u65b0\u5bb9\u91cf\n    h.buckets = make([]*pair, h.capacity) // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    h.size = 0                            // \u91cd\u7f6e\u5927\u5c0f\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for _, pair := range oldBuckets {\n        if pair != nil &amp;&amp; pair != h.TOMBSTONE {\n            h.put(pair.key, pair.val)\n        }\n    }\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nfunc (h *hashMapOpenAddressing) print() {\n    for _, pair := range h.buckets {\n        if pair == nil {\n            fmt.Println(\"nil\")\n        } else if pair == h.TOMBSTONE {\n            fmt.Println(\"TOMBSTONE\")\n        } else {\n            fmt.Printf(\"%d -&gt; %s\\n\", pair.key, pair.val)\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.swift<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    var size: Int // \u952e\u503c\u5bf9\u6570\u91cf\n    var capacity: Int // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    var loadThres: Double // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    var extendRatio: Int // \u6269\u5bb9\u500d\u6570\n    var buckets: [Pair?] // \u6876\u6570\u7ec4\n    var TOMBSTONE: Pair // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init() {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = Array(repeating: nil, count: capacity)\n        TOMBSTONE = Pair(key: -1, val: \"-1\")\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    func hashFunc(key: Int) -&gt; Int {\n        key % capacity\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    func loadFactor() -&gt; Double {\n        Double(size) / Double(capacity)\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    func findBucket(key: Int) -&gt; Int {\n        var index = hashFunc(key: key)\n        var firstTombstone = -1\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while buckets[index] != nil {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if buckets[index]!.key == key {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if firstTombstone != -1 {\n                    buckets[firstTombstone] = buckets[index]\n                    buckets[index] = TOMBSTONE\n                    return firstTombstone // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE {\n                firstTombstone = index\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % capacity\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone == -1 ? index : firstTombstone\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    func get(key: Int) -&gt; String? {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = findBucket(key: key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            return buckets[index]!.val\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return nil\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    func put(key: Int, val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if loadFactor() &gt; loadThres {\n            extend()\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = findBucket(key: key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            buckets[index]!.val = val\n            return\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        buckets[index] = Pair(key: key, val: val)\n        size += 1\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    func remove(key: Int) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = findBucket(key: key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if buckets[index] != nil, buckets[index] != TOMBSTONE {\n            buckets[index] = TOMBSTONE\n            size -= 1\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    func extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        let bucketsTmp = buckets\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio\n        buckets = Array(repeating: nil, count: capacity)\n        size = 0\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for pair in bucketsTmp {\n            if let pair, pair != TOMBSTONE {\n                put(key: pair.key, val: pair.val)\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    func print() {\n        for pair in buckets {\n            if pair == nil {\n                Swift.print(\"null\")\n            } else if pair == TOMBSTONE {\n                Swift.print(\"TOMBSTONE\")\n            } else {\n                Swift.print(\"\\(pair!.key) -&gt; \\(pair!.val)\")\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.js<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    #size; // \u952e\u503c\u5bf9\u6570\u91cf\n    #capacity; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    #loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    #extendRatio; // \u6269\u5bb9\u500d\u6570\n    #buckets; // \u6876\u6570\u7ec4\n    #TOMBSTONE; // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.#size = 0; // \u952e\u503c\u5bf9\u6570\u91cf\n        this.#capacity = 4; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n        this.#loadThres = 2.0 / 3.0; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n        this.#extendRatio = 2; // \u6269\u5bb9\u500d\u6570\n        this.#buckets = Array(this.#capacity).fill(null); // \u6876\u6570\u7ec4\n        this.#TOMBSTONE = new Pair(-1, '-1'); // \u5220\u9664\u6807\u8bb0\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    #hashFunc(key) {\n        return key % this.#capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    #loadFactor() {\n        return this.#size / this.#capacity;\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    #findBucket(key) {\n        let index = this.#hashFunc(key);\n        let firstTombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (this.#buckets[index] !== null) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (this.#buckets[index].key === key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone !== -1) {\n                    this.#buckets[firstTombstone] = this.#buckets[index];\n                    this.#buckets[index] = this.#TOMBSTONE;\n                    return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (\n                firstTombstone === -1 &amp;&amp;\n                this.#buckets[index] === this.#TOMBSTONE\n            ) {\n                firstTombstone = index;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % this.#capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone === -1 ? index : firstTombstone;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    get(key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.#findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            return this.#buckets[index].val;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    put(key, val) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (this.#loadFactor() &gt; this.#loadThres) {\n            this.#extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.#findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            this.#buckets[index].val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        this.#buckets[index] = new Pair(key, val);\n        this.#size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    remove(key) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.#findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (\n            this.#buckets[index] !== null &amp;&amp;\n            this.#buckets[index] !== this.#TOMBSTONE\n        ) {\n            this.#buckets[index] = this.#TOMBSTONE;\n            this.#size--;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    #extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        const bucketsTmp = this.#buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        this.#capacity *= this.#extendRatio;\n        this.#buckets = Array(this.#capacity).fill(null);\n        this.#size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (const pair of bucketsTmp) {\n            if (pair !== null &amp;&amp; pair !== this.#TOMBSTONE) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    print() {\n        for (const pair of this.#buckets) {\n            if (pair === null) {\n                console.log('null');\n            } else if (pair === this.#TOMBSTONE) {\n                console.log('TOMBSTONE');\n            } else {\n                console.log(pair.key + ' -&gt; ' + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.ts<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    private size: number; // \u952e\u503c\u5bf9\u6570\u91cf\n    private capacity: number; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    private loadThres: number; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    private extendRatio: number; // \u6269\u5bb9\u500d\u6570\n    private buckets: Array&lt;Pair | null&gt;; // \u6876\u6570\u7ec4\n    private TOMBSTONE: Pair; // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor() {\n        this.size = 0; // \u952e\u503c\u5bf9\u6570\u91cf\n        this.capacity = 4; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n        this.loadThres = 2.0 / 3.0; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n        this.extendRatio = 2; // \u6269\u5bb9\u500d\u6570\n        this.buckets = Array(this.capacity).fill(null); // \u6876\u6570\u7ec4\n        this.TOMBSTONE = new Pair(-1, '-1'); // \u5220\u9664\u6807\u8bb0\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    private hashFunc(key: number): number {\n        return key % this.capacity;\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    private loadFactor(): number {\n        return this.size / this.capacity;\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    private findBucket(key: number): number {\n        let index = this.hashFunc(key);\n        let firstTombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (this.buckets[index] !== null) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (this.buckets[index]!.key === key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone !== -1) {\n                    this.buckets[firstTombstone] = this.buckets[index];\n                    this.buckets[index] = this.TOMBSTONE;\n                    return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (\n                firstTombstone === -1 &amp;&amp;\n                this.buckets[index] === this.TOMBSTONE\n            ) {\n                firstTombstone = index;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % this.capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return firstTombstone === -1 ? index : firstTombstone;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    get(key: number): string | null {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            return this.buckets[index]!.val;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return null;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    put(key: number, val: string): void {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (this.loadFactor() &gt; this.loadThres) {\n            this.extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            this.buckets[index]!.val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        this.buckets[index] = new Pair(key, val);\n        this.size++;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    remove(key: number): void {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        const index = this.findBucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (\n            this.buckets[index] !== null &amp;&amp;\n            this.buckets[index] !== this.TOMBSTONE\n        ) {\n            this.buckets[index] = this.TOMBSTONE;\n            this.size--;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    private extend(): void {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        const bucketsTmp = this.buckets;\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        this.capacity *= this.extendRatio;\n        this.buckets = Array(this.capacity).fill(null);\n        this.size = 0;\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (const pair of bucketsTmp) {\n            if (pair !== null &amp;&amp; pair !== this.TOMBSTONE) {\n                this.put(pair.key, pair.val);\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    print(): void {\n        for (const pair of this.buckets) {\n            if (pair === null) {\n                console.log('null');\n            } else if (pair === this.TOMBSTONE) {\n                console.log('TOMBSTONE');\n            } else {\n                console.log(pair.key + ' -&gt; ' + pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.dart<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n  late int _size; // \u952e\u503c\u5bf9\u6570\u91cf\n  int _capacity = 4; // \u54c8\u5e0c\u8868\u5bb9\u91cf\n  double _loadThres = 2.0 / 3.0; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n  int _extendRatio = 2; // \u6269\u5bb9\u500d\u6570\n  late List&lt;Pair?&gt; _buckets; // \u6876\u6570\u7ec4\n  Pair _TOMBSTONE = Pair(-1, \"-1\"); // \u5220\u9664\u6807\u8bb0\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  HashMapOpenAddressing() {\n    _size = 0;\n    _buckets = List.generate(_capacity, (index) =&gt; null);\n  }\n\n  /* \u54c8\u5e0c\u51fd\u6570 */\n  int hashFunc(int key) {\n    return key % _capacity;\n  }\n\n  /* \u8d1f\u8f7d\u56e0\u5b50 */\n  double loadFactor() {\n    return _size / _capacity;\n  }\n\n  /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n  int findBucket(int key) {\n    int index = hashFunc(key);\n    int firstTombstone = -1;\n    // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n    while (_buckets[index] != null) {\n      // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n      if (_buckets[index]!.key == key) {\n        // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n        if (firstTombstone != -1) {\n          _buckets[firstTombstone] = _buckets[index];\n          _buckets[index] = _TOMBSTONE;\n          return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n        }\n        return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n      }\n      // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n      if (firstTombstone == -1 &amp;&amp; _buckets[index] == _TOMBSTONE) {\n        firstTombstone = index;\n      }\n      // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n      index = (index + 1) % _capacity;\n    }\n    // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n    return firstTombstone == -1 ? index : firstTombstone;\n  }\n\n  /* \u67e5\u8be2\u64cd\u4f5c */\n  String? get(int key) {\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      return _buckets[index]!.val;\n    }\n    // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n    return null;\n  }\n\n  /* \u6dfb\u52a0\u64cd\u4f5c */\n  void put(int key, String val) {\n    // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    if (loadFactor() &gt; _loadThres) {\n      extend();\n    }\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      _buckets[index]!.val = val;\n      return;\n    }\n    // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n    _buckets[index] = new Pair(key, val);\n    _size++;\n  }\n\n  /* \u5220\u9664\u64cd\u4f5c */\n  void remove(int key) {\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n    if (_buckets[index] != null &amp;&amp; _buckets[index] != _TOMBSTONE) {\n      _buckets[index] = _TOMBSTONE;\n      _size--;\n    }\n  }\n\n  /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n  void extend() {\n    // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    List&lt;Pair?&gt; bucketsTmp = _buckets;\n    // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    _capacity *= _extendRatio;\n    _buckets = List.generate(_capacity, (index) =&gt; null);\n    _size = 0;\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for (Pair? pair in bucketsTmp) {\n      if (pair != null &amp;&amp; pair != _TOMBSTONE) {\n        put(pair.key, pair.val);\n      }\n    }\n  }\n\n  /* \u6253\u5370\u54c8\u5e0c\u8868 */\n  void printHashMap() {\n    for (Pair? pair in _buckets) {\n      if (pair == null) {\n        print(\"null\");\n      } else if (pair == _TOMBSTONE) {\n        print(\"TOMBSTONE\");\n      } else {\n        print(\"${pair.key} -&gt; ${pair.val}\");\n      }\n    }\n  }\n}\n</code></pre> hash_map_open_addressing.rs<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nstruct HashMapOpenAddressing {\n    size: usize,                // \u952e\u503c\u5bf9\u6570\u91cf\n    capacity: usize,            // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    load_thres: f64,            // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    extend_ratio: usize,        // \u6269\u5bb9\u500d\u6570\n    buckets: Vec&lt;Option&lt;Pair&gt;&gt;, // \u6876\u6570\u7ec4\n    TOMBSTONE: Option&lt;Pair&gt;,    // \u5220\u9664\u6807\u8bb0\n}\n\nimpl HashMapOpenAddressing {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    fn new() -&gt; Self {\n        Self {\n            size: 0,\n            capacity: 4,\n            load_thres: 2.0 / 3.0,\n            extend_ratio: 2,\n            buckets: vec![None; 4],\n            TOMBSTONE: Some(Pair {\n                key: -1,\n                val: \"-1\".to_string(),\n            }),\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        (key % self.capacity as i32) as usize\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    fn load_factor(&amp;self) -&gt; f64 {\n        self.size as f64 / self.capacity as f64\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    fn find_bucket(&amp;mut self, key: i32) -&gt; usize {\n        let mut index = self.hash_func(key);\n        let mut first_tombstone = -1;\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while self.buckets[index].is_some() {\n            // \u82e5\u9047\u5230 key\uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if self.buckets[index].as_ref().unwrap().key == key {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u5efa\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\n                if first_tombstone != -1 {\n                    self.buckets[first_tombstone as usize] = self.buckets[index].take();\n                    self.buckets[index] = self.TOMBSTONE.clone();\n                    return first_tombstone as usize; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if first_tombstone == -1 &amp;&amp; self.buckets[index] == self.TOMBSTONE {\n                first_tombstone = index as i32;\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % self.capacity;\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        if first_tombstone == -1 {\n            index\n        } else {\n            first_tombstone as usize\n        }\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    fn get(&amp;mut self, key: i32) -&gt; Option&lt;&amp;str&gt; {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = self.find_bucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            return self.buckets[index].as_ref().map(|pair| &amp;pair.val as &amp;str);\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        None\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    fn put(&amp;mut self, key: i32, val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if self.load_factor() &gt; self.load_thres {\n            self.extend();\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = self.find_bucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            self.buckets[index].as_mut().unwrap().val = val;\n            return;\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        self.buckets[index] = Some(Pair { key, val });\n        self.size += 1;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    fn remove(&amp;mut self, key: i32) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        let index = self.find_bucket(key);\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if self.buckets[index].is_some() &amp;&amp; self.buckets[index] != self.TOMBSTONE {\n            self.buckets[index] = self.TOMBSTONE.clone();\n            self.size -= 1;\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    fn extend(&amp;mut self) {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        let buckets_tmp = self.buckets.clone();\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        self.capacity *= self.extend_ratio;\n        self.buckets = vec![None; self.capacity];\n        self.size = 0;\n\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for pair in buckets_tmp {\n            if pair.is_none() || pair == self.TOMBSTONE {\n                continue;\n            }\n            let pair = pair.unwrap();\n\n            self.put(pair.key, pair.val);\n        }\n    }\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    fn print(&amp;self) {\n        for pair in &amp;self.buckets {\n            if pair.is_none() {\n                println!(\"null\");\n            } else if pair == &amp;self.TOMBSTONE {\n                println!(\"TOMBSTONE\");\n            } else {\n                let pair = pair.as_ref().unwrap();\n                println!(\"{} -&gt; {}\", pair.key, pair.val);\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.c<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\ntypedef struct {\n    int size;         // \u952e\u503c\u5bf9\u6570\u91cf\n    int capacity;     // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    double loadThres; // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    int extendRatio;  // \u6269\u5bb9\u500d\u6570\n    Pair **buckets;   // \u6876\u6570\u7ec4\n    Pair *TOMBSTONE;  // \u5220\u9664\u6807\u8bb0\n} HashMapOpenAddressing;\n\n/* \u6784\u9020\u51fd\u6570 */\nHashMapOpenAddressing *newHashMapOpenAddressing() {\n    HashMapOpenAddressing *hashMap = (HashMapOpenAddressing *)malloc(sizeof(HashMapOpenAddressing));\n    hashMap-&gt;size = 0;\n    hashMap-&gt;capacity = 4;\n    hashMap-&gt;loadThres = 2.0 / 3.0;\n    hashMap-&gt;extendRatio = 2;\n    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);\n    hashMap-&gt;TOMBSTONE = (Pair *)malloc(sizeof(Pair));\n    hashMap-&gt;TOMBSTONE-&gt;key = -1;\n    hashMap-&gt;TOMBSTONE-&gt;val = \"-1\";\n\n    return hashMap;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delHashMapOpenAddressing(HashMapOpenAddressing *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Pair *pair = hashMap-&gt;buckets[i];\n        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {\n            free(pair-&gt;val);\n            free(pair);\n        }\n    }\n    free(hashMap-&gt;buckets);\n    free(hashMap-&gt;TOMBSTONE);\n    free(hashMap);\n}\n\n/* \u54c8\u5e0c\u51fd\u6570 */\nint hashFunc(HashMapOpenAddressing *hashMap, int key) {\n    return key % hashMap-&gt;capacity;\n}\n\n/* \u8d1f\u8f7d\u56e0\u5b50 */\ndouble loadFactor(HashMapOpenAddressing *hashMap) {\n    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;\n}\n\n/* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\nint findBucket(HashMapOpenAddressing *hashMap, int key) {\n    int index = hashFunc(hashMap, key);\n    int firstTombstone = -1;\n    // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n    while (hashMap-&gt;buckets[index] != NULL) {\n        // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        if (hashMap-&gt;buckets[index]-&gt;key == key) {\n            // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n            if (firstTombstone != -1) {\n                hashMap-&gt;buckets[firstTombstone] = hashMap-&gt;buckets[index];\n                hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;\n                return firstTombstone; // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n            }\n            return index; // \u8fd4\u56de\u6876\u7d22\u5f15\n        }\n        // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n        if (firstTombstone == -1 &amp;&amp; hashMap-&gt;buckets[index] == hashMap-&gt;TOMBSTONE) {\n            firstTombstone = index;\n        }\n        // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n        index = (index + 1) % hashMap-&gt;capacity;\n    }\n    // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n    return firstTombstone == -1 ? index : firstTombstone;\n}\n\n/* \u67e5\u8be2\u64cd\u4f5c */\nchar *get(HashMapOpenAddressing *hashMap, int key) {\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(hashMap, key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        return hashMap-&gt;buckets[index]-&gt;val;\n    }\n    // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    return \"\";\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nvoid put(HashMapOpenAddressing *hashMap, int key, char *val) {\n    // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {\n        extend(hashMap);\n    }\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(hashMap, key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        free(hashMap-&gt;buckets[index]-&gt;val);\n        hashMap-&gt;buckets[index]-&gt;val = (char *)malloc(sizeof(strlen(val) + 1));\n        strcpy(hashMap-&gt;buckets[index]-&gt;val, val);\n        hashMap-&gt;buckets[index]-&gt;val[strlen(val)] = '\\0';\n        return;\n    }\n    // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n    Pair *pair = (Pair *)malloc(sizeof(Pair));\n    pair-&gt;key = key;\n    pair-&gt;val = (char *)malloc(sizeof(strlen(val) + 1));\n    strcpy(pair-&gt;val, val);\n    pair-&gt;val[strlen(val)] = '\\0';\n\n    hashMap-&gt;buckets[index] = pair;\n    hashMap-&gt;size++;\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nvoid removeItem(HashMapOpenAddressing *hashMap, int key) {\n    // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    int index = findBucket(hashMap, key);\n    // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {\n        Pair *pair = hashMap-&gt;buckets[index];\n        free(pair-&gt;val);\n        free(pair);\n        hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;\n        hashMap-&gt;size--;\n    }\n}\n\n/* \u6269\u5bb9\u54c8\u5e0c\u8868 */\nvoid extend(HashMapOpenAddressing *hashMap) {\n    // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    Pair **bucketsTmp = hashMap-&gt;buckets;\n    int oldCapacity = hashMap-&gt;capacity;\n    // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;\n    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);\n    hashMap-&gt;size = 0;\n    // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for (int i = 0; i &lt; oldCapacity; i++) {\n        Pair *pair = bucketsTmp[i];\n        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {\n            put(hashMap, pair-&gt;key, pair-&gt;val);\n            free(pair-&gt;val);\n            free(pair);\n        }\n    }\n    free(bucketsTmp);\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nvoid print(HashMapOpenAddressing *hashMap) {\n    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {\n        Pair *pair = hashMap-&gt;buckets[i];\n        if (pair == NULL) {\n            printf(\"NULL\\n\");\n        } else if (pair == hashMap-&gt;TOMBSTONE) {\n            printf(\"TOMBSTONE\\n\");\n        } else {\n            printf(\"%d -&gt; %s\\n\", pair-&gt;key, pair-&gt;val);\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.kt<pre><code>/* \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 */\nclass HashMapOpenAddressing {\n    private var size: Int               // \u952e\u503c\u5bf9\u6570\u91cf\n    private var capacity: Int           // \u54c8\u5e0c\u8868\u5bb9\u91cf\n    private val loadThres: Double       // \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    private val extendRatio: Int        // \u6269\u5bb9\u500d\u6570\n    private var buckets: Array&lt;Pair?&gt;   // \u6876\u6570\u7ec4\n    private val TOMBSTONE: Pair         // \u5220\u9664\u6807\u8bb0\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init {\n        size = 0\n        capacity = 4\n        loadThres = 2.0 / 3.0\n        extendRatio = 2\n        buckets = arrayOfNulls(capacity)\n        TOMBSTONE = Pair(-1, \"-1\")\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fun hashFunc(key: Int): Int {\n        return key % capacity\n    }\n\n    /* \u8d1f\u8f7d\u56e0\u5b50 */\n    fun loadFactor(): Double {\n        return (size / capacity).toDouble()\n    }\n\n    /* \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 */\n    fun findBucket(key: Int): Int {\n        var index = hashFunc(key)\n        var firstTombstone = -1\n        // \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n        while (buckets[index] != null) {\n            // \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n            if (buckets[index]?.key == key) {\n                // \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n                if (firstTombstone != -1) {\n                    buckets[firstTombstone] = buckets[index]\n                    buckets[index] = TOMBSTONE\n                    return firstTombstone // \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n                }\n                return index // \u8fd4\u56de\u6876\u7d22\u5f15\n            }\n            // \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) {\n                firstTombstone = index\n            }\n            // \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n            index = (index + 1) % capacity\n        }\n        // \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n        return if (firstTombstone == -1) index else firstTombstone\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    fun get(key: Int): String? {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        val index = findBucket(key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            return buckets[index]?._val\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de null\n        return null\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    fun put(key: Int, _val: String) {\n        // \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n        if (loadFactor() &gt; loadThres) {\n            extend()\n        }\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        val index = findBucket(key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5e76\u8fd4\u56de\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index]!!._val = _val\n            return\n        }\n        // \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n        buckets[index] = Pair(key, _val)\n        size++\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    fun remove(key: Int) {\n        // \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n        val index = findBucket(key)\n        // \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) {\n            buckets[index] = TOMBSTONE\n            size--\n        }\n    }\n\n    /* \u6269\u5bb9\u54c8\u5e0c\u8868 */\n    fun extend() {\n        // \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n        val bucketsTmp = buckets\n        // \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n        capacity *= extendRatio\n        buckets = arrayOfNulls(capacity)\n        size = 0\n        // \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n        for (pair in bucketsTmp) {\n            if (pair != null &amp;&amp; pair != TOMBSTONE) {\n                put(pair.key, pair._val)\n            }\n        }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    fun print() {\n        for (pair in buckets) {\n            if (pair == null) {\n                println(\"null\")\n            } else if (pair == TOMBSTONE) {\n                println(\"TOMESTOME\")\n            } else {\n                println(\"${pair.key} -&gt; ${pair._val}\")\n            }\n        }\n    }\n}\n</code></pre> hash_map_open_addressing.rb<pre><code>### \u5f00\u653e\u5bfb\u5740\u54c8\u5e0c\u8868 ###\nclass HashMapOpenAddressing\n  TOMBSTONE = Pair.new(-1, '-1') # \u5220\u9664\u6807\u8bb0\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @size = 0 # \u952e\u503c\u5bf9\u6570\u91cf\n    @capacity = 4 # \u54c8\u5e0c\u8868\u5bb9\u91cf\n    @load_thres = 2.0 / 3.0 # \u89e6\u53d1\u6269\u5bb9\u7684\u8d1f\u8f7d\u56e0\u5b50\u9608\u503c\n    @extend_ratio = 2 # \u6269\u5bb9\u500d\u6570\n    @buckets = Array.new(@capacity) # \u6876\u6570\u7ec4\n  end\n\n  ### \u54c8\u5e0c\u51fd\u6570 ###\n  def hash_func(key)\n    key % @capacity\n  end\n\n  ### \u8d1f\u8f7d\u56e0\u5b50 ###\n  def load_factor\n    @size / @capacity\n  end\n\n  ### \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15 ###\n  def find_bucket(key)\n    index = hash_func(key)\n    first_tombstone = -1\n    # \u7ebf\u6027\u63a2\u6d4b\uff0c\u5f53\u9047\u5230\u7a7a\u6876\u65f6\u8df3\u51fa\n    while !@buckets[index].nil?\n      # \u82e5\u9047\u5230 key \uff0c\u8fd4\u56de\u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n      if @buckets[index].key == key\n        # \u82e5\u4e4b\u524d\u9047\u5230\u4e86\u5220\u9664\u6807\u8bb0\uff0c\u5219\u5c06\u952e\u503c\u5bf9\u79fb\u52a8\u81f3\u8be5\u7d22\u5f15\u5904\n        if first_tombstone != -1\n          @buckets[first_tombstone] = @buckets[index]\n          @buckets[index] = TOMBSTONE\n          return first_tombstone # \u8fd4\u56de\u79fb\u52a8\u540e\u7684\u6876\u7d22\u5f15\n        end\n        return index # \u8fd4\u56de\u6876\u7d22\u5f15\n      end\n      # \u8bb0\u5f55\u9047\u5230\u7684\u9996\u4e2a\u5220\u9664\u6807\u8bb0\n      first_tombstone = index if first_tombstone == -1 &amp;&amp; @buckets[index] == TOMBSTONE\n      # \u8ba1\u7b97\u6876\u7d22\u5f15\uff0c\u8d8a\u8fc7\u5c3e\u90e8\u5219\u8fd4\u56de\u5934\u90e8\n      index = (index + 1) % @capacity\n    end\n    # \u82e5 key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de\u6dfb\u52a0\u70b9\u7684\u7d22\u5f15\n    first_tombstone == -1 ? index : first_tombstone\n  end\n\n  ### \u67e5\u8be2\u64cd\u4f5c ###\n  def get(key)\n    # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    index = find_bucket(key)\n    # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8fd4\u56de\u5bf9\u5e94 val\n    return @buckets[index].val unless [nil, TOMBSTONE].include?(@buckets[index])\n    # \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de nil\n    nil\n  end\n\n  ### \u6dfb\u52a0\u64cd\u4f5c ###\n  def put(key, val)\n    # \u5f53\u8d1f\u8f7d\u56e0\u5b50\u8d85\u8fc7\u9608\u503c\u65f6\uff0c\u6267\u884c\u6269\u5bb9\n    extend if load_factor &gt; @load_thres\n    # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    index = find_bucket(key)\n    # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u8986\u76d6 val \u5f00\u8fd4\u56de\n    unless [nil, TOMBSTONE].include?(@buckets[index])\n      @buckets[index].val = val\n      return\n    end\n    # \u82e5\u952e\u503c\u5bf9\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0\u8be5\u952e\u503c\u5bf9\n    @buckets[index] = Pair.new(key, val)\n    @size += 1\n  end\n\n  ### \u5220\u9664\u64cd\u4f5c ###\n  def remove(key)\n    # \u641c\u7d22 key \u5bf9\u5e94\u7684\u6876\u7d22\u5f15\n    index = find_bucket(key)\n    # \u82e5\u627e\u5230\u952e\u503c\u5bf9\uff0c\u5219\u7528\u5220\u9664\u6807\u8bb0\u8986\u76d6\u5b83\n    unless [nil, TOMBSTONE].include?(@buckets[index])\n      @buckets[index] = TOMBSTONE\n      @size -= 1\n    end\n  end\n\n  ### \u6269\u5bb9\u54c8\u5e0c\u8868 ###\n  def extend\n    # \u6682\u5b58\u539f\u54c8\u5e0c\u8868\n    buckets_tmp = @buckets\n    # \u521d\u59cb\u5316\u6269\u5bb9\u540e\u7684\u65b0\u54c8\u5e0c\u8868\n    @capacity *= @extend_ratio\n    @buckets = Array.new(@capacity)\n    @size = 0\n    # \u5c06\u952e\u503c\u5bf9\u4ece\u539f\u54c8\u5e0c\u8868\u642c\u8fd0\u81f3\u65b0\u54c8\u5e0c\u8868\n    for pair in buckets_tmp\n      put(pair.key, pair.val) unless [nil, TOMBSTONE].include?(pair)\n    end\n  end\n\n  ### \u6253\u5370\u54c8\u5e0c\u8868 ###\n  def print\n    for pair in @buckets\n      if pair.nil?\n        puts \"Nil\"\n      elsif pair == TOMBSTONE\n        puts \"TOMBSTONE\"\n      else\n        puts \"#{pair.key} -&gt; #{pair.val}\"\n      end\n    end\n  end\nend\n</code></pre> hash_map_open_addressing.zig<pre><code>[class]{HashMapOpenAddressing}-[func]{}\n</code></pre>"},{"location":"chapter_hashing/hash_collision/#2-quadratic-probing","title":"2. \u00a0 Quadratic probing","text":"<p>Quadratic probing is similar to linear probing and is one of the common strategies of open addressing. When a collision occurs, quadratic probing does not simply skip a fixed number of steps but skips \"the square of the number of probes,\" i.e., \\(1, 4, 9, \\dots\\) steps.</p> <p>Quadratic probing has the following advantages:</p> <ul> <li>Quadratic probing attempts to alleviate the clustering effect of linear probing by skipping the distance of the square of the number of probes.</li> <li>Quadratic probing skips larger distances to find empty positions, helping to distribute data more evenly.</li> </ul> <p>However, quadratic probing is not perfect:</p> <ul> <li>Clustering still exists, i.e., some positions are more likely to be occupied than others.</li> <li>Due to the growth of squares, quadratic probing may not probe the entire hash table, meaning it might not access empty buckets even if they exist in the hash table.</li> </ul>"},{"location":"chapter_hashing/hash_collision/#3-double-hashing","title":"3. \u00a0 Double hashing","text":"<p>As the name suggests, the double hashing method uses multiple hash functions \\(f_1(x)\\), \\(f_2(x)\\), \\(f_3(x)\\), \\(\\dots\\) for probing.</p> <ul> <li>Inserting elements: If hash function \\(f_1(x)\\) encounters a conflict, try \\(f_2(x)\\), and so on, until an empty position is found and the element is inserted.</li> <li>Searching for elements: Search in the same order of hash functions until the target element is found and returned; if an empty position is encountered or all hash functions have been tried, it indicates the element is not in the hash table, then return <code>None</code>.</li> </ul> <p>Compared to linear probing, double hashing is less prone to clustering but involves additional computation for multiple hash functions.</p> <p>Tip</p> <p>Please note that open addressing (linear probing, quadratic probing, and double hashing) hash tables all have the issue of \"not being able to directly delete elements.\"</p>"},{"location":"chapter_hashing/hash_collision/#623-choice-of-programming-languages","title":"6.2.3 \u00a0 Choice of programming languages","text":"<p>Various programming languages have adopted different hash table implementation strategies, here are a few examples:</p> <ul> <li>Python uses open addressing. The <code>dict</code> dictionary uses pseudo-random numbers for probing.</li> <li>Java uses separate chaining. Since JDK 1.8, when the array length in <code>HashMap</code> reaches 64 and the length of a linked list reaches 8, the linked list is converted to a red-black tree to improve search performance.</li> <li>Go uses separate chaining. Go stipulates that each bucket can store up to 8 key-value pairs, and if the capacity is exceeded, an overflow bucket is connected; when there are too many overflow buckets, a special equal-size expansion operation is performed to ensure performance.</li> </ul>"},{"location":"chapter_hashing/hash_map/","title":"6.1 \u00a0 Hash table","text":"<p>A hash table achieves efficient element querying by establishing a mapping between keys and values. Specifically, when we input a <code>key</code> into the hash table, we can retrieve the corresponding <code>value</code> in \\(O(1)\\) time.</p> <p>As shown in Figure 6-1, given \\(n\\) students, each with two pieces of data: \"name\" and \"student number\". If we want to implement a query feature that returns the corresponding name when given a student number, we can use the hash table shown in Figure 6-1.</p> <p></p> <p> Figure 6-1 \u00a0 Abstract representation of a hash table </p> <p>Apart from hash tables, arrays and linked lists can also be used to implement querying functions. Their efficiency is compared in Table 6-1.</p> <ul> <li>Adding elements: Simply add the element to the end of the array (or linked list), using \\(O(1)\\) time.</li> <li>Querying elements: Since the array (or linked list) is unordered, it requires traversing all the elements, using \\(O(n)\\) time.</li> <li>Deleting elements: First, locate the element, then delete it from the array (or linked list), using \\(O(n)\\) time.</li> </ul> <p> Table 6-1 \u00a0 Comparison of element query efficiency </p> Array Linked List Hash Table Find Element \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) Add Element \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Delete Element \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) <p>Observations reveal that the time complexity for adding, deleting, and querying in a hash table is \\(O(1)\\), which is highly efficient.</p>"},{"location":"chapter_hashing/hash_map/#611-common-operations-of-hash-table","title":"6.1.1 \u00a0 Common operations of hash table","text":"<p>Common operations of a hash table include initialization, querying, adding key-value pairs, and deleting key-value pairs, etc. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig hash_map.py<pre><code># Initialize hash table\nhmap: dict = {}\n\n# Add operation\n# Add key-value pair (key, value) to the hash table\nhmap[12836] = \"Xiao Ha\"\nhmap[15937] = \"Xiao Luo\"\nhmap[16750] = \"Xiao Suan\"\nhmap[13276] = \"Xiao Fa\"\nhmap[10583] = \"Xiao Ya\"\n\n# Query operation\n# Input key into hash table, get value\nname: str = hmap[15937]\n\n# Delete operation\n# Delete key-value pair (key, value) from hash table\nhmap.pop(10583)\n</code></pre> hash_map.cpp<pre><code>/* Initialize hash table */\nunordered_map&lt;int, string&gt; map;\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap[12836] = \"Xiao Ha\";\nmap[15937] = \"Xiao Luo\";\nmap[16750] = \"Xiao Suan\";\nmap[13276] = \"Xiao Fa\";\nmap[10583] = \"Xiao Ya\";\n\n/* Query operation */\n// Input key into hash table, get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.erase(10583);\n</code></pre> hash_map.java<pre><code>/* Initialize hash table */\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap.put(12836, \"Xiao Ha\");   \nmap.put(15937, \"Xiao Luo\");   \nmap.put(16750, \"Xiao Suan\");   \nmap.put(13276, \"Xiao Fa\");\nmap.put(10583, \"Xiao Ya\");\n\n/* Query operation */\n// Input key into hash table, get value\nString name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.cs<pre><code>/* Initialize hash table */\nDictionary&lt;int, string&gt; map = new() {\n    /* Add operation */\n    // Add key-value pair (key, value) to the hash table\n    { 12836, \"Xiao Ha\" },\n    { 15937, \"Xiao Luo\" },\n    { 16750, \"Xiao Suan\" },\n    { 13276, \"Xiao Fa\" },\n    { 10583, \"Xiao Ya\" }\n};\n\n/* Query operation */\n// Input key into hash table, get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.Remove(10583);\n</code></pre> hash_map_test.go<pre><code>/* Initialize hash table */\nhmap := make(map[int]string)\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nhmap[12836] = \"Xiao Ha\"\nhmap[15937] = \"Xiao Luo\"\nhmap[16750] = \"Xiao Suan\"\nhmap[13276] = \"Xiao Fa\"\nhmap[10583] = \"Xiao Ya\"\n\n/* Query operation */\n// Input key into hash table, get value\nname := hmap[15937]\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\ndelete(hmap, 10583)\n</code></pre> hash_map.swift<pre><code>/* Initialize hash table */\nvar map: [Int: String] = [:]\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap[12836] = \"Xiao Ha\"\nmap[15937] = \"Xiao Luo\"\nmap[16750] = \"Xiao Suan\"\nmap[13276] = \"Xiao Fa\"\nmap[10583] = \"Xiao Ya\"\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map[15937]!\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.removeValue(forKey: 10583)\n</code></pre> hash_map.js<pre><code>/* Initialize hash table */\nconst map = new Map();\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap.set(12836, 'Xiao Ha');\nmap.set(15937, 'Xiao Luo');\nmap.set(16750, 'Xiao Suan');\nmap.set(13276, 'Xiao Fa');\nmap.set(10583, 'Xiao Ya');\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\n</code></pre> hash_map.ts<pre><code>/* Initialize hash table */\nconst map = new Map&lt;number, string&gt;();\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap.set(12836, 'Xiao Ha');\nmap.set(15937, 'Xiao Luo');\nmap.set(16750, 'Xiao Suan');\nmap.set(13276, 'Xiao Fa');\nmap.set(10583, 'Xiao Ya');\nconsole.info('\\nAfter adding, the hash table is\\nKey -&gt; Value');\nconsole.info(map);\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map.get(15937);\nconsole.info('\\nInput student number 15937, query name ' + name);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\nconsole.info('\\nAfter deleting 10583, the hash table is\\nKey -&gt; Value');\nconsole.info(map);\n</code></pre> hash_map.dart<pre><code>/* Initialize hash table */\nMap&lt;int, String&gt; map = {};\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap[12836] = \"Xiao Ha\";\nmap[15937] = \"Xiao Luo\";\nmap[16750] = \"Xiao Suan\";\nmap[13276] = \"Xiao Fa\";\nmap[10583] = \"Xiao Ya\";\n\n/* Query operation */\n// Input key into hash table, get value\nString name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.rs<pre><code>use std::collections::HashMap;\n\n/* Initialize hash table */\nlet mut map: HashMap&lt;i32, String&gt; = HashMap::new();\n\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap.insert(12836, \"Xiao Ha\".to_string());\nmap.insert(15937, \"Xiao Luo\".to_string());\nmap.insert(16750, \"Xiao Suan\".to_string());\nmap.insert(13279, \"Xiao Fa\".to_string());\nmap.insert(10583, \"Xiao Ya\".to_string());\n\n/* Query operation */\n// Input key into hash table, get value\nlet _name: Option&lt;&amp;String&gt; = map.get(&amp;15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nlet _removed_value: Option&lt;String&gt; = map.remove(&amp;10583);\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>\n</code></pre> hash_map.zig<pre><code>\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>There are three common ways to traverse a hash table: traversing key-value pairs, keys, and values. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig hash_map.py<pre><code># Traverse hash table\n# Traverse key-value pairs key-&gt;value\nfor key, value in hmap.items():\n    print(key, \"-&gt;\", value)\n# Traverse keys only\nfor key in hmap.keys():\n    print(key)\n# Traverse values only\nfor value in hmap.values():\n    print(value)\n</code></pre> hash_map.cpp<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (auto kv: map) {\n    cout &lt;&lt; kv.first &lt;&lt; \" -&gt; \" &lt;&lt; kv.second &lt;&lt; endl;\n}\n// Traverse using iterator key-&gt;value\nfor (auto iter = map.begin(); iter != map.end(); iter++) {\n    cout &lt;&lt; iter-&gt;first &lt;&lt; \"-&gt;\" &lt;&lt; iter-&gt;second &lt;&lt; endl;\n}\n</code></pre> hash_map.java<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (Map.Entry&lt;Integer, String&gt; kv: map.entrySet()) {\n    System.out.println(kv.getKey() + \" -&gt; \" + kv.getValue());\n}\n// Traverse keys only\nfor (int key: map.keySet()) {\n    System.out.println(key);\n}\n// Traverse values only\nfor (String val: map.values()) {\n    System.out.println(val);\n}\n</code></pre> hash_map.cs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nforeach (var kv in map) {\n    Console.WriteLine(kv.Key + \" -&gt; \" + kv.Value);\n}\n// Traverse keys only\nforeach (int key in map.Keys) {\n    Console.WriteLine(key);\n}\n// Traverse values only\nforeach (string val in map.Values) {\n    Console.WriteLine(val);\n}\n</code></pre> hash_map_test.go<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor key, value := range hmap {\n    fmt.Println(key, \"-&gt;\", value)\n}\n// Traverse keys only\nfor key := range hmap {\n    fmt.Println(key)\n}\n// Traverse values only\nfor _, value := range hmap {\n    fmt.Println(value)\n}\n</code></pre> hash_map.swift<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in map {\n    print(\"\\(key) -&gt; \\(value)\")\n}\n// Traverse keys only\nfor key in map.keys {\n    print(key)\n}\n// Traverse values only\nfor value in map.values {\n    print(value)\n}\n</code></pre> hash_map.js<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.ts<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.dart<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nmap.forEach((key, value) {\nprint('$key -&gt; $value');\n});\n\n// Traverse keys only Key\nmap.keys.forEach((key) {\nprint(key);\n});\n\n// Traverse values only Value\nmap.values.forEach((value) {\nprint(value);\n});\n</code></pre> hash_map.rs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in &amp;map {\n    println!(\"{key} -&gt; {value}\");\n}\n\n// Traverse keys only Key\nfor key in map.keys() {\n    println!(\"{key}\"); \n}\n\n// Traverse values only Value\nfor value in map.values() {\n    println!(\"{value}\");\n}\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>\n</code></pre> hash_map.zig<pre><code>// Zig example is not provided\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_hashing/hash_map/#612-simple-implementation-of-hash-table","title":"6.1.2 \u00a0 Simple implementation of hash table","text":"<p>First, let's consider the simplest case: implementing a hash table using just an array. In the hash table, each empty slot in the array is called a bucket, and each bucket can store one key-value pair. Therefore, the query operation involves finding the bucket corresponding to the <code>key</code> and retrieving the <code>value</code> from it.</p> <p>So, how do we locate the appropriate bucket based on the <code>key</code>? This is achieved through a hash function. The role of the hash function is to map a larger input space to a smaller output space. In a hash table, the input space is all possible keys, and the output space is all buckets (array indices). In other words, input a <code>key</code>, and we can use the hash function to determine the storage location of the corresponding key-value pair in the array.</p> <p>The calculation process of the hash function for a given <code>key</code> is divided into the following two steps:</p> <ol> <li>Calculate the hash value using a certain hash algorithm <code>hash()</code>.</li> <li>Take the modulus of the hash value with the number of buckets (array length) <code>capacity</code> to obtain the array index <code>index</code>.</li> </ol> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Afterward, we can use <code>index</code> to access the corresponding bucket in the hash table and thereby retrieve the <code>value</code>.</p> <p>Assuming array length <code>capacity = 100</code> and hash algorithm <code>hash(key) = key</code>, the hash function is <code>key % 100</code>. Figure 6-2 uses <code>key</code> as the student number and <code>value</code> as the name to demonstrate the working principle of the hash function.</p> <p></p> <p> Figure 6-2 \u00a0 Working principle of hash function </p> <p>The following code implements a simple hash table. Here, we encapsulate <code>key</code> and <code>value</code> into a class <code>Pair</code> to represent the key-value pair.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array_hash_map.py<pre><code>class Pair:\n    \"\"\"\u952e\u503c\u5bf9\"\"\"\n\n    def __init__(self, key: int, val: str):\n        self.key = key\n        self.val = val\n\nclass ArrayHashMap:\n    \"\"\"\u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        # \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        self.buckets: list[Pair | None] = [None] * 100\n\n    def hash_func(self, key: int) -&gt; int:\n        \"\"\"\u54c8\u5e0c\u51fd\u6570\"\"\"\n        index = key % 100\n        return index\n\n    def get(self, key: int) -&gt; str:\n        \"\"\"\u67e5\u8be2\u64cd\u4f5c\"\"\"\n        index: int = self.hash_func(key)\n        pair: Pair = self.buckets[index]\n        if pair is None:\n            return None\n        return pair.val\n\n    def put(self, key: int, val: str):\n        \"\"\"\u6dfb\u52a0\u64cd\u4f5c\"\"\"\n        pair = Pair(key, val)\n        index: int = self.hash_func(key)\n        self.buckets[index] = pair\n\n    def remove(self, key: int):\n        \"\"\"\u5220\u9664\u64cd\u4f5c\"\"\"\n        index: int = self.hash_func(key)\n        # \u7f6e\u4e3a None \uff0c\u4ee3\u8868\u5220\u9664\n        self.buckets[index] = None\n\n    def entry_set(self) -&gt; list[Pair]:\n        \"\"\"\u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9\"\"\"\n        result: list[Pair] = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair)\n        return result\n\n    def key_set(self) -&gt; list[int]:\n        \"\"\"\u83b7\u53d6\u6240\u6709\u952e\"\"\"\n        result = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair.key)\n        return result\n\n    def value_set(self) -&gt; list[str]:\n        \"\"\"\u83b7\u53d6\u6240\u6709\u503c\"\"\"\n        result = []\n        for pair in self.buckets:\n            if pair is not None:\n                result.append(pair.val)\n        return result\n\n    def print(self):\n        \"\"\"\u6253\u5370\u54c8\u5e0c\u8868\"\"\"\n        for pair in self.buckets:\n            if pair is not None:\n                print(pair.key, \"-&gt;\", pair.val)\n</code></pre> array_hash_map.cpp<pre><code>/* \u952e\u503c\u5bf9 */\nstruct Pair {\n  public:\n    int key;\n    string val;\n    Pair(int key, string val) {\n        this-&gt;key = key;\n        this-&gt;val = val;\n    }\n};\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n  private:\n    vector&lt;Pair *&gt; buckets;\n\n  public:\n    ArrayHashMap() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        buckets = vector&lt;Pair *&gt;(100);\n    }\n\n    ~ArrayHashMap() {\n        // \u91ca\u653e\u5185\u5b58\n        for (const auto &amp;bucket : buckets) {\n            delete bucket;\n        }\n        buckets.clear();\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    string get(int key) {\n        int index = hashFunc(key);\n        Pair *pair = buckets[index];\n        if (pair == nullptr)\n            return \"\";\n        return pair-&gt;val;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    void put(int key, string val) {\n        Pair *pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    void remove(int key) {\n        int index = hashFunc(key);\n        // \u91ca\u653e\u5185\u5b58\u5e76\u7f6e\u4e3a nullptr\n        delete buckets[index];\n        buckets[index] = nullptr;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    vector&lt;Pair *&gt; pairSet() {\n        vector&lt;Pair *&gt; pairSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                pairSet.push_back(pair);\n            }\n        }\n        return pairSet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    vector&lt;int&gt; keySet() {\n        vector&lt;int&gt; keySet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                keySet.push_back(pair-&gt;key);\n            }\n        }\n        return keySet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    vector&lt;string&gt; valueSet() {\n        vector&lt;string&gt; valueSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                valueSet.push_back(pair-&gt;val);\n            }\n        }\n        return valueSet;\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    void print() {\n        for (Pair *kv : pairSet()) {\n            cout &lt;&lt; kv-&gt;key &lt;&lt; \" -&gt; \" &lt;&lt; kv-&gt;val &lt;&lt; endl;\n        }\n    }\n};\n</code></pre> array_hash_map.java<pre><code>/* \u952e\u503c\u5bf9 */\nclass Pair {\n    public int key;\n    public String val;\n\n    public Pair(int key, String val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    private List&lt;Pair&gt; buckets;\n\n    public ArrayHashMap() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        buckets = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 100; i++) {\n            buckets.add(null);\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    private int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public String get(int key) {\n        int index = hashFunc(key);\n        Pair pair = buckets.get(index);\n        if (pair == null)\n            return null;\n        return pair.val;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public void put(int key, String val) {\n        Pair pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets.set(index, pair);\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public void remove(int key) {\n        int index = hashFunc(key);\n        // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n        buckets.set(index, null);\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    public List&lt;Pair&gt; pairSet() {\n        List&lt;Pair&gt; pairSet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                pairSet.add(pair);\n        }\n        return pairSet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    public List&lt;Integer&gt; keySet() {\n        List&lt;Integer&gt; keySet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                keySet.add(pair.key);\n        }\n        return keySet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    public List&lt;String&gt; valueSet() {\n        List&lt;String&gt; valueSet = new ArrayList&lt;&gt;();\n        for (Pair pair : buckets) {\n            if (pair != null)\n                valueSet.add(pair.val);\n        }\n        return valueSet;\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public void print() {\n        for (Pair kv : pairSet()) {\n            System.out.println(kv.key + \" -&gt; \" + kv.val);\n        }\n    }\n}\n</code></pre> array_hash_map.cs<pre><code>/* \u952e\u503c\u5bf9 int-&gt;string */\nclass Pair(int key, string val) {\n    public int key = key;\n    public string val = val;\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    List&lt;Pair?&gt; buckets;\n    public ArrayHashMap() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        buckets = [];\n        for (int i = 0; i &lt; 100; i++) {\n            buckets.Add(null);\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    int HashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public string? Get(int key) {\n        int index = HashFunc(key);\n        Pair? pair = buckets[index];\n        if (pair == null) return null;\n        return pair.val;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public void Put(int key, string val) {\n        Pair pair = new(key, val);\n        int index = HashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public void Remove(int key) {\n        int index = HashFunc(key);\n        // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n        buckets[index] = null;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    public List&lt;Pair&gt; PairSet() {\n        List&lt;Pair&gt; pairSet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                pairSet.Add(pair);\n        }\n        return pairSet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    public List&lt;int&gt; KeySet() {\n        List&lt;int&gt; keySet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                keySet.Add(pair.key);\n        }\n        return keySet;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    public List&lt;string&gt; ValueSet() {\n        List&lt;string&gt; valueSet = [];\n        foreach (Pair? pair in buckets) {\n            if (pair != null)\n                valueSet.Add(pair.val);\n        }\n        return valueSet;\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public void Print() {\n        foreach (Pair kv in PairSet()) {\n            Console.WriteLine(kv.key + \" -&gt; \" + kv.val);\n        }\n    }\n}\n</code></pre> array_hash_map.go<pre><code>/* \u952e\u503c\u5bf9 */\ntype pair struct {\n    key int\n    val string\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\ntype arrayHashMap struct {\n    buckets []*pair\n}\n\n/* \u521d\u59cb\u5316\u54c8\u5e0c\u8868 */\nfunc newArrayHashMap() *arrayHashMap {\n    // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n    buckets := make([]*pair, 100)\n    return &amp;arrayHashMap{buckets: buckets}\n}\n\n/* \u54c8\u5e0c\u51fd\u6570 */\nfunc (a *arrayHashMap) hashFunc(key int) int {\n    index := key % 100\n    return index\n}\n\n/* \u67e5\u8be2\u64cd\u4f5c */\nfunc (a *arrayHashMap) get(key int) string {\n    index := a.hashFunc(key)\n    pair := a.buckets[index]\n    if pair == nil {\n        return \"Not Found\"\n    }\n    return pair.val\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nfunc (a *arrayHashMap) put(key int, val string) {\n    pair := &amp;pair{key: key, val: val}\n    index := a.hashFunc(key)\n    a.buckets[index] = pair\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nfunc (a *arrayHashMap) remove(key int) {\n    index := a.hashFunc(key)\n    // \u7f6e\u4e3a nil \uff0c\u4ee3\u8868\u5220\u9664\n    a.buckets[index] = nil\n}\n\n/* \u83b7\u53d6\u6240\u6709\u952e\u5bf9 */\nfunc (a *arrayHashMap) pairSet() []*pair {\n    var pairs []*pair\n    for _, pair := range a.buckets {\n        if pair != nil {\n            pairs = append(pairs, pair)\n        }\n    }\n    return pairs\n}\n\n/* \u83b7\u53d6\u6240\u6709\u952e */\nfunc (a *arrayHashMap) keySet() []int {\n    var keys []int\n    for _, pair := range a.buckets {\n        if pair != nil {\n            keys = append(keys, pair.key)\n        }\n    }\n    return keys\n}\n\n/* \u83b7\u53d6\u6240\u6709\u503c */\nfunc (a *arrayHashMap) valueSet() []string {\n    var values []string\n    for _, pair := range a.buckets {\n        if pair != nil {\n            values = append(values, pair.val)\n        }\n    }\n    return values\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nfunc (a *arrayHashMap) print() {\n    for _, pair := range a.buckets {\n        if pair != nil {\n            fmt.Println(pair.key, \"-&gt;\", pair.val)\n        }\n    }\n}\n</code></pre> array_hash_map.swift<pre><code>/* \u952e\u503c\u5bf9 */\nclass Pair: Equatable {\n    public var key: Int\n    public var val: String\n\n    public init(key: Int, val: String) {\n        self.key = key\n        self.val = val\n    }\n\n    public static func == (lhs: Pair, rhs: Pair) -&gt; Bool {\n        lhs.key == rhs.key &amp;&amp; lhs.val == rhs.val\n    }\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    private var buckets: [Pair?]\n\n    init() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        buckets = Array(repeating: nil, count: 100)\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    private func hashFunc(key: Int) -&gt; Int {\n        let index = key % 100\n        return index\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    func get(key: Int) -&gt; String? {\n        let index = hashFunc(key: key)\n        let pair = buckets[index]\n        return pair?.val\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    func put(key: Int, val: String) {\n        let pair = Pair(key: key, val: val)\n        let index = hashFunc(key: key)\n        buckets[index] = pair\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    func remove(key: Int) {\n        let index = hashFunc(key: key)\n        // \u7f6e\u4e3a nil \uff0c\u4ee3\u8868\u5220\u9664\n        buckets[index] = nil\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    func pairSet() -&gt; [Pair] {\n        buckets.compactMap { $0 }\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    func keySet() -&gt; [Int] {\n        buckets.compactMap { $0?.key }\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    func valueSet() -&gt; [String] {\n        buckets.compactMap { $0?.val }\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    func print() {\n        for pair in pairSet() {\n            Swift.print(\"\\(pair.key) -&gt; \\(pair.val)\")\n        }\n    }\n}\n</code></pre> array_hash_map.js<pre><code>/* \u952e\u503c\u5bf9 Number -&gt; String */\nclass Pair {\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    #buckets;\n    constructor() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        this.#buckets = new Array(100).fill(null);\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    #hashFunc(key) {\n        return key % 100;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    get(key) {\n        let index = this.#hashFunc(key);\n        let pair = this.#buckets[index];\n        if (pair === null) return null;\n        return pair.val;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    set(key, val) {\n        let index = this.#hashFunc(key);\n        this.#buckets[index] = new Pair(key, val);\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    delete(key) {\n        let index = this.#hashFunc(key);\n        // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n        this.#buckets[index] = null;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    entries() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i]);\n            }\n        }\n        return arr;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    keys() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i].key);\n            }\n        }\n        return arr;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    values() {\n        let arr = [];\n        for (let i = 0; i &lt; this.#buckets.length; i++) {\n            if (this.#buckets[i]) {\n                arr.push(this.#buckets[i].val);\n            }\n        }\n        return arr;\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    print() {\n        let pairSet = this.entries();\n        for (const pair of pairSet) {\n            console.info(`${pair.key} -&gt; ${pair.val}`);\n        }\n    }\n}\n</code></pre> array_hash_map.ts<pre><code>/* \u952e\u503c\u5bf9 Number -&gt; String */\nclass Pair {\n    public key: number;\n    public val: string;\n\n    constructor(key: number, val: string) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    private readonly buckets: (Pair | null)[];\n\n    constructor() {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        this.buckets = new Array(100).fill(null);\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    private hashFunc(key: number): number {\n        return key % 100;\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    public get(key: number): string | null {\n        let index = this.hashFunc(key);\n        let pair = this.buckets[index];\n        if (pair === null) return null;\n        return pair.val;\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    public set(key: number, val: string) {\n        let index = this.hashFunc(key);\n        this.buckets[index] = new Pair(key, val);\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    public delete(key: number) {\n        let index = this.hashFunc(key);\n        // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n        this.buckets[index] = null;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    public entries(): (Pair | null)[] {\n        let arr: (Pair | null)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i]);\n            }\n        }\n        return arr;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    public keys(): (number | undefined)[] {\n        let arr: (number | undefined)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i].key);\n            }\n        }\n        return arr;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    public values(): (string | undefined)[] {\n        let arr: (string | undefined)[] = [];\n        for (let i = 0; i &lt; this.buckets.length; i++) {\n            if (this.buckets[i]) {\n                arr.push(this.buckets[i].val);\n            }\n        }\n        return arr;\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    public print() {\n        let pairSet = this.entries();\n        for (const pair of pairSet) {\n            console.info(`${pair.key} -&gt; ${pair.val}`);\n        }\n    }\n}\n</code></pre> array_hash_map.dart<pre><code>/* \u952e\u503c\u5bf9 */\nclass Pair {\n  int key;\n  String val;\n  Pair(this.key, this.val);\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n  late List&lt;Pair?&gt; _buckets;\n\n  ArrayHashMap() {\n    // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n    _buckets = List.filled(100, null);\n  }\n\n  /* \u54c8\u5e0c\u51fd\u6570 */\n  int _hashFunc(int key) {\n    final int index = key % 100;\n    return index;\n  }\n\n  /* \u67e5\u8be2\u64cd\u4f5c */\n  String? get(int key) {\n    final int index = _hashFunc(key);\n    final Pair? pair = _buckets[index];\n    if (pair == null) {\n      return null;\n    }\n    return pair.val;\n  }\n\n  /* \u6dfb\u52a0\u64cd\u4f5c */\n  void put(int key, String val) {\n    final Pair pair = Pair(key, val);\n    final int index = _hashFunc(key);\n    _buckets[index] = pair;\n  }\n\n  /* \u5220\u9664\u64cd\u4f5c */\n  void remove(int key) {\n    final int index = _hashFunc(key);\n    _buckets[index] = null;\n  }\n\n  /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n  List&lt;Pair&gt; pairSet() {\n    List&lt;Pair&gt; pairSet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        pairSet.add(pair);\n      }\n    }\n    return pairSet;\n  }\n\n  /* \u83b7\u53d6\u6240\u6709\u952e */\n  List&lt;int&gt; keySet() {\n    List&lt;int&gt; keySet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        keySet.add(pair.key);\n      }\n    }\n    return keySet;\n  }\n\n  /* \u83b7\u53d6\u6240\u6709\u503c */\n  List&lt;String&gt; values() {\n    List&lt;String&gt; valueSet = [];\n    for (final Pair? pair in _buckets) {\n      if (pair != null) {\n        valueSet.add(pair.val);\n      }\n    }\n    return valueSet;\n  }\n\n  /* \u6253\u5370\u54c8\u5e0c\u8868 */\n  void printHashMap() {\n    for (final Pair kv in pairSet()) {\n      print(\"${kv.key} -&gt; ${kv.val}\");\n    }\n  }\n}\n</code></pre> array_hash_map.rs<pre><code>/* \u952e\u503c\u5bf9 */\n#[derive(Debug, Clone, PartialEq)]\npub struct Pair {\n    pub key: i32,\n    pub val: String,\n}\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\npub struct ArrayHashMap {\n    buckets: Vec&lt;Option&lt;Pair&gt;&gt;,\n}\n\nimpl ArrayHashMap {\n    pub fn new() -&gt; ArrayHashMap {\n        // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n        Self {\n            buckets: vec![None; 100],\n        }\n    }\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fn hash_func(&amp;self, key: i32) -&gt; usize {\n        key as usize % 100\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    pub fn get(&amp;self, key: i32) -&gt; Option&lt;&amp;String&gt; {\n        let index = self.hash_func(key);\n        self.buckets[index].as_ref().map(|pair| &amp;pair.val)\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    pub fn put(&amp;mut self, key: i32, val: &amp;str) {\n        let index = self.hash_func(key);\n        self.buckets[index] = Some(Pair {\n            key,\n            val: val.to_string(),\n        });\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    pub fn remove(&amp;mut self, key: i32) {\n        let index = self.hash_func(key);\n        // \u7f6e\u4e3a None \uff0c\u4ee3\u8868\u5220\u9664\n        self.buckets[index] = None;\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    pub fn entry_set(&amp;self) -&gt; Vec&lt;&amp;Pair&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref())\n            .collect()\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    pub fn key_set(&amp;self) -&gt; Vec&lt;&amp;i32&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref().map(|pair| &amp;pair.key))\n            .collect()\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    pub fn value_set(&amp;self) -&gt; Vec&lt;&amp;String&gt; {\n        self.buckets\n            .iter()\n            .filter_map(|pair| pair.as_ref().map(|pair| &amp;pair.val))\n            .collect()\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    pub fn print(&amp;self) {\n        for pair in self.entry_set() {\n            println!(\"{} -&gt; {}\", pair.key, pair.val);\n        }\n    }\n}\n</code></pre> array_hash_map.c<pre><code>/* \u952e\u503c\u5bf9 int-&gt;string */\ntypedef struct {\n    int key;\n    char *val;\n} Pair;\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\ntypedef struct {\n    Pair *buckets[MAX_SIZE];\n} ArrayHashMap;\n\n/* \u6784\u9020\u51fd\u6570 */\nArrayHashMap *newArrayHashMap() {\n    ArrayHashMap *hmap = malloc(sizeof(ArrayHashMap));\n    for (int i=0; i &lt; MAX_SIZE; i++) {\n        hmap-&gt;buckets[i] = NULL;\n    }\n    return hmap;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delArrayHashMap(ArrayHashMap *hmap) {\n    for (int i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            free(hmap-&gt;buckets[i]-&gt;val);\n            free(hmap-&gt;buckets[i]);\n        }\n    }\n    free(hmap);\n}\n\n/* \u6dfb\u52a0\u64cd\u4f5c */\nvoid put(ArrayHashMap *hmap, const int key, const char *val) {\n    Pair *Pair = malloc(sizeof(Pair));\n    Pair-&gt;key = key;\n    Pair-&gt;val = malloc(strlen(val) + 1);\n    strcpy(Pair-&gt;val, val);\n\n    int index = hashFunc(key);\n    hmap-&gt;buckets[index] = Pair;\n}\n\n/* \u5220\u9664\u64cd\u4f5c */\nvoid removeItem(ArrayHashMap *hmap, const int key) {\n    int index = hashFunc(key);\n    free(hmap-&gt;buckets[index]-&gt;val);\n    free(hmap-&gt;buckets[index]);\n    hmap-&gt;buckets[index] = NULL;\n}\n\n/* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\nvoid pairSet(ArrayHashMap *hmap, MapSet *set) {\n    Pair *entries;\n    int i = 0, index = 0;\n    int total = 0;\n    /* \u7edf\u8ba1\u6709\u6548\u952e\u503c\u5bf9\u6570\u91cf */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    entries = malloc(sizeof(Pair) * total);\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            entries[index].key = hmap-&gt;buckets[i]-&gt;key;\n            entries[index].val = malloc(strlen(hmap-&gt;buckets[i]-&gt;val) + 1);\n            strcpy(entries[index].val, hmap-&gt;buckets[i]-&gt;val);\n            index++;\n        }\n    }\n    set-&gt;set = entries;\n    set-&gt;len = total;\n}\n\n/* \u83b7\u53d6\u6240\u6709\u952e */\nvoid keySet(ArrayHashMap *hmap, MapSet *set) {\n    int *keys;\n    int i = 0, index = 0;\n    int total = 0;\n    /* \u7edf\u8ba1\u6709\u6548\u952e\u503c\u5bf9\u6570\u91cf */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    keys = malloc(total * sizeof(int));\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            keys[index] = hmap-&gt;buckets[i]-&gt;key;\n            index++;\n        }\n    }\n    set-&gt;set = keys;\n    set-&gt;len = total;\n}\n\n/* \u83b7\u53d6\u6240\u6709\u503c */\nvoid valueSet(ArrayHashMap *hmap, MapSet *set) {\n    char **vals;\n    int i = 0, index = 0;\n    int total = 0;\n    /* \u7edf\u8ba1\u6709\u6548\u952e\u503c\u5bf9\u6570\u91cf */\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            total++;\n        }\n    }\n    vals = malloc(total * sizeof(char *));\n    for (i = 0; i &lt; MAX_SIZE; i++) {\n        if (hmap-&gt;buckets[i] != NULL) {\n            vals[index] = hmap-&gt;buckets[i]-&gt;val;\n            index++;\n        }\n    }\n    set-&gt;set = vals;\n    set-&gt;len = total;\n}\n\n/* \u6253\u5370\u54c8\u5e0c\u8868 */\nvoid print(ArrayHashMap *hmap) {\n    int i;\n    MapSet set;\n    pairSet(hmap, &amp;set);\n    Pair *entries = (Pair *)set.set;\n    for (i = 0; i &lt; set.len; i++) {\n        printf(\"%d -&gt; %s\\n\", entries[i].key, entries[i].val);\n    }\n    free(set.set);\n}\n</code></pre> array_hash_map.kt<pre><code>/* \u952e\u503c\u5bf9 */\nclass Pair(\n    var key: Int,\n    var _val: String\n)\n\n/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 */\nclass ArrayHashMap {\n    // \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n    private val buckets = arrayOfNulls&lt;Pair&gt;(100)\n\n    /* \u54c8\u5e0c\u51fd\u6570 */\n    fun hashFunc(key: Int): Int {\n        val index = key % 100\n        return index\n    }\n\n    /* \u67e5\u8be2\u64cd\u4f5c */\n    fun get(key: Int): String? {\n        val index = hashFunc(key)\n        val pair = buckets[index] ?: return null\n        return pair._val\n    }\n\n    /* \u6dfb\u52a0\u64cd\u4f5c */\n    fun put(key: Int, _val: String) {\n        val pair = Pair(key, _val)\n        val index = hashFunc(key)\n        buckets[index] = pair\n    }\n\n    /* \u5220\u9664\u64cd\u4f5c */\n    fun remove(key: Int) {\n        val index = hashFunc(key)\n        // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n        buckets[index] = null\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 */\n    fun pairSet(): MutableList&lt;Pair&gt; {\n        val pairSet = mutableListOf&lt;Pair&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                pairSet.add(pair)\n        }\n        return pairSet\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u952e */\n    fun keySet(): MutableList&lt;Int&gt; {\n        val keySet = mutableListOf&lt;Int&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                keySet.add(pair.key)\n        }\n        return keySet\n    }\n\n    /* \u83b7\u53d6\u6240\u6709\u503c */\n    fun valueSet(): MutableList&lt;String&gt; {\n        val valueSet = mutableListOf&lt;String&gt;()\n        for (pair in buckets) {\n            if (pair != null)\n                valueSet.add(pair._val)\n        }\n        return valueSet\n    }\n\n    /* \u6253\u5370\u54c8\u5e0c\u8868 */\n    fun print() {\n        for (kv in pairSet()) {\n            val key = kv.key\n            val _val = kv._val\n            println(\"$key -&gt; $_val\")\n        }\n    }\n}\n</code></pre> array_hash_map.rb<pre><code>### \u952e\u503c\u5bf9 ###\nclass Pair\n  attr_accessor :key, :val\n\n  def initialize(key, val)\n    @key = key\n    @val = val\n  end\nend\n\n### \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868 ###\nclass ArrayHashMap\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    # \u521d\u59cb\u5316\u6570\u7ec4\uff0c\u5305\u542b 100 \u4e2a\u6876\n    @buckets = Array.new(100)\n  end\n\n  ### \u54c8\u5e0c\u51fd\u6570 ###\n  def hash_func(key)\n    index = key % 100\n  end\n\n  ### \u67e5\u8be2\u64cd\u4f5c ###\n  def get(key)\n    index = hash_func(key)\n    pair = @buckets[index]\n\n    return if pair.nil?\n    pair.val\n  end\n\n  ### \u6dfb\u52a0\u64cd\u4f5c ###\n  def put(key, val)\n    pair = Pair.new(key, val)\n    index = hash_func(key)\n    @buckets[index] = pair\n  end\n\n  ### \u5220\u9664\u64cd\u4f5c ###\n  def remove(key)\n    index = hash_func(key)\n    # \u7f6e\u4e3a nil \uff0c\u4ee3\u8868\u5220\u9664\n    @buckets[index] = nil\n  end\n\n  ### \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9 ###\n  def entry_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair unless pair.nil? }\n    result\n  end\n\n  ### \u83b7\u53d6\u6240\u6709\u952e ###\n  def key_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair.key unless pair.nil? }\n    result\n  end\n\n  ### \u83b7\u53d6\u6240\u6709\u503c ###\n  def value_set\n    result = []\n    @buckets.each { |pair| result &lt;&lt; pair.val unless pair.nil? }\n    result\n  end\n\n  ### \u6253\u5370\u54c8\u5e0c\u8868 ###\n  def print\n    @buckets.each { |pair| puts \"#{pair.key} -&gt; #{pair.val}\" unless pair.nil? }\n  end\nend\n</code></pre> array_hash_map.zig<pre><code>// \u952e\u503c\u5bf9\nconst Pair = struct {\n    key: usize = undefined,\n    val: []const u8 = undefined,\n\n   pub fn init(key: usize, val: []const u8) Pair {\n        return Pair {\n            .key = key,\n            .val = val,\n        };\n    }\n};\n\n// \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u54c8\u5e0c\u8868\nfn ArrayHashMap(comptime T: type) type {\n    return struct {\n        bucket: ?std.ArrayList(?T) = null,\n        mem_allocator: std.mem.Allocator = undefined,\n\n        const Self = @This();\n\n        // \u6784\u9020\u51fd\u6570\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            self.mem_allocator = allocator;\n            // \u521d\u59cb\u5316\u4e00\u4e2a\u957f\u5ea6\u4e3a 100 \u7684\u6876\uff08\u6570\u7ec4\uff09\n            self.bucket = std.ArrayList(?T).init(self.mem_allocator);\n            var i: i32 = 0;\n            while (i &lt; 100) : (i += 1) {\n                try self.bucket.?.append(null);\n            }\n        }\n\n        // \u6790\u6784\u51fd\u6570\n        pub fn deinit(self: *Self) void {\n            if (self.bucket != null) self.bucket.?.deinit();\n        }\n\n        // \u54c8\u5e0c\u51fd\u6570\n        fn hashFunc(key: usize) usize {\n            var index = key % 100;\n            return index;\n        }\n\n        // \u67e5\u8be2\u64cd\u4f5c\n        pub fn get(self: *Self, key: usize) []const u8 {\n            var index = hashFunc(key);\n            var pair = self.bucket.?.items[index];\n            return pair.?.val;\n        }\n\n        // \u6dfb\u52a0\u64cd\u4f5c\n        pub fn put(self: *Self, key: usize, val: []const u8) !void {\n            var pair = Pair.init(key, val);\n            var index = hashFunc(key);\n            self.bucket.?.items[index] = pair;\n        }\n\n        // \u5220\u9664\u64cd\u4f5c\n        pub fn remove(self: *Self, key: usize) !void {\n            var index = hashFunc(key);\n            // \u7f6e\u4e3a null \uff0c\u4ee3\u8868\u5220\u9664\n            self.bucket.?.items[index] = null;\n        }       \n\n        // \u83b7\u53d6\u6240\u6709\u952e\u503c\u5bf9\n        pub fn pairSet(self: *Self) !std.ArrayList(T) {\n            var entry_set = std.ArrayList(T).init(self.mem_allocator);\n            for (self.bucket.?.items) |item| {\n                if (item == null) continue;\n                try entry_set.append(item.?);\n            }\n            return entry_set;\n        }  \n\n        // \u83b7\u53d6\u6240\u6709\u952e\n        pub fn keySet(self: *Self) !std.ArrayList(usize) {\n            var key_set = std.ArrayList(usize).init(self.mem_allocator);\n            for (self.bucket.?.items) |item| {\n                if (item == null) continue;\n                try key_set.append(item.?.key);\n            }\n            return key_set;\n        }  \n\n        // \u83b7\u53d6\u6240\u6709\u503c\n        pub fn valueSet(self: *Self) !std.ArrayList([]const u8) {\n            var value_set = std.ArrayList([]const u8).init(self.mem_allocator);\n            for (self.bucket.?.items) |item| {\n                if (item == null) continue;\n                try value_set.append(item.?.val);\n            }\n            return value_set;\n        }\n\n        // \u6253\u5370\u54c8\u5e0c\u8868\n        pub fn print(self: *Self) !void {\n            var entry_set = try self.pairSet();\n            defer entry_set.deinit();\n            for (entry_set.items) |item| {\n                std.debug.print(\"{} -&gt; {s}\\n\", .{item.key, item.val});\n            }\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_hashing/hash_map/#613-hash-collision-and-resizing","title":"6.1.3 \u00a0 Hash collision and resizing","text":"<p>Fundamentally, the role of the hash function is to map the entire input space of all keys to the output space of all array indices. However, the input space is often much larger than the output space. Therefore, theoretically, there must be situations where \"multiple inputs correspond to the same output\".</p> <p>For the hash function in the above example, if the last two digits of the input <code>key</code> are the same, the output of the hash function will also be the same. For example, when querying for students with student numbers 12836 and 20336, we find:</p> <pre><code>12836 % 100 = 36\n20336 % 100 = 36\n</code></pre> <p>As shown in Figure 6-3, both student numbers point to the same name, which is obviously incorrect. This situation where multiple inputs correspond to the same output is known as hash collision.</p> <p></p> <p> Figure 6-3 \u00a0 Example of hash collision </p> <p>It is easy to understand that the larger the capacity \\(n\\) of the hash table, the lower the probability of multiple keys being allocated to the same bucket, and the fewer the collisions. Therefore, expanding the capacity of the hash table can reduce hash collisions.</p> <p>As shown in Figure 6-4, before expansion, key-value pairs <code>(136, A)</code> and <code>(236, D)</code> collided; after expansion, the collision is resolved.</p> <p></p> <p> Figure 6-4 \u00a0 Hash table expansion </p> <p>Similar to array expansion, resizing a hash table requires migrating all key-value pairs from the original hash table to the new one, which is time-consuming. Furthermore, since the capacity <code>capacity</code> of the hash table changes, we need to recalculate the storage positions of all key-value pairs using the hash function, which adds to the computational overhead of the resizing process. Therefore, programming languages often reserve a sufficiently large capacity for the hash table to prevent frequent resizing.</p> <p>The load factor is an important concept for hash tables. It is defined as the ratio of the number of elements in the hash table to the number of buckets. It is used to measure the severity of hash collisions and is often used as a trigger for resizing the hash table. For example, in Java, when the load factor exceeds \\(0.75\\), the system will resize the hash table to twice its original size.</p>"},{"location":"chapter_hashing/summary/","title":"6.4 \u00a0 Summary","text":""},{"location":"chapter_hashing/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>Given an input <code>key</code>, a hash table can retrieve the corresponding <code>value</code> in \\(O(1)\\) time, which is highly efficient.</li> <li>Common hash table operations include querying, adding key-value pairs, deleting key-value pairs, and traversing the hash table.</li> <li>The hash function maps a <code>key</code> to an array index, allowing access to the corresponding bucket and retrieval of the <code>value</code>.</li> <li>Two different keys may end up with the same array index after hashing, leading to erroneous query results. This phenomenon is known as hash collision.</li> <li>The larger the capacity of the hash table, the lower the probability of hash collisions. Therefore, hash table resizing can mitigate hash collisions. Similar to array resizing, hash table resizing is costly.</li> <li>The load factor, defined as the number of elements divided by the number of buckets, reflects the severity of hash collisions and is often used as a condition to trigger hash table resizing.</li> <li>Chaining addresses hash collisions by converting each element into a linked list, storing all colliding elements in the same list. However, excessively long lists can reduce query efficiency, which can be improved by converting the lists into red-black trees.</li> <li>Open addressing handles hash collisions through multiple probes. Linear probing uses a fixed step size but it cannot delete elements and is prone to clustering. Multiple hashing uses several hash functions for probing which reduces clustering compared to linear probing but increases computational overhead.</li> <li>Different programming languages adopt various hash table implementations. For example, Java's <code>HashMap</code> uses chaining, while Python's <code>dict</code> employs open addressing.</li> <li>In hash tables, we desire hash algorithms with determinism, high efficiency, and uniform distribution. In cryptography, hash algorithms should also possess collision resistance and the avalanche effect.</li> <li>Hash algorithms typically use large prime numbers as moduli to ensure uniform distribution of hash values and reduce hash collisions.</li> <li>Common hash algorithms include MD5, SHA-1, SHA-2, and SHA-3. MD5 is often used for file integrity checks, while SHA-2 is commonly used in secure applications and protocols.</li> <li>Programming languages usually provide built-in hash algorithms for data types to calculate bucket indices in hash tables. Generally, only immutable objects are hashable.</li> </ul>"},{"location":"chapter_hashing/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: When does the time complexity of a hash table degrade to \\(O(n)\\)?</p> <p>The time complexity of a hash table can degrade to \\(O(n)\\) when hash collisions are severe. When the hash function is well-designed, the capacity is set appropriately, and collisions are evenly distributed, the time complexity is \\(O(1)\\). We usually consider the time complexity to be \\(O(1)\\) when using built-in hash tables in programming languages.</p> <p>Q: Why not use the hash function \\(f(x) = x\\)? This would eliminate collisions.</p> <p>Under the hash function \\(f(x) = x\\), each element corresponds to a unique bucket index, which is equivalent to an array. However, the input space is usually much larger than the output space (array length), so the last step of a hash function is often to take the modulo of the array length. In other words, the goal of a hash table is to map a larger state space to a smaller one while providing \\(O(1)\\) query efficiency.</p> <p>Q: Why can hash tables be more efficient than arrays, linked lists, or binary trees, even though hash tables are implemented using these structures?</p> <p>Firstly, hash tables have higher time efficiency but lower space efficiency. A significant portion of memory in hash tables remains unused.</p> <p>Secondly, hash tables are only more time-efficient in specific use cases. If a feature can be implemented with the same time complexity using an array or a linked list, it's usually faster than using a hash table. This is because the computation of the hash function incurs overhead, making the constant factor in the time complexity larger.</p> <p>Lastly, the time complexity of hash tables can degrade. For example, in chaining, we perform search operations in a linked list or red-black tree, which still risks degrading to \\(O(n)\\) time.</p> <p>Q: Does multiple hashing also have the flaw of not being able to delete elements directly? Can space marked as deleted be reused?</p> <p>Multiple hashing is a form of open addressing, and all open addressing methods have the drawback of not being able to delete elements directly; they require marking elements as deleted. Marked spaces can be reused. When inserting new elements into the hash table, and the hash function points to a position marked as deleted, that position can be used by the new element. This maintains the probing sequence of the hash table while ensuring efficient use of space.</p> <p>Q: Why do hash collisions occur during the search process in linear probing?</p> <p>During the search process, the hash function points to the corresponding bucket and key-value pair. If the <code>key</code> doesn't match, it indicates a hash collision. Therefore, linear probing will search downwards at a predetermined step size until the correct key-value pair is found or the search fails.</p> <p>Q: Why can resizing a hash table alleviate hash collisions?</p> <p>The last step of a hash function often involves taking the modulo of the array length \\(n\\), to keep the output within the array index range. When resizing, the array length \\(n\\) changes, and the indices corresponding to the keys may also change. Keys that were previously mapped to the same bucket might be distributed across multiple buckets after resizing, thereby mitigating hash collisions.</p>"},{"location":"chapter_heap/","title":"Chapter 8. \u00a0 Heap","text":"<p>Abstract</p> <p>The heap is like mountain peaks, stacked and undulating, each with its unique shape.</p> <p>Among these peaks, the highest one always catches the eye first.</p>"},{"location":"chapter_heap/#chapter-contents","title":"Chapter contents","text":"<ul> <li>8.1 \u00a0 Heap</li> <li>8.2 \u00a0 Building a heap</li> <li>8.3 \u00a0 Top-k problem</li> <li>8.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_heap/build_heap/","title":"8.2 \u00a0 Heap construction operation","text":"<p>In some cases, we want to build a heap using all elements of a list, and this process is known as \"heap construction operation.\"</p>"},{"location":"chapter_heap/build_heap/#821-implementing-with-heap-insertion-operation","title":"8.2.1 \u00a0 Implementing with heap insertion operation","text":"<p>First, we create an empty heap and then iterate through the list, performing the \"heap insertion operation\" on each element in turn. This means adding the element to the end of the heap and then \"heapifying\" it from bottom to top.</p> <p>Each time an element is added to the heap, the length of the heap increases by one. Since nodes are added to the binary tree from top to bottom, the heap is constructed \"from top to bottom.\"</p> <p>Let the number of elements be \\(n\\), and each element's insertion operation takes \\(O(\\log{n})\\) time, thus the time complexity of this heap construction method is \\(O(n \\log n)\\).</p>"},{"location":"chapter_heap/build_heap/#822-implementing-by-heapifying-through-traversal","title":"8.2.2 \u00a0 Implementing by heapifying through traversal","text":"<p>In fact, we can implement a more efficient method of heap construction in two steps.</p> <ol> <li>Add all elements of the list as they are into the heap, at this point the properties of the heap are not yet satisfied.</li> <li>Traverse the heap in reverse order (reverse of level-order traversal), and perform \"top to bottom heapify\" on each non-leaf node.</li> </ol> <p>After heapifying a node, the subtree with that node as the root becomes a valid sub-heap. Since the traversal is in reverse order, the heap is built \"from bottom to top.\"</p> <p>The reason for choosing reverse traversal is that it ensures the subtree below the current node is already a valid sub-heap, making the heapification of the current node effective.</p> <p>It's worth mentioning that since leaf nodes have no children, they naturally form valid sub-heaps and do not need to be heapified. As shown in the following code, the last non-leaf node is the parent of the last node; we start from it and traverse in reverse order to perform heapification:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_heap.py<pre><code>def __init__(self, nums: list[int]):\n    \"\"\"\u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806\"\"\"\n    # \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    self.max_heap = nums\n    # \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in range(self.parent(self.size() - 1), -1, -1):\n        self.sift_down(i)\n</code></pre> my_heap.cpp<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nMaxHeap(vector&lt;int&gt; nums) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    maxHeap = nums;\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = parent(size() - 1); i &gt;= 0; i--) {\n        siftDown(i);\n    }\n}\n</code></pre> my_heap.java<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nMaxHeap(List&lt;Integer&gt; nums) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    maxHeap = new ArrayList&lt;&gt;(nums);\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = parent(size() - 1); i &gt;= 0; i--) {\n        siftDown(i);\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* \u6784\u9020\u51fd\u6570\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nMaxHeap(IEnumerable&lt;int&gt; nums) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    maxHeap = new List&lt;int&gt;(nums);\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    var size = Parent(this.Size() - 1);\n    for (int i = size; i &gt;= 0; i--) {\n        SiftDown(i);\n    }\n}\n</code></pre> my_heap.go<pre><code>/* \u6784\u9020\u51fd\u6570\uff0c\u6839\u636e\u5207\u7247\u5efa\u5806 */\nfunc newMaxHeap(nums []any) *maxHeap {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    h := &amp;maxHeap{data: nums}\n    for i := h.parent(len(h.data) - 1); i &gt;= 0; i-- {\n        // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n        h.siftDown(i)\n    }\n    return h\n}\n</code></pre> my_heap.swift<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\ninit(nums: [Int]) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    maxHeap = nums\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in (0 ... parent(i: size() - 1)).reversed() {\n        siftDown(i: i)\n    }\n}\n</code></pre> my_heap.js<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u5efa\u7acb\u7a7a\u5806\u6216\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nconstructor(nums) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    this.#maxHeap = nums === undefined ? [] : [...nums];\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (let i = this.#parent(this.size() - 1); i &gt;= 0; i--) {\n        this.#siftDown(i);\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u5efa\u7acb\u7a7a\u5806\u6216\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nconstructor(nums?: number[]) {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    this.maxHeap = nums === undefined ? [] : [...nums];\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (let i = this.parent(this.size() - 1); i &gt;= 0; i--) {\n        this.siftDown(i);\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nMaxHeap(List&lt;int&gt; nums) {\n  // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n  _maxHeap = nums;\n  // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n  for (int i = _parent(size() - 1); i &gt;= 0; i--) {\n    siftDown(i);\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\nfn new(nums: Vec&lt;i32&gt;) -&gt; Self {\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    let mut heap = MaxHeap { max_heap: nums };\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in (0..=Self::parent(heap.size() - 1)).rev() {\n        heap.sift_down(i);\n    }\n    heap\n}\n</code></pre> my_heap.c<pre><code>/* \u6784\u9020\u51fd\u6570\uff0c\u6839\u636e\u5207\u7247\u5efa\u5806 */\nMaxHeap *newMaxHeap(int nums[], int size) {\n    // \u6240\u6709\u5143\u7d20\u5165\u5806\n    MaxHeap *maxHeap = (MaxHeap *)malloc(sizeof(MaxHeap));\n    maxHeap-&gt;size = size;\n    memcpy(maxHeap-&gt;data, nums, size * sizeof(int));\n    for (int i = parent(maxHeap, size - 1); i &gt;= 0; i--) {\n        // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n        siftDown(maxHeap, i);\n    }\n    return maxHeap;\n}\n</code></pre> my_heap.kt<pre><code>/* \u5927\u9876\u5806 */\nclass MaxHeap(nums: MutableList&lt;Int&gt;?) {\n    // \u4f7f\u7528\u5217\u8868\u800c\u975e\u6570\u7ec4\uff0c\u8fd9\u6837\u65e0\u987b\u8003\u8651\u6269\u5bb9\u95ee\u9898\n    private val maxHeap = mutableListOf&lt;Int&gt;()\n\n    /* \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806 */\n    init {\n        // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n        maxHeap.addAll(nums!!)\n        // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n        for (i in parent(size() - 1) downTo 0) {\n            siftDown(i)\n        }\n    }\n\n    /* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    private fun left(i: Int): Int {\n        return 2 * i + 1\n    }\n\n    /* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    private fun right(i: Int): Int {\n        return 2 * i + 2\n    }\n\n    /* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    private fun parent(i: Int): Int {\n        return (i - 1) / 2 // \u5411\u4e0b\u6574\u9664\n    }\n\n    /* \u4ea4\u6362\u5143\u7d20 */\n    private fun swap(i: Int, j: Int) {\n        val temp = maxHeap[i]\n        maxHeap[i] = maxHeap[j]\n        maxHeap[j] = temp\n    }\n\n    /* \u83b7\u53d6\u5806\u5927\u5c0f */\n    fun size(): Int {\n        return maxHeap.size\n    }\n\n    /* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        /* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\n        return size() == 0\n    }\n\n    /* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\n    fun peek(): Int {\n        return maxHeap[0]\n    }\n\n    /* \u5143\u7d20\u5165\u5806 */\n    fun push(_val: Int) {\n        // \u6dfb\u52a0\u8282\u70b9\n        maxHeap.add(_val)\n        // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n        siftUp(size() - 1)\n    }\n\n    /* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\n    private fun siftUp(it: Int) {\n        // Kotlin\u7684\u51fd\u6570\u53c2\u6570\u4e0d\u53ef\u53d8\uff0c\u56e0\u6b64\u521b\u5efa\u4e34\u65f6\u53d8\u91cf\n        var i = it\n        while (true) {\n            // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n            val p = parent(i)\n            // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n            if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p]) break\n            // \u4ea4\u6362\u4e24\u8282\u70b9\n            swap(i, p)\n            // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n            i = p\n        }\n    }\n\n    /* \u5143\u7d20\u51fa\u5806 */\n    fun pop(): Int {\n        // \u5224\u7a7a\u5904\u7406\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        swap(0, size() - 1)\n        // \u5220\u9664\u8282\u70b9\n        val _val = maxHeap.removeAt(size() - 1)\n        // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n        siftDown(0)\n        // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n        return _val\n    }\n\n    /* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\n    private fun siftDown(it: Int) {\n        // Kotlin\u7684\u51fd\u6570\u53c2\u6570\u4e0d\u53ef\u53d8\uff0c\u56e0\u6b64\u521b\u5efa\u4e34\u65f6\u53d8\u91cf\n        var i = it\n        while (true) {\n            // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n            val l = left(i)\n            val r = right(i)\n            var ma = i\n            if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma]) ma = l\n            if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma]) ma = r\n            // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n            if (ma == i) break\n            // \u4ea4\u6362\u4e24\u8282\u70b9\n            swap(i, ma)\n            // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n            i = ma\n        }\n    }\n\n    /* \u6253\u5370\u5806\uff08\u4e8c\u53c9\u6811\uff09 */\n    fun print() {\n        val queue = PriorityQueue { a: Int, b: Int -&gt; b - a }\n        queue.addAll(maxHeap)\n        printHeap(queue)\n    }\n}\n</code></pre> my_heap.rb<pre><code>[class]{MaxHeap}-[func]{__init__}\n</code></pre> my_heap.zig<pre><code>// \u6784\u9020\u65b9\u6cd5\uff0c\u6839\u636e\u8f93\u5165\u5217\u8868\u5efa\u5806\nfn init(self: *Self, allocator: std.mem.Allocator, nums: []const T) !void {\n    if (self.max_heap != null) return;\n    self.max_heap = std.ArrayList(T).init(allocator);\n    // \u5c06\u5217\u8868\u5143\u7d20\u539f\u5c01\u4e0d\u52a8\u6dfb\u52a0\u8fdb\u5806\n    try self.max_heap.?.appendSlice(nums);\n    // \u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    var i: usize = parent(self.size() - 1) + 1;\n    while (i &gt; 0) : (i -= 1) {\n        try self.siftDown(i - 1);\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_heap/build_heap/#823-complexity-analysis","title":"8.2.3 \u00a0 Complexity analysis","text":"<p>Next, let's attempt to calculate the time complexity of this second method of heap construction.</p> <ul> <li>Assuming the number of nodes in the complete binary tree is \\(n\\), then the number of leaf nodes is \\((n + 1) / 2\\), where \\(/\\) is integer division. Therefore, the number of nodes that need to be heapified is \\((n - 1) / 2\\).</li> <li>In the process of \"top to bottom heapification,\" each node is heapified to the leaf nodes at most, so the maximum number of iterations is the height of the binary tree \\(\\log n\\).</li> </ul> <p>Multiplying the two, we get the time complexity of the heap construction process as \\(O(n \\log n)\\). But this estimate is not accurate, because it does not take into account the nature of the binary tree having far more nodes at the lower levels than at the top.</p> <p>Let's perform a more accurate calculation. To simplify the calculation, assume a \"perfect binary tree\" with \\(n\\) nodes and height \\(h\\); this assumption does not affect the correctness of the result.</p> <p></p> <p> Figure 8-5 \u00a0 Node counts at each level of a perfect binary tree </p> <p>As shown in Figure 8-5, the maximum number of iterations for a node \"to be heapified from top to bottom\" is equal to the distance from that node to the leaf nodes, which is precisely \"node height.\" Therefore, we can sum the \"number of nodes \\(\\times\\) node height\" at each level, to get the total number of heapification iterations for all nodes.</p> \\[ T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{(h-1)}\\times1 \\] <p>To simplify the above equation, we need to use knowledge of sequences from high school, first multiply \\(T(h)\\) by \\(2\\), to get:</p> \\[ \\begin{aligned} T(h) &amp; = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{h-1}\\times1 \\newline 2T(h) &amp; = 2^1h + 2^2(h-1) + 2^3(h-2) + \\dots + 2^h\\times1 \\newline \\end{aligned} \\] <p>By subtracting \\(T(h)\\) from \\(2T(h)\\) using the method of displacement, we get:</p> \\[ 2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \\dots + 2^{h-1} + 2^h \\] <p>Observing the equation, \\(T(h)\\) is an geometric series, which can be directly calculated using the sum formula, resulting in a time complexity of:</p> \\[ \\begin{aligned} T(h) &amp; = 2 \\frac{1 - 2^h}{1 - 2} - h \\newline &amp; = 2^{h+1} - h - 2 \\newline &amp; = O(2^h) \\end{aligned} \\] <p>Further, a perfect binary tree with height \\(h\\) has \\(n = 2^{h+1} - 1\\) nodes, thus the complexity is \\(O(2^h) = O(n)\\). This calculation shows that the time complexity of inputting a list and constructing a heap is \\(O(n)\\), which is very efficient.</p>"},{"location":"chapter_heap/heap/","title":"8.1 \u00a0 Heap","text":"<p>A heap is a complete binary tree that satisfies specific conditions and can be mainly divided into two types, as shown in Figure 8-1.</p> <ul> <li>Min heap: The value of any node \\(\\leq\\) the values of its child nodes.</li> <li>Max heap: The value of any node \\(\\geq\\) the values of its child nodes.</li> </ul> <p></p> <p> Figure 8-1 \u00a0 Min heap and max heap </p> <p>As a special case of a complete binary tree, heaps have the following characteristics:</p> <ul> <li>The bottom layer nodes are filled from left to right, and nodes in other layers are fully filled.</li> <li>The root node of the binary tree is called the \"heap top,\" and the bottom-rightmost node is called the \"heap bottom.\"</li> <li>For max heaps (min heaps), the value of the heap top element (root node) is the largest (smallest).</li> </ul>"},{"location":"chapter_heap/heap/#811-common-operations-on-heaps","title":"8.1.1 \u00a0 Common operations on heaps","text":"<p>It should be noted that many programming languages provide a priority queue, which is an abstract data structure defined as a queue with priority sorting.</p> <p>In fact, heaps are often used to implement priority queues, with max heaps equivalent to priority queues where elements are dequeued in descending order. From a usage perspective, we can consider \"priority queue\" and \"heap\" as equivalent data structures. Therefore, this book does not make a special distinction between the two, uniformly referring to them as \"heap.\"</p> <p>Common operations on heaps are shown in Table 8-1, and the method names depend on the programming language.</p> <p> Table 8-1 \u00a0 Efficiency of Heap Operations </p> Method name Description Time complexity <code>push()</code> Add an element to the heap \\(O(\\log n)\\) <code>pop()</code> Remove the top element from the heap \\(O(\\log n)\\) <code>peek()</code> Access the top element (for max/min heap, the max/min value) \\(O(1)\\) <code>size()</code> Get the number of elements in the heap \\(O(1)\\) <code>isEmpty()</code> Check if the heap is empty \\(O(1)\\) <p>In practice, we can directly use the heap class (or priority queue class) provided by programming languages.</p> <p>Similar to sorting algorithms where we have \"ascending order\" and \"descending order,\" we can switch between \"min heap\" and \"max heap\" by setting a <code>flag</code> or modifying the <code>Comparator</code>. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig heap.py<pre><code># \u521d\u59cb\u5316\u5c0f\u9876\u5806\nmin_heap, flag = [], 1\n# \u521d\u59cb\u5316\u5927\u9876\u5806\nmax_heap, flag = [], -1\n\n# Python \u7684 heapq \u6a21\u5757\u9ed8\u8ba4\u5b9e\u73b0\u5c0f\u9876\u5806\n# \u8003\u8651\u5c06\u201c\u5143\u7d20\u53d6\u8d1f\u201d\u540e\u518d\u5165\u5806\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u5927\u5c0f\u5173\u7cfb\u98a0\u5012\uff0c\u4ece\u800c\u5b9e\u73b0\u5927\u9876\u5806\n# \u5728\u672c\u793a\u4f8b\u4e2d\uff0cflag = 1 \u65f6\u5bf9\u5e94\u5c0f\u9876\u5806\uff0cflag = -1 \u65f6\u5bf9\u5e94\u5927\u9876\u5806\n\n# \u5143\u7d20\u5165\u5806\nheapq.heappush(max_heap, flag * 1)\nheapq.heappush(max_heap, flag * 3)\nheapq.heappush(max_heap, flag * 2)\nheapq.heappush(max_heap, flag * 5)\nheapq.heappush(max_heap, flag * 4)\n\n# \u83b7\u53d6\u5806\u9876\u5143\u7d20\npeek: int = flag * max_heap[0] # 5\n\n# \u5806\u9876\u5143\u7d20\u51fa\u5806\n# \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\nval = flag * heapq.heappop(max_heap) # 5\nval = flag * heapq.heappop(max_heap) # 4\nval = flag * heapq.heappop(max_heap) # 3\nval = flag * heapq.heappop(max_heap) # 2\nval = flag * heapq.heappop(max_heap) # 1\n\n# \u83b7\u53d6\u5806\u5927\u5c0f\nsize: int = len(max_heap)\n\n# \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a\nis_empty: bool = not max_heap\n\n# \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806\nmin_heap: list[int] = [1, 3, 2, 5, 4]\nheapq.heapify(min_heap)\n</code></pre> heap.cpp<pre><code>/* \u521d\u59cb\u5316\u5806 */\n// \u521d\u59cb\u5316\u5c0f\u9876\u5806\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n// \u521d\u59cb\u5316\u5927\u9876\u5806\npriority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;\n\n/* \u5143\u7d20\u5165\u5806 */\nmaxHeap.push(1);\nmaxHeap.push(3);\nmaxHeap.push(2);\nmaxHeap.push(5);\nmaxHeap.push(4);\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nint peek = maxHeap.top(); // 5\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n// \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\nmaxHeap.pop(); // 5\nmaxHeap.pop(); // 4\nmaxHeap.pop(); // 3\nmaxHeap.pop(); // 2\nmaxHeap.pop(); // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nint size = maxHeap.size();\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nbool isEmpty = maxHeap.empty();\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nvector&lt;int&gt; input{1, 3, 2, 5, 4};\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap(input.begin(), input.end());\n</code></pre> heap.java<pre><code>/* \u521d\u59cb\u5316\u5806 */\n// \u521d\u59cb\u5316\u5c0f\u9876\u5806\nQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n// \u521d\u59cb\u5316\u5927\u9876\u5806\uff08\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u4fee\u6539 Comparator \u5373\u53ef\uff09\nQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\n\n/* \u5143\u7d20\u5165\u5806 */\nmaxHeap.offer(1);\nmaxHeap.offer(3);\nmaxHeap.offer(2);\nmaxHeap.offer(5);\nmaxHeap.offer(4);\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nint peek = maxHeap.peek(); // 5\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n// \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\npeek = maxHeap.poll(); // 5\npeek = maxHeap.poll(); // 4\npeek = maxHeap.poll(); // 3\npeek = maxHeap.poll(); // 2\npeek = maxHeap.poll(); // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nint size = maxHeap.size();\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nboolean isEmpty = maxHeap.isEmpty();\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nminHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4));\n</code></pre> heap.cs<pre><code>/* \u521d\u59cb\u5316\u5806 */\n// \u521d\u59cb\u5316\u5c0f\u9876\u5806\nPriorityQueue&lt;int, int&gt; minHeap = new();\n// \u521d\u59cb\u5316\u5927\u9876\u5806\uff08\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u4fee\u6539 Comparator \u5373\u53ef\uff09\nPriorityQueue&lt;int, int&gt; maxHeap = new(Comparer&lt;int&gt;.Create((x, y) =&gt; y - x));\n\n/* \u5143\u7d20\u5165\u5806 */\nmaxHeap.Enqueue(1, 1);\nmaxHeap.Enqueue(3, 3);\nmaxHeap.Enqueue(2, 2);\nmaxHeap.Enqueue(5, 5);\nmaxHeap.Enqueue(4, 4);\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nint peek = maxHeap.Peek();//5\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n// \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\npeek = maxHeap.Dequeue();  // 5\npeek = maxHeap.Dequeue();  // 4\npeek = maxHeap.Dequeue();  // 3\npeek = maxHeap.Dequeue();  // 2\npeek = maxHeap.Dequeue();  // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nint size = maxHeap.Count;\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nbool isEmpty = maxHeap.Count == 0;\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nminHeap = new PriorityQueue&lt;int, int&gt;([(1, 1), (3, 3), (2, 2), (5, 5), (4, 4)]);\n</code></pre> heap.go<pre><code>// Go \u8bed\u8a00\u4e2d\u53ef\u4ee5\u901a\u8fc7\u5b9e\u73b0 heap.Interface \u6765\u6784\u5efa\u6574\u6570\u5927\u9876\u5806\n// \u5b9e\u73b0 heap.Interface \u9700\u8981\u540c\u65f6\u5b9e\u73b0 sort.Interface\ntype intHeap []any\n\n// Push heap.Interface \u7684\u65b9\u6cd5\uff0c\u5b9e\u73b0\u63a8\u5165\u5143\u7d20\u5230\u5806\nfunc (h *intHeap) Push(x any) {\n    // Push \u548c Pop \u4f7f\u7528 pointer receiver \u4f5c\u4e3a\u53c2\u6570\n    // \u56e0\u4e3a\u5b83\u4eec\u4e0d\u4ec5\u4f1a\u5bf9\u5207\u7247\u7684\u5185\u5bb9\u8fdb\u884c\u8c03\u6574\uff0c\u8fd8\u4f1a\u4fee\u6539\u5207\u7247\u7684\u957f\u5ea6\u3002\n    *h = append(*h, x.(int))\n}\n\n// Pop heap.Interface \u7684\u65b9\u6cd5\uff0c\u5b9e\u73b0\u5f39\u51fa\u5806\u9876\u5143\u7d20\nfunc (h *intHeap) Pop() any {\n    // \u5f85\u51fa\u5806\u5143\u7d20\u5b58\u653e\u5728\u6700\u540e\n    last := (*h)[len(*h)-1]\n    *h = (*h)[:len(*h)-1]\n    return last\n}\n\n// Len sort.Interface \u7684\u65b9\u6cd5\nfunc (h *intHeap) Len() int {\n    return len(*h)\n}\n\n// Less sort.Interface \u7684\u65b9\u6cd5\nfunc (h *intHeap) Less(i, j int) bool {\n    // \u5982\u679c\u5b9e\u73b0\u5c0f\u9876\u5806\uff0c\u5219\u9700\u8981\u8c03\u6574\u4e3a\u5c0f\u4e8e\u53f7\n    return (*h)[i].(int) &gt; (*h)[j].(int)\n}\n\n// Swap sort.Interface \u7684\u65b9\u6cd5\nfunc (h *intHeap) Swap(i, j int) {\n    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n}\n\n// Top \u83b7\u53d6\u5806\u9876\u5143\u7d20\nfunc (h *intHeap) Top() any {\n    return (*h)[0]\n}\n\n/* Driver Code */\nfunc TestHeap(t *testing.T) {\n    /* \u521d\u59cb\u5316\u5806 */\n    // \u521d\u59cb\u5316\u5927\u9876\u5806\n    maxHeap := &amp;intHeap{}\n    heap.Init(maxHeap)\n    /* \u5143\u7d20\u5165\u5806 */\n    // \u8c03\u7528 heap.Interface \u7684\u65b9\u6cd5\uff0c\u6765\u6dfb\u52a0\u5143\u7d20\n    heap.Push(maxHeap, 1)\n    heap.Push(maxHeap, 3)\n    heap.Push(maxHeap, 2)\n    heap.Push(maxHeap, 4)\n    heap.Push(maxHeap, 5)\n\n    /* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\n    top := maxHeap.Top()\n    fmt.Printf(\"\u5806\u9876\u5143\u7d20\u4e3a %d\\n\", top)\n\n    /* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n    // \u8c03\u7528 heap.Interface \u7684\u65b9\u6cd5\uff0c\u6765\u79fb\u9664\u5143\u7d20\n    heap.Pop(maxHeap) // 5\n    heap.Pop(maxHeap) // 4\n    heap.Pop(maxHeap) // 3\n    heap.Pop(maxHeap) // 2\n    heap.Pop(maxHeap) // 1\n\n    /* \u83b7\u53d6\u5806\u5927\u5c0f */\n    size := len(*maxHeap)\n    fmt.Printf(\"\u5806\u5143\u7d20\u6570\u91cf\u4e3a %d\\n\", size)\n\n    /* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\n    isEmpty := len(*maxHeap) == 0\n    fmt.Printf(\"\u5806\u662f\u5426\u4e3a\u7a7a %t\\n\", isEmpty)\n}\n</code></pre> heap.swift<pre><code>/* \u521d\u59cb\u5316\u5806 */\n// Swift \u7684 Heap \u7c7b\u578b\u540c\u65f6\u652f\u6301\u6700\u5927\u5806\u548c\u6700\u5c0f\u5806\uff0c\u4e14\u9700\u8981\u5f15\u5165 swift-collections\nvar heap = Heap&lt;Int&gt;()\n\n/* \u5143\u7d20\u5165\u5806 */\nheap.insert(1)\nheap.insert(3)\nheap.insert(2)\nheap.insert(5)\nheap.insert(4)\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nvar peek = heap.max()!\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\npeek = heap.removeMax() // 5\npeek = heap.removeMax() // 4\npeek = heap.removeMax() // 3\npeek = heap.removeMax() // 2\npeek = heap.removeMax() // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nlet size = heap.count\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nlet isEmpty = heap.isEmpty\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nlet heap2 = Heap([1, 3, 2, 5, 4])\n</code></pre> heap.js<pre><code>// JavaScript \u672a\u63d0\u4f9b\u5185\u7f6e Heap \u7c7b\n</code></pre> heap.ts<pre><code>// TypeScript \u672a\u63d0\u4f9b\u5185\u7f6e Heap \u7c7b\n</code></pre> heap.dart<pre><code>// Dart \u672a\u63d0\u4f9b\u5185\u7f6e Heap \u7c7b\n</code></pre> heap.rs<pre><code>use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n/* \u521d\u59cb\u5316\u5806 */\n// \u521d\u59cb\u5316\u5c0f\u9876\u5806\nlet mut min_heap = BinaryHeap::&lt;Reverse&lt;i32&gt;&gt;::new();\n// \u521d\u59cb\u5316\u5927\u9876\u5806\nlet mut max_heap = BinaryHeap::new();\n\n/* \u5143\u7d20\u5165\u5806 */\nmax_heap.push(1);\nmax_heap.push(3);\nmax_heap.push(2);\nmax_heap.push(5);\nmax_heap.push(4);\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nlet peek = max_heap.peek().unwrap();  // 5\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n// \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\nlet peek = max_heap.pop().unwrap();   // 5\nlet peek = max_heap.pop().unwrap();   // 4\nlet peek = max_heap.pop().unwrap();   // 3\nlet peek = max_heap.pop().unwrap();   // 2\nlet peek = max_heap.pop().unwrap();   // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nlet size = max_heap.len();\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nlet is_empty = max_heap.is_empty();\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nlet min_heap = BinaryHeap::from(vec![Reverse(1), Reverse(3), Reverse(2), Reverse(5), Reverse(4)]);\n</code></pre> heap.c<pre><code>// C \u672a\u63d0\u4f9b\u5185\u7f6e Heap \u7c7b\n</code></pre> heap.kt<pre><code>/* \u521d\u59cb\u5316\u5806 */\n// \u521d\u59cb\u5316\u5c0f\u9876\u5806\nvar minHeap = PriorityQueue&lt;Int&gt;()\n// \u521d\u59cb\u5316\u5927\u9876\u5806\uff08\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u4fee\u6539 Comparator \u5373\u53ef\uff09\nval maxHeap = PriorityQueue { a: Int, b: Int -&gt; b - a }\n\n/* \u5143\u7d20\u5165\u5806 */\nmaxHeap.offer(1)\nmaxHeap.offer(3)\nmaxHeap.offer(2)\nmaxHeap.offer(5)\nmaxHeap.offer(4)\n\n/* \u83b7\u53d6\u5806\u9876\u5143\u7d20 */\nvar peek = maxHeap.peek() // 5\n\n/* \u5806\u9876\u5143\u7d20\u51fa\u5806 */\n// \u51fa\u5806\u5143\u7d20\u4f1a\u5f62\u6210\u4e00\u4e2a\u4ece\u5927\u5230\u5c0f\u7684\u5e8f\u5217\npeek = maxHeap.poll() // 5\npeek = maxHeap.poll() // 4\npeek = maxHeap.poll() // 3\npeek = maxHeap.poll() // 2\npeek = maxHeap.poll() // 1\n\n/* \u83b7\u53d6\u5806\u5927\u5c0f */\nval size = maxHeap.size\n\n/* \u5224\u65ad\u5806\u662f\u5426\u4e3a\u7a7a */\nval isEmpty = maxHeap.isEmpty()\n\n/* \u8f93\u5165\u5217\u8868\u5e76\u5efa\u5806 */\nminHeap = PriorityQueue(mutableListOf(1, 3, 2, 5, 4))\n</code></pre> heap.rb<pre><code>\n</code></pre> heap.zig<pre><code>\n</code></pre> \u53ef\u89c6\u5316\u8fd0\u884c <p>https://pythontutor.com/render.html#code=import%20heapq%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B0%8F%E9%A1%B6%E5%A0%86%0A%20%20%20%20min_heap,%20flag%20%3D%20%5B%5D,%201%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20max_heap,%20flag%20%3D%20%5B%5D,%20-1%0A%20%20%20%20%0A%20%20%20%20%23%20Python%20%E7%9A%84%20heapq%20%E6%A8%A1%E5%9D%97%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E5%B0%8F%E9%A1%B6%E5%A0%86%0A%20%20%20%20%23%20%E8%80%83%E8%99%91%E5%B0%86%E2%80%9C%E5%85%83%E7%B4%A0%E5%8F%96%E8%B4%9F%E2%80%9D%E5%90%8E%E5%86%8D%E5%85%A5%E5%A0%86%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB%E9%A2%A0%E5%80%92%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20%23%20%E5%9C%A8%E6%9C%AC%E7%A4%BA%E4%BE%8B%E4%B8%AD%EF%BC%8Cflag%20%3D%201%20%E6%97%B6%E5%AF%B9%E5%BA%94%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%8Cflag%20%3D%20-1%20%E6%97%B6%E5%AF%B9%E5%BA%94%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E5%A0%86%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%201%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%203%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%202%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%205%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%204%29%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%0A%20%20%20%20peek%20%3D%20flag%20*%20max_heap%5B0%5D%20%23%205%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%87%BA%E5%A0%86%0A%20%20%20%20%23%20%E5%87%BA%E5%A0%86%E5%85%83%E7%B4%A0%E4%BC%9A%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E7%9A%84%E5%BA%8F%E5%88%97%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%205%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%204%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%203%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%202%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%201%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%A0%86%E5%A4%A7%E5%B0%8F%0A%20%20%20%20size%20%3D%20len%28max_heap%29%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E5%A0%86%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20not%20max_heap%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%BE%93%E5%85%A5%E5%88%97%E8%A1%A8%E5%B9%B6%E5%BB%BA%E5%A0%86%0A%20%20%20%20min_heap%20%3D%20%5B1,%203,%202,%205,%204%5D%0A%20%20%20%20heapq.heapify%28min_heap%29&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_heap/heap/#812-implementation-of-heaps","title":"8.1.2 \u00a0 Implementation of heaps","text":"<p>The following implementation is of a max heap. To convert it into a min heap, simply invert all size logic comparisons (for example, replace \\(\\geq\\) with \\(\\leq\\)). Interested readers are encouraged to implement it on their own.</p>"},{"location":"chapter_heap/heap/#1-storage-and-representation-of-heaps","title":"1. \u00a0 Storage and representation of heaps","text":"<p>As mentioned in the \"Binary Trees\" section, complete binary trees are well-suited for array representation. Since heaps are a type of complete binary tree, we will use arrays to store heaps.</p> <p>When using an array to represent a binary tree, elements represent node values, and indexes represent node positions in the binary tree. Node pointers are implemented through an index mapping formula.</p> <p>As shown in Figure 8-2, given an index \\(i\\), the index of its left child is \\(2i + 1\\), the index of its right child is \\(2i + 2\\), and the index of its parent is \\((i - 1) / 2\\) (floor division). When the index is out of bounds, it signifies a null node or the node does not exist.</p> <p></p> <p> Figure 8-2 \u00a0 Representation and storage of heaps </p> <p>We can encapsulate the index mapping formula into functions for convenient later use:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_heap.py<pre><code>def left(self, i: int) -&gt; int:\n    \"\"\"\u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n    return 2 * i + 1\n\ndef right(self, i: int) -&gt; int:\n    \"\"\"\u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n    return 2 * i + 2\n\ndef parent(self, i: int) -&gt; int:\n    \"\"\"\u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n    return (i - 1) // 2  # \u5411\u4e0b\u6574\u9664\n</code></pre> my_heap.cpp<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint left(int i) {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint right(int i) {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nint parent(int i) {\n    return (i - 1) / 2; // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.java<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint left(int i) {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint right(int i) {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nint parent(int i) {\n    return (i - 1) / 2; // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.cs<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint Left(int i) {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint Right(int i) {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nint Parent(int i) {\n    return (i - 1) / 2; // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.go<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (h *maxHeap) left(i int) int {\n    return 2*i + 1\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (h *maxHeap) right(i int) int {\n    return 2*i + 2\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (h *maxHeap) parent(i int) int {\n    // \u5411\u4e0b\u6574\u9664\n    return (i - 1) / 2\n}\n</code></pre> my_heap.swift<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc left(i: Int) -&gt; Int {\n    2 * i + 1\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc right(i: Int) -&gt; Int {\n    2 * i + 2\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc parent(i: Int) -&gt; Int {\n    (i - 1) / 2 // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.js<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n#left(i) {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n#right(i) {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n#parent(i) {\n    return Math.floor((i - 1) / 2); // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.ts<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nleft(i: number): number {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nright(i: number): number {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nparent(i: number): number {\n    return Math.floor((i - 1) / 2); // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.dart<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint _left(int i) {\n  return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint _right(int i) {\n  return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nint _parent(int i) {\n  return (i - 1) ~/ 2; // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.rs<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfn left(i: usize) -&gt; usize {\n    2 * i + 1\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfn right(i: usize) -&gt; usize {\n    2 * i + 2\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nfn parent(i: usize) -&gt; usize {\n    (i - 1) / 2 // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.c<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint left(MaxHeap *maxHeap, int i) {\n    return 2 * i + 1;\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nint right(MaxHeap *maxHeap, int i) {\n    return 2 * i + 2;\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nint parent(MaxHeap *maxHeap, int i) {\n    return (i - 1) / 2; // \u5411\u4e0b\u53d6\u6574\n}\n</code></pre> my_heap.kt<pre><code>/* \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfun left(i: Int): Int {\n    return 2 * i + 1\n}\n\n/* \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfun right(i: Int): Int {\n    return 2 * i + 2\n}\n\n/* \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nfun parent(i: Int): Int {\n    return (i - 1) / 2 // \u5411\u4e0b\u6574\u9664\n}\n</code></pre> my_heap.rb<pre><code>### \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 ###\ndef left(i)\n  2 * i + 1\nend\n\n### \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 ###\ndef right(i)\n  2 * i + 2\nend\n\n### \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15 ###\ndef parent(i)\n  (i - 1) / 2     # \u5411\u4e0b\u6574\u9664\nend\n</code></pre> my_heap.zig<pre><code>// \u83b7\u53d6\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\nfn left(i: usize) usize {\n    return 2 * i + 1;\n}\n\n// \u83b7\u53d6\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\nfn right(i: usize) usize {\n    return 2 * i + 2;\n}\n\n// \u83b7\u53d6\u7236\u8282\u70b9\u7684\u7d22\u5f15\nfn parent(i: usize) usize {\n    // return (i - 1) / 2; // \u5411\u4e0b\u6574\u9664\n    return @divFloor(i - 1, 2);\n}\n</code></pre>"},{"location":"chapter_heap/heap/#2-accessing-the-top-element-of-the-heap","title":"2. \u00a0 Accessing the top element of the heap","text":"<p>The top element of the heap is the root node of the binary tree, which is also the first element of the list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_heap.py<pre><code>def peek(self) -&gt; int:\n    \"\"\"\u8bbf\u95ee\u5806\u9876\u5143\u7d20\"\"\"\n    return self.max_heap[0]\n</code></pre> my_heap.cpp<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint peek() {\n    return maxHeap[0];\n}\n</code></pre> my_heap.java<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint peek() {\n    return maxHeap.get(0);\n}\n</code></pre> my_heap.cs<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint Peek() {\n    return maxHeap[0];\n}\n</code></pre> my_heap.go<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfunc (h *maxHeap) peek() any {\n    return h.data[0]\n}\n</code></pre> my_heap.swift<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfunc peek() -&gt; Int {\n    maxHeap[0]\n}\n</code></pre> my_heap.js<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\npeek() {\n    return this.#maxHeap[0];\n}\n</code></pre> my_heap.ts<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\npeek(): number {\n    return this.maxHeap[0];\n}\n</code></pre> my_heap.dart<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint peek() {\n  return _maxHeap[0];\n}\n</code></pre> my_heap.rs<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfn peek(&amp;self) -&gt; Option&lt;i32&gt; {\n    self.max_heap.first().copied()\n}\n</code></pre> my_heap.c<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint peek(MaxHeap *maxHeap) {\n    return maxHeap-&gt;data[0];\n}\n</code></pre> my_heap.kt<pre><code>/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfun peek(): Int {\n    return maxHeap[0]\n}\n</code></pre> my_heap.rb<pre><code>### \u8bbf\u95ee\u5806\u9876\u5143\u7d20 ###\ndef peek\n  @max_heap[0]\nend\n</code></pre> my_heap.zig<pre><code>// \u8bbf\u95ee\u5806\u9876\u5143\u7d20\nfn peek(self: *Self) T {\n    return self.max_heap.?.items[0];\n}  \n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_heap/heap/#3-inserting-an-element-into-the-heap","title":"3. \u00a0 Inserting an element into the heap","text":"<p>Given an element <code>val</code>, we first add it to the bottom of the heap. After addition, since <code>val</code> may be larger than other elements in the heap, the heap's integrity might be compromised, thus it's necessary to repair the path from the inserted node to the root node. This operation is called heapifying.</p> <p>Considering starting from the node inserted, perform heapify from bottom to top. As shown in Figure 8-3, we compare the value of the inserted node with its parent node, and if the inserted node is larger, we swap them. Then continue this operation, repairing each node in the heap from bottom to top until passing the root node or encountering a node that does not need to be swapped.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-3 \u00a0 Steps of element insertion into the heap </p> <p>Given a total of \\(n\\) nodes, the height of the tree is \\(O(\\log n)\\). Hence, the loop iterations for the heapify operation are at most \\(O(\\log n)\\), making the time complexity of the element insertion operation \\(O(\\log n)\\). The code is as shown:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_heap.py<pre><code>def push(self, val: int):\n    \"\"\"\u5143\u7d20\u5165\u5806\"\"\"\n    # \u6dfb\u52a0\u8282\u70b9\n    self.max_heap.append(val)\n    # \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    self.sift_up(self.size() - 1)\n\ndef sift_up(self, i: int):\n    \"\"\"\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316\"\"\"\n    while True:\n        # \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        p = self.parent(i)\n        # \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if p &lt; 0 or self.max_heap[i] &lt;= self.max_heap[p]:\n            break\n        # \u4ea4\u6362\u4e24\u8282\u70b9\n        self.swap(i, p)\n        # \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p\n</code></pre> my_heap.cpp<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid push(int val) {\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap.push_back(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    siftUp(size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nvoid siftUp(int i) {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        int p = parent(i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p])\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(maxHeap[i], maxHeap[p]);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.java<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid push(int val) {\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap.add(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    siftUp(size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nvoid siftUp(int i) {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        int p = parent(i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || maxHeap.get(i) &lt;= maxHeap.get(p))\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid Push(int val) {\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap.Add(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    SiftUp(Size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nvoid SiftUp(int i) {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        int p = Parent(i);\n        // \u82e5\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\uff0c\u5219\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p])\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        Swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.go<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfunc (h *maxHeap) push(val any) {\n    // \u6dfb\u52a0\u8282\u70b9\n    h.data = append(h.data, val)\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    h.siftUp(len(h.data) - 1)\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nfunc (h *maxHeap) siftUp(i int) {\n    for true {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        p := h.parent(i)\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if p &lt; 0 || h.data[i].(int) &lt;= h.data[p].(int) {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        h.swap(i, p)\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p\n    }\n}\n</code></pre> my_heap.swift<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfunc push(val: Int) {\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap.append(val)\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    siftUp(i: size() - 1)\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nfunc siftUp(i: Int) {\n    var i = i\n    while true {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        let p = parent(i: i)\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if p &lt; 0 || maxHeap[i] &lt;= maxHeap[p] {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i: i, j: p)\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p\n    }\n}\n</code></pre> my_heap.js<pre><code>/* \u5143\u7d20\u5165\u5806 */\npush(val) {\n    // \u6dfb\u52a0\u8282\u70b9\n    this.#maxHeap.push(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    this.#siftUp(this.size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\n#siftUp(i) {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        const p = this.#parent(i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || this.#maxHeap[i] &lt;= this.#maxHeap[p]) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        this.#swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* \u5143\u7d20\u5165\u5806 */\npush(val: number): void {\n    // \u6dfb\u52a0\u8282\u70b9\n    this.maxHeap.push(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    this.siftUp(this.size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nsiftUp(i: number): void {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        const p = this.parent(i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || this.maxHeap[i] &lt;= this.maxHeap[p]) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        this.swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid push(int val) {\n  // \u6dfb\u52a0\u8282\u70b9\n  _maxHeap.add(val);\n  // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n  siftUp(size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nvoid siftUp(int i) {\n  while (true) {\n    // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n    int p = _parent(i);\n    // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n    if (p &lt; 0 || _maxHeap[i] &lt;= _maxHeap[p]) {\n      break;\n    }\n    // \u4ea4\u6362\u4e24\u8282\u70b9\n    _swap(i, p);\n    // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n    i = p;\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfn push(&amp;mut self, val: i32) {\n    // \u6dfb\u52a0\u8282\u70b9\n    self.max_heap.push(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    self.sift_up(self.size() - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nfn sift_up(&amp;mut self, mut i: usize) {\n    loop {\n        // \u8282\u70b9 i \u5df2\u7ecf\u662f\u5806\u9876\u8282\u70b9\u4e86\uff0c\u7ed3\u675f\u5806\u5316\n        if i == 0 {\n            break;\n        }\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        let p = Self::parent(i);\n        // \u5f53\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if self.max_heap[i] &lt;= self.max_heap[p] {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        self.swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.c<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid push(MaxHeap *maxHeap, int val) {\n    // \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u4e0d\u5e94\u8be5\u6dfb\u52a0\u8fd9\u4e48\u591a\u8282\u70b9\n    if (maxHeap-&gt;size == MAX_SIZE) {\n        printf(\"heap is full!\");\n        return;\n    }\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap-&gt;data[maxHeap-&gt;size] = val;\n    maxHeap-&gt;size++;\n\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    siftUp(maxHeap, maxHeap-&gt;size - 1);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nvoid siftUp(MaxHeap *maxHeap, int i) {\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        int p = parent(maxHeap, i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || maxHeap-&gt;data[i] &lt;= maxHeap-&gt;data[p]) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(maxHeap, i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> my_heap.kt<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfun push(_val: Int) {\n    // \u6dfb\u52a0\u8282\u70b9\n    maxHeap.add(_val)\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    siftUp(size() - 1)\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 */\nfun siftUp(it: Int) {\n    // Kotlin\u7684\u51fd\u6570\u53c2\u6570\u4e0d\u53ef\u53d8\uff0c\u56e0\u6b64\u521b\u5efa\u4e34\u65f6\u53d8\u91cf\n    var i = it\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        val p = parent(i)\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 || maxHeap[i] &lt;= maxHeap[p]) break\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i, p)\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p\n    }\n}\n</code></pre> my_heap.rb<pre><code>### \u5143\u7d20\u5165\u5806 ###\ndef push(val)\n  # \u6dfb\u52a0\u8282\u70b9\n  @max_heap &lt;&lt; val\n  # \u4ece\u5e95\u81f3\u9876\u5806\u5316\n  sift_up(size - 1)\nend\n\n### \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316 ###\ndef sift_up(i)\n  loop do\n    # \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n    p = parent(i)\n    # \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n    break if p &lt; 0 || @max_heap[i] &lt;= @max_heap[p]\n    # \u4ea4\u6362\u4e24\u8282\u70b9\n    swap(i, p)\n    # \u5faa\u73af\u5411\u4e0a\u5806\u5316\n    i = p\n  end\nend\n</code></pre> my_heap.zig<pre><code>// \u5143\u7d20\u5165\u5806\nfn push(self: *Self, val: T) !void {\n    // \u6dfb\u52a0\u8282\u70b9\n    try self.max_heap.?.append(val);\n    // \u4ece\u5e95\u81f3\u9876\u5806\u5316\n    try self.siftUp(self.size() - 1);\n}  \n\n// \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u5e95\u81f3\u9876\u5806\u5316\nfn siftUp(self: *Self, i_: usize) !void {\n    var i = i_;\n    while (true) {\n        // \u83b7\u53d6\u8282\u70b9 i \u7684\u7236\u8282\u70b9\n        var p = parent(i);\n        // \u5f53\u201c\u8d8a\u8fc7\u6839\u8282\u70b9\u201d\u6216\u201c\u8282\u70b9\u65e0\u987b\u4fee\u590d\u201d\u65f6\uff0c\u7ed3\u675f\u5806\u5316\n        if (p &lt; 0 or self.max_heap.?.items[i] &lt;= self.max_heap.?.items[p]) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        try self.swap(i, p);\n        // \u5faa\u73af\u5411\u4e0a\u5806\u5316\n        i = p;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_heap/heap/#4-removing-the-top-element-from-the-heap","title":"4. \u00a0 Removing the top element from the heap","text":"<p>The top element of the heap is the root node of the binary tree, that is, the first element of the list. If we directly remove the first element from the list, all node indexes in the binary tree would change, making it difficult to use heapify for repairs subsequently. To minimize changes in element indexes, we use the following steps.</p> <ol> <li>Swap the top element with the bottom element of the heap (swap the root node with the rightmost leaf node).</li> <li>After swapping, remove the bottom of the heap from the list (note, since it has been swapped, what is actually being removed is the original top element).</li> <li>Starting from the root node, perform heapify from top to bottom.</li> </ol> <p>As shown in Figure 8-4, the direction of \"heapify from top to bottom\" is opposite to \"heapify from bottom to top\". We compare the value of the root node with its two children and swap it with the largest child. Then repeat this operation until passing the leaf node or encountering a node that does not need to be swapped.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-4 \u00a0 Steps of removing the top element from the heap </p> <p>Similar to the element insertion operation, the time complexity of the top element removal operation is also \\(O(\\log n)\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig my_heap.py<pre><code>def pop(self) -&gt; int:\n    \"\"\"\u5143\u7d20\u51fa\u5806\"\"\"\n    # \u5224\u7a7a\u5904\u7406\n    if self.is_empty():\n        raise IndexError(\"\u5806\u4e3a\u7a7a\")\n    # \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    self.swap(0, self.size() - 1)\n    # \u5220\u9664\u8282\u70b9\n    val = self.max_heap.pop()\n    # \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    self.sift_down(0)\n    # \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val\n\ndef sift_down(self, i: int):\n    \"\"\"\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316\"\"\"\n    while True:\n        # \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        l, r, ma = self.left(i), self.right(i), i\n        if l &lt; self.size() and self.max_heap[l] &gt; self.max_heap[ma]:\n            ma = l\n        if r &lt; self.size() and self.max_heap[r] &gt; self.max_heap[ma]:\n            ma = r\n        # \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i:\n            break\n        # \u4ea4\u6362\u4e24\u8282\u70b9\n        self.swap(i, ma)\n        # \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n</code></pre> my_heap.cpp<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nvoid pop() {\n    // \u5224\u7a7a\u5904\u7406\n    if (isEmpty()) {\n        throw out_of_range(\"\u5806\u4e3a\u7a7a\");\n    }\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    swap(maxHeap[0], maxHeap[size() - 1]);\n    // \u5220\u9664\u8282\u70b9\n    maxHeap.pop_back();\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    siftDown(0);\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = left(i), r = right(i), ma = i;\n        if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])\n            ma = l;\n        if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i)\n            break;\n        swap(maxHeap[i], maxHeap[ma]);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.java<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nint pop() {\n    // \u5224\u7a7a\u5904\u7406\n    if (isEmpty())\n        throw new IndexOutOfBoundsException();\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    swap(0, size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    int val = maxHeap.remove(size() - 1);\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    siftDown(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = left(i), r = right(i), ma = i;\n        if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))\n            ma = l;\n        if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i)\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.cs<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nint Pop() {\n    // \u5224\u7a7a\u5904\u7406\n    if (IsEmpty())\n        throw new IndexOutOfRangeException();\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    Swap(0, Size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    int val = maxHeap.Last();\n    maxHeap.RemoveAt(Size() - 1);\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    SiftDown(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid SiftDown(int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = Left(i), r = Right(i), ma = i;\n        if (l &lt; Size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])\n            ma = l;\n        if (r &lt; Size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])\n            ma = r;\n        // \u82e5\u201c\u8282\u70b9 i \u6700\u5927\u201d\u6216\u201c\u8d8a\u8fc7\u53f6\u8282\u70b9\u201d\uff0c\u5219\u7ed3\u675f\u5806\u5316\n        if (ma == i) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        Swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.go<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nfunc (h *maxHeap) pop() any {\n    // \u5224\u7a7a\u5904\u7406\n    if h.isEmpty() {\n        fmt.Println(\"error\")\n        return nil\n    }\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    h.swap(0, h.size()-1)\n    // \u5220\u9664\u8282\u70b9\n    val := h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    h.siftDown(0)\n\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunc (h *maxHeap) siftDown(i int) {\n    for true {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a max\n        l, r, max := h.left(i), h.right(i), i\n        if l &lt; h.size() &amp;&amp; h.data[l].(int) &gt; h.data[max].(int) {\n            max = l\n        }\n        if r &lt; h.size() &amp;&amp; h.data[r].(int) &gt; h.data[max].(int) {\n            max = r\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if max == i {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        h.swap(i, max)\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = max\n    }\n}\n</code></pre> my_heap.swift<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nfunc pop() -&gt; Int {\n    // \u5224\u7a7a\u5904\u7406\n    if isEmpty() {\n        fatalError(\"\u5806\u4e3a\u7a7a\")\n    }\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    swap(i: 0, j: size() - 1)\n    // \u5220\u9664\u8282\u70b9\n    let val = maxHeap.remove(at: size() - 1)\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    siftDown(i: 0)\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunc siftDown(i: Int) {\n    var i = i\n    while true {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let l = left(i: i)\n        let r = right(i: i)\n        var ma = i\n        if l &lt; size(), maxHeap[l] &gt; maxHeap[ma] {\n            ma = l\n        }\n        if r &lt; size(), maxHeap[r] &gt; maxHeap[ma] {\n            ma = r\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i: i, j: ma)\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n    }\n}\n</code></pre> my_heap.js<pre><code>/* \u5143\u7d20\u51fa\u5806 */\npop() {\n    // \u5224\u7a7a\u5904\u7406\n    if (this.isEmpty()) throw new Error('\u5806\u4e3a\u7a7a');\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    this.#swap(0, this.size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    const val = this.#maxHeap.pop();\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    this.#siftDown(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\n#siftDown(i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        const l = this.#left(i),\n            r = this.#right(i);\n        let ma = i;\n        if (l &lt; this.size() &amp;&amp; this.#maxHeap[l] &gt; this.#maxHeap[ma]) ma = l;\n        if (r &lt; this.size() &amp;&amp; this.#maxHeap[r] &gt; this.#maxHeap[ma]) ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma === i) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        this.#swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.ts<pre><code>/* \u5143\u7d20\u51fa\u5806 */\npop(): number {\n    // \u5224\u7a7a\u5904\u7406\n    if (this.isEmpty()) throw new RangeError('Heap is empty.');\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    this.swap(0, this.size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    const val = this.maxHeap.pop();\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    this.siftDown(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nsiftDown(i: number): void {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        const l = this.left(i),\n            r = this.right(i);\n        let ma = i;\n        if (l &lt; this.size() &amp;&amp; this.maxHeap[l] &gt; this.maxHeap[ma]) ma = l;\n        if (r &lt; this.size() &amp;&amp; this.maxHeap[r] &gt; this.maxHeap[ma]) ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma === i) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        this.swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.dart<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nint pop() {\n  // \u5224\u7a7a\u5904\u7406\n  if (isEmpty()) throw Exception('\u5806\u4e3a\u7a7a');\n  // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n  _swap(0, size() - 1);\n  // \u5220\u9664\u8282\u70b9\n  int val = _maxHeap.removeLast();\n  // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n  siftDown(0);\n  // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n  return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(int i) {\n  while (true) {\n    // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n    int l = _left(i);\n    int r = _right(i);\n    int ma = i;\n    if (l &lt; size() &amp;&amp; _maxHeap[l] &gt; _maxHeap[ma]) ma = l;\n    if (r &lt; size() &amp;&amp; _maxHeap[r] &gt; _maxHeap[ma]) ma = r;\n    // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n    if (ma == i) break;\n    // \u4ea4\u6362\u4e24\u8282\u70b9\n    _swap(i, ma);\n    // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n    i = ma;\n  }\n}\n</code></pre> my_heap.rs<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nfn pop(&amp;mut self) -&gt; i32 {\n    // \u5224\u7a7a\u5904\u7406\n    if self.is_empty() {\n        panic!(\"index out of bounds\");\n    }\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    self.swap(0, self.size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    let val = self.max_heap.pop().unwrap();\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    self.sift_down(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    val\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfn sift_down(&amp;mut self, mut i: usize) {\n    loop {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let (l, r, mut ma) = (Self::left(i), Self::right(i), i);\n        if l &lt; self.size() &amp;&amp; self.max_heap[l] &gt; self.max_heap[ma] {\n            ma = l;\n        }\n        if r &lt; self.size() &amp;&amp; self.max_heap[r] &gt; self.max_heap[ma] {\n            ma = r;\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        self.swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> my_heap.c<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nint pop(MaxHeap *maxHeap) {\n    // \u5224\u7a7a\u5904\u7406\n    if (isEmpty(maxHeap)) {\n        printf(\"heap is empty!\");\n        return INT_MAX;\n    }\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    swap(maxHeap, 0, size(maxHeap) - 1);\n    // \u5220\u9664\u8282\u70b9\n    int val = maxHeap-&gt;data[maxHeap-&gt;size - 1];\n    maxHeap-&gt;size--;\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    siftDown(maxHeap, 0);\n\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(MaxHeap *maxHeap, int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a max\n        int l = left(maxHeap, i);\n        int r = right(maxHeap, i);\n        int max = i;\n        if (l &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[l] &gt; maxHeap-&gt;data[max]) {\n            max = l;\n        }\n        if (r &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[r] &gt; maxHeap-&gt;data[max]) {\n            max = r;\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (max == i) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(maxHeap, i, max);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = max;\n    }\n}\n</code></pre> my_heap.kt<pre><code>/* \u5143\u7d20\u51fa\u5806 */\nfun pop(): Int {\n    // \u5224\u7a7a\u5904\u7406\n    if (isEmpty()) throw IndexOutOfBoundsException()\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    swap(0, size() - 1)\n    // \u5220\u9664\u8282\u70b9\n    val _val = maxHeap.removeAt(size() - 1)\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    siftDown(0)\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return _val\n}\n\n/* \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfun siftDown(it: Int) {\n    // Kotlin\u7684\u51fd\u6570\u53c2\u6570\u4e0d\u53ef\u53d8\uff0c\u56e0\u6b64\u521b\u5efa\u4e34\u65f6\u53d8\u91cf\n    var i = it\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        val l = left(i)\n        val r = right(i)\n        var ma = i\n        if (l &lt; size() &amp;&amp; maxHeap[l] &gt; maxHeap[ma]) ma = l\n        if (r &lt; size() &amp;&amp; maxHeap[r] &gt; maxHeap[ma]) ma = r\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i) break\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(i, ma)\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n    }\n}\n</code></pre> my_heap.rb<pre><code>### \u5143\u7d20\u51fa\u5806 ###\ndef pop\n  # \u5224\u7a7a\u5904\u7406\n  raise IndexError, \"\u5806\u4e3a\u7a7a\" if is_empty?\n  # \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n  swap(0, size - 1)\n  # \u5220\u9664\u8282\u70b9\n  val = @max_heap.pop\n  # \u4ece\u9876\u81f3\u5e95\u5806\u5316\n  sift_down(0)\n  # \u8fd4\u56de\u5806\u9876\u5143\u7d20\n  val\nend\n\n### \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 ###\ndef sift_down(i)\n  loop do\n    # \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n    l, r, ma = left(i), right(i), i\n    ma = l if l &lt; size &amp;&amp; @max_heap[l] &gt; @max_heap[ma]\n    ma = r if r &lt; size &amp;&amp; @max_heap[r] &gt; @max_heap[ma]\n\n    # \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n    break if ma == i\n\n    # \u4ea4\u6362\u4e24\u8282\u70b9\n    swap(i, ma)\n    # \u5faa\u73af\u5411\u4e0b\u5806\u5316\n    i = ma\n  end\nend\n</code></pre> my_heap.zig<pre><code>// \u5143\u7d20\u51fa\u5806\nfn pop(self: *Self) !T {\n    // \u5224\u65ad\u5904\u7406\n    if (self.isEmpty()) unreachable;\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    try self.swap(0, self.size() - 1);\n    // \u5220\u9664\u8282\u70b9\n    var val = self.max_heap.?.pop();\n    // \u4ece\u9876\u81f3\u5e95\u5806\u5316\n    try self.siftDown(0);\n    // \u8fd4\u56de\u5806\u9876\u5143\u7d20\n    return val;\n} \n\n// \u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316\nfn siftDown(self: *Self, i_: usize) !void {\n    var i = i_;\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        var l = left(i);\n        var r = right(i);\n        var ma = i;\n        if (l &lt; self.size() and self.max_heap.?.items[l] &gt; self.max_heap.?.items[ma]) ma = l;\n        if (r &lt; self.size() and self.max_heap.?.items[r] &gt; self.max_heap.?.items[ma]) ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i) break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        try self.swap(i, ma);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_heap/heap/#813-common-applications-of-heaps","title":"8.1.3 \u00a0 Common applications of heaps","text":"<ul> <li>Priority Queue: Heaps are often the preferred data structure for implementing priority queues, with both enqueue and dequeue operations having a time complexity of \\(O(\\log n)\\), and building a queue having a time complexity of \\(O(n)\\), all of which are very efficient.</li> <li>Heap Sort: Given a set of data, we can create a heap from them and then continually perform element removal operations to obtain ordered data. However, we usually use a more elegant method to implement heap sort, as detailed in the \"Heap Sort\" section.</li> <li>Finding the Largest \\(k\\) Elements: This is a classic algorithm problem and also a typical application, such as selecting the top 10 hot news for Weibo hot search, picking the top 10 selling products, etc.</li> </ul>"},{"location":"chapter_heap/summary/","title":"8.4 \u00a0 Summary","text":""},{"location":"chapter_heap/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>A heap is a complete binary tree, which can be divided into a max heap and a min heap based on its property. The top element of a max (min) heap is the largest (smallest).</li> <li>A priority queue is defined as a queue with dequeue priority, usually implemented using a heap.</li> <li>Common operations of a heap and their corresponding time complexities include: element insertion into the heap \\(O(\\log n)\\), removing the top element from the heap \\(O(\\log n)\\), and accessing the top element of the heap \\(O(1)\\).</li> <li>A complete binary tree is well-suited to be represented by an array, thus heaps are commonly stored using arrays.</li> <li>Heapify operations are used to maintain the properties of the heap and are used in both heap insertion and removal operations.</li> <li>The time complexity of inserting \\(n\\) elements into a heap and building the heap can be optimized to \\(O(n)\\), which is highly efficient.</li> <li>Top-k is a classic algorithm problem that can be efficiently solved using the heap data structure, with a time complexity of \\(O(n \\log k)\\).</li> </ul>"},{"location":"chapter_heap/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is the \"heap\" in data structures the same concept as the \"heap\" in memory management?</p> <p>The two are not the same concept, even though they are both referred to as \"heap\". The heap in computer system memory is part of dynamic memory allocation, where the program can use it to store data during execution. The program can request a certain amount of heap memory to store complex structures like objects and arrays. When these data are no longer needed, the program needs to release this memory to prevent memory leaks. Compared to stack memory, the management and usage of heap memory need to be more cautious, as improper use may lead to memory leaks and dangling pointers.</p>"},{"location":"chapter_heap/top_k/","title":"8.3 \u00a0 Top-k problem","text":"<p>Question</p> <p>Given an unordered array <code>nums</code> of length \\(n\\), return the largest \\(k\\) elements in the array.</p> <p>For this problem, we will first introduce two straightforward solutions, then explain a more efficient heap-based method.</p>"},{"location":"chapter_heap/top_k/#831-method-1-iterative-selection","title":"8.3.1 \u00a0 Method 1: Iterative selection","text":"<p>We can perform \\(k\\) rounds of iterations as shown in Figure 8-6, extracting the \\(1^{st}\\), \\(2^{nd}\\), \\(\\dots\\), \\(k^{th}\\) largest elements in each round, with a time complexity of \\(O(nk)\\).</p> <p>This method is only suitable when \\(k \\ll n\\), as the time complexity approaches \\(O(n^2)\\) when \\(k\\) is close to \\(n\\), which is very time-consuming.</p> <p></p> <p> Figure 8-6 \u00a0 Iteratively finding the largest k elements </p> <p>Tip</p> <p>When \\(k = n\\), we can obtain a complete ordered sequence, which is equivalent to the \"selection sort\" algorithm.</p>"},{"location":"chapter_heap/top_k/#832-method-2-sorting","title":"8.3.2 \u00a0 Method 2: Sorting","text":"<p>As shown in Figure 8-7, we can first sort the array <code>nums</code> and then return the last \\(k\\) elements, with a time complexity of \\(O(n \\log n)\\).</p> <p>Clearly, this method \"overachieves\" the task, as we only need to find the largest \\(k\\) elements, without the need to sort the other elements.</p> <p></p> <p> Figure 8-7 \u00a0 Sorting to find the largest k elements </p>"},{"location":"chapter_heap/top_k/#833-method-3-heap","title":"8.3.3 \u00a0 Method 3: Heap","text":"<p>We can solve the Top-k problem more efficiently based on heaps, as shown in the following process.</p> <ol> <li>Initialize a min heap, where the top element is the smallest.</li> <li>First, insert the first \\(k\\) elements of the array into the heap.</li> <li>Starting from the \\(k + 1^{th}\\) element, if the current element is greater than the top element of the heap, remove the top element of the heap and insert the current element into the heap.</li> <li>After completing the traversal, the heap contains the largest \\(k\\) elements.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 8-8 \u00a0 Find the largest k elements based on heap </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig top_k.py<pre><code>def top_k_heap(nums: list[int], k: int) -&gt; list[int]:\n    \"\"\"\u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20\"\"\"\n    # \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    heap = []\n    # \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for i in range(k):\n        heapq.heappush(heap, nums[i])\n    # \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for i in range(k, len(nums)):\n        # \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if nums[i] &gt; heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, nums[i])\n    return heap\n</code></pre> top_k.cpp<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; topKHeap(vector&lt;int&gt; &amp;nums, int k) {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (int i = 0; i &lt; k; i++) {\n        heap.push(nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (int i = k; i &lt; nums.size(); i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; heap.top()) {\n            heap.pop();\n            heap.push(nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.java<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nQueue&lt;Integer&gt; topKHeap(int[] nums, int k) {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    Queue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;();\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (int i = 0; i &lt; k; i++) {\n        heap.offer(nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (int i = k; i &lt; nums.length; i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; heap.peek()) {\n            heap.poll();\n            heap.offer(nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.cs<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nPriorityQueue&lt;int, int&gt; TopKHeap(int[] nums, int k) {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    PriorityQueue&lt;int, int&gt; heap = new();\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (int i = 0; i &lt; k; i++) {\n        heap.Enqueue(nums[i], nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (int i = k; i &lt; nums.Length; i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; heap.Peek()) {\n            heap.Dequeue();\n            heap.Enqueue(nums[i], nums[i]);\n        }\n    }\n    return heap;\n}\n</code></pre> top_k.go<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfunc topKHeap(nums []int, k int) *minHeap {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    h := &amp;minHeap{}\n    heap.Init(h)\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for i := 0; i &lt; k; i++ {\n        heap.Push(h, nums[i])\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for i := k; i &lt; len(nums); i++ {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if nums[i] &gt; h.Top().(int) {\n            heap.Pop(h)\n            heap.Push(h, nums[i])\n        }\n    }\n    return h\n}\n</code></pre> top_k.swift<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfunc topKHeap(nums: [Int], k: Int) -&gt; [Int] {\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5c0f\u9876\u5806\uff0c\u5e76\u5c06\u524d k \u4e2a\u5143\u7d20\u5efa\u5806\n    var heap = Heap(nums.prefix(k))\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for i in nums.indices.dropFirst(k) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if nums[i] &gt; heap.min()! {\n            _ = heap.removeMin()\n            heap.insert(nums[i])\n        }\n    }\n    return heap.unordered\n}\n</code></pre> top_k.js<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfunction pushMinHeap(maxHeap, val) {\n    // \u5143\u7d20\u53d6\u53cd\n    maxHeap.push(-val);\n}\n\n/* \u5143\u7d20\u51fa\u5806 */\nfunction popMinHeap(maxHeap) {\n    // \u5143\u7d20\u53d6\u53cd\n    return -maxHeap.pop();\n}\n\n/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfunction peekMinHeap(maxHeap) {\n    // \u5143\u7d20\u53d6\u53cd\n    return -maxHeap.peek();\n}\n\n/* \u53d6\u51fa\u5806\u4e2d\u5143\u7d20 */\nfunction getMinHeap(maxHeap) {\n    // \u5143\u7d20\u53d6\u53cd\n    return maxHeap.getMaxHeap().map((num) =&gt; -num);\n}\n\n/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfunction topKHeap(nums, k) {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    // \u8bf7\u6ce8\u610f\uff1a\u6211\u4eec\u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\uff0c\u4ece\u800c\u7528\u5927\u9876\u5806\u6765\u6a21\u62df\u5c0f\u9876\u5806\n    const maxHeap = new MaxHeap([]);\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (let i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (let i = k; i &lt; nums.length; i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    // \u8fd4\u56de\u5806\u4e2d\u5143\u7d20\n    return getMinHeap(maxHeap);\n}\n</code></pre> top_k.ts<pre><code>/* \u5143\u7d20\u5165\u5806 */\nfunction pushMinHeap(maxHeap: MaxHeap, val: number): void {\n    // \u5143\u7d20\u53d6\u53cd\n    maxHeap.push(-val);\n}\n\n/* \u5143\u7d20\u51fa\u5806 */\nfunction popMinHeap(maxHeap: MaxHeap): number {\n    // \u5143\u7d20\u53d6\u53cd\n    return -maxHeap.pop();\n}\n\n/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nfunction peekMinHeap(maxHeap: MaxHeap): number {\n    // \u5143\u7d20\u53d6\u53cd\n    return -maxHeap.peek();\n}\n\n/* \u53d6\u51fa\u5806\u4e2d\u5143\u7d20 */\nfunction getMinHeap(maxHeap: MaxHeap): number[] {\n    // \u5143\u7d20\u53d6\u53cd\n    return maxHeap.getMaxHeap().map((num: number) =&gt; -num);\n}\n\n/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfunction topKHeap(nums: number[], k: number): number[] {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    // \u8bf7\u6ce8\u610f\uff1a\u6211\u4eec\u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\uff0c\u4ece\u800c\u7528\u5927\u9876\u5806\u6765\u6a21\u62df\u5c0f\u9876\u5806\n    const maxHeap = new MaxHeap([]);\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (let i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (let i = k; i &lt; nums.length; i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    // \u8fd4\u56de\u5806\u4e2d\u5143\u7d20\n    return getMinHeap(maxHeap);\n}\n</code></pre> top_k.dart<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nMinHeap topKHeap(List&lt;int&gt; nums, int k) {\n  // \u521d\u59cb\u5316\u5c0f\u9876\u5806\uff0c\u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n  MinHeap heap = MinHeap(nums.sublist(0, k));\n  // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n  for (int i = k; i &lt; nums.length; i++) {\n    // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n    if (nums[i] &gt; heap.peek()) {\n      heap.pop();\n      heap.push(nums[i]);\n    }\n  }\n  return heap;\n}\n</code></pre> top_k.rs<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfn top_k_heap(nums: Vec&lt;i32&gt;, k: usize) -&gt; BinaryHeap&lt;Reverse&lt;i32&gt;&gt; {\n    // BinaryHeap \u662f\u5927\u9876\u5806\uff0c\u4f7f\u7528 Reverse \u5c06\u5143\u7d20\u53d6\u53cd\uff0c\u4ece\u800c\u5b9e\u73b0\u5c0f\u9876\u5806\n    let mut heap = BinaryHeap::&lt;Reverse&lt;i32&gt;&gt;::new();\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for &amp;num in nums.iter().take(k) {\n        heap.push(Reverse(num));\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for &amp;num in nums.iter().skip(k) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if num &gt; heap.peek().unwrap().0 {\n            heap.pop();\n            heap.push(Reverse(num));\n        }\n    }\n    heap\n}\n</code></pre> top_k.c<pre><code>/* \u5143\u7d20\u5165\u5806 */\nvoid pushMinHeap(MaxHeap *maxHeap, int val) {\n    // \u5143\u7d20\u53d6\u53cd\n    push(maxHeap, -val);\n}\n\n/* \u5143\u7d20\u51fa\u5806 */\nint popMinHeap(MaxHeap *maxHeap) {\n    // \u5143\u7d20\u53d6\u53cd\n    return -pop(maxHeap);\n}\n\n/* \u8bbf\u95ee\u5806\u9876\u5143\u7d20 */\nint peekMinHeap(MaxHeap *maxHeap) {\n    // \u5143\u7d20\u53d6\u53cd\n    return -peek(maxHeap);\n}\n\n/* \u53d6\u51fa\u5806\u4e2d\u5143\u7d20 */\nint *getMinHeap(MaxHeap *maxHeap) {\n    // \u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\u5e76\u5b58\u5165 res \u6570\u7ec4\n    int *res = (int *)malloc(maxHeap-&gt;size * sizeof(int));\n    for (int i = 0; i &lt; maxHeap-&gt;size; i++) {\n        res[i] = -maxHeap-&gt;data[i];\n    }\n    return res;\n}\n\n/* \u53d6\u51fa\u5806\u4e2d\u5143\u7d20 */\nint *getMinHeap(MaxHeap *maxHeap) {\n    // \u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\u5e76\u5b58\u5165 res \u6570\u7ec4\n    int *res = (int *)malloc(maxHeap-&gt;size * sizeof(int));\n    for (int i = 0; i &lt; maxHeap-&gt;size; i++) {\n        res[i] = -maxHeap-&gt;data[i];\n    }\n    return res;\n}\n\n// \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20\u7684\u51fd\u6570\nint *topKHeap(int *nums, int sizeNums, int k) {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    // \u8bf7\u6ce8\u610f\uff1a\u6211\u4eec\u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\uff0c\u4ece\u800c\u7528\u5927\u9876\u5806\u6765\u6a21\u62df\u5c0f\u9876\u5806\n    int *empty = (int *)malloc(0);\n    MaxHeap *maxHeap = newMaxHeap(empty, 0);\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (int i = 0; i &lt; k; i++) {\n        pushMinHeap(maxHeap, nums[i]);\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (int i = k; i &lt; sizeNums; i++) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; peekMinHeap(maxHeap)) {\n            popMinHeap(maxHeap);\n            pushMinHeap(maxHeap, nums[i]);\n        }\n    }\n    int *res = getMinHeap(maxHeap);\n    // \u91ca\u653e\u5185\u5b58\n    delMaxHeap(maxHeap);\n    return res;\n}\n</code></pre> top_k.kt<pre><code>/* \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 */\nfun topKHeap(nums: IntArray, k: Int): Queue&lt;Int&gt; {\n    // \u521d\u59cb\u5316\u5c0f\u9876\u5806\n    val heap = PriorityQueue&lt;Int&gt;()\n    // \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n    for (i in 0..&lt;k) {\n        heap.offer(nums[i])\n    }\n    // \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n    for (i in k..&lt;nums.size) {\n        // \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n        if (nums[i] &gt; heap.peek()) {\n            heap.poll()\n            heap.offer(nums[i])\n        }\n    }\n    return heap\n}\n</code></pre> top_k.rb<pre><code>### \u57fa\u4e8e\u5806\u67e5\u627e\u6570\u7ec4\u4e2d\u6700\u5927\u7684 k \u4e2a\u5143\u7d20 ###\ndef top_k_heap(nums, k)\n  # \u521d\u59cb\u5316\u5c0f\u9876\u5806\n  # \u8bf7\u6ce8\u610f\uff1a\u6211\u4eec\u5c06\u5806\u4e2d\u6240\u6709\u5143\u7d20\u53d6\u53cd\uff0c\u4ece\u800c\u7528\u5927\u9876\u5806\u6765\u6a21\u62df\u5c0f\u9876\u5806\n  max_heap = MaxHeap.new([])\n\n  # \u5c06\u6570\u7ec4\u7684\u524d k \u4e2a\u5143\u7d20\u5165\u5806\n  for i in 0...k\n    push_min_heap(max_heap, nums[i])\n  end\n\n  # \u4ece\u7b2c k+1 \u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u4fdd\u6301\u5806\u7684\u957f\u5ea6\u4e3a k\n  for i in k...nums.length\n    # \u82e5\u5f53\u524d\u5143\u7d20\u5927\u4e8e\u5806\u9876\u5143\u7d20\uff0c\u5219\u5c06\u5806\u9876\u5143\u7d20\u51fa\u5806\u3001\u5f53\u524d\u5143\u7d20\u5165\u5806\n    if nums[i] &gt; peek_min_heap(max_heap)\n      pop_min_heap(max_heap)\n      push_min_heap(max_heap, nums[i])\n    end\n  end\n\n  get_min_heap(max_heap)\nend\n</code></pre> top_k.zig<pre><code>[class]{}-[func]{topKHeap}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>A total of \\(n\\) rounds of heap insertions and deletions are performed, with the maximum heap size being \\(k\\), hence the time complexity is \\(O(n \\log k)\\). This method is very efficient; when \\(k\\) is small, the time complexity tends towards \\(O(n)\\); when \\(k\\) is large, the time complexity will not exceed \\(O(n \\log n)\\).</p> <p>Additionally, this method is suitable for scenarios with dynamic data streams. By continuously adding data, we can maintain the elements within the heap, thereby achieving dynamic updates of the largest \\(k\\) elements.</p>"},{"location":"chapter_hello_algo/","title":"Before starting","text":"<p>A few years ago, I shared the \"Sword for Offer\" problem solutions on LeetCode, receiving encouragement and support from many readers. During interactions with readers, the most common question I encountered was \"how to get started with algorithms.\" Gradually, I developed a keen interest in this question.</p> <p>Directly solving problems seems to be the most popular method \u2014 it's simple, direct, and effective. However, problem-solving is like playing a game of Minesweeper: those with strong self-study abilities can defuse the mines one by one, but those with insufficient basics might end up metaphorically bruised from explosions, retreating step by step in frustration. Going through textbooks is also common, but for those aiming for job applications, the energy spent on thesis writing, resume submissions, and preparation for written tests and interviews leaves little for tackling thick books, turning it into a daunting challenge.</p> <p>If you're facing similar troubles, then this book is lucky to have found you. This book is my answer to the question. While it may not be the best solution, it is at least a positive attempt. This book may not directly land you an offer, but it will guide you through the \"knowledge map\" in data structures and algorithms, help you understand the shapes, sizes, and locations of different \"mines,\" and enable you to master various \"demining methods.\" With these skills, I believe you can solve problems and read literature more comfortably, gradually building a knowledge system.</p> <p>I deeply agree with Professor Feynman's statement: \"Knowledge isn't free. You have to pay attention.\" In this sense, this book is not entirely \"free.\" To not disappoint the precious \"attention\" you pay for this book, I will do my best, dedicating my utmost \"attention\" to this book.</p> <p>Knowing my limitations, although the content of this book has been refined over time, there are surely many errors remaining. I sincerely request critiques and corrections from all teachers and students.</p> <p></p> Hello, Algo! <p>The advent of computers has brought significant changes to the world. With their high-speed computing power and excellent programmability, they have become the ideal medium for executing algorithms and processing data. Whether it's the realistic graphics of video games, the intelligent decisions in autonomous driving, the brilliant Go games of AlphaGo, or the natural interactions of ChatGPT, these applications are all exquisite demonstrations of algorithms at work on computers.</p> <p>In fact, before the advent of computers, algorithms and data structures already existed in every corner of the world. Early algorithms were relatively simple, such as ancient counting methods and tool-making procedures. As civilization progressed, algorithms became more refined and complex. From the exquisite craftsmanship of artisans, to industrial products that liberate productive forces, to the scientific laws governing the universe, almost every ordinary or astonishing thing has behind it the ingenious thought of algorithms.</p> <p>Similarly, data structures are everywhere: from social networks to subway lines, many systems can be modeled as \"graphs\"; from a country to a family, the main forms of social organization exhibit characteristics of \"trees\"; winter clothes are like a \"stack\", where the first item worn is the last to be taken off; a badminton shuttle tube resembles a \"queue\", with one end for insertion and the other for retrieval; a dictionary is like a \"hash table\", enabling quick search for target entries.</p> <p>This book aims to help readers understand the core concepts of algorithms and data structures through clear, easy-to-understand animated illustrations and runnable code examples, and to be able to implement them through programming. On this basis, this book strives to reveal the vivid manifestations of algorithms in the complex world, showcasing the beauty of algorithms. I hope this book can help you!</p>"},{"location":"chapter_introduction/","title":"Chapter 1. \u00a0 Encounter with algorithms","text":"<p>Abstract</p> <p>A graceful maiden dances, intertwined with the data, her skirt swaying to the melody of algorithms.</p> <p>She invites you to a dance, follow her steps, and enter the world of algorithms full of logic and beauty.</p>"},{"location":"chapter_introduction/#chapter-contents","title":"Chapter contents","text":"<ul> <li>1.1 \u00a0 Algorithms are everywhere</li> <li>1.2 \u00a0 What is an algorithm</li> <li>1.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_introduction/algorithms_are_everywhere/","title":"1.1 \u00a0 Algorithms are everywhere","text":"<p>When we hear the word \"algorithm,\" we naturally think of mathematics. However, many algorithms do not involve complex mathematics but rely more on basic logic, which can be seen everywhere in our daily lives.</p> <p>Before formally discussing algorithms, there's an interesting fact worth sharing: you have already unconsciously learned many algorithms and have become accustomed to applying them in your daily life. Here, I will give a few specific examples to prove this point.</p> <p>Example 1: Looking Up a Dictionary. In an English dictionary, words are listed alphabetically. Suppose we're searching for a word that starts with the letter \\(r\\). This is typically done in the following way:</p> <ol> <li>Open the dictionary to about halfway and check the first letter on the page, let's say the letter is \\(m\\).</li> <li>Since \\(r\\) comes after \\(m\\) in the alphabet, we can ignore the first half of the dictionary and focus on the latter half.</li> <li>Repeat steps <code>1.</code> and <code>2.</code> until you find the page where the word starts with \\(r\\).</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 1-1 \u00a0 Process of Looking Up a Dictionary </p> <p>This essential skill for elementary students, looking up a dictionary, is actually the famous \"Binary Search\" algorithm. From a data structure perspective, we can consider the dictionary as a sorted \"array\"; from an algorithmic perspective, the series of actions taken to look up a word in the dictionary can be viewed as \"Binary Search.\"</p> <p>Example 2: Organizing Playing Cards. When playing cards, we need to arrange the cards in our hand in ascending order, as shown in the following process.</p> <ol> <li>Divide the playing cards into \"ordered\" and \"unordered\" sections, assuming initially the leftmost card is already in order.</li> <li>Take out a card from the unordered section and insert it into the correct position in the ordered section; after this, the leftmost two cards are in order.</li> <li>Continue to repeat step <code>2.</code> until all cards are in order.</li> </ol> <p></p> <p> Figure 1-2 \u00a0 Playing cards sorting process </p> <p>The above method of organizing playing cards is essentially the \"Insertion Sort\" algorithm, which is very efficient for small datasets. Many programming languages' sorting functions include the insertion sort.</p> <p>Example 3: Making Change. Suppose we buy goods worth \\(69\\) yuan at a supermarket and give the cashier \\(100\\) yuan, then the cashier needs to give us \\(31\\) yuan in change. They would naturally complete the thought process as shown in Figure 1-3.</p> <ol> <li>The options are currencies smaller than \\(31\\), including \\(1\\), \\(5\\), \\(10\\), and \\(20\\).</li> <li>Take out the largest \\(20\\) from the options, leaving \\(31 - 20 = 11\\).</li> <li>Take out the largest \\(10\\) from the remaining options, leaving \\(11 - 10 = 1\\).</li> <li>Take out the largest \\(1\\) from the remaining options, leaving \\(1 - 1 = 0\\).</li> <li>Complete the change-making, with the solution being \\(20 + 10 + 1 = 31\\).</li> </ol> <p></p> <p> Figure 1-3 \u00a0 Change making process </p> <p>In the above steps, we make the best choice at each step (using the largest denomination possible), ultimately resulting in a feasible change-making plan. From the perspective of data structures and algorithms, this method is essentially a \"Greedy\" algorithm.</p> <p>From cooking a meal to interstellar travel, almost all problem-solving involves algorithms. The advent of computers allows us to store data structures in memory and write code to call the CPU and GPU to execute algorithms. In this way, we can transfer real-life problems to computers, solving various complex issues more efficiently.</p> <p>Tip</p> <p>If concepts such as data structures, algorithms, arrays, and binary search still seem somewhat obsecure, I encourage you to continue reading. This book will gently guide you into the realm of understanding data structures and algorithms.</p>"},{"location":"chapter_introduction/summary/","title":"1.3 \u00a0 Summary","text":"<ul> <li>Algorithms are ubiquitous in daily life and are not as inaccessible and complex as they might seem. In fact, we have already unconsciously learned many algorithms to solve various problems in life.</li> <li>The principle of looking up a word in a dictionary is consistent with the binary search algorithm. The binary search algorithm embodies the important algorithmic concept of divide and conquer.</li> <li>The process of organizing playing cards is very similar to the insertion sort algorithm. The insertion sort algorithm is suitable for sorting small datasets.</li> <li>The steps of making change in currency essentially follow the greedy algorithm, where each step involves making the best possible choice at the moment.</li> <li>An algorithm is a set of instructions or steps used to solve a specific problem within a finite amount of time, while a data structure is the way data is organized and stored in a computer.</li> <li>Data structures and algorithms are closely linked. Data structures are the foundation of algorithms, and algorithms are the stage to utilize the functions of data structures.</li> <li>We can liken data structures and algorithms to building blocks. The blocks represent data, the shape and connection method of the blocks represent data structures, and the steps of assembling the blocks correspond to algorithms.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/","title":"1.2 \u00a0 What is an algorithm","text":""},{"location":"chapter_introduction/what_is_dsa/#121-definition-of-an-algorithm","title":"1.2.1 \u00a0 Definition of an algorithm","text":"<p>An algorithm is a set of instructions or steps to solve a specific problem within a finite amount of time. It has the following characteristics:</p> <ul> <li>The problem is clearly defined, including unambiguous definitions of input and output.</li> <li>The algorithm is feasible, meaning it can be completed within a finite number of steps, time, and memory space.</li> <li>Each step has a definitive meaning. The output is consistently the same under the same inputs and conditions.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#122-definition-of-a-data-structure","title":"1.2.2 \u00a0 Definition of a data structure","text":"<p>A data structure is a way of organizing and storing data in a computer, with the following design goals:</p> <ul> <li>Minimize space occupancy to save computer memory.</li> <li>Make data operations as fast as possible, covering data access, addition, deletion, updating, etc.</li> <li>Provide concise data representation and logical information to enable efficient algorithm execution.</li> </ul> <p>Designing data structures is a balancing act, often requiring trade-offs. If you want to improve in one aspect, you often need to compromise in another. Here are two examples:</p> <ul> <li>Compared to arrays, linked lists offer more convenience in data addition and deletion but sacrifice data access speed.</li> <li>Graphs, compared to linked lists, provide richer logical information but require more memory space.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#123-relationship-between-data-structures-and-algorithms","title":"1.2.3 \u00a0 Relationship between data structures and algorithms","text":"<p>As shown in Figure 1-4, data structures and algorithms are highly related and closely integrated, specifically in the following three aspects:</p> <ul> <li>Data structures are the foundation of algorithms. They provide structured data storage and methods for manipulating data for algorithms.</li> <li>Algorithms are the stage where data structures come into play. The data structure alone only stores data information; it is through the application of algorithms that specific problems can be solved.</li> <li>Algorithms can often be implemented based on different data structures, but their execution efficiency can vary greatly. Choosing the right data structure is key.</li> </ul> <p></p> <p> Figure 1-4 \u00a0 Relationship between data structures and algorithms </p> <p>Data structures and algorithms can be likened to a set of building blocks, as illustrated in Figure 1-5. A building block set includes numerous pieces, accompanied by detailed assembly instructions. Following these instructions step by step allows us to construct an intricate block model.</p> <p></p> <p> Figure 1-5 \u00a0 Assembling blocks </p> <p>The detailed correspondence between the two is shown in Table 1-1.</p> <p> Table 1-1 \u00a0 Comparing data structures and algorithms to building blocks </p> Data Structures and Algorithms Building Blocks Input data Unassembled blocks Data structure Organization of blocks, including shape, size, connections, etc Algorithm A series of steps to assemble the blocks into the desired shape Output data Completed Block model <p>It's worth noting that data structures and algorithms are independent of programming languages. For this reason, this book is able to provide implementations in multiple programming languages.</p> <p>Conventional Abbreviation</p> <p>In real-life discussions, we often refer to \"Data Structures and Algorithms\" simply as \"Algorithms\". For example, the well-known LeetCode algorithm problems actually test both data structure and algorithm knowledge.</p>"},{"location":"chapter_preface/","title":"Chapter 0. \u00a0 Preface","text":"<p>Abstract</p> <p>Algorithms are like a beautiful symphony, with each line of code flowing like a rhythm.</p> <p>May this book ring softly in your mind, leaving a unique and profound melody.</p>"},{"location":"chapter_preface/#chapter-contents","title":"Chapter contents","text":"<ul> <li>0.1 \u00a0 About this book</li> <li>0.2 \u00a0 How to read</li> <li>0.3 \u00a0 Summary</li> </ul>"},{"location":"chapter_preface/about_the_book/","title":"0.1 \u00a0 About this book","text":"<p>This open-source project aims to create a free, and beginner-friendly crash course on data structures and algorithms.</p> <ul> <li>Using animated illustrations, it delivers structured insights into data structures and algorithmic concepts, ensuring comprehensibility and a smooth learning curve.</li> <li>Run code with just one click, supporting Java, C++, Python, Go, JS, TS, C#, Swift, Rust, Dart, Zig and other languages.</li> <li>Readers are encouraged to engage with each other in the discussion area for each section, questions and comments are usually answered within two days.</li> </ul>"},{"location":"chapter_preface/about_the_book/#011-target-audience","title":"0.1.1 \u00a0 Target audience","text":"<p>If you are new to algorithms with limited exposure, or you have accumulated some experience in algorithms, but you only have a vague understanding of data structures and algorithms, and you are constantly jumping between \"yep\" and \"hmm\", then this book is for you!</p> <p>If you have already accumulated a certain amount of problem-solving experience, and are familiar with most types of problems, then this book can help you review and organize your algorithm knowledge system. The repository's source code can be used as a \"problem-solving toolkit\" or an \"algorithm cheat sheet\".</p> <p>If you are an algorithm expert, we look forward to receiving your valuable suggestions, or join us and collaborate.</p> <p>Prerequisites</p> <p>You should know how to write and read simple code in at least one programming language.</p>"},{"location":"chapter_preface/about_the_book/#012-content-structure","title":"0.1.2 \u00a0 Content structure","text":"<p>The main content of the book is shown in Figure 0-1.</p> <ul> <li>Complexity analysis: explores aspects and methods for evaluating data structures and algorithms. Covers methods of deriving time complexity and space complexity, along with common types and examples.</li> <li>Data structures: focuses on fundamental data types, classification methods, definitions, pros and cons, common operations, types, applications, and implementation methods of data structures such as array, linked list, stack, queue, hash table, tree, heap, graph, etc.</li> <li>Algorithms: defines algorithms, discusses their pros and cons, efficiency, application scenarios, problem-solving steps, and includes sample questions for various algorithms such as search, sorting, divide and conquer, backtracking, dynamic programming, greedy algorithms, and more.</li> </ul> <p></p> <p> Figure 0-1 \u00a0 Main content of the book </p>"},{"location":"chapter_preface/about_the_book/#013-acknowledgements","title":"0.1.3 \u00a0 Acknowledgements","text":"<p>This book is continuously improved with the joint efforts of many contributors from the open-source community. Thanks to each writer who invested their time and energy, listed in the order generated by GitHub: krahets, codingonion, nuomi1, Gonglja, Reanon, justin-tse, danielsss, hpstory, S-N-O-R-L-A-X, night-cruise, msk397, gvenusleo, RiverTwilight, gyt95, zhuoqinyue, Zuoxun, Xia-Sang, mingXta, FangYuan33, GN-Yu, IsChristina, xBLACKICEx, guowei-gong, Cathay-Chen, mgisr, JoseHung, qualifier1024, pengchzn, Guanngxu, longsizhuo, L-Super, what-is-me, yuan0221, lhxsm, Slone123c, WSL0809, longranger2, theNefelibatas, xiongsp, JeffersonHuang, hongyun-robot, K3v123, yuelinxin, a16su, gaofer, malone6, Wonderdch, xjr7670, DullSword, Horbin-Magician, NI-SW, reeswell, XC-Zero, XiaChuerwu, yd-j, iron-irax, huawuque404, MolDuM, Nigh, KorsChen, foursevenlove, 52coder, bubble9um, youshaoXG, curly210102, gltianwen, fanchenggang, Transmigration-zhou, FloranceYeh, FreddieLi, ShiMaRing, lipusheng, Javesun99, JackYang-hellobobo, shanghai-Jerry, 0130w, Keynman, psychelzh, logan-qiu, ZnYang2018, MwumLi, 1ch0, Phoenix0415, qingpeng9802, Richard-Zhang1019, QiLOL, Suremotoo, Turing-1024-Lee, Evilrabbit520, GaochaoZhu, ZJKung, linzeyan, hezhizhen, ZongYangL, beintentional, czruby, coderlef, dshlstarr, szu17dmy, fbigm, gledfish, hts0000, boloboloda, iStig, jiaxianhua, wenjianmin, keshida, kilikilikid, lclc6, lwbaptx, liuxjerry, lucaswangdev, lyl625760, chadyi, noobcodemaker, selear, siqyka, syd168, 4yDX3906, tao363, wangwang105, weibk, yabo083, yi427, yishangzhang, zhouLion, baagod, ElaBosak233, xb534, luluxia, yanedie, thomasq0, YangXuanyi and th1nk3r-ing.</p> <p>The code review work for this book was completed by codingonion, Gonglja, gvenusleo, hpstory, justin\u2010tse, krahets, night-cruise, nuomi1, and Reanon (listed in alphabetical order). Thanks to them for their time and effort, ensuring the standardization and uniformity of the code in various languages.</p> <p>Throughout the creation of this book, numerous individuals provided invaluable assistance, including but not limited to:</p> <ul> <li>Thanks to my mentor at the company, Dr. Xi Li, who encouraged me in a conversation to \"get moving fast,\" which solidified my determination to write this book;</li> <li>Thanks to my girlfriend Bubble, as the first reader of this book, for offering many valuable suggestions from the perspective of a beginner in algorithms, making this book more suitable for newbies;</li> <li>Thanks to Tengbao, Qibao, and Feibao for coming up with a creative name for this book, evoking everyone's fond memories of writing their first line of code \"Hello World!\";</li> <li>Thanks to Xiaoquan for providing professional help in intellectual property, which has played a significant role in the development of this open-source book;</li> <li>Thanks to Sutong for designing a beautiful cover and logo for this book, and for patiently making multiple revisions under my insistence;</li> <li>Thanks to @squidfunk for providing writing and typesetting suggestions, as well as his developed open-source documentation theme Material-for-MkDocs.</li> </ul> <p>Throughout the writing journey, I delved into numerous textbooks and articles on data structures and algorithms. These works served as exemplary models, ensuring the accuracy and quality of this book's content. I extend my gratitude to all who preceded me for their invaluable contributions!</p> <p>This book advocates a combination of hands-on and minds-on learning, inspired in this regard by \"Dive into Deep Learning\". I highly recommend this excellent book to all readers.</p> <p>Heartfelt thanks to my parents, whose ongoing support and encouragement have allowed me to do this interesting work.</p>"},{"location":"chapter_preface/suggestions/","title":"0.2 \u00a0 How to read","text":"<p>Tip</p> <p>For the best reading experience, it is recommended that you read through this section.</p>"},{"location":"chapter_preface/suggestions/#021-writing-conventions","title":"0.2.1 \u00a0 Writing conventions","text":"<ul> <li>Chapters marked with '*' after the title are optional and contain relatively challenging content. If you are short on time, it is advisable to skip them.</li> <li>Technical terms will be in boldface (in the print and PDF versions) or underlined (in the web version), for instance, array. It's advisable to familiarize yourself with these for better comprehension of technical texts.</li> <li>Bolded text indicates key content or summary statements, which deserve special attention.</li> <li>Words and phrases with specific meanings are indicated with \u201cquotation marks\u201d to avoid ambiguity.</li> <li>When it comes to terms that are inconsistent between programming languages, this book follows Python, for example using <code>None</code> to mean <code>null</code>.</li> <li>This book partially ignores the comment conventions for programming languages in exchange for a more compact layout of the content. The comments primarily consist of three types: title comments, content comments, and multi-line comments.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>\"\"\"Header comments for labeling functions, classes, test samples, etc\"\"\"\n\n# Comments for explaining details\n\n\"\"\"\nMultiline\ncomments\n\"\"\"\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>/* Header comments for labeling functions, classes, test samples, etc */\n\n// Comments for explaining details.\n\n/**\n * Multiline\n * comments\n */\n</code></pre> <pre><code>// Header comments for labeling functions, classes, test samples, etc\n\n// Comments for explaining details.\n\n// Multiline\n// comments\n</code></pre>"},{"location":"chapter_preface/suggestions/#022-efficient-learning-via-animated-illustrations","title":"0.2.2 \u00a0 Efficient learning via animated illustrations","text":"<p>Compared with text, videos and pictures have a higher density of information and are more structured, making them easier to understand. In this book, key and difficult concepts are mainly presented through animations and illustrations, with text serving as explanations and supplements.</p> <p>When encountering content with animations or illustrations as shown in Figure 0-2, prioritize understanding the figure, with text as supplementary, integrating both for a comprehensive understanding.</p> <p></p> <p> Figure 0-2 \u00a0 Animated illustration example </p>"},{"location":"chapter_preface/suggestions/#023-deepen-understanding-through-coding-practice","title":"0.2.3 \u00a0 Deepen understanding through coding practice","text":"<p>The source code of this book is hosted on the GitHub Repository. As shown in Figure 0-3, the source code comes with test examples and can be executed with just a single click.</p> <p>If time permits, it's recommended to type out the code yourself. If pressed for time, at least read and run all the codes.</p> <p>Compared to just reading code, writing code often yields more learning. Learning by doing is the real way to learn.</p> <p></p> <p> Figure 0-3 \u00a0 Running code example </p> <p>Setting up to run the code involves three main steps.</p> <p>Step 1: Install a local programming environment. Follow the tutorial in the appendix for installation, or skip this step if already installed.</p> <p>Step 2: Clone or download the code repository. Visit the GitHub Repository.</p> <p>If Git is installed, use the following command to clone the repository:</p> <pre><code>git clone https://github.com/krahets/hello-algo.git\n</code></pre> <p>Alternatively, you can also click the \"Download ZIP\" button at the location shown in Figure 0-4 to directly download the code as a compressed ZIP file. Then, you can simply extract it locally.</p> <p></p> <p> Figure 0-4 \u00a0 Cloning repository and downloading code </p> <p>Step 3: Run the source code. As shown in Figure 0-5, for the code block labeled with the file name at the top, we can find the corresponding source code file in the <code>codes</code> folder of the repository. These files can be executed with a single click, which will help you save unnecessary debugging time and allow you to focus on learning.</p> <p></p> <p> Figure 0-5 \u00a0 Code block and corresponding source code file </p>"},{"location":"chapter_preface/suggestions/#024-learning-together-in-discussion","title":"0.2.4 \u00a0 Learning together in discussion","text":"<p>While reading this book, please don't skip over the points that you didn't learn. Feel free to post your questions in the comment section. We will be happy to answer them and can usually respond within two days.</p> <p>As illustrated in Figure 0-6, each chapter features a comment section at the bottom. I encourage you to pay attention to these comments. They not only expose you to others' encountered problems, aiding in identifying knowledge gaps and sparking deeper contemplation, but also invite you to generously contribute by answering fellow readers' inquiries, sharing insights, and fostering mutual improvement.</p> <p></p> <p> Figure 0-6 \u00a0 Comment section example </p>"},{"location":"chapter_preface/suggestions/#025-algorithm-learning-path","title":"0.2.5 \u00a0 Algorithm learning path","text":"<p>Overall, the journey of mastering data structures and algorithms can be divided into three stages:</p> <ol> <li>Stage 1: Introduction to algorithms. We need to familiarize ourselves with the characteristics and usage of various data structures and learn about the principles, processes, uses, and efficiency of different algorithms.</li> <li>Stage 2: Practicing algorithm problems. It is recommended to start from popular problems, such as Sword for Offer and LeetCode Hot 100, and accumulate at least 100 questions to familiarize yourself with mainstream algorithmic problems. Forgetfulness can be a challenge when you start practicing, but rest assured that this is normal. We can follow the \"Ebbinghaus Forgetting Curve\" to review the questions, and usually after 3~5 rounds of repetitions, we will be able to memorize them.</li> <li>Stage 3: Building the knowledge system. In terms of learning, we can read algorithm column articles, solution frameworks, and algorithm textbooks to continuously enrich the knowledge system. In terms of practicing, we can try advanced strategies, such as categorizing by topic, multiple solutions for a single problem,  and one solution for multiple problems, etc. Insights on these strategies can be found in various communities.</li> </ol> <p>As shown in Figure 0-7, this book mainly covers \u201cStage 1,\u201d aiming to help you more efficiently embark on Stages 2 and 3.</p> <p></p> <p> Figure 0-7 \u00a0 Algorithm learning path </p>"},{"location":"chapter_preface/summary/","title":"0.3 \u00a0 Summary","text":"<ul> <li>The main audience of this book is beginners in algorithm. If you already have some basic knowledge, this book can help you systematically review your algorithm knowledge, and the source code in this book can also be used as a \"Coding Toolkit\".</li> <li>The book consists of three main sections, Complexity Analysis, Data Structures, and Algorithms, covering most of the topics in the field.</li> <li>For newcomers to algorithms, it is crucial to read an introductory book in the beginning stages to avoid many detours or common pitfalls.</li> <li>Animations and figures within the book are usually used to introduce key points and difficult knowledge. These should be given more attention when reading the book.</li> <li>Practice is the best way to learn programming. It is highly recommended that you run the source code and type in the code yourself.</li> <li>Each chapter in the web version of this book features a discussion section, and you are welcome to share your questions and insights at any time.</li> </ul>"},{"location":"chapter_reference/","title":"References","text":"<p>[1] Thomas H. Cormen, et al. Introduction to Algorithms (3<sup>rd</sup> Edition).</p> <p>[2] Aditya Bhargava. Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People (1<sup>st</sup> Edition).</p> <p>[3] Robert Sedgewick, et al. Algorithms (4<sup>th</sup> Edition).</p> <p>[4] Yan Weimin. Data Structures (C Language Version).</p> <p>[5] Deng Junhui. Data Structures (C++ Language Version, Third Edition).</p> <p>[6] Mark Allen Weiss, translated by Chen Yue. Data Structures and Algorithm Analysis in Java (Third Edition).</p> <p>[7] Cheng Jie. Speaking of Data Structures.</p> <p>[8] Wang Zheng. The Beauty of Data Structures and Algorithms.</p> <p>[9] Gayle Laakmann McDowell. Cracking the Coding Interview: 189 Programming Questions and Solutions (6<sup>th</sup> Edition).</p> <p>[10] Aston Zhang, et al. Dive into Deep Learning.</p>"},{"location":"chapter_searching/","title":"Chapter 10. \u00a0 Searching","text":"<p>Abstract</p> <p>Searching is an unknown adventure, where we may need to traverse every corner of a mysterious space, or perhaps quickly pinpoint our target.</p> <p>In this journey of discovery, each exploration may yield an unexpected answer.</p>"},{"location":"chapter_searching/#chapter-contents","title":"Chapter contents","text":"<ul> <li>10.1 \u00a0 Binary search</li> <li>10.2 \u00a0 Binary search insertion</li> <li>10.3 \u00a0 Binary search boundaries</li> <li>10.4 \u00a0 Hashing optimization strategies</li> <li>10.5 \u00a0 Search algorithms revisited</li> <li>10.6 \u00a0 Summary</li> </ul>"},{"location":"chapter_searching/binary_search/","title":"10.1 \u00a0 Binary search","text":"<p>Binary search is an efficient search algorithm based on the divide-and-conquer strategy. It utilizes the orderliness of data, reducing the search range by half each round until the target element is found or the search interval is empty.</p> <p>Question</p> <p>Given an array <code>nums</code> of length \\(n\\), with elements arranged in ascending order and non-repeating. Please find and return the index of element <code>target</code> in this array. If the array does not contain the element, return \\(-1\\). An example is shown in Figure 10-1.</p> <p></p> <p> Figure 10-1 \u00a0 Binary search example data </p> <p>As shown in Figure 10-2, we first initialize pointers \\(i = 0\\) and \\(j = n - 1\\), pointing to the first and last elements of the array, representing the search interval \\([0, n - 1]\\). Please note that square brackets indicate a closed interval, which includes the boundary values themselves.</p> <p>Next, perform the following two steps in a loop.</p> <ol> <li>Calculate the midpoint index \\(m = \\lfloor {(i + j) / 2} \\rfloor\\), where \\(\\lfloor \\: \\rfloor\\) denotes the floor operation.</li> <li>Compare the size of <code>nums[m]</code> and <code>target</code>, divided into the following three scenarios.<ol> <li>If <code>nums[m] &lt; target</code>, it indicates that <code>target</code> is in the interval \\([m + 1, j]\\), thus set \\(i = m + 1\\).</li> <li>If <code>nums[m] &gt; target</code>, it indicates that <code>target</code> is in the interval \\([i, m - 1]\\), thus set \\(j = m - 1\\).</li> <li>If <code>nums[m] = target</code>, it indicates that <code>target</code> is found, thus return index \\(m\\).</li> </ol> </li> </ol> <p>If the array does not contain the target element, the search interval will eventually reduce to empty. In this case, return \\(-1\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 10-2 \u00a0 Binary search process </p> <p>It's worth noting that since \\(i\\) and \\(j\\) are both of type <code>int</code>, \\(i + j\\) might exceed the range of <code>int</code> type. To avoid large number overflow, we usually use the formula \\(m = \\lfloor {i + (j - i) / 2} \\rfloor\\) to calculate the midpoint.</p> <p>The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search.py<pre><code>def binary_search(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09\"\"\"\n    # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    i, j = 0, len(nums) - 1\n    # \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt;= j:\n        # \u7406\u8bba\u4e0a Python \u7684\u6570\u5b57\u53ef\u4ee5\u65e0\u9650\u5927\uff08\u53d6\u51b3\u4e8e\u5185\u5b58\u5927\u5c0f\uff09\uff0c\u65e0\u987b\u8003\u8651\u5927\u6570\u8d8a\u754c\u95ee\u9898\n        m = (i + j) // 2  # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target:\n            i = m + 1  # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        elif nums[m] &gt; target:\n            j = m - 1  # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        else:\n            return m  # \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    return -1  # \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n</code></pre> binary_search.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    int i = 0, j = nums.size() - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nint binarySearch(int[] nums, int target) {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    int i = 0, j = nums.length - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nint BinarySearch(int[] nums, int target) {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    int i = 0, j = nums.Length - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2;   // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        else                       // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfunc binarySearch(nums []int, target int) int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    i, j := 0, len(nums)-1\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    for i &lt;= j {\n        m := i + (j-i)/2      // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        } else { // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfunc binarySearch(nums: [Int], target: Int) -&gt; Int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        } else { // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfunction binarySearch(nums, target) {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    let i = 0,\n        j = nums.length - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m \uff0c\u4f7f\u7528 parseInt() \u5411\u4e0b\u53d6\u6574\n        const m = parseInt(i + (j - i) / 2);\n        if (nums[m] &lt; target)\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target)\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        else return m; // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfunction binarySearch(nums: number[], target: number): number {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    let i = 0,\n        j = nums.length - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        const m = Math.floor(i + (j - i) / 2);\n        if (nums[m] &lt; target) {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        } else if (nums[m] &gt; target) {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        } else {\n            // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n        }\n    }\n    return -1; // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n}\n</code></pre> binary_search.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nint binarySearch(List&lt;int&gt; nums, int target) {\n  // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n  int i = 0, j = nums.length - 1;\n  // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    if (nums[m] &lt; target) {\n      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n      i = m + 1;\n    } else if (nums[m] &gt; target) {\n      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n      j = m - 1;\n    } else {\n      // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n      return m;\n    }\n  }\n  // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n  return -1;\n}\n</code></pre> binary_search.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfn binary_search(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    let mut i = 0;\n    let mut j = nums.len() as i32 - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m as usize] &lt; target {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        } else if nums[m as usize] &gt; target {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        } else {\n            // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nint binarySearch(int *nums, int len, int target) {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    int i = 0, j = len - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 */\nfun binarySearch(nums: IntArray, target: Int): Int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    var i = 0\n    var j = nums.size - 1\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        else  // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09 ###\ndef binary_search(nums, target)\n  # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n  i, j = 0, nums.length - 1\n\n  # \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n  while i &lt;= j\n    # \u7406\u8bba\u4e0a Ruby \u7684\u6570\u5b57\u53ef\u4ee5\u65e0\u9650\u5927\uff08\u53d6\u51b3\u4e8e\u5185\u5b58\u5927\u5c0f\uff09\uff0c\u65e0\u987b\u8003\u8651\u5927\u6570\u8d8a\u754c\u95ee\u9898\n    m = (i + j) / 2   # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n\n    if nums[m] &lt; target\n      i = m + 1 # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n    elsif nums[m] &gt; target\n      j = m - 1 # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n    else\n      return m  # \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    end\n  end\n\n  -1  # \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\nend\n</code></pre> binary_search.zig<pre><code>// \u4e8c\u5206\u67e5\u627e\uff08\u53cc\u95ed\u533a\u95f4\uff09\nfn binarySearch(comptime T: type, nums: std.ArrayList(T), target: T) T {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1] \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20\n    var i: usize = 0;\n    var j: usize = nums.items.len - 1;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i &gt; j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        var m = i + (j - i) / 2;                // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums.items[m] &lt; target) {           // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1;\n        } else if (nums.items[m] &gt; target) {    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1;\n        } else {                                // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return @intCast(m);\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Time complexity is \\(O(\\log n)\\) : In the binary loop, the interval reduces by half each round, hence the number of iterations is \\(\\log_2 n\\).</p> <p>Space complexity is \\(O(1)\\) : Pointers \\(i\\) and \\(j\\) use constant size space.</p>"},{"location":"chapter_searching/binary_search/#1011-interval-representation-methods","title":"10.1.1 \u00a0 Interval representation methods","text":"<p>Besides the aforementioned closed interval, a common interval representation is the \"left-closed right-open\" interval, defined as \\([0, n)\\), where the left boundary includes itself, and the right boundary does not include itself. In this representation, the interval \\([i, j)\\) is empty when \\(i = j\\).</p> <p>We can implement a binary search algorithm with the same functionality based on this representation:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search.py<pre><code>def binary_search_lcro(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09\"\"\"\n    # \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    i, j = 0, len(nums)\n    # \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt; j:\n        m = (i + j) // 2  # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target:\n            i = m + 1  # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n        elif nums[m] &gt; target:\n            j = m  # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n        else:\n            return m  # \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    return -1  # \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n</code></pre> binary_search.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nint binarySearchLCRO(vector&lt;int&gt; &amp;nums, int target) {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    int i = 0, j = nums.size();\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nint binarySearchLCRO(int[] nums, int target) {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    int i = 0, j = nums.length;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nint BinarySearchLCRO(int[] nums, int target) {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    int i = 0, j = nums.Length;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        int m = i + (j - i) / 2;   // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        else                       // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfunc binarySearchLCRO(nums []int, target int) int {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    i, j := 0, len(nums)\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    for i &lt; j {\n        m := i + (j-i)/2      // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m\n        } else { // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfunc binarySearchLCRO(nums: [Int], target: Int) -&gt; Int {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    var i = nums.startIndex\n    var j = nums.endIndex\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt; j {\n        let m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target { // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m\n        } else { // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfunction binarySearchLCRO(nums, target) {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    let i = 0,\n        j = nums.length;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m \uff0c\u4f7f\u7528 parseInt() \u5411\u4e0b\u53d6\u6574\n        const m = parseInt(i + (j - i) / 2);\n        if (nums[m] &lt; target)\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target)\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n        else return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfunction binarySearchLCRO(nums: number[], target: number): number {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    let i = 0,\n        j = nums.length;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        const m = Math.floor(i + (j - i) / 2);\n        if (nums[m] &lt; target) {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        } else if (nums[m] &gt; target) {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        } else {\n            // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n        }\n    }\n    return -1; // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n}\n</code></pre> binary_search.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nint binarySearchLCRO(List&lt;int&gt; nums, int target) {\n  // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n  int i = 0, j = nums.length;\n  // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n  while (i &lt; j) {\n    int m = i + (j - i) ~/ 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    if (nums[m] &lt; target) {\n      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n      i = m + 1;\n    } else if (nums[m] &gt; target) {\n      // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n      j = m;\n    } else {\n      // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n      return m;\n    }\n  }\n  // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n  return -1;\n}\n</code></pre> binary_search.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfn binary_search_lcro(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    let mut i = 0;\n    let mut j = nums.len() as i32;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while i &lt; j {\n        let m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m as usize] &lt; target {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        } else if nums[m as usize] &gt; target {\n            // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        } else {\n            // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nint binarySearchLCRO(int *nums, int len, int target) {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    int i = 0, j = len;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target)    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        else // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m;\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> binary_search.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 */\nfun binarySearchLCRO(nums: IntArray, target: Int): Int {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    var i = 0\n    var j = nums.size\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt; j) {\n        val m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1\n        else if (nums[m] &gt; target) // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m\n        else  // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return m\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1\n}\n</code></pre> binary_search.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09 ###\ndef binary_search_lcro(nums, target)\n  # \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n  i, j = 0, nums.length\n\n  # \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n  while i &lt; j\n    # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n    elsif nums[m] &gt; target\n      j = m - 1 # \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n    else\n      return m  # \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n    end\n  end\n\n  -1  # \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\nend\n</code></pre> binary_search.zig<pre><code>// \u4e8c\u5206\u67e5\u627e\uff08\u5de6\u95ed\u53f3\u5f00\u533a\u95f4\uff09\nfn binarySearchLCRO(comptime T: type, nums: std.ArrayList(T), target: T) T {\n    // \u521d\u59cb\u5316\u5de6\u95ed\u53f3\u5f00\u533a\u95f4 [0, n) \uff0c\u5373 i, j \u5206\u522b\u6307\u5411\u6570\u7ec4\u9996\u5143\u7d20\u3001\u5c3e\u5143\u7d20+1\n    var i: usize = 0;\n    var j: usize = nums.items.len;\n    // \u5faa\u73af\uff0c\u5f53\u641c\u7d22\u533a\u95f4\u4e3a\u7a7a\u65f6\u8df3\u51fa\uff08\u5f53 i = j \u65f6\u4e3a\u7a7a\uff09\n    while (i &lt;= j) {\n        var m = i + (j - i) / 2;                // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums.items[m] &lt; target) {           // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [m+1, j) \u4e2d\n            i = m + 1;\n        } else if (nums.items[m] &gt; target) {    // \u6b64\u60c5\u51b5\u8bf4\u660e target \u5728\u533a\u95f4 [i, m) \u4e2d\n            j = m;\n        } else {                                // \u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de\u5176\u7d22\u5f15\n            return @intCast(m);\n        }\n    }\n    // \u672a\u627e\u5230\u76ee\u6807\u5143\u7d20\uff0c\u8fd4\u56de -1\n    return -1;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>As shown in Figure 10-3, in the two types of interval representations, the initialization of the binary search algorithm, the loop condition, and the narrowing interval operation are different.</p> <p>Since both boundaries in the \"closed interval\" representation are defined as closed, the operations to narrow the interval through pointers \\(i\\) and \\(j\\) are also symmetrical. This makes it less prone to errors, therefore, it is generally recommended to use the \"closed interval\" approach.</p> <p></p> <p> Figure 10-3 \u00a0 Two types of interval definitions </p>"},{"location":"chapter_searching/binary_search/#1012-advantages-and-limitations","title":"10.1.2 \u00a0 Advantages and limitations","text":"<p>Binary search performs well in both time and space aspects.</p> <ul> <li>Binary search is time-efficient. With large data volumes, the logarithmic time complexity has a significant advantage. For instance, when the data size \\(n = 2^{20}\\), linear search requires \\(2^{20} = 1048576\\) iterations, while binary search only requires \\(\\log_2 2^{20} = 20\\) iterations.</li> <li>Binary search does not require extra space. Compared to search algorithms that rely on additional space (like hash search), binary search is more space-efficient.</li> </ul> <p>However, binary search is not suitable for all situations, mainly for the following reasons.</p> <ul> <li>Binary search is only applicable to ordered data. If the input data is unordered, it is not worth sorting it just to use binary search, as sorting algorithms typically have a time complexity of \\(O(n \\log n)\\), which is higher than both linear and binary search. For scenarios with frequent element insertion to maintain array order, inserting elements into specific positions has a time complexity of \\(O(n)\\), which is also quite costly.</li> <li>Binary search is only applicable to arrays. Binary search requires non-continuous (jumping) element access, which is inefficient in linked lists, thus not suitable for use in linked lists or data structures based on linked lists.</li> <li>With small data volumes, linear search performs better. In linear search, each round only requires 1 decision operation; whereas in binary search, it involves 1 addition, 1 division, 1 to 3 decision operations, 1 addition (subtraction), totaling 4 to 6 operations; therefore, when data volume \\(n\\) is small, linear search can be faster than binary search.</li> </ul>"},{"location":"chapter_searching/binary_search_edge/","title":"10.3 \u00a0 Binary search boundaries","text":""},{"location":"chapter_searching/binary_search_edge/#1031-find-the-left-boundary","title":"10.3.1 \u00a0 Find the left boundary","text":"<p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\), which may contain duplicate elements, return the index of the leftmost element <code>target</code>. If the element is not present in the array, return \\(-1\\).</p> <p>Recall the method of binary search for an insertion point, after the search is completed, \\(i\\) points to the leftmost <code>target</code>, thus searching for the insertion point is essentially searching for the index of the leftmost <code>target</code>.</p> <p>Consider implementing the search for the left boundary using the function for finding an insertion point. Note that the array might not contain <code>target</code>, which could lead to the following two results:</p> <ul> <li>The index \\(i\\) of the insertion point is out of bounds.</li> <li>The element <code>nums[i]</code> is not equal to <code>target</code>.</li> </ul> <p>In these cases, simply return \\(-1\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_edge.py<pre><code>def binary_search_left_edge(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target\"\"\"\n    # \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    i = binary_search_insertion(nums, target)\n    # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if i == len(nums) or nums[i] != target:\n        return -1\n    # \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i\n</code></pre> binary_search_edge.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nint binarySearchLeftEdge(vector&lt;int&gt; &amp;nums, int target) {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    int i = binarySearchInsertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i == nums.size() || nums[i] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nint binarySearchLeftEdge(int[] nums, int target) {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    int i = binary_search_insertion.binarySearchInsertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i == nums.length || nums[i] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nint BinarySearchLeftEdge(int[] nums, int target) {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    int i = binary_search_insertion.BinarySearchInsertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i == nums.Length || nums[i] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfunc binarySearchLeftEdge(nums []int, target int) int {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    i := binarySearchInsertion(nums, target)\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if i == len(nums) || nums[i] != target {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i\n}\n</code></pre> binary_search_edge.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfunc binarySearchLeftEdge(nums: [Int], target: Int) -&gt; Int {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    let i = binarySearchInsertion(nums: nums, target: target)\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if i == nums.endIndex || nums[i] != target {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i\n}\n</code></pre> binary_search_edge.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfunction binarySearchLeftEdge(nums, target) {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    const i = binarySearchInsertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i === nums.length || nums[i] !== target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfunction binarySearchLeftEdge(nums: Array&lt;number&gt;, target: number): number {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    const i = binarySearchInsertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i === nums.length || nums[i] !== target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nint binarySearchLeftEdge(List&lt;int&gt; nums, int target) {\n  // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n  int i = binarySearchInsertion(nums, target);\n  // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n  if (i == nums.length || nums[i] != target) {\n    return -1;\n  }\n  // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n  return i;\n}\n</code></pre> binary_search_edge.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfn binary_search_left_edge(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    let i = binary_search_insertion(nums, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if i == nums.len() as i32 || nums[i as usize] != target {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    i\n}\n</code></pre> binary_search_edge.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nint binarySearchLeftEdge(int *nums, int numSize, int target) {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    int i = binarySearchInsertion(nums, numSize, target);\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i == numSize || nums[i] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i;\n}\n</code></pre> binary_search_edge.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target */\nfun binarySearchLeftEdge(nums: IntArray, target: Int): Int {\n    // \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n    val i = binarySearchInsertion(nums, target)\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (i == nums.size || nums[i] != target) {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\n    return i\n}\n</code></pre> binary_search_edge.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target ###\ndef binary_search_left_edge(nums, target)\n  # \u7b49\u4ef7\u4e8e\u67e5\u627e target \u7684\u63d2\u5165\u70b9\n  i = binary_search_insertion(nums, target)\n\n  # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n  return -1 if i == nums.length || nums[i] != target\n\n  i # \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 i\nend\n</code></pre> binary_search_edge.zig<pre><code>[class]{}-[func]{binarySearchLeftEdge}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_searching/binary_search_edge/#1032-find-the-right-boundary","title":"10.3.2 \u00a0 Find the right boundary","text":"<p>So how do we find the rightmost <code>target</code>? The most straightforward way is to modify the code, replacing the pointer contraction operation in the case of <code>nums[m] == target</code>. The code is omitted here, but interested readers can implement it on their own.</p> <p>Below we introduce two more cunning methods.</p>"},{"location":"chapter_searching/binary_search_edge/#1-reusing-the-search-for-the-left-boundary","title":"1. \u00a0 Reusing the search for the left boundary","text":"<p>In fact, we can use the function for finding the leftmost element to find the rightmost element, specifically by transforming the search for the rightmost <code>target</code> into a search for the leftmost <code>target + 1</code>.</p> <p>As shown in Figure 10-7, after the search is completed, the pointer \\(i\\) points to the leftmost <code>target + 1</code> (if it exists), while \\(j\\) points to the rightmost <code>target</code>, thus returning \\(j\\) is sufficient.</p> <p></p> <p> Figure 10-7 \u00a0 Transforming the search for the right boundary into the search for the left boundary </p> <p>Please note, the insertion point returned is \\(i\\), therefore, it should be subtracted by \\(1\\) to obtain \\(j\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_edge.py<pre><code>def binary_search_right_edge(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target\"\"\"\n    # \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    i = binary_search_insertion(nums, target + 1)\n    # j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    j = i - 1\n    # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if j == -1 or nums[j] != target:\n        return -1\n    # \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j\n</code></pre> binary_search_edge.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nint binarySearchRightEdge(vector&lt;int&gt; &amp;nums, int target) {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    int i = binarySearchInsertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    int j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nint binarySearchRightEdge(int[] nums, int target) {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    int i = binary_search_insertion.binarySearchInsertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    int j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nint BinarySearchRightEdge(int[] nums, int target) {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    int i = binary_search_insertion.BinarySearchInsertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    int j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfunc binarySearchRightEdge(nums []int, target int) int {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    i := binarySearchInsertion(nums, target+1)\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    j := i - 1\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if j == -1 || nums[j] != target {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j\n}\n</code></pre> binary_search_edge.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfunc binarySearchRightEdge(nums: [Int], target: Int) -&gt; Int {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    let i = binarySearchInsertion(nums: nums, target: target + 1)\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    let j = i - 1\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if j == -1 || nums[j] != target {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j\n}\n</code></pre> binary_search_edge.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfunction binarySearchRightEdge(nums, target) {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    const i = binarySearchInsertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    const j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j === -1 || nums[j] !== target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfunction binarySearchRightEdge(nums: Array&lt;number&gt;, target: number): number {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    const i = binarySearchInsertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    const j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j === -1 || nums[j] !== target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nint binarySearchRightEdge(List&lt;int&gt; nums, int target) {\n  // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n  int i = binarySearchInsertion(nums, target + 1);\n  // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n  int j = i - 1;\n  // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n  if (j == -1 || nums[j] != target) {\n    return -1;\n  }\n  // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n  return j;\n}\n</code></pre> binary_search_edge.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfn binary_search_right_edge(nums: &amp;[i32], target: i32) -&gt; i32 {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    let i = binary_search_insertion(nums, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    let j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if j == -1 || nums[j as usize] != target {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    j\n}\n</code></pre> binary_search_edge.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nint binarySearchRightEdge(int *nums, int numSize, int target) {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    int i = binarySearchInsertion(nums, numSize, target + 1);\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    int j = i - 1;\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j == -1 || nums[j] != target) {\n        return -1;\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j;\n}\n</code></pre> binary_search_edge.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target */\nfun binarySearchRightEdge(nums: IntArray, target: Int): Int {\n    // \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n    val i = binarySearchInsertion(nums, target + 1)\n    // j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n    val j = i - 1\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n    if (j == -1 || nums[j] != target) {\n        return -1\n    }\n    // \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\n    return j\n}\n</code></pre> binary_search_edge.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\u6700\u53f3\u4e00\u4e2a target ###\ndef binary_search_right_edge(nums, target)\n  # \u8f6c\u5316\u4e3a\u67e5\u627e\u6700\u5de6\u4e00\u4e2a target + 1\n  i = binary_search_insertion(nums, target + 1)\n\n  # j \u6307\u5411\u6700\u53f3\u4e00\u4e2a target \uff0ci \u6307\u5411\u9996\u4e2a\u5927\u4e8e target \u7684\u5143\u7d20\n  j = i - 1\n\n  # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de -1\n  return -1 if j == -1 || nums[j] != target\n\n  j # \u627e\u5230 target \uff0c\u8fd4\u56de\u7d22\u5f15 j\nend\n</code></pre> binary_search_edge.zig<pre><code>[class]{}-[func]{binarySearchRightEdge}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_searching/binary_search_edge/#2-transforming-into-an-element-search","title":"2. \u00a0 Transforming into an element search","text":"<p>We know that when the array does not contain <code>target</code>, \\(i\\) and \\(j\\) will eventually point to the first element greater and smaller than <code>target</code> respectively.</p> <p>Thus, as shown in Figure 10-8, we can construct an element that does not exist in the array, to search for the left and right boundaries.</p> <ul> <li>To find the leftmost <code>target</code>: it can be transformed into searching for <code>target - 0.5</code>, and return the pointer \\(i\\).</li> <li>To find the rightmost <code>target</code>: it can be transformed into searching for <code>target + 0.5</code>, and return the pointer \\(j\\).</li> </ul> <p></p> <p> Figure 10-8 \u00a0 Transforming the search for boundaries into the search for an element </p> <p>The code is omitted here, but two points are worth noting.</p> <ul> <li>The given array does not contain decimals, meaning we do not need to worry about how to handle equal situations.</li> <li>Since this method introduces decimals, the variable <code>target</code> in the function needs to be changed to a floating point type (no change needed in Python).</li> </ul>"},{"location":"chapter_searching/binary_search_insertion/","title":"10.2 \u00a0 Binary search insertion","text":"<p>Binary search is not only used to search for target elements but also to solve many variant problems, such as searching for the insertion position of target elements.</p>"},{"location":"chapter_searching/binary_search_insertion/#1021-case-with-no-duplicate-elements","title":"10.2.1 \u00a0 Case with no duplicate elements","text":"<p>Question</p> <p>Given an ordered array <code>nums</code> of length \\(n\\) and an element <code>target</code>, where the array has no duplicate elements. Now insert <code>target</code> into the array <code>nums</code> while maintaining its order. If the element <code>target</code> already exists in the array, insert it to its left side. Please return the index of <code>target</code> in the array after insertion. See the example shown in Figure 10-4.</p> <p></p> <p> Figure 10-4 \u00a0 Example data for binary search insertion point </p> <p>If you want to reuse the binary search code from the previous section, you need to answer the following two questions.</p> <p>Question one: When the array contains <code>target</code>, is the insertion point index the index of that element?</p> <p>The requirement to insert <code>target</code> to the left of equal elements means that the newly inserted <code>target</code> replaces the original <code>target</code> position. Thus, when the array contains <code>target</code>, the insertion point index is the index of that <code>target</code>.</p> <p>Question two: When the array does not contain <code>target</code>, what is the index of the insertion point?</p> <p>Further consider the binary search process: when <code>nums[m] &lt; target</code>, pointer \\(i\\) moves, meaning that pointer \\(i\\) is approaching an element greater than or equal to <code>target</code>. Similarly, pointer \\(j\\) is always approaching an element less than or equal to <code>target</code>.</p> <p>Therefore, at the end of the binary, it is certain that: \\(i\\) points to the first element greater than <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>. It is easy to see that when the array does not contain <code>target</code>, the insertion index is \\(i\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_insertion.py<pre><code>def binary_search_insertion_simple(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09\"\"\"\n    i, j = 0, len(nums) - 1  # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while i &lt;= j:\n        m = (i + j) // 2  # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target:\n            i = m + 1  # target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        elif nums[m] &gt; target:\n            j = m - 1  # target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        else:\n            return m  # \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n    # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n</code></pre> binary_search_insertion.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertionSimple(vector&lt;int&gt; &amp;nums, int target) {\n    int i = 0, j = nums.size() - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertionSimple(int[] nums, int target) {\n    int i = 0, j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nint BinarySearchInsertionSimple(int[] nums, int target) {\n    int i = 0, j = nums.Length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfunc binarySearchInsertionSimple(nums []int, target int) int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    i, j := 0, len(nums)-1\n    for i &lt;= j {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        m := i + (j-i)/2\n        if nums[m] &lt; target {\n            // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target {\n            // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        } else {\n            // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n            return m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfunc binarySearchInsertionSimple(nums: [Int], target: Int) -&gt; Int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target {\n            i = m + 1 // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if nums[m] &gt; target {\n            j = m - 1 // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfunction binarySearchInsertionSimple(nums, target) {\n    let i = 0,\n        j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m, \u4f7f\u7528 Math.floor() \u5411\u4e0b\u53d6\u6574\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfunction binarySearchInsertionSimple(\n    nums: Array&lt;number&gt;,\n    target: number\n): number {\n    let i = 0,\n        j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m, \u4f7f\u7528 Math.floor() \u5411\u4e0b\u53d6\u6574\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertionSimple(List&lt;int&gt; nums, int target) {\n  int i = 0, j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    if (nums[m] &lt; target) {\n      i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n    } else if (nums[m] &gt; target) {\n      j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n    } else {\n      return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n    }\n  }\n  // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n  return i;\n}\n</code></pre> binary_search_insertion.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfn binary_search_insertion_simple(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let (mut i, mut j) = (0, nums.len() as i32 - 1); // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m as usize] &lt; target {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if nums[m as usize] &gt; target {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m;\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    i\n}\n</code></pre> binary_search_insertion.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertionSimple(int *nums, int numSize, int target) {\n    int i = 0, j = numSize - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m; // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 */\nfun binarySearchInsertionSimple(nums: IntArray, target: Int): Int {\n    var i = 0\n    var j = nums.size - 1 // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1 // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1 // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            return m // \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n        }\n    }\n    // \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u65e0\u91cd\u590d\u5143\u7d20\uff09 ###\ndef binary_search_insertion_simple(nums, target)\n  # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n  i, j = 0, nums.length - 1\n\n  while i &lt;= j\n    # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n    elsif nums[m] &gt; target\n      j = m - 1 # target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n    else\n      return m  # \u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 m\n    end\n  end\n\n  i # \u672a\u627e\u5230 target \uff0c\u8fd4\u56de\u63d2\u5165\u70b9 i\nend\n</code></pre> binary_search_insertion.zig<pre><code>[class]{}-[func]{binarySearchInsertionSimple}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_searching/binary_search_insertion/#1022-case-with-duplicate-elements","title":"10.2.2 \u00a0 Case with duplicate elements","text":"<p>Question</p> <p>Based on the previous question, assume the array may contain duplicate elements, all else remains the same.</p> <p>Suppose there are multiple <code>target</code>s in the array, ordinary binary search can only return the index of one of the <code>target</code>s, and it cannot determine how many <code>target</code>s are to the left and right of that element.</p> <p>The task requires inserting the target element to the very left, so we need to find the index of the leftmost <code>target</code> in the array. Initially consider implementing this through the steps shown in Figure 10-5.</p> <ol> <li>Perform a binary search, get an arbitrary index of <code>target</code>, denoted as \\(k\\).</li> <li>Start from index \\(k\\), and perform a linear search to the left until the leftmost <code>target</code> is found and return.</li> </ol> <p></p> <p> Figure 10-5 \u00a0 Linear search for the insertion point of duplicate elements </p> <p>Although this method is feasible, it includes linear search, so its time complexity is \\(O(n)\\). This method is inefficient when the array contains many duplicate <code>target</code>s.</p> <p>Now consider extending the binary search code. As shown in Figure 10-6, the overall process remains the same, each round first calculates the midpoint index \\(m\\), then judges the size relationship between <code>target</code> and <code>nums[m]</code>, divided into the following cases.</p> <ul> <li>When <code>nums[m] &lt; target</code> or <code>nums[m] &gt; target</code>, it means <code>target</code> has not been found yet, thus use the normal binary search interval reduction operation, thus making pointers \\(i\\) and \\(j\\) approach <code>target</code>.</li> <li>When <code>nums[m] == target</code>, it indicates that the elements less than <code>target</code> are in the interval \\([i, m - 1]\\), therefore use \\(j = m - 1\\) to narrow the interval, thus making pointer \\(j\\) approach elements less than <code>target</code>.</li> </ul> <p>After the loop, \\(i\\) points to the leftmost <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>, therefore index \\(i\\) is the insertion point.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 10-6 \u00a0 Steps for binary search insertion point of duplicate elements </p> <p>Observe the code, the operations of the branch <code>nums[m] &gt; target</code> and <code>nums[m] == target</code> are the same, so the two can be combined.</p> <p>Even so, we can still keep the conditions expanded, as their logic is clearer and more readable.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_insertion.py<pre><code>def binary_search_insertion(nums: list[int], target: int) -&gt; int:\n    \"\"\"\u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09\"\"\"\n    i, j = 0, len(nums) - 1  # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while i &lt;= j:\n        m = (i + j) // 2  # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target:\n            i = m + 1  # target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        elif nums[m] &gt; target:\n            j = m - 1  # target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        else:\n            j = m - 1  # \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n    # \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n</code></pre> binary_search_insertion.cpp<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertion(vector&lt;int&gt; &amp;nums, int target) {\n    int i = 0, j = nums.size() - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.java<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertion(int[] nums, int target) {\n    int i = 0, j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.cs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nint BinarySearchInsertion(int[] nums, int target) {\n    int i = 0, j = nums.Length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.go<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nfunc binarySearchInsertion(nums []int, target int) int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    i, j := 0, len(nums)-1\n    for i &lt;= j {\n        // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        m := i + (j-i)/2\n        if nums[m] &lt; target {\n            // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n            i = m + 1\n        } else if nums[m] &gt; target {\n            // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        } else {\n            // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n            j = m - 1\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.swift<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nfunc binarySearchInsertion(nums: [Int], target: Int) -&gt; Int {\n    // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    var i = nums.startIndex\n    var j = nums.endIndex - 1\n    while i &lt;= j {\n        let m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m] &lt; target {\n            i = m + 1 // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if nums[m] &gt; target {\n            j = m - 1 // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1 // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.js<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nfunction binarySearchInsertion(nums, target) {\n    let i = 0,\n        j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m, \u4f7f\u7528 Math.floor() \u5411\u4e0b\u53d6\u6574\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.ts<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nfunction binarySearchInsertion(nums: Array&lt;number&gt;, target: number): number {\n    let i = 0,\n        j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        const m = Math.floor(i + (j - i) / 2); // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m, \u4f7f\u7528 Math.floor() \u5411\u4e0b\u53d6\u6574\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.dart<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertion(List&lt;int&gt; nums, int target) {\n  int i = 0, j = nums.length - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n  while (i &lt;= j) {\n    int m = i + (j - i) ~/ 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    if (nums[m] &lt; target) {\n      i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n    } else if (nums[m] &gt; target) {\n      j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n    } else {\n      j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n    }\n  }\n  // \u8fd4\u56de\u63d2\u5165\u70b9 i\n  return i;\n}\n</code></pre> binary_search_insertion.rs<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\npub fn binary_search_insertion(nums: &amp;[i32], target: i32) -&gt; i32 {\n    let (mut i, mut j) = (0, nums.len() as i32 - 1); // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while i &lt;= j {\n        let m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if nums[m as usize] &lt; target {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if nums[m as usize] &gt; target {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    i\n}\n</code></pre> binary_search_insertion.c<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nint binarySearchInsertion(int *nums, int numSize, int target) {\n    int i = 0, j = numSize - 1; // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        int m = i + (j - i) / 2; // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1; // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1; // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1; // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i;\n}\n</code></pre> binary_search_insertion.kt<pre><code>/* \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 */\nfun binarySearchInsertion(nums: IntArray, target: Int): Int {\n    var i = 0\n    var j = nums.size - 1 // \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n    while (i &lt;= j) {\n        val m = i + (j - i) / 2 // \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n        if (nums[m] &lt; target) {\n            i = m + 1 // target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n        } else if (nums[m] &gt; target) {\n            j = m - 1 // target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n        } else {\n            j = m - 1 // \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n        }\n    }\n    // \u8fd4\u56de\u63d2\u5165\u70b9 i\n    return i\n}\n</code></pre> binary_search_insertion.rb<pre><code>### \u4e8c\u5206\u67e5\u627e\u63d2\u5165\u70b9\uff08\u5b58\u5728\u91cd\u590d\u5143\u7d20\uff09 ###\ndef binary_search_insertion(nums, target)\n  # \u521d\u59cb\u5316\u53cc\u95ed\u533a\u95f4 [0, n-1]\n  i, j = 0, nums.length - 1\n\n  while i &lt;= j\n    # \u8ba1\u7b97\u4e2d\u70b9\u7d22\u5f15 m\n    m = (i + j) / 2\n\n    if nums[m] &lt; target\n      i = m + 1 # target \u5728\u533a\u95f4 [m+1, j] \u4e2d\n    elsif nums[m] &gt; target\n      j = m - 1 # target \u5728\u533a\u95f4 [i, m-1] \u4e2d\n    else\n      j = m - 1 # \u9996\u4e2a\u5c0f\u4e8e target \u7684\u5143\u7d20\u5728\u533a\u95f4 [i, m-1] \u4e2d\n    end\n  end\n\n  i # \u8fd4\u56de\u63d2\u5165\u70b9 i\nend\n</code></pre> binary_search_insertion.zig<pre><code>[class]{}-[func]{binarySearchInsertion}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Tip</p> <p>The code in this section uses \"closed intervals\". Readers interested can implement the \"left-closed right-open\" method themselves.</p> <p>In summary, binary search is merely about setting search targets for pointers \\(i\\) and \\(j\\), which might be a specific element (like <code>target</code>) or a range of elements (like elements less than <code>target</code>).</p> <p>In the continuous loop of binary search, pointers \\(i\\) and \\(j\\) gradually approach the predefined target. Ultimately, they either find the answer or stop after crossing the boundary.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/","title":"10.4 \u00a0 Hash optimization strategies","text":"<p>In algorithm problems, we often reduce the time complexity of algorithms by replacing linear search with hash search. Let's use an algorithm problem to deepen understanding.</p> <p>Question</p> <p>Given an integer array <code>nums</code> and a target element <code>target</code>, please search for two elements in the array whose \"sum\" equals <code>target</code>, and return their array indices. Any solution is acceptable.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#1041-linear-search-trading-time-for-space","title":"10.4.1 \u00a0 Linear search: trading time for space","text":"<p>Consider traversing all possible combinations directly. As shown in Figure 10-9, we initiate a two-layer loop, and in each round, we determine whether the sum of the two integers equals <code>target</code>. If so, we return their indices.</p> <p></p> <p> Figure 10-9 \u00a0 Linear search solution for two-sum problem </p> <p>The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig two_sum.py<pre><code>def two_sum_brute_force(nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"\u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e\"\"\"\n    # \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n</code></pre> two_sum.cpp<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nvector&lt;int&gt; twoSumBruteForce(vector&lt;int&gt; &amp;nums, int target) {\n    int size = nums.size();\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return {i, j};\n        }\n    }\n    return {};\n}\n</code></pre> two_sum.java<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nint[] twoSumBruteForce(int[] nums, int target) {\n    int size = nums.length;\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return new int[] { i, j };\n        }\n    }\n    return new int[0];\n}\n</code></pre> two_sum.cs<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nint[] TwoSumBruteForce(int[] nums, int target) {\n    int size = nums.Length;\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (int i = 0; i &lt; size - 1; i++) {\n        for (int j = i + 1; j &lt; size; j++) {\n            if (nums[i] + nums[j] == target)\n                return [i, j];\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.go<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nfunc twoSumBruteForce(nums []int, target int) []int {\n    size := len(nums)\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for i := 0; i &lt; size-1; i++ {\n        for j := i + 1; j &lt; size; j++ {\n            if nums[i]+nums[j] == target {\n                return []int{i, j}\n            }\n        }\n    }\n    return nil\n}\n</code></pre> two_sum.swift<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nfunc twoSumBruteForce(nums: [Int], target: Int) -&gt; [Int] {\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for i in nums.indices.dropLast() {\n        for j in nums.indices.dropFirst(i + 1) {\n            if nums[i] + nums[j] == target {\n                return [i, j]\n            }\n        }\n    }\n    return [0]\n}\n</code></pre> two_sum.js<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nfunction twoSumBruteForce(nums, target) {\n    const n = nums.length;\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.ts<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nfunction twoSumBruteForce(nums: number[], target: number): number[] {\n    const n = nums.length;\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.dart<pre><code>/* \u65b9\u6cd5\u4e00\uff1a \u66b4\u529b\u679a\u4e3e */\nList&lt;int&gt; twoSumBruteForce(List&lt;int&gt; nums, int target) {\n  int size = nums.length;\n  // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n  for (var i = 0; i &lt; size - 1; i++) {\n    for (var j = i + 1; j &lt; size; j++) {\n      if (nums[i] + nums[j] == target) return [i, j];\n    }\n  }\n  return [0];\n}\n</code></pre> two_sum.rs<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\npub fn two_sum_brute_force(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; Option&lt;Vec&lt;i32&gt;&gt; {\n    let size = nums.len();\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for i in 0..size - 1 {\n        for j in i + 1..size {\n            if nums[i] + nums[j] == target {\n                return Some(vec![i as i32, j as i32]);\n            }\n        }\n    }\n    None\n}\n</code></pre> two_sum.c<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nint *twoSumBruteForce(int *nums, int numsSize, int target, int *returnSize) {\n    for (int i = 0; i &lt; numsSize; ++i) {\n        for (int j = i + 1; j &lt; numsSize; ++j) {\n            if (nums[i] + nums[j] == target) {\n                int *res = malloc(sizeof(int) * 2);\n                res[0] = i, res[1] = j;\n                *returnSize = 2;\n                return res;\n            }\n        }\n    }\n    *returnSize = 0;\n    return NULL;\n}\n</code></pre> two_sum.kt<pre><code>/* \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e */\nfun twoSumBruteForce(nums: IntArray, target: Int): IntArray {\n    val size = nums.size\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    for (i in 0..&lt;size - 1) {\n        for (j in i + 1..&lt;size) {\n            if (nums[i] + nums[j] == target) return intArrayOf(i, j)\n        }\n    }\n    return IntArray(0)\n}\n</code></pre> two_sum.rb<pre><code>### \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e ###\ndef two_sum_brute_force(nums, target)\n  # \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n  for i in 0...(nums.length - 1)\n    for j in (i + 1)...nums.length\n      return [i, j] if nums[i] + nums[j] == target\n    end\n  end\n\n  []\nend\n</code></pre> two_sum.zig<pre><code>// \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u679a\u4e3e\nfn twoSumBruteForce(nums: []i32, target: i32) ?[2]i32 {\n    var size: usize = nums.len;\n    var i: usize = 0;\n    // \u4e24\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n^2)\n    while (i &lt; size - 1) : (i += 1) {\n        var j = i + 1;\n        while (j &lt; size) : (j += 1) {\n            if (nums[i] + nums[j] == target) {\n                return [_]i32{@intCast(i), @intCast(j)};\n            }\n        }\n    }\n    return null;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>This method has a time complexity of \\(O(n^2)\\) and a space complexity of \\(O(1)\\), which is very time-consuming with large data volumes.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#1042-hash-search-trading-space-for-time","title":"10.4.2 \u00a0 Hash search: trading space for time","text":"<p>Consider using a hash table, with key-value pairs being the array elements and their indices, respectively. Loop through the array, performing the steps shown in the figures below each round.</p> <ol> <li>Check if the number <code>target - nums[i]</code> is in the hash table. If so, directly return the indices of these two elements.</li> <li>Add the key-value pair <code>nums[i]</code> and index <code>i</code> to the hash table.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt; <p></p> <p></p> <p></p> <p> Figure 10-10 \u00a0 Help hash table solve two-sum </p> <p>The implementation code is shown below, requiring only a single loop:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig two_sum.py<pre><code>def two_sum_hash_table(nums: list[int], target: int) -&gt; list[int]:\n    \"\"\"\u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868\"\"\"\n    # \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    dic = {}\n    # \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for i in range(len(nums)):\n        if target - nums[i] in dic:\n            return [dic[target - nums[i]], i]\n        dic[nums[i]] = i\n    return []\n</code></pre> two_sum.cpp<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nvector&lt;int&gt; twoSumHashTable(vector&lt;int&gt; &amp;nums, int target) {\n    int size = nums.size();\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    unordered_map&lt;int, int&gt; dic;\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.find(target - nums[i]) != dic.end()) {\n            return {dic[target - nums[i]], i};\n        }\n        dic.emplace(nums[i], i);\n    }\n    return {};\n}\n</code></pre> two_sum.java<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nint[] twoSumHashTable(int[] nums, int target) {\n    int size = nums.length;\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    Map&lt;Integer, Integer&gt; dic = new HashMap&lt;&gt;();\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.containsKey(target - nums[i])) {\n            return new int[] { dic.get(target - nums[i]), i };\n        }\n        dic.put(nums[i], i);\n    }\n    return new int[0];\n}\n</code></pre> two_sum.cs<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nint[] TwoSumHashTable(int[] nums, int target) {\n    int size = nums.Length;\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    Dictionary&lt;int, int&gt; dic = [];\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (int i = 0; i &lt; size; i++) {\n        if (dic.ContainsKey(target - nums[i])) {\n            return [dic[target - nums[i]], i];\n        }\n        dic.Add(nums[i], i);\n    }\n    return [];\n}\n</code></pre> two_sum.go<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nfunc twoSumHashTable(nums []int, target int) []int {\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    hashTable := map[int]int{}\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for idx, val := range nums {\n        if preIdx, ok := hashTable[target-val]; ok {\n            return []int{preIdx, idx}\n        }\n        hashTable[val] = idx\n    }\n    return nil\n}\n</code></pre> two_sum.swift<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nfunc twoSumHashTable(nums: [Int], target: Int) -&gt; [Int] {\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    var dic: [Int: Int] = [:]\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for i in nums.indices {\n        if let j = dic[target - nums[i]] {\n            return [j, i]\n        }\n        dic[nums[i]] = i\n    }\n    return [0]\n}\n</code></pre> two_sum.js<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nfunction twoSumHashTable(nums, target) {\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    let m = {};\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (let i = 0; i &lt; nums.length; i++) {\n        if (m[target - nums[i]] !== undefined) {\n            return [m[target - nums[i]], i];\n        } else {\n            m[nums[i]] = i;\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.ts<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nfunction twoSumHashTable(nums: number[], target: number): number[] {\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    let m: Map&lt;number, number&gt; = new Map();\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (let i = 0; i &lt; nums.length; i++) {\n        let index = m.get(target - nums[i]);\n        if (index !== undefined) {\n            return [index, i];\n        } else {\n            m.set(nums[i], i);\n        }\n    }\n    return [];\n}\n</code></pre> two_sum.dart<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a \u8f85\u52a9\u54c8\u5e0c\u8868 */\nList&lt;int&gt; twoSumHashTable(List&lt;int&gt; nums, int target) {\n  int size = nums.length;\n  // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n  Map&lt;int, int&gt; dic = HashMap();\n  // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n  for (var i = 0; i &lt; size; i++) {\n    if (dic.containsKey(target - nums[i])) {\n      return [dic[target - nums[i]]!, i];\n    }\n    dic.putIfAbsent(nums[i], () =&gt; i);\n  }\n  return [0];\n}\n</code></pre> two_sum.rs<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\npub fn two_sum_hash_table(nums: &amp;Vec&lt;i32&gt;, target: i32) -&gt; Option&lt;Vec&lt;i32&gt;&gt; {\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    let mut dic = HashMap::new();\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (i, num) in nums.iter().enumerate() {\n        match dic.get(&amp;(target - num)) {\n            Some(v) =&gt; return Some(vec![*v as i32, i as i32]),\n            None =&gt; dic.insert(num, i as i32),\n        };\n    }\n    None\n}\n</code></pre> two_sum.c<pre><code>/* \u54c8\u5e0c\u8868 */\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh; // \u57fa\u4e8e uthash.h \u5b9e\u73b0\n} HashTable;\n\n/* \u54c8\u5e0c\u8868\u67e5\u8be2 */\nHashTable *find(HashTable *h, int key) {\n    HashTable *tmp;\n    HASH_FIND_INT(h, &amp;key, tmp);\n    return tmp;\n}\n\n/* \u54c8\u5e0c\u8868\u5143\u7d20\u63d2\u5165 */\nvoid insert(HashTable *h, int key, int val) {\n    HashTable *t = find(h, key);\n    if (t == NULL) {\n        HashTable *tmp = malloc(sizeof(HashTable));\n        tmp-&gt;key = key, tmp-&gt;val = val;\n        HASH_ADD_INT(h, key, tmp);\n    } else {\n        t-&gt;val = val;\n    }\n}\n\n/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nint *twoSumHashTable(int *nums, int numsSize, int target, int *returnSize) {\n    HashTable *hashtable = NULL;\n    for (int i = 0; i &lt; numsSize; i++) {\n        HashTable *t = find(hashtable, target - nums[i]);\n        if (t != NULL) {\n            int *res = malloc(sizeof(int) * 2);\n            res[0] = t-&gt;val, res[1] = i;\n            *returnSize = 2;\n            return res;\n        }\n        insert(hashtable, nums[i], i);\n    }\n    *returnSize = 0;\n    return NULL;\n}\n</code></pre> two_sum.kt<pre><code>/* \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 */\nfun twoSumHashTable(nums: IntArray, target: Int): IntArray {\n    val size = nums.size\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    val dic = HashMap&lt;Int, Int&gt;()\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    for (i in 0..&lt;size) {\n        if (dic.containsKey(target - nums[i])) {\n            return intArrayOf(dic[target - nums[i]]!!, i)\n        }\n        dic[nums[i]] = i\n    }\n    return IntArray(0)\n}\n</code></pre> two_sum.rb<pre><code>### \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868 ###\ndef two_sum_hash_table(nums, target)\n  # \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n  dic = {}\n  # \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n  for i in 0...nums.length\n    return [dic[target - nums[i]], i] if dic.has_key?(target - nums[i])\n\n    dic[nums[i]] = i\n  end\n\n  []\nend\n</code></pre> two_sum.zig<pre><code>// \u65b9\u6cd5\u4e8c\uff1a\u8f85\u52a9\u54c8\u5e0c\u8868\nfn twoSumHashTable(nums: []i32, target: i32) !?[2]i32 {\n    var size: usize = nums.len;\n    // \u8f85\u52a9\u54c8\u5e0c\u8868\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    var dic = std.AutoHashMap(i32, i32).init(std.heap.page_allocator);\n    defer dic.deinit();\n    var i: usize = 0;\n    // \u5355\u5c42\u5faa\u73af\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\n    while (i &lt; size) : (i += 1) {\n        if (dic.contains(target - nums[i])) {\n            return [_]i32{dic.get(target - nums[i]).?, @intCast(i)};\n        }\n        try dic.put(nums[i], @intCast(i));\n    }\n    return null;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>This method reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) by using hash search, greatly improving the running efficiency.</p> <p>As it requires maintaining an additional hash table, the space complexity is \\(O(n)\\). Nevertheless, this method has a more balanced time-space efficiency overall, making it the optimal solution for this problem.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/","title":"10.5 \u00a0 Search algorithms revisited","text":"<p>Searching algorithms (searching algorithm) are used to search for one or several elements that meet specific criteria in data structures such as arrays, linked lists, trees, or graphs.</p> <p>Searching algorithms can be divided into the following two categories based on their implementation approaches.</p> <ul> <li>Locating the target element by traversing the data structure, such as traversals of arrays, linked lists, trees, and graphs, etc.</li> <li>Using the organizational structure of the data or the prior information contained in the data to achieve efficient element search, such as binary search, hash search, and binary search tree search, etc.</li> </ul> <p>It is not difficult to notice that these topics have been introduced in previous chapters, so searching algorithms are not unfamiliar to us. In this section, we will revisit searching algorithms from a more systematic perspective.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1051-brute-force-search","title":"10.5.1 \u00a0 Brute-force search","text":"<p>Brute-force search locates the target element by traversing every element of the data structure.</p> <ul> <li>\"Linear search\" is suitable for linear data structures such as arrays and linked lists. It starts from one end of the data structure, accesses each element one by one, until the target element is found or the other end is reached without finding the target element.</li> <li>\"Breadth-first search\" and \"Depth-first search\" are two traversal strategies for graphs and trees. Breadth-first search starts from the initial node and searches layer by layer, accessing nodes from near to far. Depth-first search starts from the initial node, follows a path until the end, then backtracks and tries other paths until the entire data structure is traversed.</li> </ul> <p>The advantage of brute-force search is its simplicity and versatility, no need for data preprocessing and the help of additional data structures.</p> <p>However, the time complexity of this type of algorithm is \\(O(n)\\), where \\(n\\) is the number of elements, so the performance is poor in cases of large data volumes.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1052-adaptive-search","title":"10.5.2 \u00a0 Adaptive search","text":"<p>Adaptive search uses the unique properties of data (such as order) to optimize the search process, thereby locating the target element more efficiently.</p> <ul> <li>\"Binary search\" uses the orderliness of data to achieve efficient searching, only suitable for arrays.</li> <li>\"Hash search\" uses a hash table to establish a key-value mapping between search data and target data, thus implementing the query operation.</li> <li>\"Tree search\" in a specific tree structure (such as a binary search tree), quickly eliminates nodes based on node value comparisons, thus locating the target element.</li> </ul> <p>The advantage of these algorithms is high efficiency, with time complexities reaching \\(O(\\log n)\\) or even \\(O(1)\\).</p> <p>However, using these algorithms often requires data preprocessing. For example, binary search requires sorting the array in advance, and hash search and tree search both require the help of additional data structures, maintaining these structures also requires extra time and space overhead.</p> <p>Tip</p> <p>Adaptive search algorithms are often referred to as search algorithms, mainly used for quickly retrieving target elements in specific data structures.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#1053-choosing-a-search-method","title":"10.5.3 \u00a0 Choosing a search method","text":"<p>Given a set of data of size \\(n\\), we can use linear search, binary search, tree search, hash search, and other methods to search for the target element from it. The working principles of these methods are shown in Figure 10-11.</p> <p></p> <p> Figure 10-11 \u00a0 Various search strategies </p> <p>The operation efficiency and characteristics of the aforementioned methods are shown in the following table.</p> <p> Table 10-1 \u00a0 Comparison of search algorithm efficiency </p> Linear search Binary search Tree search Hash search Search element \\(O(n)\\) \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(1)\\) Insert element \\(O(1)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Delete element \\(O(n)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Extra space \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) \\(O(n)\\) Data preprocessing / Sorting \\(O(n \\log n)\\) Building tree \\(O(n \\log n)\\) Building hash table \\(O(n)\\) Data orderliness Unordered Ordered Ordered Unordered <p>The choice of search algorithm also depends on the volume of data, search performance requirements, data query and update frequency, etc.</p> <p>Linear search</p> <ul> <li>Good versatility, no need for any data preprocessing operations. If we only need to query the data once, then the time for data preprocessing in the other three methods would be longer than the time for linear search.</li> <li>Suitable for small volumes of data, where time complexity has a smaller impact on efficiency.</li> <li>Suitable for scenarios with high data update frequency, because this method does not require any additional maintenance of the data.</li> </ul> <p>Binary search</p> <ul> <li>Suitable for large data volumes, with stable efficiency performance, the worst time complexity being \\(O(\\log n)\\).</li> <li>The data volume cannot be too large, because storing arrays requires contiguous memory space.</li> <li>Not suitable for scenarios with frequent additions and deletions, because maintaining an ordered array incurs high overhead.</li> </ul> <p>Hash search</p> <ul> <li>Suitable for scenarios with high query performance requirements, with an average time complexity of \\(O(1)\\).</li> <li>Not suitable for scenarios needing ordered data or range searches, because hash tables cannot maintain data orderliness.</li> <li>High dependency on hash functions and hash collision handling strategies, with significant performance degradation risks.</li> <li>Not suitable for overly large data volumes, because hash tables need extra space to minimize collisions and provide good query performance.</li> </ul> <p>Tree search</p> <ul> <li>Suitable for massive data, because tree nodes are stored scattered in memory.</li> <li>Suitable for maintaining ordered data or range searches.</li> <li>In the continuous addition and deletion of nodes, the binary search tree may become skewed, degrading the time complexity to \\(O(n)\\).</li> <li>If using AVL trees or red-black trees, operations can run stably at \\(O(\\log n)\\) efficiency, but the operation to maintain tree balance adds extra overhead.</li> </ul>"},{"location":"chapter_searching/summary/","title":"10.6 \u00a0 Summary","text":"<ul> <li>Binary search depends on the order of data and performs the search by iteratively halving the search interval. It requires the input data to be sorted and is only applicable to arrays or array-based data structures.</li> <li>Brute force search locates data by traversing the data structure. Linear search is suitable for arrays and linked lists, while breadth-first search and depth-first search are suitable for graphs and trees. These algorithms are highly versatile, requiring no preprocessing of data, but have a higher time complexity of \\(O(n)\\).</li> <li>Hash search, tree search, and binary search are efficient searching methods, capable of quickly locating target elements in specific data structures. These algorithms are highly efficient, with time complexities reaching \\(O(\\log n)\\) or even \\(O(1)\\), but they usually require additional data structures.</li> <li>In practice, we need to analyze factors such as data volume, search performance requirements, data query and update frequencies, etc., to choose the appropriate search method.</li> <li>Linear search is suitable for small or frequently updated data; binary search is suitable for large, sorted data; hash search is suitable for scenarios requiring high query efficiency without the need for range queries; tree search is appropriate for large dynamic data that needs to maintain order and support range queries.</li> <li>Replacing linear search with hash search is a common strategy to optimize runtime, reducing the time complexity from \\(O(n)\\) to \\(O(1)\\).</li> </ul>"},{"location":"chapter_sorting/","title":"Chapter 11. \u00a0 Sorting","text":"<p>Abstract</p> <p>Sorting is like a magical key that turns chaos into order, enabling us to understand and handle data in a more efficient manner.</p> <p>Whether it's simple ascending order or complex categorical arrangements, sorting reveals the harmonious beauty of data.</p>"},{"location":"chapter_sorting/#chapter-contents","title":"Chapter contents","text":"<ul> <li>11.1 \u00a0 Sorting algorithms</li> <li>11.2 \u00a0 Selection sort</li> <li>11.3 \u00a0 Bubble sort</li> <li>11.4 \u00a0 Insertion sort</li> <li>11.5 \u00a0 Quick sort</li> <li>11.6 \u00a0 Merge sort</li> <li>11.7 \u00a0 Heap sort</li> <li>11.8 \u00a0 Bucket sort</li> <li>11.9 \u00a0 Counting sort</li> <li>11.10 \u00a0 Radix sort</li> <li>11.11 \u00a0 Summary</li> </ul>"},{"location":"chapter_sorting/bubble_sort/","title":"11.3 \u00a0 Bubble sort","text":"<p>Bubble sort achieves sorting by continuously comparing and swapping adjacent elements. This process resembles bubbles rising from the bottom to the top, hence the name bubble sort.</p> <p>As shown in Figure 11-4, the bubbling process can be simulated using element swap operations: starting from the leftmost end of the array and moving right, sequentially compare the size of adjacent elements. If \"left element &gt; right element,\" then swap them. After the traversal, the largest element will be moved to the far right end of the array.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-4 \u00a0 Simulating bubble process using element swap </p>"},{"location":"chapter_sorting/bubble_sort/#1131-algorithm-process","title":"11.3.1 \u00a0 Algorithm process","text":"<p>Assuming the length of the array is \\(n\\), the steps of bubble sort are shown in Figure 11-5.</p> <ol> <li>First, perform a \"bubble\" on \\(n\\) elements, swapping the largest element to its correct position.</li> <li>Next, perform a \"bubble\" on the remaining \\(n - 1\\) elements, swapping the second largest element to its correct position.</li> <li>Similarly, after \\(n - 1\\) rounds of \"bubbling,\" the top \\(n - 1\\) largest elements will be swapped to their correct positions.</li> <li>The only remaining element is necessarily the smallest and does not require sorting, thus the array sorting is complete.</li> </ol> <p></p> <p> Figure 11-5 \u00a0 Bubble sort process </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig bubble_sort.py<pre><code>def bubble_sort(nums: list[int]):\n    \"\"\"\u5192\u6ce1\u6392\u5e8f\"\"\"\n    n = len(nums)\n    # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in range(n - 1, 0, -1):\n        # \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n</code></pre> bubble_sort.cpp<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nvoid bubbleSort(vector&lt;int&gt; &amp;nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                // \u8fd9\u91cc\u4f7f\u7528\u4e86 std::swap() \u51fd\u6570\n                swap(nums[j], nums[j + 1]);\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.java<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nvoid bubbleSort(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.cs<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nvoid BubbleSort(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.go<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfunc bubbleSort(nums []int) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.swift<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfunc bubbleSort(nums: inout [Int]) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums.swapAt(j, j + 1)\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.js<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfunction bubbleSort(nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.ts<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfunction bubbleSort(nums: number[]): void {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.dart<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nvoid bubbleSort(List&lt;int&gt; nums) {\n  // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n    for (int j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n      }\n    }\n  }\n}\n</code></pre> bubble_sort.rs<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfn bubble_sort(nums: &amp;mut [i32]) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in (1..nums.len()).rev() {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.c<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nvoid bubbleSort(int nums[], int size) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = size - 1; i &gt; 0; i--) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.kt<pre><code>/* \u5192\u6ce1\u6392\u5e8f */\nfun bubbleSort(nums: IntArray) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n            }\n        }\n    }\n}\n</code></pre> bubble_sort.rb<pre><code>[class]{}-[func]{bubble_sort}\n</code></pre> bubble_sort.zig<pre><code>// \u5192\u6ce1\u6392\u5e8f\nfn bubbleSort(nums: []i32) void {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    var i: usize = nums.len - 1;\n    while (i &gt; 0) : (i -= 1) {\n        var j: usize = 0;\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        while (j &lt; i) : (j += 1) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                var tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/bubble_sort/#1132-efficiency-optimization","title":"11.3.2 \u00a0 Efficiency optimization","text":"<p>We find that if no swaps are performed in a round of \"bubbling,\" the array is already sorted, and we can return the result immediately. Thus, we can add a flag <code>flag</code> to monitor this situation and return immediately when it occurs.</p> <p>Even after optimization, the worst-case time complexity and average time complexity of bubble sort remain at \\(O(n^2)\\); however, when the input array is completely ordered, it can achieve the best time complexity of \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig bubble_sort.py<pre><code>def bubble_sort_with_flag(nums: list[int]):\n    \"\"\"\u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09\"\"\"\n    n = len(nums)\n    # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in range(n - 1, 0, -1):\n        flag = False  # \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        # \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in range(i):\n            if nums[j] &gt; nums[j + 1]:\n                # \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True  # \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n        if not flag:\n            break  # \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n</code></pre> bubble_sort.cpp<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nvoid bubbleSortWithFlag(vector&lt;int&gt; &amp;nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.size() - 1; i &gt; 0; i--) {\n        bool flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                // \u8fd9\u91cc\u4f7f\u7528\u4e86 std::swap() \u51fd\u6570\n                swap(nums[j], nums[j + 1]);\n                flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag)\n            break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.java<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09 */\nvoid bubbleSortWithFlag(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        boolean flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag)\n            break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.cs<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nvoid BubbleSortWithFlag(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        bool flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                (nums[j + 1], nums[j]) = (nums[j], nums[j + 1]);\n                flag = true;  // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag) break;     // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.go<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nfunc bubbleSortWithFlag(nums []int) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i := len(nums) - 1; i &gt; 0; i-- {\n        flag := false // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j := 0; j &lt; i; j++ {\n            if nums[j] &gt; nums[j+1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n                flag = true // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if flag == false { // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n            break\n        }\n    }\n}\n</code></pre> bubble_sort.swift<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nfunc bubbleSortWithFlag(nums: inout [Int]) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in nums.indices.dropFirst().reversed() {\n        var flag = false // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        for j in 0 ..&lt; i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                nums.swapAt(j, j + 1)\n                flag = true // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if !flag { // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n            break\n        }\n    }\n}\n</code></pre> bubble_sort.js<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nfunction bubbleSortWithFlag(nums) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        let flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag) break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.ts<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nfunction bubbleSortWithFlag(nums: number[]): void {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        let flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (let j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag) break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.dart<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nvoid bubbleSortWithFlag(List&lt;int&gt; nums) {\n  // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    bool flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n    // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n    for (int j = 0; j &lt; i; j++) {\n      if (nums[j] &gt; nums[j + 1]) {\n        // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n        int tmp = nums[j];\n        nums[j] = nums[j + 1];\n        nums[j + 1] = tmp;\n        flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n      }\n    }\n    if (!flag) break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n  }\n}\n</code></pre> bubble_sort.rs<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09 */\nfn bubble_sort_with_flag(nums: &amp;mut [i32]) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for i in (1..nums.len()).rev() {\n        let mut flag = false; // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for j in 0..i {\n            if nums[j] &gt; nums[j + 1] {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                let tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true; // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if !flag {\n            break; // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n        };\n    }\n}\n</code></pre> bubble_sort.c<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09*/\nvoid bubbleSortWithFlag(int nums[], int size) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (int i = size - 1; i &gt; 0; i--) {\n        bool flag = false;\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (int j = 0; j &lt; i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n                flag = true;\n            }\n        }\n        if (!flag)\n            break;\n    }\n}\n</code></pre> bubble_sort.kt<pre><code>/* \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09 */\nfun bubbleSortWithFlag(nums: IntArray) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    for (i in nums.size - 1 downTo 1) {\n        var flag = false // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        for (j in 0..&lt;i) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                val temp = nums[j]\n                nums[j] = nums[j + 1]\n                nums[j + 1] = temp\n                flag = true // \u8bb0\u5f55\u4ea4\u6362\u5143\u7d20\n            }\n        }\n        if (!flag) break // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> bubble_sort.rb<pre><code>[class]{}-[func]{bubble_sort_with_flag}\n</code></pre> bubble_sort.zig<pre><code>// \u5192\u6ce1\u6392\u5e8f\uff08\u6807\u5fd7\u4f18\u5316\uff09\nfn bubbleSortWithFlag(nums: []i32) void {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [0, i]\n    var i: usize = nums.len - 1;\n    while (i &gt; 0) : (i -= 1) {\n        var flag = false;   // \u521d\u59cb\u5316\u6807\u5fd7\u4f4d\n        var j: usize = 0;\n        // \u5185\u5faa\u73af\uff1a\u5c06\u672a\u6392\u5e8f\u533a\u95f4 [0, i] \u4e2d\u7684\u6700\u5927\u5143\u7d20\u4ea4\u6362\u81f3\u8be5\u533a\u95f4\u7684\u6700\u53f3\u7aef\n        while (j &lt; i) : (j += 1) {\n            if (nums[j] &gt; nums[j + 1]) {\n                // \u4ea4\u6362 nums[j] \u4e0e nums[j + 1]\n                var tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n                flag = true;\n            }\n        }\n        if (!flag) break;   // \u6b64\u8f6e\u201c\u5192\u6ce1\u201d\u672a\u4ea4\u6362\u4efb\u4f55\u5143\u7d20\uff0c\u76f4\u63a5\u8df3\u51fa\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/bubble_sort/#1133-algorithm-characteristics","title":"11.3.3 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), adaptive sorting: The length of the array traversed in each round of \"bubbling\" decreases sequentially from \\(n - 1\\), \\(n - 2\\), \\(\\dots\\), \\(2\\), \\(1\\), totaling \\((n - 1) n / 2\\). With the introduction of <code>flag</code> optimization, the best time complexity can reach \\(O(n)\\).</li> <li>Space complexity of \\(O(1)\\), in-place sorting: Only a constant amount of extra space is used by pointers \\(i\\) and \\(j\\).</li> <li>Stable sorting: As equal elements are not swapped during the \"bubbling\".</li> </ul>"},{"location":"chapter_sorting/bucket_sort/","title":"11.8 \u00a0 Bucket sort","text":"<p>The previously mentioned sorting algorithms are all \"comparison-based sorting algorithms,\" which sort by comparing the size of elements. Such sorting algorithms cannot surpass a time complexity of \\(O(n \\log n)\\). Next, we will discuss several \"non-comparison sorting algorithms\" that can achieve linear time complexity.</p> <p>Bucket sort is a typical application of the divide-and-conquer strategy. It involves setting up a series of ordered buckets, each corresponding to a range of data, and then distributing the data evenly among these buckets; each bucket is then sorted individually; finally, all the data are merged in the order of the buckets.</p>"},{"location":"chapter_sorting/bucket_sort/#1181-algorithm-process","title":"11.8.1 \u00a0 Algorithm process","text":"<p>Consider an array of length \\(n\\), with elements in the range \\([0, 1)\\). The bucket sort process is illustrated in Figure 11-13.</p> <ol> <li>Initialize \\(k\\) buckets and distribute \\(n\\) elements into these \\(k\\) buckets.</li> <li>Sort each bucket individually (using the built-in sorting function of the programming language).</li> <li>Merge the results in the order from the smallest to the largest bucket.</li> </ol> <p></p> <p> Figure 11-13 \u00a0 Bucket sort algorithm process </p> <p>The code is shown as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig bucket_sort.py<pre><code>def bucket_sort(nums: list[float]):\n    \"\"\"\u6876\u6392\u5e8f\"\"\"\n    # \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    k = len(nums) // 2\n    buckets = [[] for _ in range(k)]\n    # 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for num in nums:\n        # \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        i = int(num * k)\n        # \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].append(num)\n    # 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for bucket in buckets:\n        # \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.sort()\n    # 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    i = 0\n    for bucket in buckets:\n        for num in bucket:\n            nums[i] = num\n            i += 1\n</code></pre> bucket_sort.cpp<pre><code>/* \u6876\u6392\u5e8f */\nvoid bucketSort(vector&lt;float&gt; &amp;nums) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    int k = nums.size() / 2;\n    vector&lt;vector&lt;float&gt;&gt; buckets(k);\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (float num : nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        int i = num * k;\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 bucket_idx\n        buckets[i].push_back(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (vector&lt;float&gt; &amp;bucket : buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        sort(bucket.begin(), bucket.end());\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    int i = 0;\n    for (vector&lt;float&gt; &amp;bucket : buckets) {\n        for (float num : bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.java<pre><code>/* \u6876\u6392\u5e8f */\nvoid bucketSort(float[] nums) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    int k = nums.length / 2;\n    List&lt;List&lt;Float&gt;&gt; buckets = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; k; i++) {\n        buckets.add(new ArrayList&lt;&gt;());\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (float num : nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        int i = (int) (num * k);\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets.get(i).add(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (List&lt;Float&gt; bucket : buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        Collections.sort(bucket);\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    int i = 0;\n    for (List&lt;Float&gt; bucket : buckets) {\n        for (float num : bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.cs<pre><code>/* \u6876\u6392\u5e8f */\nvoid BucketSort(float[] nums) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    int k = nums.Length / 2;\n    List&lt;List&lt;float&gt;&gt; buckets = [];\n    for (int i = 0; i &lt; k; i++) {\n        buckets.Add([]);\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    foreach (float num in nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        int i = (int)(num * k);\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].Add(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    foreach (List&lt;float&gt; bucket in buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.Sort();\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    int j = 0;\n    foreach (List&lt;float&gt; bucket in buckets) {\n        foreach (float num in bucket) {\n            nums[j++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.go<pre><code>/* \u6876\u6392\u5e8f */\nfunc bucketSort(nums []float64) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    k := len(nums) / 2\n    buckets := make([][]float64, k)\n    for i := 0; i &lt; k; i++ {\n        buckets[i] = make([]float64, 0)\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for _, num := range nums {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        i := int(num * float64(k))\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i] = append(buckets[i], num)\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for i := 0; i &lt; k; i++ {\n        // \u4f7f\u7528\u5185\u7f6e\u5207\u7247\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        sort.Float64s(buckets[i])\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    i := 0\n    for _, bucket := range buckets {\n        for _, num := range bucket {\n            nums[i] = num\n            i++\n        }\n    }\n}\n</code></pre> bucket_sort.swift<pre><code>/* \u6876\u6392\u5e8f */\nfunc bucketSort(nums: inout [Double]) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    let k = nums.count / 2\n    var buckets = (0 ..&lt; k).map { _ in [Double]() }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for num in nums {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        let i = Int(num * Double(k))\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].append(num)\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for i in buckets.indices {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        buckets[i].sort()\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    var i = nums.startIndex\n    for bucket in buckets {\n        for num in bucket {\n            nums[i] = num\n            i += 1\n        }\n    }\n}\n</code></pre> bucket_sort.js<pre><code>/* \u6876\u6392\u5e8f */\nfunction bucketSort(nums) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    const k = nums.length / 2;\n    const buckets = [];\n    for (let i = 0; i &lt; k; i++) {\n        buckets.push([]);\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (const num of nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        const i = Math.floor(num * k);\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].push(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (const bucket of buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.sort((a, b) =&gt; a - b);\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    let i = 0;\n    for (const bucket of buckets) {\n        for (const num of bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.ts<pre><code>/* \u6876\u6392\u5e8f */\nfunction bucketSort(nums: number[]): void {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    const k = nums.length / 2;\n    const buckets: number[][] = [];\n    for (let i = 0; i &lt; k; i++) {\n        buckets.push([]);\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (const num of nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        const i = Math.floor(num * k);\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].push(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (const bucket of buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.sort((a, b) =&gt; a - b);\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    let i = 0;\n    for (const bucket of buckets) {\n        for (const num of bucket) {\n            nums[i++] = num;\n        }\n    }\n}\n</code></pre> bucket_sort.dart<pre><code>/* \u6876\u6392\u5e8f */\nvoid bucketSort(List&lt;double&gt; nums) {\n  // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n  int k = nums.length ~/ 2;\n  List&lt;List&lt;double&gt;&gt; buckets = List.generate(k, (index) =&gt; []);\n\n  // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n  for (double _num in nums) {\n    // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 _num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n    int i = (_num * k).toInt();\n    // \u5c06 _num \u6dfb\u52a0\u8fdb\u6876 bucket_idx\n    buckets[i].add(_num);\n  }\n  // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n  for (List&lt;double&gt; bucket in buckets) {\n    bucket.sort();\n  }\n  // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n  int i = 0;\n  for (List&lt;double&gt; bucket in buckets) {\n    for (double _num in bucket) {\n      nums[i++] = _num;\n    }\n  }\n}\n</code></pre> bucket_sort.rs<pre><code>/* \u6876\u6392\u5e8f */\nfn bucket_sort(nums: &amp;mut [f64]) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    let k = nums.len() / 2;\n    let mut buckets = vec![vec![]; k];\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for &amp;mut num in &amp;mut *nums {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        let i = (num * k as f64) as usize;\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].push(num);\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for bucket in &amp;mut buckets {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    let mut i = 0;\n    for bucket in &amp;mut buckets {\n        for &amp;mut num in bucket {\n            nums[i] = num;\n            i += 1;\n        }\n    }\n}\n</code></pre> bucket_sort.c<pre><code>/* \u6876\u6392\u5e8f */\nvoid bucketSort(float nums[], int n) {\n    int k = n / 2;                                 // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\n    int *sizes = malloc(k * sizeof(int));          // \u8bb0\u5f55\u6bcf\u4e2a\u6876\u7684\u5927\u5c0f\n    float **buckets = malloc(k * sizeof(float *)); // \u52a8\u6001\u6570\u7ec4\u7684\u6570\u7ec4\uff08\u6876\uff09\n    // \u4e3a\u6bcf\u4e2a\u6876\u9884\u5206\u914d\u8db3\u591f\u7684\u7a7a\u95f4\n    for (int i = 0; i &lt; k; ++i) {\n        buckets[i] = (float *)malloc(n * sizeof(float));\n        sizes[i] = 0;\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (int i = 0; i &lt; n; ++i) {\n        int idx = (int)(nums[i] * k);\n        buckets[idx][sizes[idx]++] = nums[i];\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (int i = 0; i &lt; k; ++i) {\n        qsort(buckets[i], sizes[i], sizeof(float), compare);\n    }\n    // 3. \u5408\u5e76\u6392\u5e8f\u540e\u7684\u6876\n    int idx = 0;\n    for (int i = 0; i &lt; k; ++i) {\n        for (int j = 0; j &lt; sizes[i]; ++j) {\n            nums[idx++] = buckets[i][j];\n        }\n        // \u91ca\u653e\u5185\u5b58\n        free(buckets[i]);\n    }\n}\n</code></pre> bucket_sort.kt<pre><code>/* \u6876\u6392\u5e8f */\nfun bucketSort(nums: FloatArray) {\n    // \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n    val k = nums.size / 2\n    val buckets = mutableListOf&lt;MutableList&lt;Float&gt;&gt;()\n    for (i in 0..&lt;k) {\n        buckets.add(mutableListOf())\n    }\n    // 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n    for (num in nums) {\n        // \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n        val i = (num * k).toInt()\n        // \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n        buckets[i].add(num)\n    }\n    // 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n    for (bucket in buckets) {\n        // \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n        bucket.sort()\n    }\n    // 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n    var i = 0\n    for (bucket in buckets) {\n        for (num in bucket) {\n            nums[i++] = num\n        }\n    }\n}\n</code></pre> bucket_sort.rb<pre><code>### \u6876\u6392\u5e8f ###\ndef bucket_sort(nums)\n  # \u521d\u59cb\u5316 k = n/2 \u4e2a\u6876\uff0c\u9884\u671f\u5411\u6bcf\u4e2a\u6876\u5206\u914d 2 \u4e2a\u5143\u7d20\n  k = nums.length / 2\n  buckets = Array.new(k) { [] }\n\n  # 1. \u5c06\u6570\u7ec4\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\n  nums.each do |num|\n    # \u8f93\u5165\u6570\u636e\u8303\u56f4\u4e3a [0, 1)\uff0c\u4f7f\u7528 num * k \u6620\u5c04\u5230\u7d22\u5f15\u8303\u56f4 [0, k-1]\n    i = (num * k).to_i\n    # \u5c06 num \u6dfb\u52a0\u8fdb\u6876 i\n    buckets[i] &lt;&lt; num\n  end\n\n  # 2. \u5bf9\u5404\u4e2a\u6876\u6267\u884c\u6392\u5e8f\n  buckets.each do |bucket|\n    # \u4f7f\u7528\u5185\u7f6e\u6392\u5e8f\u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u66ff\u6362\u6210\u5176\u4ed6\u6392\u5e8f\u7b97\u6cd5\n    bucket.sort!\n  end\n\n  # 3. \u904d\u5386\u6876\u5408\u5e76\u7ed3\u679c\n  i = 0\n  buckets.each do |bucket|\n    bucket.each do |num|\n      nums[i] = num\n      i += 1\n    end\n  end\nend\n</code></pre> bucket_sort.zig<pre><code>[class]{}-[func]{bucketSort}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/bucket_sort/#1182-algorithm-characteristics","title":"11.8.2 \u00a0 Algorithm characteristics","text":"<p>Bucket sort is suitable for handling very large data sets. For example, if the input data includes 1 million elements, and system memory limitations prevent loading all the data at once, you can divide the data into 1,000 buckets and sort each bucket separately before merging the results.</p> <ul> <li>Time complexity is \\(O(n + k)\\): Assuming the elements are evenly distributed across the buckets, the number of elements in each bucket is \\(n/k\\). Assuming sorting a single bucket takes \\(O(n/k \\log(n/k))\\) time, sorting all buckets takes \\(O(n \\log(n/k))\\) time. When the number of buckets \\(k\\) is relatively large, the time complexity tends towards \\(O(n)\\). Merging the results requires traversing all buckets and elements, taking \\(O(n + k)\\) time.</li> <li>Adaptive sorting: In the worst case, all data is distributed into a single bucket, and sorting that bucket takes \\(O(n^2)\\) time.</li> <li>Space complexity is \\(O(n + k)\\), non-in-place sorting: It requires additional space for \\(k\\) buckets and a total of \\(n\\) elements.</li> <li>Whether bucket sort is stable depends on whether the algorithm used to sort elements within the buckets is stable.</li> </ul>"},{"location":"chapter_sorting/bucket_sort/#1183-how-to-achieve-even-distribution","title":"11.8.3 \u00a0 How to achieve even distribution","text":"<p>The theoretical time complexity of bucket sort can reach \\(O(n)\\), the key is to evenly distribute the elements across all buckets, as real data is often not uniformly distributed. For example, if we want to evenly distribute all products on Taobao by price range into 10 buckets, but the distribution of product prices is uneven, with many under 100 yuan and few over 1000 yuan. If the price range is evenly divided into 10, the difference in the number of products in each bucket will be very large.</p> <p>To achieve even distribution, we can initially set a rough dividing line, roughly dividing the data into 3 buckets. After the distribution is complete, the buckets with more products can be further divided into 3 buckets, until the number of elements in all buckets is roughly equal.</p> <p>As shown in Figure 11-14, this method essentially creates a recursive tree, aiming to make the leaf node values as even as possible. Of course, you don't have to divide the data into 3 buckets each round; the specific division method can be flexibly chosen based on data characteristics.</p> <p></p> <p> Figure 11-14 \u00a0 Recursive division of buckets </p> <p>If we know the probability distribution of product prices in advance, we can set the price dividing line for each bucket based on the data probability distribution. It is worth noting that it is not necessarily required to specifically calculate the data distribution; it can also be approximated based on data characteristics using some probability model.</p> <p>As shown in Figure 11-15, we assume that product prices follow a normal distribution, allowing us to reasonably set the price intervals, thereby evenly distributing the products into the respective buckets.</p> <p></p> <p> Figure 11-15 \u00a0 Dividing buckets based on probability distribution </p>"},{"location":"chapter_sorting/counting_sort/","title":"11.9 \u00a0 Counting sort","text":"<p>Counting sort achieves sorting by counting the number of elements, typically applied to arrays of integers.</p>"},{"location":"chapter_sorting/counting_sort/#1191-simple-implementation","title":"11.9.1 \u00a0 Simple implementation","text":"<p>Let's start with a simple example. Given an array <code>nums</code> of length \\(n\\), where all elements are \"non-negative integers\", the overall process of counting sort is illustrated in the following diagram.</p> <ol> <li>Traverse the array to find the maximum number, denoted as \\(m\\), then create an auxiliary array <code>counter</code> of length \\(m + 1\\).</li> <li>Use <code>counter</code> to count the occurrence of each number in <code>nums</code>, where <code>counter[num]</code> corresponds to the occurrence of the number <code>num</code>. The counting method is simple, just traverse <code>nums</code> (suppose the current number is <code>num</code>), and increase <code>counter[num]</code> by \\(1\\) each round.</li> <li>Since the indices of <code>counter</code> are naturally ordered, all numbers are essentially sorted already. Next, we traverse <code>counter</code>, filling <code>nums</code> in ascending order of occurrence.</li> </ol> <p></p> <p> Figure 11-16 \u00a0 Counting sort process </p> <p>The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig counting_sort.py<pre><code>def counting_sort_naive(nums: list[int]):\n    \"\"\"\u8ba1\u6570\u6392\u5e8f\"\"\"\n    # \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\n    # 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    m = 0\n    for num in nums:\n        m = max(m, num)\n    # 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    # counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    counter = [0] * (m + 1)\n    for num in nums:\n        counter[num] += 1\n    # 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    i = 0\n    for num in range(m + 1):\n        for _ in range(counter[num]):\n            nums[i] = num\n            i += 1\n</code></pre> counting_sort.cpp<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nvoid countingSortNaive(vector&lt;int&gt; &amp;nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int num : nums) {\n        m = max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    vector&lt;int&gt; counter(m + 1, 0);\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.java<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nvoid countingSortNaive(int[] nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int num : nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int[] counter = new int[m + 1];\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.cs<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nvoid CountingSortNaive(int[] nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    foreach (int num in nums) {\n        m = Math.Max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int[] counter = new int[m + 1];\n    foreach (int num in nums) {\n        counter[num]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.go<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfunc countingSortNaive(nums []int) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    m := 0\n    for _, num := range nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    counter := make([]int, m+1)\n    for _, num := range nums {\n        counter[num]++\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    for i, num := 0, 0; num &lt; m+1; num++ {\n        for j := 0; j &lt; counter[num]; j++ {\n            nums[i] = num\n            i++\n        }\n    }\n}\n</code></pre> counting_sort.swift<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfunc countingSortNaive(nums: inout [Int]) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = nums.max()!\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    var counter = Array(repeating: 0, count: m + 1)\n    for num in nums {\n        counter[num] += 1\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    var i = 0\n    for num in 0 ..&lt; m + 1 {\n        for _ in 0 ..&lt; counter[num] {\n            nums[i] = num\n            i += 1\n        }\n    }\n}\n</code></pre> counting_sort.js<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfunction countingSortNaive(nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = 0;\n    for (const num of nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    const counter = new Array(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    let i = 0;\n    for (let num = 0; num &lt; m + 1; num++) {\n        for (let j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.ts<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfunction countingSortNaive(nums: number[]): void {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = 0;\n    for (const num of nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    const counter: number[] = new Array&lt;number&gt;(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    let i = 0;\n    for (let num = 0; num &lt; m + 1; num++) {\n        for (let j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n}\n</code></pre> counting_sort.dart<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nvoid countingSortNaive(List&lt;int&gt; nums) {\n  // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n  int m = 0;\n  for (int _num in nums) {\n    m = max(m, _num);\n  }\n  // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n  // counter[_num] \u4ee3\u8868 _num \u7684\u51fa\u73b0\u6b21\u6570\n  List&lt;int&gt; counter = List.filled(m + 1, 0);\n  for (int _num in nums) {\n    counter[_num]++;\n  }\n  // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n  int i = 0;\n  for (int _num = 0; _num &lt; m + 1; _num++) {\n    for (int j = 0; j &lt; counter[_num]; j++, i++) {\n      nums[i] = _num;\n    }\n  }\n}\n</code></pre> counting_sort.rs<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfn counting_sort_naive(nums: &amp;mut [i32]) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = *nums.into_iter().max().unwrap();\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    let mut counter = vec![0; m as usize + 1];\n    for &amp;num in &amp;*nums {\n        counter[num as usize] += 1;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    let mut i = 0;\n    for num in 0..m + 1 {\n        for _ in 0..counter[num as usize] {\n            nums[i] = num;\n            i += 1;\n        }\n    }\n}\n</code></pre> counting_sort.c<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nvoid countingSortNaive(int nums[], int size) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] &gt; m) {\n            m = nums[i];\n        }\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int *counter = calloc(m + 1, sizeof(int));\n    for (int i = 0; i &lt; size; i++) {\n        counter[nums[i]]++;\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    int i = 0;\n    for (int num = 0; num &lt; m + 1; num++) {\n        for (int j = 0; j &lt; counter[num]; j++, i++) {\n            nums[i] = num;\n        }\n    }\n    // 4. \u91ca\u653e\u5185\u5b58\n    free(counter);\n}\n</code></pre> counting_sort.kt<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u7b80\u5355\u5b9e\u73b0\uff0c\u65e0\u6cd5\u7528\u4e8e\u6392\u5e8f\u5bf9\u8c61\nfun countingSortNaive(nums: IntArray) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    var m = 0\n    for (num in nums) {\n        m = max(m, num)\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    val counter = IntArray(m + 1)\n    for (num in nums) {\n        counter[num]++\n    }\n    // 3. \u904d\u5386 counter \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u539f\u6570\u7ec4 nums\n    var i = 0\n    for (num in 0..&lt;m + 1) {\n        var j = 0\n        while (j &lt; counter[num]) {\n            nums[i] = num\n            j++\n            i++\n        }\n    }\n}\n</code></pre> counting_sort.rb<pre><code>[class]{}-[func]{counting_sort_naive}\n</code></pre> counting_sort.zig<pre><code>[class]{}-[func]{countingSortNaive}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Connection between counting sort and bucket sort</p> <p>From the perspective of bucket sort, we can consider each index of the counting array <code>counter</code> in counting sort as a bucket, and the process of counting as distributing elements into the corresponding buckets. Essentially, counting sort is a special case of bucket sort for integer data.</p>"},{"location":"chapter_sorting/counting_sort/#1192-complete-implementation","title":"11.9.2 \u00a0 Complete implementation","text":"<p>Astute readers might have noticed, if the input data is an object, the above step <code>3.</code> becomes ineffective. Suppose the input data is a product object, we want to sort the products by their price (a class member variable), but the above algorithm can only provide the sorting result for the price.</p> <p>So how can we get the sorting result for the original data? First, we calculate the \"prefix sum\" of <code>counter</code>. As the name suggests, the prefix sum at index <code>i</code>, <code>prefix[i]</code>, equals the sum of the first <code>i</code> elements of the array:</p> \\[ \\text{prefix}[i] = \\sum_{j=0}^i \\text{counter[j]} \\] <p>The prefix sum has a clear meaning, <code>prefix[num] - 1</code> represents the last occurrence index of element <code>num</code> in the result array <code>res</code>. This information is crucial, as it tells us where each element should appear in the result array. Next, we traverse the original array <code>nums</code> for each element <code>num</code> in reverse order, performing the following two steps in each iteration.</p> <ol> <li>Fill <code>num</code> into the array <code>res</code> at the index <code>prefix[num] - 1</code>.</li> <li>Reduce the prefix sum <code>prefix[num]</code> by \\(1\\), thus obtaining the next index to place <code>num</code>.</li> </ol> <p>After the traversal, the array <code>res</code> contains the sorted result, and finally, <code>res</code> replaces the original array <code>nums</code>. The complete counting sort process is shown in the figures below.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-17 \u00a0 Counting sort process </p> <p>The implementation code of counting sort is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig counting_sort.py<pre><code>def counting_sort(nums: list[int]):\n    \"\"\"\u8ba1\u6570\u6392\u5e8f\"\"\"\n    # \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\n    # 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    m = max(nums)\n    # 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    # counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    counter = [0] * (m + 1)\n    for num in nums:\n        counter[num] += 1\n    # 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    # \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for i in range(m):\n        counter[i + 1] += counter[i]\n    # 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    # \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    n = len(nums)\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        num = nums[i]\n        res[counter[num] - 1] = num  # \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num] -= 1  # \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    # \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in range(n):\n        nums[i] = res[i]\n</code></pre> counting_sort.cpp<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nvoid countingSort(vector&lt;int&gt; &amp;nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int num : nums) {\n        m = max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    vector&lt;int&gt; counter(m + 1, 0);\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    int n = nums.size();\n    vector&lt;int&gt; res(n);\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--;              // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    nums = res;\n}\n</code></pre> counting_sort.java<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nvoid countingSort(int[] nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int num : nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int[] counter = new int[m + 1];\n    for (int num : nums) {\n        counter[num]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    int n = nums.length;\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.cs<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nvoid CountingSort(int[] nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    foreach (int num in nums) {\n        m = Math.Max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int[] counter = new int[m + 1];\n    foreach (int num in nums) {\n        counter[num]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    int n = nums.Length;\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.go<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfunc countingSort(nums []int) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    m := 0\n    for _, num := range nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    counter := make([]int, m+1)\n    for _, num := range nums {\n        counter[num]++\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for i := 0; i &lt; m; i++ {\n        counter[i+1] += counter[i]\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    n := len(nums)\n    res := make([]int, n)\n    for i := n - 1; i &gt;= 0; i-- {\n        num := nums[i]\n        // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        res[counter[num]-1] = num\n        // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n        counter[num]--\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    copy(nums, res)\n}\n</code></pre> counting_sort.swift<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfunc countingSort(nums: inout [Int]) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = nums.max()!\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    var counter = Array(repeating: 0, count: m + 1)\n    for num in nums {\n        counter[num] += 1\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for i in 0 ..&lt; m {\n        counter[i + 1] += counter[i]\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    var res = Array(repeating: 0, count: nums.count)\n    for i in nums.indices.reversed() {\n        let num = nums[i]\n        res[counter[num] - 1] = num // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num] -= 1 // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in nums.indices {\n        nums[i] = res[i]\n    }\n}\n</code></pre> counting_sort.js<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfunction countingSort(nums) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = 0;\n    for (const num of nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    const counter = new Array(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (let i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    const n = nums.length;\n    const res = new Array(n);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.ts<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfunction countingSort(nums: number[]): void {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = 0;\n    for (const num of nums) {\n        m = Math.max(m, num);\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    const counter: number[] = new Array&lt;number&gt;(m + 1).fill(0);\n    for (const num of nums) {\n        counter[num]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (let i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    const n = nums.length;\n    const res: number[] = new Array&lt;number&gt;(n);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.dart<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nvoid countingSort(List&lt;int&gt; nums) {\n  // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n  int m = 0;\n  for (int _num in nums) {\n    m = max(m, _num);\n  }\n  // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n  // counter[_num] \u4ee3\u8868 _num \u7684\u51fa\u73b0\u6b21\u6570\n  List&lt;int&gt; counter = List.filled(m + 1, 0);\n  for (int _num in nums) {\n    counter[_num]++;\n  }\n  // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n  // \u5373 counter[_num]-1 \u662f _num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n  for (int i = 0; i &lt; m; i++) {\n    counter[i + 1] += counter[i];\n  }\n  // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n  // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n  int n = nums.length;\n  List&lt;int&gt; res = List.filled(n, 0);\n  for (int i = n - 1; i &gt;= 0; i--) {\n    int _num = nums[i];\n    res[counter[_num] - 1] = _num; // \u5c06 _num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n    counter[_num]--; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e _num \u7684\u7d22\u5f15\n  }\n  // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n  nums.setAll(0, res);\n}\n</code></pre> counting_sort.rs<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfn counting_sort(nums: &amp;mut [i32]) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    let m = *nums.into_iter().max().unwrap();\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    let mut counter = vec![0; m as usize + 1];\n    for &amp;num in &amp;*nums {\n        counter[num as usize] += 1;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for i in 0..m as usize {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    let n = nums.len();\n    let mut res = vec![0; n];\n    for i in (0..n).rev() {\n        let num = nums[i];\n        res[counter[num as usize] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num as usize] -= 1; // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in 0..n {\n        nums[i] = res[i];\n    }\n}\n</code></pre> counting_sort.c<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nvoid countingSort(int nums[], int size) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    int m = 0;\n    for (int i = 0; i &lt; size; i++) {\n        if (nums[i] &gt; m) {\n            m = nums[i];\n        }\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    int *counter = calloc(m, sizeof(int));\n    for (int i = 0; i &lt; size; i++) {\n        counter[nums[i]]++;\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (int i = 0; i &lt; m; i++) {\n        counter[i + 1] += counter[i];\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    int *res = malloc(sizeof(int) * size);\n    for (int i = size - 1; i &gt;= 0; i--) {\n        int num = nums[i];\n        res[counter[num] - 1] = num; // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]--;              // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    memcpy(nums, res, size * sizeof(int));\n    // 5. \u91ca\u653e\u5185\u5b58\n    free(counter);\n}\n</code></pre> counting_sort.kt<pre><code>/* \u8ba1\u6570\u6392\u5e8f */\n// \u5b8c\u6574\u5b9e\u73b0\uff0c\u53ef\u6392\u5e8f\u5bf9\u8c61\uff0c\u5e76\u4e14\u662f\u7a33\u5b9a\u6392\u5e8f\nfun countingSort(nums: IntArray) {\n    // 1. \u7edf\u8ba1\u6570\u7ec4\u6700\u5927\u5143\u7d20 m\n    var m = 0\n    for (num in nums) {\n        m = max(m, num)\n    }\n    // 2. \u7edf\u8ba1\u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    // counter[num] \u4ee3\u8868 num \u7684\u51fa\u73b0\u6b21\u6570\n    val counter = IntArray(m + 1)\n    for (num in nums) {\n        counter[num]++\n    }\n    // 3. \u6c42 counter \u7684\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u6b21\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u5c3e\u7d22\u5f15\u201d\n    // \u5373 counter[num]-1 \u662f num \u5728 res \u4e2d\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u7d22\u5f15\n    for (i in 0..&lt;m) {\n        counter[i + 1] += counter[i]\n    }\n    // 4. \u5012\u5e8f\u904d\u5386 nums \uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165\u7ed3\u679c\u6570\u7ec4 res\n    // \u521d\u59cb\u5316\u6570\u7ec4 res \u7528\u4e8e\u8bb0\u5f55\u7ed3\u679c\n    val n = nums.size\n    val res = IntArray(n)\n    for (i in n - 1 downTo 0) {\n        val num = nums[i]\n        res[counter[num] - 1] = num // \u5c06 num \u653e\u7f6e\u5230\u5bf9\u5e94\u7d22\u5f15\u5904\n        counter[num]-- // \u4ee4\u524d\u7f00\u548c\u81ea\u51cf 1 \uff0c\u5f97\u5230\u4e0b\u6b21\u653e\u7f6e num \u7684\u7d22\u5f15\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u6570\u7ec4 res \u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (i in 0..&lt;n) {\n        nums[i] = res[i]\n    }\n}\n</code></pre> counting_sort.rb<pre><code>[class]{}-[func]{counting_sort}\n</code></pre> counting_sort.zig<pre><code>[class]{}-[func]{countingSort}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/counting_sort/#1193-algorithm-characteristics","title":"11.9.3 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n + m)\\), non-adaptive sort: Involves traversing <code>nums</code> and <code>counter</code>, both using linear time. Generally, \\(n \\gg m\\), and the time complexity tends towards \\(O(n)\\).</li> <li>Space complexity is \\(O(n + m)\\), non-in-place sort: Utilizes arrays <code>res</code> and <code>counter</code> of lengths \\(n\\) and \\(m\\) respectively.</li> <li>Stable sort: Since elements are filled into <code>res</code> in a \"right-to-left\" order, reversing the traversal of <code>nums</code> can prevent changing the relative position between equal elements, thereby achieving a stable sort. Actually, traversing <code>nums</code> in order can also produce the correct sorting result, but the outcome is unstable.</li> </ul>"},{"location":"chapter_sorting/counting_sort/#1194-limitations","title":"11.9.4 \u00a0 Limitations","text":"<p>By now, you might find counting sort very clever, as it can achieve efficient sorting merely by counting quantities. However, the prerequisites for using counting sort are relatively strict.</p> <p>Counting sort is only suitable for non-negative integers. If you want to apply it to other types of data, you need to ensure that these data can be converted to non-negative integers without changing the relative sizes of the elements. For example, for an array containing negative integers, you can first add a constant to all numbers, converting them all to positive numbers, and then convert them back after sorting is complete.</p> <p>Counting sort is suitable for large data volumes but small data ranges. For example, in the above example, \\(m\\) should not be too large, otherwise, it will occupy too much space. And when \\(n \\ll m\\), counting sort uses \\(O(m)\\) time, which may be slower than \\(O(n \\log n)\\) sorting algorithms.</p>"},{"location":"chapter_sorting/heap_sort/","title":"11.7 \u00a0 Heap sort","text":"<p>Tip</p> <p>Before reading this section, please make sure you have completed the \"Heap\" chapter.</p> <p>Heap sort is an efficient sorting algorithm based on the heap data structure. We can implement heap sort using the \"heap creation\" and \"element extraction\" operations we have already learned.</p> <ol> <li>Input the array and establish a min-heap, where the smallest element is at the heap's top.</li> <li>Continuously perform the extraction operation, recording the extracted elements in sequence to obtain a sorted list from smallest to largest.</li> </ol> <p>Although the above method is feasible, it requires an additional array to save the popped elements, which is somewhat space-consuming. In practice, we usually use a more elegant implementation.</p>"},{"location":"chapter_sorting/heap_sort/#1171-algorithm-flow","title":"11.7.1 \u00a0 Algorithm flow","text":"<p>Suppose the array length is \\(n\\), the heap sort process is as follows.</p> <ol> <li>Input the array and establish a max-heap. After completion, the largest element is at the heap's top.</li> <li>Swap the top element of the heap (the first element) with the heap's bottom element (the last element). After the swap, reduce the heap's length by \\(1\\) and increase the sorted elements count by \\(1\\).</li> <li>Starting from the heap top, perform the sift-down operation from top to bottom. After the sift-down, the heap's property is restored.</li> <li>Repeat steps <code>2.</code> and <code>3.</code> Loop for \\(n - 1\\) rounds to complete the sorting of the array.</li> </ol> <p>Tip</p> <p>In fact, the element extraction operation also includes steps <code>2.</code> and <code>3.</code>, with the addition of a popping element step.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-12 \u00a0 Heap sort process </p> <p>In the code implementation, we used the sift-down function <code>sift_down()</code> from the \"Heap\" chapter. It is important to note that since the heap's length decreases as the maximum element is extracted, we need to add a length parameter \\(n\\) to the <code>sift_down()</code> function to specify the current effective length of the heap. The code is shown below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig heap_sort.py<pre><code>def sift_down(nums: list[int], n: int, i: int):\n    \"\"\"\u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316\"\"\"\n    while True:\n        # \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        l = 2 * i + 1\n        r = 2 * i + 2\n        ma = i\n        if l &lt; n and nums[l] &gt; nums[ma]:\n            ma = l\n        if r &lt; n and nums[r] &gt; nums[ma]:\n            ma = r\n        # \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i:\n            break\n        # \u4ea4\u6362\u4e24\u8282\u70b9\n        nums[i], nums[ma] = nums[ma], nums[i]\n        # \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n\ndef heap_sort(nums: list[int]):\n    \"\"\"\u5806\u6392\u5e8f\"\"\"\n    # \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in range(len(nums) // 2 - 1, -1, -1):\n        sift_down(nums, len(nums), i)\n    # \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for i in range(len(nums) - 1, 0, -1):\n        # \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        nums[0], nums[i] = nums[i], nums[0]\n        # \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        sift_down(nums, i, 0)\n</code></pre> heap_sort.cpp<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(vector&lt;int&gt; &amp;nums, int n, int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        swap(nums[i], nums[ma]);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nvoid heapSort(vector&lt;int&gt; &amp;nums) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = nums.size() / 2 - 1; i &gt;= 0; --i) {\n        siftDown(nums, nums.size(), i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (int i = nums.size() - 1; i &gt; 0; --i) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        swap(nums[0], nums[i]);\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.java<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(int[] nums, int n, int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i)\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        int temp = nums[i];\n        nums[i] = nums[ma];\n        nums[ma] = temp;\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nvoid heapSort(int[] nums) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = nums.length / 2 - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (int i = nums.length - 1; i &gt; 0; i--) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        int tmp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = tmp;\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.cs<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid SiftDown(int[] nums, int n, int i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i)\n            break;\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        (nums[ma], nums[i]) = (nums[i], nums[ma]);\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nvoid HeapSort(int[] nums) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = nums.Length / 2 - 1; i &gt;= 0; i--) {\n        SiftDown(nums, nums.Length, i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (int i = nums.Length - 1; i &gt; 0; i--) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        (nums[i], nums[0]) = (nums[0], nums[i]);\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        SiftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.go<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunc siftDown(nums *[]int, n, i int) {\n    for true {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        l := 2*i + 1\n        r := 2*i + 2\n        ma := i\n        if l &lt; n &amp;&amp; (*nums)[l] &gt; (*nums)[ma] {\n            ma = l\n        }\n        if r &lt; n &amp;&amp; (*nums)[r] &gt; (*nums)[ma] {\n            ma = r\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        (*nums)[i], (*nums)[ma] = (*nums)[ma], (*nums)[i]\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfunc heapSort(nums *[]int) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i := len(*nums)/2 - 1; i &gt;= 0; i-- {\n        siftDown(nums, len(*nums), i)\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for i := len(*nums) - 1; i &gt; 0; i-- {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        (*nums)[0], (*nums)[i] = (*nums)[i], (*nums)[0]\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0)\n    }\n}\n</code></pre> heap_sort.swift<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunc siftDown(nums: inout [Int], n: Int, i: Int) {\n    var i = i\n    while true {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let l = 2 * i + 1\n        let r = 2 * i + 2\n        var ma = i\n        if l &lt; n, nums[l] &gt; nums[ma] {\n            ma = l\n        }\n        if r &lt; n, nums[r] &gt; nums[ma] {\n            ma = r\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i {\n            break\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        nums.swapAt(i, ma)\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfunc heapSort(nums: inout [Int]) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in stride(from: nums.count / 2 - 1, through: 0, by: -1) {\n        siftDown(nums: &amp;nums, n: nums.count, i: i)\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for i in nums.indices.dropFirst().reversed() {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        nums.swapAt(0, i)\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums: &amp;nums, n: i, i: 0)\n    }\n}\n</code></pre> heap_sort.js<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunction siftDown(nums, n, i) {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) {\n            ma = l;\n        }\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) {\n            ma = r;\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma === i) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        [nums[i], nums[ma]] = [nums[ma], nums[i]];\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfunction heapSort(nums) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (let i = Math.floor(nums.length / 2) - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        [nums[0], nums[i]] = [nums[i], nums[0]];\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.ts<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfunction siftDown(nums: number[], n: number, i: number): void {\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) {\n            ma = l;\n        }\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) {\n            ma = r;\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma === i) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        [nums[i], nums[ma]] = [nums[ma], nums[i]];\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfunction heapSort(nums: number[]): void {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (let i = Math.floor(nums.length / 2) - 1; i &gt;= 0; i--) {\n        siftDown(nums, nums.length, i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (let i = nums.length - 1; i &gt; 0; i--) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        [nums[0], nums[i]] = [nums[i], nums[0]];\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.dart<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(List&lt;int&gt; nums, int n, int i) {\n  while (true) {\n    // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    int ma = i;\n    if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) ma = l;\n    if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) ma = r;\n    // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n    if (ma == i) break;\n    // \u4ea4\u6362\u4e24\u8282\u70b9\n    int temp = nums[i];\n    nums[i] = nums[ma];\n    nums[ma] = temp;\n    // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n    i = ma;\n  }\n}\n\n/* \u5806\u6392\u5e8f */\nvoid heapSort(List&lt;int&gt; nums) {\n  // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n  for (int i = nums.length ~/ 2 - 1; i &gt;= 0; i--) {\n    siftDown(nums, nums.length, i);\n  }\n  // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n  for (int i = nums.length - 1; i &gt; 0; i--) {\n    // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    int tmp = nums[0];\n    nums[0] = nums[i];\n    nums[i] = tmp;\n    // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n    siftDown(nums, i, 0);\n  }\n}\n</code></pre> heap_sort.rs<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfn sift_down(nums: &amp;mut [i32], n: usize, mut i: usize) {\n    loop {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let mut ma = i;\n        if l &lt; n &amp;&amp; nums[l] &gt; nums[ma] {\n            ma = l;\n        }\n        if r &lt; n &amp;&amp; nums[r] &gt; nums[ma] {\n            ma = r;\n        }\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if ma == i {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        let temp = nums[i];\n        nums[i] = nums[ma];\n        nums[ma] = temp;\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfn heap_sort(nums: &amp;mut [i32]) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for i in (0..=nums.len() / 2 - 1).rev() {\n        sift_down(nums, nums.len(), i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for i in (1..=nums.len() - 1).rev() {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        let tmp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = tmp;\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        sift_down(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.c<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nvoid siftDown(int nums[], int n, int i) {\n    while (1) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        int ma = i;\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])\n            ma = l;\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])\n            ma = r;\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i) {\n            break;\n        }\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        int temp = nums[i];\n        nums[i] = nums[ma];\n        nums[ma] = temp;\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma;\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nvoid heapSort(int nums[], int n) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (int i = n / 2 - 1; i &gt;= 0; --i) {\n        siftDown(nums, n, i);\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (int i = n - 1; i &gt; 0; --i) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        int tmp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = tmp;\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0);\n    }\n}\n</code></pre> heap_sort.kt<pre><code>/* \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 */\nfun siftDown(nums: IntArray, n: Int, li: Int) {\n    var i = li\n    while (true) {\n        // \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n        val l = 2 * i + 1\n        val r = 2 * i + 2\n        var ma = i\n        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) \n            ma = l\n        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) \n            ma = r\n        // \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n        if (ma == i) \n            break\n        // \u4ea4\u6362\u4e24\u8282\u70b9\n        val temp = nums[i]\n        nums[i] = nums[ma]\n        nums[ma] = temp\n        // \u5faa\u73af\u5411\u4e0b\u5806\u5316\n        i = ma\n    }\n}\n\n/* \u5806\u6392\u5e8f */\nfun heapSort(nums: IntArray) {\n    // \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n    for (i in nums.size / 2 - 1 downTo 0) {\n        siftDown(nums, nums.size, i)\n    }\n    // \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n    for (i in nums.size - 1 downTo 1) {\n        // \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n        val temp = nums[0]\n        nums[0] = nums[i]\n        nums[i] = temp\n        // \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n        siftDown(nums, i, 0)\n    }\n}\n</code></pre> heap_sort.rb<pre><code>### \u5806\u7684\u957f\u5ea6\u4e3a n \uff0c\u4ece\u8282\u70b9 i \u5f00\u59cb\uff0c\u4ece\u9876\u81f3\u5e95\u5806\u5316 ###\ndef sift_down(nums, n, i)\n  while true\n    # \u5224\u65ad\u8282\u70b9 i, l, r \u4e2d\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u8bb0\u4e3a ma\n    l = 2 * i + 1\n    r = 2 * i + 2\n    ma = i\n    ma = l if l &lt; n &amp;&amp; nums[l] &gt; nums[ma]\n    ma = r if r &lt; n &amp;&amp; nums[r] &gt; nums[ma]\n    # \u82e5\u8282\u70b9 i \u6700\u5927\u6216\u7d22\u5f15 l, r \u8d8a\u754c\uff0c\u5219\u65e0\u987b\u7ee7\u7eed\u5806\u5316\uff0c\u8df3\u51fa\n    break if ma == i\n    # \u4ea4\u6362\u4e24\u8282\u70b9\n    nums[i], nums[ma] = nums[ma], nums[i]\n    # \u5faa\u73af\u5411\u4e0b\u5806\u5316\n    i = ma\n  end\nend\n\n### \u5806\u6392\u5e8f ###\ndef heap_sort(nums)\n  # \u5efa\u5806\u64cd\u4f5c\uff1a\u5806\u5316\u9664\u53f6\u8282\u70b9\u4ee5\u5916\u7684\u5176\u4ed6\u6240\u6709\u8282\u70b9\n  (nums.length / 2 - 1).downto(0) do |i|\n    sift_down(nums, nums.length, i)\n  end\n  # \u4ece\u5806\u4e2d\u63d0\u53d6\u6700\u5927\u5143\u7d20\uff0c\u5faa\u73af n-1 \u8f6e\n  (nums.length - 1).downto(1) do |i|\n    # \u4ea4\u6362\u6839\u8282\u70b9\u4e0e\u6700\u53f3\u53f6\u8282\u70b9\uff08\u4ea4\u6362\u9996\u5143\u7d20\u4e0e\u5c3e\u5143\u7d20\uff09\n    nums[0], nums[i] = nums[i], nums[0]\n    # \u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4ece\u9876\u81f3\u5e95\u8fdb\u884c\u5806\u5316\n    sift_down(nums, i, 0)\n  end\nend\n</code></pre> heap_sort.zig<pre><code>[class]{}-[func]{siftDown}\n\n[class]{}-[func]{heapSort}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/heap_sort/#1172-algorithm-characteristics","title":"11.7.2 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n \\log n)\\), non-adaptive sort: The heap creation uses \\(O(n)\\) time. Extracting the largest element from the heap takes \\(O(\\log n)\\) time, looping for \\(n - 1\\) rounds.</li> <li>Space complexity is \\(O(1)\\), in-place sort: A few pointer variables use \\(O(1)\\) space. The element swapping and heapifying operations are performed on the original array.</li> <li>Non-stable sort: The relative positions of equal elements may change during the swapping of the heap's top and bottom elements.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/","title":"11.4 \u00a0 Insertion sort","text":"<p>Insertion sort is a simple sorting algorithm that works very much like the process of manually sorting a deck of cards.</p> <p>Specifically, we select a pivot element from the unsorted interval, compare it with the elements in the sorted interval to its left, and insert the element into the correct position.</p> <p>Figure 11-6 shows the process of inserting an element into an array. Assuming the pivot element is <code>base</code>, we need to move all elements between the target index and <code>base</code> one position to the right, then assign <code>base</code> to the target index.</p> <p></p> <p> Figure 11-6 \u00a0 Single insertion operation </p>"},{"location":"chapter_sorting/insertion_sort/#1141-algorithm-process","title":"11.4.1 \u00a0 Algorithm process","text":"<p>The overall process of insertion sort is shown in Figure 11-7.</p> <ol> <li>Initially, the first element of the array is sorted.</li> <li>The second element of the array is taken as <code>base</code>, and after inserting it into the correct position, the first two elements of the array are sorted.</li> <li>The third element is taken as <code>base</code>, and after inserting it into the correct position, the first three elements of the array are sorted.</li> <li>And so on, in the last round, the last element is taken as <code>base</code>, and after inserting it into the correct position, all elements are sorted.</li> </ol> <p></p> <p> Figure 11-7 \u00a0 Insertion sort process </p> <p>Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig insertion_sort.py<pre><code>def insertion_sort(nums: list[int]):\n    \"\"\"\u63d2\u5165\u6392\u5e8f\"\"\"\n    # \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for i in range(1, len(nums)):\n        base = nums[i]\n        j = i - 1\n        # \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while j &gt;= 0 and nums[j] &gt; base:\n            nums[j + 1] = nums[j]  # \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j -= 1\n        nums[j + 1] = base  # \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n</code></pre> insertion_sort.cpp<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nvoid insertionSort(vector&lt;int&gt; &amp;nums) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (int i = 1; i &lt; nums.size(); i++) {\n        int base = nums[i], j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--;\n        }\n        nums[j + 1] = base; // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.java<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nvoid insertionSort(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (int i = 1; i &lt; nums.length; i++) {\n        int base = nums[i], j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--;\n        }\n        nums[j + 1] = base;        // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.cs<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nvoid InsertionSort(int[] nums) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (int i = 1; i &lt; nums.Length; i++) {\n        int bas = nums[i], j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; bas) {\n            nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--;\n        }\n        nums[j + 1] = bas;         // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.go<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfunc insertionSort(nums []int) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for i := 1; i &lt; len(nums); i++ {\n        base := nums[i]\n        j := i - 1\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        for j &gt;= 0 &amp;&amp; nums[j] &gt; base {\n            nums[j+1] = nums[j] // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--\n        }\n        nums[j+1] = base // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.swift<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfunc insertionSort(nums: inout [Int]) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for i in nums.indices.dropFirst() {\n        let base = nums[i]\n        var j = i - 1\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while j &gt;= 0, nums[j] &gt; base {\n            nums[j + 1] = nums[j] // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j -= 1\n        }\n        nums[j + 1] = base // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.js<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfunction insertionSort(nums) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (let i = 1; i &lt; nums.length; i++) {\n        let base = nums[i],\n            j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--;\n        }\n        nums[j + 1] = base; // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.ts<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfunction insertionSort(nums: number[]): void {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (let i = 1; i &lt; nums.length; i++) {\n        const base = nums[i];\n        let j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--;\n        }\n        nums[j + 1] = base; // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.dart<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nvoid insertionSort(List&lt;int&gt; nums) {\n  // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n  for (int i = 1; i &lt; nums.length; i++) {\n    int base = nums[i], j = i - 1;\n    // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n    while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n      nums[j + 1] = nums[j]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n      j--;\n    }\n    nums[j + 1] = base; // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n  }\n}\n</code></pre> insertion_sort.rs<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfn insertion_sort(nums: &amp;mut [i32]) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for i in 1..nums.len() {\n        let (base, mut j) = (nums[i], (i - 1) as i32);\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while j &gt;= 0 &amp;&amp; nums[j as usize] &gt; base {\n            nums[(j + 1) as usize] = nums[j as usize]; // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j -= 1;\n        }\n        nums[(j + 1) as usize] = base; // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.c<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nvoid insertionSort(int nums[], int size) {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    for (int i = 1; i &lt; size; i++) {\n        int base = nums[i], j = i - 1;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            nums[j + 1] = nums[j];\n            j--;\n        }\n        // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n        nums[j + 1] = base;\n    }\n}\n</code></pre> insertion_sort.kt<pre><code>/* \u63d2\u5165\u6392\u5e8f */\nfun insertionSort(nums: IntArray) {\n    //\u5916\u5faa\u73af: \u5df2\u6392\u5e8f\u5143\u7d20\u4e3a 1, 2, ..., n\n    for (i in nums.indices) {\n        val base = nums[i]\n        var j = i - 1\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {\n            nums[j + 1] = nums[j] // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n            j--\n        }\n        nums[j + 1] = base        // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> insertion_sort.rb<pre><code>### \u63d2\u5165\u6392\u5e8f ###\ndef insertion_sort(nums)\n  n = nums.length\n  # \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n  for i in 1...n\n    base = nums[i]\n    j = i - 1\n    # \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n    while j &gt;= 0 &amp;&amp; nums[j] &gt; base\n      nums[j + 1] = nums[j] # \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n      j -= 1\n    end\n    nums[j + 1] = base # \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n  end\nend\n</code></pre> insertion_sort.zig<pre><code>// \u63d2\u5165\u6392\u5e8f\nfn insertionSort(nums: []i32) void {\n    // \u5916\u5faa\u73af\uff1a\u5df2\u6392\u5e8f\u533a\u95f4\u4e3a [0, i-1]\n    var i: usize = 1;\n    while (i &lt; nums.len) : (i += 1) {\n        var base = nums[i];\n        var j: usize = i;\n        // \u5185\u5faa\u73af\uff1a\u5c06 base \u63d2\u5165\u5230\u5df2\u6392\u5e8f\u533a\u95f4 [0, i-1] \u4e2d\u7684\u6b63\u786e\u4f4d\u7f6e\n        while (j &gt;= 1 and nums[j - 1] &gt; base) : (j -= 1) {\n            nums[j] = nums[j - 1];  // \u5c06 nums[j] \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n        }\n        nums[j] = base;             // \u5c06 base \u8d4b\u503c\u5230\u6b63\u786e\u4f4d\u7f6e\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/insertion_sort/#1142-algorithm-characteristics","title":"11.4.2 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n^2)\\), adaptive sorting: In the worst case, each insertion operation requires \\(n - 1\\), \\(n-2\\), ..., \\(2\\), \\(1\\) loops, summing up to \\((n - 1) n / 2\\), thus the time complexity is \\(O(n^2)\\). In the case of ordered data, the insertion operation will terminate early. When the input array is completely ordered, insertion sort achieves the best time complexity of \\(O(n)\\).</li> <li>Space complexity is \\(O(1)\\), in-place sorting: Pointers \\(i\\) and \\(j\\) use a constant amount of extra space.</li> <li>Stable sorting: During the insertion operation, we insert elements to the right of equal elements, not changing their order.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/#1143-advantages-of-insertion-sort","title":"11.4.3 \u00a0 Advantages of insertion sort","text":"<p>The time complexity of insertion sort is \\(O(n^2)\\), while the time complexity of quicksort, which we will study next, is \\(O(n \\log n)\\). Although insertion sort has a higher time complexity, it is usually faster in cases of small data volumes.</p> <p>This conclusion is similar to that for linear and binary search. Algorithms like quicksort that have a time complexity of \\(O(n \\log n)\\) and are based on the divide-and-conquer strategy often involve more unit operations. In cases of small data volumes, the numerical values of \\(n^2\\) and \\(n \\log n\\) are close, and complexity does not dominate, with the number of unit operations per round playing a decisive role.</p> <p>In fact, many programming languages (such as Java) use insertion sort in their built-in sorting functions. The general approach is: for long arrays, use sorting algorithms based on divide-and-conquer strategies, such as quicksort; for short arrays, use insertion sort directly.</p> <p>Although bubble sort, selection sort, and insertion sort all have a time complexity of \\(O(n^2)\\), in practice, insertion sort is used significantly more frequently than bubble sort and selection sort, mainly for the following reasons.</p> <ul> <li>Bubble sort is based on element swapping, which requires the use of a temporary variable, involving 3 unit operations; insertion sort is based on element assignment, requiring only 1 unit operation. Therefore, the computational overhead of bubble sort is generally higher than that of insertion sort.</li> <li>The time complexity of selection sort is always \\(O(n^2)\\). Given a set of partially ordered data, insertion sort is usually more efficient than selection sort.</li> <li>Selection sort is unstable and cannot be applied to multi-level sorting.</li> </ul>"},{"location":"chapter_sorting/merge_sort/","title":"11.6 \u00a0 Merge sort","text":"<p>Merge sort is a sorting algorithm based on the divide-and-conquer strategy, involving the \"divide\" and \"merge\" phases shown in Figure 11-10.</p> <ol> <li>Divide phase: Recursively split the array from the midpoint, transforming the sorting problem of a long array into that of shorter arrays.</li> <li>Merge phase: Stop dividing when the length of the sub-array is 1, start merging, and continuously combine two shorter ordered arrays into one longer ordered array until the process is complete.</li> </ol> <p></p> <p> Figure 11-10 \u00a0 The divide and merge phases of merge sort </p>"},{"location":"chapter_sorting/merge_sort/#1161-algorithm-workflow","title":"11.6.1 \u00a0 Algorithm workflow","text":"<p>As shown in Figure 11-11, the \"divide phase\" recursively splits the array from the midpoint into two sub-arrays from top to bottom.</p> <ol> <li>Calculate the midpoint <code>mid</code>, recursively divide the left sub-array (interval <code>[left, mid]</code>) and the right sub-array (interval <code>[mid + 1, right]</code>).</li> <li>Continue with step <code>1.</code> recursively until the sub-array interval length is 1 to stop.</li> </ol> <p>The \"merge phase\" combines the left and right sub-arrays into a single ordered array from bottom to top. Note that merging starts with sub-arrays of length 1, and each sub-array is ordered during the merge phase.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-11 \u00a0 Merge sort process </p> <p>It is observed that the order of recursion in merge sort is consistent with the post-order traversal of a binary tree.</p> <ul> <li>Post-order traversal: First recursively traverse the left subtree, then the right subtree, and finally handle the root node.</li> <li>Merge sort: First recursively handle the left sub-array, then the right sub-array, and finally perform the merge.</li> </ul> <p>The implementation of merge sort is shown in the following code. Note that the interval to be merged in <code>nums</code> is <code>[left, right]</code>, while the corresponding interval in <code>tmp</code> is <code>[0, right - left]</code>.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig merge_sort.py<pre><code>def merge(nums: list[int], left: int, mid: int, right: int):\n    \"\"\"\u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\"\"\"\n    # \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    # \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    tmp = [0] * (right - left + 1)\n    # \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    i, j, k = left, mid + 1, 0\n    # \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid and j &lt;= right:\n        if nums[i] &lt;= nums[j]:\n            tmp[k] = nums[i]\n            i += 1\n        else:\n            tmp[k] = nums[j]\n            j += 1\n        k += 1\n    # \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid:\n        tmp[k] = nums[i]\n        i += 1\n        k += 1\n    while j &lt;= right:\n        tmp[k] = nums[j]\n        j += 1\n        k += 1\n    # \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for k in range(0, len(tmp)):\n        nums[left + k] = tmp[k]\n\ndef merge_sort(nums: list[int], left: int, right: int):\n    \"\"\"\u5f52\u5e76\u6392\u5e8f\"\"\"\n    # \u7ec8\u6b62\u6761\u4ef6\n    if left &gt;= right:\n        return  # \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    # \u5212\u5206\u9636\u6bb5\n    mid = (left + right) // 2  # \u8ba1\u7b97\u4e2d\u70b9\n    merge_sort(nums, left, mid)  # \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    merge_sort(nums, mid + 1, right)  # \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    # \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right)\n</code></pre> merge_sort.cpp<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nvoid merge(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    vector&lt;int&gt; tmp(right - left + 1);\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    int i = left, j = mid + 1, k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmp.size(); k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nvoid mergeSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right)\n        return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    int mid = (left + right) / 2;    // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid);      // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.java<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nvoid merge(int[] nums, int left, int mid, int right) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    int[] tmp = new int[right - left + 1];\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    int i = left, j = mid + 1, k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nvoid mergeSort(int[] nums, int left, int right) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right)\n        return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    int mid = (left + right) / 2; // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid); // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.cs<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nvoid Merge(int[] nums, int left, int mid, int right) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    int[] tmp = new int[right - left + 1];\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    int i = left, j = mid + 1, k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmp.Length; ++k) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nvoid MergeSort(int[] nums, int left, int right) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right) return;       // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    int mid = (left + right) / 2;    // \u8ba1\u7b97\u4e2d\u70b9\n    MergeSort(nums, left, mid);      // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    MergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    Merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.go<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfunc merge(nums []int, left, mid, right int) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    tmp := make([]int, right-left+1)\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    i, j, k := left, mid+1, 0\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    for i &lt;= mid &amp;&amp; j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i]\n            i++\n        } else {\n            tmp[k] = nums[j]\n            j++\n        }\n        k++\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    for i &lt;= mid {\n        tmp[k] = nums[i]\n        i++\n        k++\n    }\n    for j &lt;= right {\n        tmp[k] = nums[j]\n        j++\n        k++\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for k := 0; k &lt; len(tmp); k++ {\n        nums[left+k] = tmp[k]\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfunc mergeSort(nums []int, left, right int) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if left &gt;= right {\n        return\n    }\n    // \u5212\u5206\u9636\u6bb5\n    mid := (left + right) / 2\n    mergeSort(nums, left, mid)\n    mergeSort(nums, mid+1, right)\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right)\n}\n</code></pre> merge_sort.swift<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfunc merge(nums: inout [Int], left: Int, mid: Int, right: Int) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    var tmp = Array(repeating: 0, count: right - left + 1)\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    var i = left, j = mid + 1, k = 0\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid, j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i]\n            i += 1\n        } else {\n            tmp[k] = nums[j]\n            j += 1\n        }\n        k += 1\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid {\n        tmp[k] = nums[i]\n        i += 1\n        k += 1\n    }\n    while j &lt;= right {\n        tmp[k] = nums[j]\n        j += 1\n        k += 1\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for k in tmp.indices {\n        nums[left + k] = tmp[k]\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfunc mergeSort(nums: inout [Int], left: Int, right: Int) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if left &gt;= right { // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n        return\n    }\n    // \u5212\u5206\u9636\u6bb5\n    let mid = (left + right) / 2 // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums: &amp;nums, left: left, right: mid) // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums: &amp;nums, left: mid + 1, right: right) // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums: &amp;nums, left: left, mid: mid, right: right)\n}\n</code></pre> merge_sort.js<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfunction merge(nums, left, mid, right) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    const tmp = new Array(right - left + 1);\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    let i = left,\n        j = mid + 1,\n        k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfunction mergeSort(nums, left, right) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right) return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    let mid = Math.floor((left + right) / 2); // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid); // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.ts<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfunction merge(nums: number[], left: number, mid: number, right: number): void {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    const tmp = new Array(right - left + 1);\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    let i = left,\n        j = mid + 1,\n        k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmp.length; k++) {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfunction mergeSort(nums: number[], left: number, right: number): void {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right) return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    let mid = Math.floor((left + right) / 2); // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid); // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.dart<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nvoid merge(List&lt;int&gt; nums, int left, int mid, int right) {\n  // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n  // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n  List&lt;int&gt; tmp = List.filled(right - left + 1, 0);\n  // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n  int i = left, j = mid + 1, k = 0;\n  // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n  while (i &lt;= mid &amp;&amp; j &lt;= right) {\n    if (nums[i] &lt;= nums[j])\n      tmp[k++] = nums[i++];\n    else\n      tmp[k++] = nums[j++];\n  }\n  // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n  while (i &lt;= mid) {\n    tmp[k++] = nums[i++];\n  }\n  while (j &lt;= right) {\n    tmp[k++] = nums[j++];\n  }\n  // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n  for (k = 0; k &lt; tmp.length; k++) {\n    nums[left + k] = tmp[k];\n  }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nvoid mergeSort(List&lt;int&gt; nums, int left, int right) {\n  // \u7ec8\u6b62\u6761\u4ef6\n  if (left &gt;= right) return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n  // \u5212\u5206\u9636\u6bb5\n  int mid = (left + right) ~/ 2; // \u8ba1\u7b97\u4e2d\u70b9\n  mergeSort(nums, left, mid); // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n  mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n  // \u5408\u5e76\u9636\u6bb5\n  merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.rs<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfn merge(nums: &amp;mut [i32], left: usize, mid: usize, right: usize) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    let tmp_size = right - left + 1;\n    let mut tmp = vec![0; tmp_size];\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    let (mut i, mut j, mut k) = (left, mid + 1, 0);\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid &amp;&amp; j &lt;= right {\n        if nums[i] &lt;= nums[j] {\n            tmp[k] = nums[i];\n            i += 1;\n        } else {\n            tmp[k] = nums[j];\n            j += 1;\n        }\n        k += 1;\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while i &lt;= mid {\n        tmp[k] = nums[i];\n        k += 1;\n        i += 1;\n    }\n    while j &lt;= right {\n        tmp[k] = nums[j];\n        k += 1;\n        j += 1;\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for k in 0..tmp_size {\n        nums[left + k] = tmp[k];\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfn merge_sort(nums: &amp;mut [i32], left: usize, right: usize) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if left &gt;= right {\n        return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    }\n\n    // \u5212\u5206\u9636\u6bb5\n    let mid = (left + right) / 2; // \u8ba1\u7b97\u4e2d\u70b9\n    merge_sort(nums, left, mid); // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    merge_sort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.c<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nvoid merge(int *nums, int left, int mid, int right) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    int tmpSize = right - left + 1;\n    int *tmp = (int *)malloc(tmpSize * sizeof(int));\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    int i = left, j = mid + 1, k = 0;\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j]) {\n            tmp[k++] = nums[i++];\n        } else {\n            tmp[k++] = nums[j++];\n        }\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++];\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++];\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (k = 0; k &lt; tmpSize; ++k) {\n        nums[left + k] = tmp[k];\n    }\n    // \u91ca\u653e\u5185\u5b58\n    free(tmp);\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nvoid mergeSort(int *nums, int left, int right) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right)\n        return; // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    int mid = (left + right) / 2;    // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid);      // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right); // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right);\n}\n</code></pre> merge_sort.kt<pre><code>/* \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 */\nfun merge(nums: IntArray, left: Int, mid: Int, right: Int) {\n    // \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n    // \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp \uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n    val tmp = IntArray(right - left + 1)\n    // \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n    var i = left\n    var j = mid + 1\n    var k = 0\n    // \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid &amp;&amp; j &lt;= right) {\n        if (nums[i] &lt;= nums[j])\n            tmp[k++] = nums[i++]\n        else \n            tmp[k++] = nums[j++]\n    }\n    // \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n    while (i &lt;= mid) {\n        tmp[k++] = nums[i++]\n    }\n    while (j &lt;= right) {\n        tmp[k++] = nums[j++]\n    }\n    // \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n    for (l in tmp.indices) {\n        nums[left + l] = tmp[l]\n    }\n}\n\n/* \u5f52\u5e76\u6392\u5e8f */\nfun mergeSort(nums: IntArray, left: Int, right: Int) {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right) return  // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    val mid = (left + right) / 2 // \u8ba1\u7b97\u4e2d\u70b9\n    mergeSort(nums, left, mid) // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    mergeSort(nums, mid + 1, right) // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    merge(nums, left, mid, right)\n}\n</code></pre> merge_sort.rb<pre><code>### \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4 ###\ndef merge(nums, left, mid, right)\n  # \u5de6\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [left, mid], \u53f3\u5b50\u6570\u7ec4\u533a\u95f4\u4e3a [mid+1, right]\n  # \u521b\u5efa\u4e00\u4e2a\u4e34\u65f6\u6570\u7ec4 tmp\uff0c\u7528\u4e8e\u5b58\u653e\u5408\u5e76\u540e\u7684\u7ed3\u679c\n  tmp = Array.new(right - left + 1, 0)\n  # \u521d\u59cb\u5316\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\n  i, j, k = left, mid + 1, 0\n  # \u5f53\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u8fd8\u6709\u5143\u7d20\u65f6\uff0c\u8fdb\u884c\u6bd4\u8f83\u5e76\u5c06\u8f83\u5c0f\u7684\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n  while i &lt;= mid &amp;&amp; j &lt;= right\n    if nums[i] &lt;= nums[j]\n      tmp[k] = nums[i]\n      i += 1\n    else\n      tmp[k] = nums[j]\n      j += 1\n    end\n    k += 1\n  end\n  # \u5c06\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\u590d\u5236\u5230\u4e34\u65f6\u6570\u7ec4\u4e2d\n  while i &lt;= mid\n    tmp[k] = nums[i]\n    i += 1\n    k += 1\n  end\n  while j &lt;= right\n    tmp[k] = nums[j]\n    j += 1\n    k += 1\n  end\n  # \u5c06\u4e34\u65f6\u6570\u7ec4 tmp \u4e2d\u7684\u5143\u7d20\u590d\u5236\u56de\u539f\u6570\u7ec4 nums \u7684\u5bf9\u5e94\u533a\u95f4\n  (0...tmp.length).each do |k|\n    nums[left + k] = tmp[k]\n  end\nend\n\n### \u5f52\u5e76\u6392\u5e8f ###\ndef merge_sort(nums, left, right)\n  # \u7ec8\u6b62\u6761\u4ef6\n  # \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n  return if left &gt;= right\n  # \u5212\u5206\u9636\u6bb5\n  mid = (left + right) / 2 # \u8ba1\u7b97\u4e2d\u70b9\n  merge_sort(nums, left, mid) # \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n  merge_sort(nums, mid + 1, right) # \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n  # \u5408\u5e76\u9636\u6bb5\n  merge(nums, left, mid, right)\nend\n</code></pre> merge_sort.zig<pre><code>// \u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\n// \u5de6\u5b50\u6570\u7ec4\u533a\u95f4 [left, mid]\n// \u53f3\u5b50\u6570\u7ec4\u533a\u95f4 [mid + 1, right]\nfn merge(nums: []i32, left: usize, mid: usize, right: usize) !void {\n    // \u521d\u59cb\u5316\u8f85\u52a9\u6570\u7ec4\n    var mem_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer mem_arena.deinit();\n    const mem_allocator = mem_arena.allocator();\n    var tmp = try mem_allocator.alloc(i32, right + 1 - left);\n    std.mem.copy(i32, tmp, nums[left..right+1]);\n    // \u5de6\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\u548c\u7ed3\u675f\u7d22\u5f15  \n    var leftStart = left - left;\n    var leftEnd = mid - left;\n    // \u53f3\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u7d22\u5f15\u548c\u7ed3\u675f\u7d22\u5f15       \n    var rightStart = mid + 1 - left;\n    var rightEnd = right - left;\n    // i, j \u5206\u522b\u6307\u5411\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\u7684\u9996\u5143\u7d20\n    var i = leftStart;\n    var j = rightStart;\n    // \u901a\u8fc7\u8986\u76d6\u539f\u6570\u7ec4 nums \u6765\u5408\u5e76\u5de6\u5b50\u6570\u7ec4\u548c\u53f3\u5b50\u6570\u7ec4\n    var k = left;\n    while (k &lt;= right) : (k += 1) {\n        // \u82e5\u201c\u5de6\u5b50\u6570\u7ec4\u5df2\u5168\u90e8\u5408\u5e76\u5b8c\u201d\uff0c\u5219\u9009\u53d6\u53f3\u5b50\u6570\u7ec4\u5143\u7d20\uff0c\u5e76\u4e14 j++\n        if (i &gt; leftEnd) {\n            nums[k] = tmp[j];\n            j += 1;\n        // \u5426\u5219\uff0c\u82e5\u201c\u53f3\u5b50\u6570\u7ec4\u5df2\u5168\u90e8\u5408\u5e76\u5b8c\u201d\u6216\u201c\u5de6\u5b50\u6570\u7ec4\u5143\u7d20 &lt;= \u53f3\u5b50\u6570\u7ec4\u5143\u7d20\u201d\uff0c\u5219\u9009\u53d6\u5de6\u5b50\u6570\u7ec4\u5143\u7d20\uff0c\u5e76\u4e14 i++\n        } else if  (j &gt; rightEnd or tmp[i] &lt;= tmp[j]) {\n            nums[k] = tmp[i];\n            i += 1;\n        // \u5426\u5219\uff0c\u82e5\u201c\u5de6\u53f3\u5b50\u6570\u7ec4\u90fd\u672a\u5168\u90e8\u5408\u5e76\u5b8c\u201d\u4e14\u201c\u5de6\u5b50\u6570\u7ec4\u5143\u7d20 &gt; \u53f3\u5b50\u6570\u7ec4\u5143\u7d20\u201d\uff0c\u5219\u9009\u53d6\u53f3\u5b50\u6570\u7ec4\u5143\u7d20\uff0c\u5e76\u4e14 j++\n        } else {\n            nums[k] = tmp[j];\n            j += 1;\n        }\n    }\n}\n\n// \u5f52\u5e76\u6392\u5e8f\nfn mergeSort(nums: []i32, left: usize, right: usize) !void {\n    // \u7ec8\u6b62\u6761\u4ef6\n    if (left &gt;= right) return;              // \u5f53\u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    // \u5212\u5206\u9636\u6bb5\n    var mid = (left + right) / 2;           // \u8ba1\u7b97\u4e2d\u70b9\n    try mergeSort(nums, left, mid);         // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\n    try mergeSort(nums, mid + 1, right);    // \u9012\u5f52\u53f3\u5b50\u6570\u7ec4\n    // \u5408\u5e76\u9636\u6bb5\n    try merge(nums, left, mid, right);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/merge_sort/#1162-algorithm-characteristics","title":"11.6.2 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sort: The division creates a recursion tree of height \\(\\log n\\), with each layer merging a total of \\(n\\) operations, resulting in an overall time complexity of \\(O(n \\log n)\\).</li> <li>Space complexity of \\(O(n)\\), non-in-place sort: The recursion depth is \\(\\log n\\), using \\(O(\\log n)\\) stack frame space. The merging operation requires auxiliary arrays, using an additional space of \\(O(n)\\).</li> <li>Stable sort: During the merging process, the order of equal elements remains unchanged.</li> </ul>"},{"location":"chapter_sorting/merge_sort/#1163-linked-list-sorting","title":"11.6.3 \u00a0 Linked List sorting","text":"<p>For linked lists, merge sort has significant advantages over other sorting algorithms, optimizing the space complexity of the linked list sorting task to \\(O(1)\\).</p> <ul> <li>Divide phase: \"Iteration\" can be used instead of \"recursion\" to perform the linked list division work, thus saving the stack frame space used by recursion.</li> <li>Merge phase: In linked lists, node addition and deletion operations can be achieved by changing references (pointers), so no extra lists need to be created during the merge phase (combining two short ordered lists into one long ordered list).</li> </ul> <p>Detailed implementation details are complex, and interested readers can consult related materials for learning.</p>"},{"location":"chapter_sorting/quick_sort/","title":"11.5 \u00a0 Quick sort","text":"<p>Quick sort is a sorting algorithm based on the divide and conquer strategy, known for its efficiency and wide application.</p> <p>The core operation of quick sort is \"pivot partitioning,\" aiming to: select an element from the array as the \"pivot,\" move all elements smaller than the pivot to its left, and move elements greater than the pivot to its right. Specifically, the pivot partitioning process is illustrated as follows.</p> <ol> <li>Select the leftmost element of the array as the pivot, and initialize two pointers <code>i</code> and <code>j</code> at both ends of the array.</li> <li>Set up a loop where each round uses <code>i</code> (<code>j</code>) to find the first element larger (smaller) than the pivot, then swap these two elements.</li> <li>Repeat step <code>2.</code> until <code>i</code> and <code>j</code> meet, finally swap the pivot to the boundary between the two sub-arrays.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-8 \u00a0 Pivot division process </p> <p>After the pivot partitioning, the original array is divided into three parts: left sub-array, pivot, and right sub-array, satisfying \"any element in the left sub-array \\(\\leq\\) pivot \\(\\leq\\) any element in the right sub-array.\" Therefore, we only need to sort these two sub-arrays next.</p> <p>Quick sort's divide and conquer strategy</p> <p>The essence of pivot partitioning is to simplify a longer array's sorting problem into two shorter arrays' sorting problems.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig quick_sort.py<pre><code>def partition(self, nums: list[int], left: int, right: int) -&gt; int:\n    \"\"\"\u54e8\u5175\u5212\u5206\"\"\"\n    # \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    i, j = left, right\n    while i &lt; j:\n        while i &lt; j and nums[j] &gt;= nums[left]:\n            j -= 1  # \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while i &lt; j and nums[i] &lt;= nums[left]:\n            i += 1  # \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        # \u5143\u7d20\u4ea4\u6362\n        nums[i], nums[j] = nums[j], nums[i]\n    # \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    nums[i], nums[left] = nums[left], nums[i]\n    return i  # \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n</code></pre> quick_sort.cpp<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nvoid swap(vector&lt;int&gt; &amp;nums, int i, int j) {\n    int tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nint partition(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;            // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.java<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nvoid swap(int[] nums, int i, int j) {\n    int tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nint partition(int[] nums, int left, int right) {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left);  // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;             // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.cs<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nvoid Swap(int[] nums, int i, int j) {\n    (nums[j], nums[i]) = (nums[i], nums[j]);\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nint Partition(int[] nums, int left, int right) {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        Swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    Swap(nums, i, left);  // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;             // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.go<pre><code>/* \u54e8\u5175\u5212\u5206 */\nfunc (q *quickSort) partition(nums []int, left, right int) int {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    i, j := left, right\n    for i &lt; j {\n        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j-- // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i++ // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        // \u5143\u7d20\u4ea4\u6362\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    nums[i], nums[left] = nums[left], nums[i]\n    return i // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.swift<pre><code>/* \u54e8\u5175\u5212\u5206 */\nfunc partition(nums: inout [Int], left: Int, right: Int) -&gt; Int {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    var i = left\n    var j = right\n    while i &lt; j {\n        while i &lt; j, nums[j] &gt;= nums[left] {\n            j -= 1 // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while i &lt; j, nums[i] &lt;= nums[left] {\n            i += 1 // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        nums.swapAt(i, j) // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    nums.swapAt(i, left) // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.js<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nswap(nums, i, j) {\n    let tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\npartition(nums, left, right) {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        // \u5143\u7d20\u4ea4\u6362\n        this.swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    this.swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.ts<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nswap(nums: number[], i: number, j: number): void {\n    let tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\npartition(nums: number[], left: number, right: number): number {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        // \u5143\u7d20\u4ea4\u6362\n        this.swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    this.swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.dart<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nvoid _swap(List&lt;int&gt; nums, int i, int j) {\n  int tmp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nint _partition(List&lt;int&gt; nums, int left, int right) {\n  // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n  int i = left, j = right;\n  while (i &lt; j) {\n    while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n    while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n    _swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n  }\n  _swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n  return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.rs<pre><code>/* \u54e8\u5175\u5212\u5206 */\nfn partition(nums: &amp;mut [i32], left: usize, right: usize) -&gt; usize {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let (mut i, mut j) = (left, right);\n    while i &lt; j {\n        while i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        nums.swap(i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    nums.swap(i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    i // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.c<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nvoid swap(int nums[], int i, int j) {\n    int tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nint partition(int nums[], int left, int right) {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i++; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n        swap(nums, i, j);\n    }\n    // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    swap(nums, i, left);\n    // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n    return i;\n}\n</code></pre> quick_sort.kt<pre><code>/* \u5143\u7d20\u4ea4\u6362 */\nfun swap(nums: IntArray, i: Int, j: Int) {\n    val temp = nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n}\n\n/* \u54e8\u5175\u5212\u5206 */\nfun partition(nums: IntArray, left: Int, right: Int): Int {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    var i = left\n    var j = right\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--           // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++           // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j)  // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left)   // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i              // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.rb<pre><code>[class]{QuickSort}-[func]{partition}\n</code></pre> quick_sort.zig<pre><code>// \u5143\u7d20\u4ea4\u6362\nfn swap(nums: []i32, i: usize, j: usize) void {\n    var tmp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = tmp;\n}\n\n// \u54e8\u5175\u5212\u5206\nfn partition(nums: []i32, left: usize, right: usize) usize {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    var i = left;\n    var j = right;\n    while (i &lt; j) {\n        while (i &lt; j and nums[j] &gt;= nums[left]) j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j and nums[i] &lt;= nums[left]) i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j);   // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left);    // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;               // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/quick_sort/#1151-algorithm-process","title":"11.5.1 \u00a0 Algorithm process","text":"<p>The overall process of quick sort is shown in Figure 11-9.</p> <ol> <li>First, perform a \"pivot partitioning\" on the original array to obtain the unsorted left and right sub-arrays.</li> <li>Then, recursively perform \"pivot partitioning\" on both the left and right sub-arrays.</li> <li>Continue recursively until the sub-array length reaches 1, thus completing the sorting of the entire array.</li> </ol> <p></p> <p> Figure 11-9 \u00a0 Quick sort process </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig quick_sort.py<pre><code>def quick_sort(self, nums: list[int], left: int, right: int):\n    \"\"\"\u5feb\u901f\u6392\u5e8f\"\"\"\n    # \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if left &gt;= right:\n        return\n    # \u54e8\u5175\u5212\u5206\n    pivot = self.partition(nums, left, right)\n    # \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    self.quick_sort(nums, left, pivot - 1)\n    self.quick_sort(nums, pivot + 1, right)\n</code></pre> quick_sort.cpp<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nvoid quickSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right)\n        return;\n    // \u54e8\u5175\u5212\u5206\n    int pivot = partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.java<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nvoid quickSort(int[] nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right)\n        return;\n    // \u54e8\u5175\u5212\u5206\n    int pivot = partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.cs<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nvoid QuickSort(int[] nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right)\n        return;\n    // \u54e8\u5175\u5212\u5206\n    int pivot = Partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    QuickSort(nums, left, pivot - 1);\n    QuickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.go<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nfunc (q *quickSort) quickSort(nums []int, left, right int) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if left &gt;= right {\n        return\n    }\n    // \u54e8\u5175\u5212\u5206\n    pivot := q.partition(nums, left, right)\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    q.quickSort(nums, left, pivot-1)\n    q.quickSort(nums, pivot+1, right)\n}\n</code></pre> quick_sort.swift<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nfunc quickSort(nums: inout [Int], left: Int, right: Int) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if left &gt;= right {\n        return\n    }\n    // \u54e8\u5175\u5212\u5206\n    let pivot = partition(nums: &amp;nums, left: left, right: right)\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums: &amp;nums, left: left, right: pivot - 1)\n    quickSort(nums: &amp;nums, left: pivot + 1, right: right)\n}\n</code></pre> quick_sort.js<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nquickSort(nums, left, right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right) return;\n    // \u54e8\u5175\u5212\u5206\n    const pivot = this.partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    this.quickSort(nums, left, pivot - 1);\n    this.quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.ts<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nquickSort(nums: number[], left: number, right: number): void {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right) {\n        return;\n    }\n    // \u54e8\u5175\u5212\u5206\n    const pivot = this.partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    this.quickSort(nums, left, pivot - 1);\n    this.quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.dart<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nvoid quickSort(List&lt;int&gt; nums, int left, int right) {\n  // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n  if (left &gt;= right) return;\n  // \u54e8\u5175\u5212\u5206\n  int pivot = _partition(nums, left, right);\n  // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n  quickSort(nums, left, pivot - 1);\n  quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.rs<pre><code>/* \u5feb\u901f\u6392\u5e8f */\npub fn quick_sort(left: i32, right: i32, nums: &amp;mut [i32]) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if left &gt;= right {\n        return;\n    }\n    // \u54e8\u5175\u5212\u5206\n    let pivot = Self::partition(nums, left as usize, right as usize) as i32;\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    Self::quick_sort(left, pivot - 1, nums);\n    Self::quick_sort(pivot + 1, right, nums);\n}\n</code></pre> quick_sort.c<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nvoid quickSort(int nums[], int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right) {\n        return;\n    }\n    // \u54e8\u5175\u5212\u5206\n    int pivot = partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> quick_sort.kt<pre><code>/* \u5feb\u901f\u6392\u5e8f */\nfun quickSort(nums: IntArray, left: Int, right: Int) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right) return\n    // \u54e8\u5175\u5212\u5206\n    val pivot = partition(nums, left, right)\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums, left, pivot - 1)\n    quickSort(nums, pivot + 1, right)\n}\n</code></pre> quick_sort.rb<pre><code>[class]{QuickSort}-[func]{quick_sort}\n</code></pre> quick_sort.zig<pre><code>// \u5feb\u901f\u6392\u5e8f\nfn quickSort(nums: []i32, left: usize, right: usize) void {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    if (left &gt;= right) return;\n    // \u54e8\u5175\u5212\u5206\n    var pivot = partition(nums, left, right);\n    // \u9012\u5f52\u5de6\u5b50\u6570\u7ec4\u3001\u53f3\u5b50\u6570\u7ec4\n    quickSort(nums, left, pivot - 1);\n    quickSort(nums, pivot + 1, right);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/quick_sort/#1152-algorithm-features","title":"11.5.2 \u00a0 Algorithm features","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), adaptive sorting: In average cases, the recursive levels of pivot partitioning are \\(\\log n\\), and the total number of loops per level is \\(n\\), using \\(O(n \\log n)\\) time overall. In the worst case, each round of pivot partitioning divides an array of length \\(n\\) into two sub-arrays of lengths \\(0\\) and \\(n - 1\\), reaching \\(n\\) recursive levels, and using \\(O(n^2)\\) time overall.</li> <li>Space complexity of \\(O(n)\\), in-place sorting: In completely reversed input arrays, reaching the worst recursion depth of \\(n\\), using \\(O(n)\\) stack frame space. The sorting operation is performed on the original array without the aid of additional arrays.</li> <li>Non-stable sorting: In the final step of pivot partitioning, the pivot may be swapped to the right of equal elements.</li> </ul>"},{"location":"chapter_sorting/quick_sort/#1153-why-is-quick-sort-fast","title":"11.5.3 \u00a0 Why is quick sort fast","text":"<p>From its name, it is apparent that quick sort should have certain efficiency advantages. Although the average time complexity of quick sort is the same as \"merge sort\" and \"heap sort,\" quick sort is generally more efficient, mainly for the following reasons.</p> <ul> <li>Low probability of worst-case scenarios: Although the worst time complexity of quick sort is \\(O(n^2)\\), less stable than merge sort, in most cases, quick sort can operate under a time complexity of \\(O(n \\log n)\\).</li> <li>High cache usage efficiency: During the pivot partitioning operation, the system can load the entire sub-array into the cache, thus accessing elements more efficiently. In contrast, algorithms like \"heap sort\" need to access elements in a jumping manner, lacking this feature.</li> <li>Small constant coefficient of complexity: Among the mentioned algorithms, quick sort has the fewest total number of comparisons, assignments, and swaps. This is similar to why \"insertion sort\" is faster than \"bubble sort.\"</li> </ul>"},{"location":"chapter_sorting/quick_sort/#1154-pivot-optimization","title":"11.5.4 \u00a0 Pivot optimization","text":"<p>Quick sort's time efficiency may decrease under certain inputs. For example, if the input array is completely reversed, since we select the leftmost element as the pivot, after the pivot partitioning, the pivot is swapped to the array's right end, causing the left sub-array length to be \\(n - 1\\) and the right sub-array length to be \\(0\\). If this recursion continues, each round of pivot partitioning will have a sub-array length of \\(0\\), and the divide and conquer strategy fails, degrading quick sort to a form similar to \"bubble sort.\"</p> <p>To avoid this situation, we can optimize the strategy for selecting the pivot in the pivot partitioning. For instance, we can randomly select an element as the pivot. However, if luck is not on our side, and we keep selecting suboptimal pivots, the efficiency is still not satisfactory.</p> <p>It's important to note that programming languages usually generate \"pseudo-random numbers\". If we construct a specific test case for a pseudo-random number sequence, the efficiency of quick sort may still degrade.</p> <p>For further improvement, we can select three candidate elements (usually the first, last, and midpoint elements of the array), and use the median of these three candidate elements as the pivot. This significantly increases the probability that the pivot is \"neither too small nor too large\". Of course, we can also select more candidate elements to further enhance the algorithm's robustness. Using this method significantly reduces the probability of time complexity degradation to \\(O(n^2)\\).</p> <p>Sample code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig quick_sort.py<pre><code>def median_three(self, nums: list[int], left: int, mid: int, right: int) -&gt; int:\n    \"\"\"\u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\"\"\"\n    l, m, r = nums[left], nums[mid], nums[right]\n    if (l &lt;= m &lt;= r) or (r &lt;= m &lt;= l):\n        return mid  # m \u5728 l \u548c r \u4e4b\u95f4\n    if (m &lt;= l &lt;= r) or (r &lt;= l &lt;= m):\n        return left  # l \u5728 m \u548c r \u4e4b\u95f4\n    return right\n\ndef partition(self, nums: list[int], left: int, right: int) -&gt; int:\n    \"\"\"\u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09\"\"\"\n    # \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    med = self.median_three(nums, left, (left + right) // 2, right)\n    # \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    nums[left], nums[med] = nums[med], nums[left]\n    # \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    i, j = left, right\n    while i &lt; j:\n        while i &lt; j and nums[j] &gt;= nums[left]:\n            j -= 1  # \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while i &lt; j and nums[i] &lt;= nums[left]:\n            i += 1  # \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        # \u5143\u7d20\u4ea4\u6362\n        nums[i], nums[j] = nums[j], nums[i]\n    # \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    nums[i], nums[left] = nums[left], nums[i]\n    return i  # \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n</code></pre> quick_sort.cpp<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nint medianThree(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nint partition(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;            // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.java<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nint medianThree(int[] nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nint partition(int[] nums, int left, int right) {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left);  // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;             // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.cs<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nint MedianThree(int[] nums, int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nint Partition(int[] nums, int left, int right) {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    int med = MedianThree(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    Swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--;          // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        Swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    Swap(nums, i, left);  // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;             // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.go<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nfunc (q *quickSortMedian) medianThree(nums []int, left, mid, right int) int {\n    l, m, r := nums[left], nums[mid], nums[right]\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid // m \u5728 l \u548c r \u4e4b\u95f4\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left // l \u5728 m \u548c r \u4e4b\u95f4\n    }\n    return right\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09*/\nfunc (q *quickSortMedian) partition(nums []int, left, right int) int {\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    med := q.medianThree(nums, left, (left+right)/2, right)\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    nums[left], nums[med] = nums[med], nums[left]\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    i, j := left, right\n    for i &lt; j {\n        for i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j-- //\u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        for i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i++ //\u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        //\u5143\u7d20\u4ea4\u6362\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    //\u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    nums[i], nums[left] = nums[left], nums[i]\n    return i //\u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.swift<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nfunc medianThree(nums: [Int], left: Int, mid: Int, right: Int) -&gt; Int {\n    let l = nums[left]\n    let m = nums[mid]\n    let r = nums[right]\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid // m \u5728 l \u548c r \u4e4b\u95f4\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left // l \u5728 m \u548c r \u4e4b\u95f4\n    }\n    return right\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nfunc partitionMedian(nums: inout [Int], left: Int, right: Int) -&gt; Int {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    let med = medianThree(nums: nums, left: left, mid: (left + right) / 2, right: right)\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    nums.swapAt(left, med)\n    return partition(nums: &amp;nums, left: left, right: right)\n}\n</code></pre> quick_sort.js<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nmedianThree(nums, left, mid, right) {\n    let l = nums[left],\n        m = nums[mid],\n        r = nums[right];\n    // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) return mid;\n    // l \u5728 m \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) return left;\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\npartition(nums, left, right) {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    let med = this.medianThree(\n        nums,\n        left,\n        Math.floor((left + right) / 2),\n        right\n    );\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    this.swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        this.swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    this.swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.ts<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nmedianThree(\n    nums: number[],\n    left: number,\n    mid: number,\n    right: number\n): number {\n    let l = nums[left],\n        m = nums[mid],\n        r = nums[right];\n    // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) return mid;\n    // l \u5728 m \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) return left;\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\npartition(nums: number[], left: number, right: number): number {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    let med = this.medianThree(\n        nums,\n        left,\n        Math.floor((left + right) / 2),\n        right\n    );\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    this.swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let i = left,\n        j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) {\n            j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) {\n            i++; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        this.swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    this.swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.dart<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nint _medianThree(List&lt;int&gt; nums, int left, int mid, int right) {\n  int l = nums[left], m = nums[mid], r = nums[right];\n  if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n    return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n  if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n    return left; // l \u5728 m \u548c r \u4e4b\u95f4\n  return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nint _partition(List&lt;int&gt; nums, int left, int right) {\n  // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n  int med = _medianThree(nums, left, (left + right) ~/ 2, right);\n  // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n  _swap(nums, left, med);\n  // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n  int i = left, j = right;\n  while (i &lt; j) {\n    while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n    while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n    _swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n  }\n  _swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n  return i; // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.rs<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nfn median_three(nums: &amp;mut [i32], left: usize, mid: usize, right: usize) -&gt; usize {\n    let (l, m, r) = (nums[left], nums[mid], nums[right]);\n    if (l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l) {\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    }\n    if (m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m) {\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    }\n    right\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nfn partition(nums: &amp;mut [i32], left: usize, right: usize) -&gt; usize {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    let med = Self::median_three(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    nums.swap(left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    let (mut i, mut j) = (left, right);\n    while i &lt; j {\n        while i &lt; j &amp;&amp; nums[j] &gt;= nums[left] {\n            j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        while i &lt; j &amp;&amp; nums[i] &lt;= nums[left] {\n            i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        }\n        nums.swap(i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    nums.swap(i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    i // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.c<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nint medianThree(int nums[], int left, int mid, int right) {\n    int l = nums[left], m = nums[mid], r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    return right;\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nint partitionMedian(int nums[], int left, int right) {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    int med = medianThree(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    int i = left, j = right;\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++;          // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j); // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left); // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;            // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.kt<pre><code>/* \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570 */\nfun medianThree(nums: IntArray, left: Int, mid: Int, right: Int): Int {\n    val l = nums[left]\n    val m = nums[mid]\n    val r = nums[right]\n    if ((m in l..r) || (m in r..l))\n        return mid  // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((l in m..r) || (l in r..m))\n        return left // l \u5728 m \u548c r \u4e4b\u95f4\n    return right\n}\n\n/* \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09 */\nfun partitionMedian(nums: IntArray, left: Int, right: Int): Int {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    val med = medianThree(nums, left, (left + right) / 2, right)\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    swap(nums, left, med)\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    var i = left\n    var j = right\n    while (i &lt; j) {\n        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])\n            j--                      // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])\n            i++                      // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j)             // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left)              // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i                         // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> quick_sort.rb<pre><code>[class]{QuickSortMedian}-[func]{median_three}\n\n[class]{QuickSortMedian}-[func]{partition}\n</code></pre> quick_sort.zig<pre><code>// \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\nfn medianThree(nums: []i32, left: usize, mid: usize, right: usize) usize {\n    var l = nums[left];\n    var m = nums[mid];\n    var r = nums[right];\n    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))\n        return mid; // m \u5728 l \u548c r \u4e4b\u95f4\n    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))\n        return left; // l \u5728 m \u548c r \u4e4b\u95f4\n    return right;\n}\n\n// \u54e8\u5175\u5212\u5206\uff08\u4e09\u6570\u53d6\u4e2d\u503c\uff09\nfn partition(nums: []i32, left: usize, right: usize) usize {\n    // \u9009\u53d6\u4e09\u4e2a\u5019\u9009\u5143\u7d20\u7684\u4e2d\u4f4d\u6570\n    var med = medianThree(nums, left, (left + right) / 2, right);\n    // \u5c06\u4e2d\u4f4d\u6570\u4ea4\u6362\u81f3\u6570\u7ec4\u6700\u5de6\u7aef\n    swap(nums, left, med);\n    // \u4ee5 nums[left] \u4e3a\u57fa\u51c6\u6570\n    var i = left;\n    var j = right;\n    while (i &lt; j) {\n        while (i &lt; j and nums[j] &gt;= nums[left]) j -= 1; // \u4ece\u53f3\u5411\u5de6\u627e\u9996\u4e2a\u5c0f\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        while (i &lt; j and nums[i] &lt;= nums[left]) i += 1; // \u4ece\u5de6\u5411\u53f3\u627e\u9996\u4e2a\u5927\u4e8e\u57fa\u51c6\u6570\u7684\u5143\u7d20\n        swap(nums, i, j);   // \u4ea4\u6362\u8fd9\u4e24\u4e2a\u5143\u7d20\n    }\n    swap(nums, i, left);    // \u5c06\u57fa\u51c6\u6570\u4ea4\u6362\u81f3\u4e24\u5b50\u6570\u7ec4\u7684\u5206\u754c\u7ebf\n    return i;               // \u8fd4\u56de\u57fa\u51c6\u6570\u7684\u7d22\u5f15\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/quick_sort/#1155-tail-recursion-optimization","title":"11.5.5 \u00a0 Tail recursion optimization","text":"<p>Under certain inputs, quick sort may occupy more space. For a completely ordered input array, assume the sub-array length in recursion is \\(m\\), each round of pivot partitioning produces a left sub-array of length \\(0\\) and a right sub-array of length \\(m - 1\\), meaning the problem size reduced per recursive call is very small (only one element), and the height of the recursion tree can reach \\(n - 1\\), requiring \\(O(n)\\) stack frame space.</p> <p>To prevent the accumulation of stack frame space, we can compare the lengths of the two sub-arrays after each round of pivot sorting, and only recursively sort the shorter sub-array. Since the length of the shorter sub-array will not exceed \\(n / 2\\), this method ensures that the recursion depth does not exceed \\(\\log n\\), thus optimizing the worst space complexity to \\(O(\\log n)\\). The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig quick_sort.py<pre><code>def quick_sort(self, nums: list[int], left: int, right: int):\n    \"\"\"\u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09\"\"\"\n    # \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while left &lt; right:\n        # \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        pivot = self.partition(nums, left, right)\n        # \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if pivot - left &lt; right - pivot:\n            self.quick_sort(nums, left, pivot - 1)  # \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1  # \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        else:\n            self.quick_sort(nums, pivot + 1, right)  # \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1  # \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n</code></pre> quick_sort.cpp<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nvoid quickSort(vector&lt;int&gt; &amp;nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        int pivot = partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            quickSort(nums, left, pivot - 1); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1;                 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1;                 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.java<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nvoid quickSort(int[] nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        int pivot = partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            quickSort(nums, left, pivot - 1); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.cs<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nvoid QuickSort(int[] nums, int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        int pivot = Partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            QuickSort(nums, left, pivot - 1);  // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1;  // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            QuickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.go<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09*/\nfunc (q *quickSortTailCall) quickSort(nums []int, left, right int) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    for left &lt; right {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        pivot := q.partition(nums, left, right)\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if pivot-left &lt; right-pivot {\n            q.quickSort(nums, left, pivot-1) // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1                 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            q.quickSort(nums, pivot+1, right) // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1                 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.swift<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nfunc quickSortTailCall(nums: inout [Int], left: Int, right: Int) {\n    var left = left\n    var right = right\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while left &lt; right {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        let pivot = partition(nums: &amp;nums, left: left, right: right)\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left) &lt; (right - pivot) {\n            quickSortTailCall(nums: &amp;nums, left: left, right: pivot - 1) // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            quickSortTailCall(nums: &amp;nums, left: pivot + 1, right: right) // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.js<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nquickSort(nums, left, right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        let pivot = this.partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            this.quickSort(nums, left, pivot - 1); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            this.quickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.ts<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nquickSort(nums: number[], left: number, right: number): void {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        let pivot = this.partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            this.quickSort(nums, left, pivot - 1); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            this.quickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.dart<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nvoid quickSort(List&lt;int&gt; nums, int left, int right) {\n  // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n  while (left &lt; right) {\n    // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n    int pivot = _partition(nums, left, right);\n    // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n    if (pivot - left &lt; right - pivot) {\n      quickSort(nums, left, pivot - 1); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n      left = pivot + 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n    } else {\n      quickSort(nums, pivot + 1, right); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n      right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n    }\n  }\n}\n</code></pre> quick_sort.rs<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\npub fn quick_sort(mut left: i32, mut right: i32, nums: &amp;mut [i32]) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while left &lt; right {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        let pivot = Self::partition(nums, left as usize, right as usize) as i32;\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if pivot - left &lt; right - pivot {\n            Self::quick_sort(left, pivot - 1, nums); // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            Self::quick_sort(pivot + 1, right, nums); // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1; // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.c<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nvoid quickSortTailCall(int nums[], int left, int right) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        int pivot = partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            quickSortTailCall(nums, left, pivot - 1);\n            // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n            left = pivot + 1;\n        } else {\n            // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            quickSortTailCall(nums, pivot + 1, right);\n            // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n            right = pivot - 1;\n        }\n    }\n}\n</code></pre> quick_sort.kt<pre><code>/* \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09 */\nfun quickSortTailCall(nums: IntArray, left: Int, right: Int) {\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\n    var l = left\n    var r = right\n    while (l &lt; r) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        val pivot = partition(nums, l, r)\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - l &lt; r - pivot) {\n            quickSort(nums, l, pivot - 1) // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            l = pivot + 1 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, r) // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            r = pivot - 1 // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> quick_sort.rb<pre><code>[class]{QuickSortTailCall}-[func]{quick_sort}\n</code></pre> quick_sort.zig<pre><code>// \u5feb\u901f\u6392\u5e8f\uff08\u5c3e\u9012\u5f52\u4f18\u5316\uff09\nfn quickSort(nums: []i32, left_: usize, right_: usize) void {\n    var left = left_;\n    var right = right_;\n    // \u5b50\u6570\u7ec4\u957f\u5ea6\u4e3a 1 \u65f6\u7ec8\u6b62\u9012\u5f52\n    while (left &lt; right) {\n        // \u54e8\u5175\u5212\u5206\u64cd\u4f5c\n        var pivot = partition(nums, left, right);\n        // \u5bf9\u4e24\u4e2a\u5b50\u6570\u7ec4\u4e2d\u8f83\u77ed\u7684\u90a3\u4e2a\u6267\u884c\u5feb\u901f\u6392\u5e8f\n        if (pivot - left &lt; right - pivot) {\n            quickSort(nums, left, pivot - 1);   // \u9012\u5f52\u6392\u5e8f\u5de6\u5b50\u6570\u7ec4\n            left = pivot + 1;                   // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [pivot + 1, right]\n        } else {\n            quickSort(nums, pivot + 1, right);  // \u9012\u5f52\u6392\u5e8f\u53f3\u5b50\u6570\u7ec4\n            right = pivot - 1;                  // \u5269\u4f59\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [left, pivot - 1]\n        }\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/radix_sort/","title":"11.10 \u00a0 Radix sort","text":"<p>The previous section introduced counting sort, which is suitable for scenarios where the data volume \\(n\\) is large but the data range \\(m\\) is small. Suppose we need to sort \\(n = 10^6\\) student IDs, where each ID is an \\(8\\)-digit number. This means the data range \\(m = 10^8\\) is very large, requiring a significant amount of memory space for counting sort, while radix sort can avoid this situation.</p> <p>Radix sort shares the core idea with counting sort, which also sorts by counting the frequency of elements. Building on this, radix sort utilizes the progressive relationship between the digits of numbers, sorting each digit in turn to achieve the final sorted order.</p>"},{"location":"chapter_sorting/radix_sort/#11101-algorithm-process","title":"11.10.1 \u00a0 Algorithm process","text":"<p>Taking the student ID data as an example, assuming the least significant digit is the \\(1^{st}\\) and the most significant is the \\(8^{th}\\), the radix sort process is illustrated in the following diagram.</p> <ol> <li>Initialize digit \\(k = 1\\).</li> <li>Perform \"counting sort\" on the \\(k^{th}\\) digit of the student IDs. After completion, the data will be sorted from smallest to largest based on the \\(k^{th}\\) digit.</li> <li>Increment \\(k\\) by \\(1\\), then return to step <code>2.</code> and continue iterating until all digits have been sorted, then the process ends.</li> </ol> <p></p> <p> Figure 11-18 \u00a0 Radix sort algorithm process </p> <p>Below we dissect the code implementation. For a number \\(x\\) in base \\(d\\), to obtain its \\(k^{th}\\) digit \\(x_k\\), the following calculation formula can be used:</p> \\[ x_k = \\lfloor\\frac{x}{d^{k-1}}\\rfloor \\bmod d \\] <p>Where \\(\\lfloor a \\rfloor\\) denotes rounding down the floating point number \\(a\\), and \\(\\bmod \\: d\\) denotes taking the modulus of \\(d\\). For student ID data, \\(d = 10\\) and \\(k \\in [1, 8]\\).</p> <p>Additionally, we need to slightly modify the counting sort code to allow sorting based on the \\(k^{th}\\) digit:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig radix_sort.py<pre><code>def digit(num: int, exp: int) -&gt; int:\n    \"\"\"\u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1)\"\"\"\n    # \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num // exp) % 10\n\ndef counting_sort_digit(nums: list[int], exp: int):\n    \"\"\"\u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09\"\"\"\n    # \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    counter = [0] * 10\n    n = len(nums)\n    # \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for i in range(n):\n        d = digit(nums[i], exp)  # \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d] += 1  # \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    # \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for i in range(1, 10):\n        counter[i] += counter[i - 1]\n    # \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        d = digit(nums[i], exp)\n        j = counter[d] - 1  # \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]  # \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d] -= 1  # \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    # \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in range(n):\n        nums[i] = res[i]\n\ndef radix_sort(nums: list[int]):\n    \"\"\"\u57fa\u6570\u6392\u5e8f\"\"\"\n    # \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    m = max(nums)\n    # \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    exp = 1\n    while exp &lt;= m:\n        # \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        # k = 1 -&gt; exp = 1\n        # k = 2 -&gt; exp = 10\n        # \u5373 exp = 10^(k-1)\n        counting_sort_digit(nums, exp)\n        exp *= 10\n</code></pre> radix_sort.cpp<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nvoid countingSortDigit(vector&lt;int&gt; &amp;nums, int exp) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    vector&lt;int&gt; counter(10, 0);\n    int n = nums.size();\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (int i = 0; i &lt; n; i++) {\n        int d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++;                // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    vector&lt;int&gt; res(n, 0);\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i];       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--;           // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; n; i++)\n        nums[i] = res[i];\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nvoid radixSort(vector&lt;int&gt; &amp;nums) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    int m = *max_element(nums.begin(), nums.end());\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (int exp = 1; exp &lt;= m; exp *= 10)\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n}\n</code></pre> radix_sort.java<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nvoid countingSortDigit(int[] nums, int exp) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    int[] counter = new int[10];\n    int n = nums.length;\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (int i = 0; i &lt; n; i++) {\n        int d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++;                // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i];       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--;           // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; n; i++)\n        nums[i] = res[i];\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nvoid radixSort(int[] nums) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    int m = Integer.MIN_VALUE;\n    for (int num : nums)\n        if (num &gt; m)\n            m = num;\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (int exp = 1; exp &lt;= m; exp *= 10) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.cs<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nint Digit(int num, int exp) {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nvoid CountingSortDigit(int[] nums, int exp) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    int[] counter = new int[10];\n    int n = nums.Length;\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (int i = 0; i &lt; n; i++) {\n        int d = Digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++;                // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    int[] res = new int[n];\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int d = Digit(nums[i], exp);\n        int j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i];       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--;           // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nvoid RadixSort(int[] nums) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    int m = int.MinValue;\n    foreach (int num in nums) {\n        if (num &gt; m) m = num;\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (int exp = 1; exp &lt;= m; exp *= 10) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        CountingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.go<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfunc digit(num, exp int) int {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfunc countingSortDigit(nums []int, exp int) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    counter := make([]int, 10)\n    n := len(nums)\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for i := 0; i &lt; n; i++ {\n        d := digit(nums[i], exp) // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++             // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for i := 1; i &lt; 10; i++ {\n        counter[i] += counter[i-1]\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    res := make([]int, n)\n    for i := n - 1; i &gt;= 0; i-- {\n        d := digit(nums[i], exp)\n        j := counter[d] - 1 // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]    // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--        // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i := 0; i &lt; n; i++ {\n        nums[i] = res[i]\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfunc radixSort(nums []int) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    max := math.MinInt\n    for _, num := range nums {\n        if num &gt; max {\n            max = num\n        }\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for exp := 1; max &gt;= exp; exp *= 10 {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp)\n    }\n}\n</code></pre> radix_sort.swift<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfunc digit(num: Int, exp: Int) -&gt; Int {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    (num / exp) % 10\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfunc countingSortDigit(nums: inout [Int], exp: Int) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    var counter = Array(repeating: 0, count: 10)\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for i in nums.indices {\n        let d = digit(num: nums[i], exp: exp) // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d] += 1 // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for i in 1 ..&lt; 10 {\n        counter[i] += counter[i - 1]\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    var res = Array(repeating: 0, count: nums.count)\n    for i in nums.indices.reversed() {\n        let d = digit(num: nums[i], exp: exp)\n        let j = counter[d] - 1 // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i] // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d] -= 1 // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in nums.indices {\n        nums[i] = res[i]\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfunc radixSort(nums: inout [Int]) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    var m = Int.min\n    for num in nums {\n        if num &gt; m {\n            m = num\n        }\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for exp in sequence(first: 1, next: { m &gt;= ($0 * 10) ? $0 * 10 : nil }) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums: &amp;nums, exp: exp)\n    }\n}\n</code></pre> radix_sort.js<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfunction digit(num, exp) {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return Math.floor(num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfunction countingSortDigit(nums, exp) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    const counter = new Array(10).fill(0);\n    const n = nums.length;\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (let i = 0; i &lt; n; i++) {\n        const d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++; // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (let i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    const res = new Array(n).fill(0);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const d = digit(nums[i], exp);\n        const j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]; // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--; // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfunction radixSort(nums) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    let m = Number.MIN_VALUE;\n    for (const num of nums) {\n        if (num &gt; m) {\n            m = num;\n        }\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (let exp = 1; exp &lt;= m; exp *= 10) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.ts<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfunction digit(num: number, exp: number): number {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return Math.floor(num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfunction countingSortDigit(nums: number[], exp: number): void {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    const counter = new Array(10).fill(0);\n    const n = nums.length;\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (let i = 0; i &lt; n; i++) {\n        const d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++; // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (let i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    const res = new Array(n).fill(0);\n    for (let i = n - 1; i &gt;= 0; i--) {\n        const d = digit(nums[i], exp);\n        const j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]; // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--; // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (let i = 0; i &lt; n; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfunction radixSort(nums: number[]): void {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    let m = Number.MIN_VALUE;\n    for (const num of nums) {\n        if (num &gt; m) {\n            m = num;\n        }\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (let exp = 1; exp &lt;= m; exp *= 10) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp);\n    }\n}\n</code></pre> radix_sort.dart<pre><code>/* \u83b7\u53d6\u5143\u7d20 _num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nint digit(int _num, int exp) {\n  // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n  return (_num ~/ exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nvoid countingSortDigit(List&lt;int&gt; nums, int exp) {\n  // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n  List&lt;int&gt; counter = List&lt;int&gt;.filled(10, 0);\n  int n = nums.length;\n  // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n  for (int i = 0; i &lt; n; i++) {\n    int d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n    counter[d]++; // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n  }\n  // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n  for (int i = 1; i &lt; 10; i++) {\n    counter[i] += counter[i - 1];\n  }\n  // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n  List&lt;int&gt; res = List&lt;int&gt;.filled(n, 0);\n  for (int i = n - 1; i &gt;= 0; i--) {\n    int d = digit(nums[i], exp);\n    int j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n    res[j] = nums[i]; // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n    counter[d]--; // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n  }\n  // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n  for (int i = 0; i &lt; n; i++) nums[i] = res[i];\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nvoid radixSort(List&lt;int&gt; nums) {\n  // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n  // dart \u4e2d int \u7684\u957f\u5ea6\u662f 64 \u4f4d\u7684\n  int m = -1 &lt;&lt; 63;\n  for (int _num in nums) if (_num &gt; m) m = _num;\n  // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n  for (int exp = 1; exp &lt;= m; exp *= 10)\n    // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n    // k = 1 -&gt; exp = 1\n    // k = 2 -&gt; exp = 10\n    // \u5373 exp = 10^(k-1)\n    countingSortDigit(nums, exp);\n}\n</code></pre> radix_sort.rs<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfn digit(num: i32, exp: i32) -&gt; usize {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return ((num / exp) % 10) as usize;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfn counting_sort_digit(nums: &amp;mut [i32], exp: i32) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    let mut counter = [0; 10];\n    let n = nums.len();\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for i in 0..n {\n        let d = digit(nums[i], exp); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d] += 1; // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for i in 1..10 {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    let mut res = vec![0; n];\n    for i in (0..n).rev() {\n        let d = digit(nums[i], exp);\n        let j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]; // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d] -= 1; // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for i in 0..n {\n        nums[i] = res[i];\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfn radix_sort(nums: &amp;mut [i32]) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    let m = *nums.into_iter().max().unwrap();\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    let mut exp = 1;\n    while exp &lt;= m {\n        counting_sort_digit(nums, exp);\n        exp *= 10;\n    }\n}\n</code></pre> radix_sort.c<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nint digit(int num, int exp) {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10;\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nvoid countingSortDigit(int nums[], int size, int exp) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    int *counter = (int *)malloc((sizeof(int) * 10));\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (int i = 0; i &lt; size; i++) {\n        // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        int d = digit(nums[i], exp);\n        // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n        counter[d]++;\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (int i = 1; i &lt; 10; i++) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    int *res = (int *)malloc(sizeof(int) * size);\n    for (int i = size - 1; i &gt;= 0; i--) {\n        int d = digit(nums[i], exp);\n        int j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i];       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--;           // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (int i = 0; i &lt; size; i++) {\n        nums[i] = res[i];\n    }\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nvoid radixSort(int nums[], int size) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    int max = INT32_MIN;\n    for (size_t i = 0; i &lt; size - 1; i++) {\n        if (nums[i] &gt; max) {\n            max = nums[i];\n        }\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    for (int exp = 1; max &gt;= exp; exp *= 10)\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, size, exp);\n}\n</code></pre> radix_sort.kt<pre><code>/* \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1) */\nfun digit(num: Int, exp: Int): Int {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return (num / exp) % 10\n}\n\n/* \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09 */\nfun countingSortDigit(nums: IntArray, exp: Int) {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    val counter = IntArray(10)\n    val n = nums.size\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (i in 0..&lt;n) {\n        val d = digit(nums[i], exp) // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d]++                // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    for (i in 1..9) {\n        counter[i] += counter[i - 1]\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    val res = IntArray(n)\n    for (i in n - 1 downTo 0) {\n        val d = digit(nums[i], exp)\n        val j = counter[d] - 1 // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i]       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d]--           // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    for (i in 0..&lt;n)\n        nums[i] = res[i]\n}\n\n/* \u57fa\u6570\u6392\u5e8f */\nfun radixSort(nums: IntArray) {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    var m = Int.MIN_VALUE\n    for (num in nums) if (num &gt; m) m = num\n    var exp = 1\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    while (exp &lt;= m) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        countingSortDigit(nums, exp)\n        exp *= 10\n    }\n}\n</code></pre> radix_sort.rb<pre><code>[class]{}-[func]{digit}\n\n[class]{}-[func]{counting_sort_digit}\n\n[class]{}-[func]{radix_sort}\n</code></pre> radix_sort.zig<pre><code>// \u83b7\u53d6\u5143\u7d20 num \u7684\u7b2c k \u4f4d\uff0c\u5176\u4e2d exp = 10^(k-1)\nfn digit(num: i32, exp: i32) i32 {\n    // \u4f20\u5165 exp \u800c\u975e k \u53ef\u4ee5\u907f\u514d\u5728\u6b64\u91cd\u590d\u6267\u884c\u6602\u8d35\u7684\u6b21\u65b9\u8ba1\u7b97\n    return @mod(@divFloor(num, exp), 10);\n}\n\n// \u8ba1\u6570\u6392\u5e8f\uff08\u6839\u636e nums \u7b2c k \u4f4d\u6392\u5e8f\uff09\nfn countingSortDigit(nums: []i32, exp: i32) !void {\n    // \u5341\u8fdb\u5236\u7684\u4f4d\u8303\u56f4\u4e3a 0~9 \uff0c\u56e0\u6b64\u9700\u8981\u957f\u5ea6\u4e3a 10 \u7684\u6876\u6570\u7ec4\n    var mem_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    // defer mem_arena.deinit();\n    const mem_allocator = mem_arena.allocator();\n    var counter = try mem_allocator.alloc(usize, 10);\n    @memset(counter, 0);\n    var n = nums.len;\n    // \u7edf\u8ba1 0~9 \u5404\u6570\u5b57\u7684\u51fa\u73b0\u6b21\u6570\n    for (nums) |num| {\n        var d: u32 = @bitCast(digit(num, exp)); // \u83b7\u53d6 nums[i] \u7b2c k \u4f4d\uff0c\u8bb0\u4e3a d\n        counter[d] += 1; // \u7edf\u8ba1\u6570\u5b57 d \u7684\u51fa\u73b0\u6b21\u6570\n    }\n    // \u6c42\u524d\u7f00\u548c\uff0c\u5c06\u201c\u51fa\u73b0\u4e2a\u6570\u201d\u8f6c\u6362\u4e3a\u201c\u6570\u7ec4\u7d22\u5f15\u201d\n    var i: usize = 1;\n    while (i &lt; 10) : (i += 1) {\n        counter[i] += counter[i - 1];\n    }\n    // \u5012\u5e8f\u904d\u5386\uff0c\u6839\u636e\u6876\u5185\u7edf\u8ba1\u7ed3\u679c\uff0c\u5c06\u5404\u5143\u7d20\u586b\u5165 res\n    var res = try mem_allocator.alloc(i32, n);\n    i = n - 1;\n    while (i &gt;= 0) : (i -= 1) {\n        var d: u32 = @bitCast(digit(nums[i], exp));\n        var j = counter[d] - 1; // \u83b7\u53d6 d \u5728\u6570\u7ec4\u4e2d\u7684\u7d22\u5f15 j\n        res[j] = nums[i];       // \u5c06\u5f53\u524d\u5143\u7d20\u586b\u5165\u7d22\u5f15 j\n        counter[d] -= 1;        // \u5c06 d \u7684\u6570\u91cf\u51cf 1\n        if (i == 0) break;\n    }\n    // \u4f7f\u7528\u7ed3\u679c\u8986\u76d6\u539f\u6570\u7ec4 nums\n    i = 0;\n    while (i &lt; n) : (i += 1) {\n        nums[i] = res[i];\n    }\n}\n\n// \u57fa\u6570\u6392\u5e8f\nfn radixSort(nums: []i32) !void {\n    // \u83b7\u53d6\u6570\u7ec4\u7684\u6700\u5927\u5143\u7d20\uff0c\u7528\u4e8e\u5224\u65ad\u6700\u5927\u4f4d\u6570\n    var m: i32 = std.math.minInt(i32);\n    for (nums) |num| {\n        if (num &gt; m) m = num;\n    }\n    // \u6309\u7167\u4ece\u4f4e\u4f4d\u5230\u9ad8\u4f4d\u7684\u987a\u5e8f\u904d\u5386\n    var exp: i32 = 1;\n    while (exp &lt;= m) : (exp *= 10) {\n        // \u5bf9\u6570\u7ec4\u5143\u7d20\u7684\u7b2c k \u4f4d\u6267\u884c\u8ba1\u6570\u6392\u5e8f\n        // k = 1 -&gt; exp = 1\n        // k = 2 -&gt; exp = 10\n        // \u5373 exp = 10^(k-1)\n        try countingSortDigit(nums, exp);    \n    }\n} \n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Why start sorting from the least significant digit?</p> <p>In consecutive sorting rounds, the result of a later round will override the result of an earlier round. For example, if the result of the first round is \\(a &lt; b\\) and the result of the second round is \\(a &gt; b\\), the result of the second round will replace the first round's result. Since the significance of higher digits is greater than that of lower digits, it makes sense to sort lower digits before higher digits.</p>"},{"location":"chapter_sorting/radix_sort/#11102-algorithm-characteristics","title":"11.10.2 \u00a0 Algorithm characteristics","text":"<p>Compared to counting sort, radix sort is suitable for larger numerical ranges, but it assumes that the data can be represented in a fixed number of digits, and the number of digits should not be too large. For example, floating-point numbers are not suitable for radix sort, as their digit count \\(k\\) may be large, potentially leading to a time complexity \\(O(nk) \\gg O(n^2)\\).</p> <ul> <li>Time complexity is \\(O(nk)\\), non-adaptive sorting: Assuming the data size is \\(n\\), the data is in base \\(d\\), and the maximum number of digits is \\(k\\), then sorting a single digit takes \\(O(n + d)\\) time, and sorting all \\(k\\) digits takes \\(O((n + d)k)\\) time. Generally, both \\(d\\) and \\(k\\) are relatively small, leading to a time complexity approaching \\(O(n)\\).</li> <li>Space complexity is \\(O(n + d)\\), non-in-place sorting: Like counting sort, radix sort relies on arrays <code>res</code> and <code>counter</code> of lengths \\(n\\) and \\(d\\) respectively.</li> <li>Stable sorting: When counting sort is stable, radix sort is also stable; if counting sort is unstable, radix sort cannot guarantee a correct sorting outcome.</li> </ul>"},{"location":"chapter_sorting/selection_sort/","title":"11.2 \u00a0 Selection sort","text":"<p>Selection sort works on a very simple principle: it starts a loop where each iteration selects the smallest element from the unsorted interval and moves it to the end of the sorted interval.</p> <p>Suppose the length of the array is \\(n\\), the algorithm flow of selection sort is as shown in Figure 11-2.</p> <ol> <li>Initially, all elements are unsorted, i.e., the unsorted (index) interval is \\([0, n-1]\\).</li> <li>Select the smallest element in the interval \\([0, n-1]\\) and swap it with the element at index \\(0\\). After this, the first element of the array is sorted.</li> <li>Select the smallest element in the interval \\([1, n-1]\\) and swap it with the element at index \\(1\\). After this, the first two elements of the array are sorted.</li> <li>Continue in this manner. After \\(n - 1\\) rounds of selection and swapping, the first \\(n - 1\\) elements are sorted.</li> <li>The only remaining element is necessarily the largest element and does not need sorting, thus the array is sorted.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 11-2 \u00a0 Selection sort process </p> <p>In the code, we use \\(k\\) to record the smallest element within the unsorted interval:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig selection_sort.py<pre><code>def selection_sort(nums: list[int]):\n    \"\"\"\u9009\u62e9\u6392\u5e8f\"\"\"\n    n = len(nums)\n    # \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for i in range(n - 1):\n        # \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        k = i\n        for j in range(i + 1, n):\n            if nums[j] &lt; nums[k]:\n                k = j  # \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        # \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        nums[i], nums[k] = nums[k], nums[i]\n</code></pre> selection_sort.cpp<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nvoid selectionSort(vector&lt;int&gt; &amp;nums) {\n    int n = nums.size();\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        swap(nums[i], nums[k]);\n    }\n}\n</code></pre> selection_sort.java<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nvoid selectionSort(int[] nums) {\n    int n = nums.length;\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n}\n</code></pre> selection_sort.cs<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nvoid SelectionSort(int[] nums) {\n    int n = nums.Length;\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        (nums[k], nums[i]) = (nums[i], nums[k]);\n    }\n}\n</code></pre> selection_sort.go<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfunc selectionSort(nums []int) {\n    n := len(nums)\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for i := 0; i &lt; n-1; i++ {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        k := i\n        for j := i + 1; j &lt; n; j++ {\n            if nums[j] &lt; nums[k] {\n                // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n                k = j\n            }\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        nums[i], nums[k] = nums[k], nums[i]\n\n    }\n}\n</code></pre> selection_sort.swift<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfunc selectionSort(nums: inout [Int]) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for i in nums.indices.dropLast() {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        var k = i\n        for j in nums.indices.dropFirst(i + 1) {\n            if nums[j] &lt; nums[k] {\n                k = j // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n            }\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        nums.swapAt(i, k)\n    }\n}\n</code></pre> selection_sort.js<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfunction selectionSort(nums) {\n    let n = nums.length;\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (let i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        let k = i;\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k]) {\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n            }\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        [nums[i], nums[k]] = [nums[k], nums[i]];\n    }\n}\n</code></pre> selection_sort.ts<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfunction selectionSort(nums: number[]): void {\n    let n = nums.length;\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (let i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        let k = i;\n        for (let j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k]) {\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n            }\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        [nums[i], nums[k]] = [nums[k], nums[i]];\n    }\n}\n</code></pre> selection_sort.dart<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nvoid selectionSort(List&lt;int&gt; nums) {\n  int n = nums.length;\n  // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n  for (int i = 0; i &lt; n - 1; i++) {\n    // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n    int k = i;\n    for (int j = i + 1; j &lt; n; j++) {\n      if (nums[j] &lt; nums[k]) k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n    }\n    // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n    int temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n  }\n}\n</code></pre> selection_sort.rs<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfn selection_sort(nums: &amp;mut [i32]) {\n    if nums.is_empty() {\n        return;\n    }\n    let n = nums.len();\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for i in 0..n - 1 {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        let mut k = i;\n        for j in i + 1..n {\n            if nums[j] &lt; nums[k] {\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n            }\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        nums.swap(i, k);\n    }\n}\n</code></pre> selection_sort.c<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nvoid selectionSort(int nums[], int n) {\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (int i = 0; i &lt; n - 1; i++) {\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        int k = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (nums[j] &lt; nums[k])\n                k = j; // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        int temp = nums[i];\n        nums[i] = nums[k];\n        nums[k] = temp;\n    }\n}\n</code></pre> selection_sort.kt<pre><code>/* \u9009\u62e9\u6392\u5e8f */\nfun selectionSort(nums: IntArray) {\n    val n = nums.size\n    // \u5916\u5faa\u73af\uff1a\u672a\u6392\u5e8f\u533a\u95f4\u4e3a [i, n-1]\n    for (i in 0..&lt;n - 1) {\n        var k = i\n        // \u5185\u5faa\u73af\uff1a\u627e\u5230\u672a\u6392\u5e8f\u533a\u95f4\u5185\u7684\u6700\u5c0f\u5143\u7d20\n        for (j in i + 1..&lt;n) {\n            if (nums[j] &lt; nums[k])\n                k = j // \u8bb0\u5f55\u6700\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n        }\n        // \u5c06\u8be5\u6700\u5c0f\u5143\u7d20\u4e0e\u672a\u6392\u5e8f\u533a\u95f4\u7684\u9996\u4e2a\u5143\u7d20\u4ea4\u6362\n        val temp = nums[i]\n        nums[i] = nums[k]\n        nums[k] = temp\n    }\n}\n</code></pre> selection_sort.rb<pre><code>[class]{}-[func]{selection_sort}\n</code></pre> selection_sort.zig<pre><code>[class]{}-[func]{selectionSort}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_sorting/selection_sort/#1121-algorithm-characteristics","title":"11.2.1 \u00a0 Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), non-adaptive sort: There are \\(n - 1\\) rounds in the outer loop, with the unsorted interval length starting at \\(n\\) in the first round and decreasing to \\(2\\) in the last round, i.e., the outer loops contain \\(n\\), \\(n - 1\\), \\(\\dots\\), \\(3\\), \\(2\\) inner loops respectively, summing up to \\(\\frac{(n - 1)(n + 2)}{2}\\).</li> <li>Space complexity of \\(O(1)\\), in-place sort: Uses constant extra space with pointers \\(i\\) and \\(j\\).</li> <li>Non-stable sort: As shown in Figure 11-3, an element <code>nums[i]</code> may be swapped to the right of an equal element, causing their relative order to change.</li> </ul> <p> Figure 11-3 \u00a0 Selection sort instability example </p>"},{"location":"chapter_sorting/sorting_algorithm/","title":"11.1 \u00a0 Sorting algorithms","text":"<p>Sorting algorithms (sorting algorithm) are used to arrange a set of data in a specific order. Sorting algorithms have a wide range of applications because ordered data can usually be searched, analyzed, and processed more efficiently.</p> <p>As shown in Figure 11-1, the data types in sorting algorithms can be integers, floating point numbers, characters, or strings, etc. Sorting rules can be set according to needs, such as numerical size, character ASCII order, or custom rules.</p> <p></p> <p> Figure 11-1 \u00a0 Data types and comparator examples </p>"},{"location":"chapter_sorting/sorting_algorithm/#1111-evaluation-dimensions","title":"11.1.1 \u00a0 Evaluation dimensions","text":"<p>Execution efficiency: We expect the time complexity of sorting algorithms to be as low as possible, with a lower number of overall operations (reduction in the constant factor of time complexity). For large data volumes, execution efficiency is particularly important.</p> <p>In-place property: As the name implies, in-place sorting is achieved by directly manipulating the original array, without the need for additional auxiliary arrays, thus saving memory. Generally, in-place sorting involves fewer data movement operations and is faster.</p> <p>Stability: Stable sorting ensures that the relative order of equal elements in the array does not change after sorting.</p> <p>Stable sorting is a necessary condition for multi-level sorting scenarios. Suppose we have a table storing student information, with the first and second columns being name and age, respectively. In this case, unstable sorting might lead to a loss of orderedness in the input data:</p> <pre><code># Input data is sorted by name\n# (name, age)\n  ('A', 19)\n  ('B', 18)\n  ('C', 21)\n  ('D', 19)\n  ('E', 23)\n\n# Assuming an unstable sorting algorithm is used to sort the list by age,\n# the result changes the relative position of ('D', 19) and ('A', 19),\n# and the property of the input data being sorted by name is lost\n  ('B', 18)\n  ('D', 19)\n  ('A', 19)\n  ('C', 21)\n  ('E', 23)\n</code></pre> <p>Adaptability: Adaptive sorting has a time complexity that depends on the input data, i.e., the best time complexity, worst time complexity, and average time complexity are not exactly equal.</p> <p>Adaptability needs to be assessed according to the specific situation. If the worst time complexity is worse than the average, it suggests that the performance of the sorting algorithm might deteriorate under certain data, hence it is seen as a negative attribute; whereas, if the best time complexity is better than the average, it is considered a positive attribute.</p> <p>Comparison-based: Comparison-based sorting relies on comparison operators (\\(&lt;\\), \\(=\\), \\(&gt;\\)) to determine the relative order of elements and thus sort the entire array, with the theoretical optimal time complexity being \\(O(n \\log n)\\). Meanwhile, non-comparison sorting does not use comparison operators and can achieve a time complexity of \\(O(n)\\), but its versatility is relatively poor.</p>"},{"location":"chapter_sorting/sorting_algorithm/#1112-ideal-sorting-algorithm","title":"11.1.2 \u00a0 Ideal sorting algorithm","text":"<p>Fast execution, in-place, stable, positively adaptive, and versatile. Clearly, no sorting algorithm that combines all these features has been found to date. Therefore, when selecting a sorting algorithm, it is necessary to decide based on the specific characteristics of the data and the requirements of the problem.</p> <p>Next, we will learn about various sorting algorithms together and analyze the advantages and disadvantages of each based on the above evaluation dimensions.</p>"},{"location":"chapter_sorting/summary/","title":"11.11 \u00a0 Summary","text":""},{"location":"chapter_sorting/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>Bubble sort works by swapping adjacent elements. By adding a flag to enable early return, we can optimize the best-case time complexity of bubble sort to \\(O(n)\\).</li> <li>Insertion sort sorts each round by inserting elements from the unsorted interval into the correct position in the sorted interval. Although the time complexity of insertion sort is \\(O(n^2)\\), it is very popular in sorting small amounts of data due to relatively fewer operations per unit.</li> <li>Quick sort is based on sentinel partitioning operations. In sentinel partitioning, it's possible to always pick the worst pivot, leading to a time complexity degradation to \\(O(n^2)\\). Introducing median or random pivots can reduce the probability of such degradation. Tail recursion can effectively reduce the recursion depth, optimizing the space complexity to \\(O(\\log n)\\).</li> <li>Merge sort includes dividing and merging two phases, typically embodying the divide-and-conquer strategy. In merge sort, sorting an array requires creating auxiliary arrays, resulting in a space complexity of \\(O(n)\\); however, the space complexity for sorting a list can be optimized to \\(O(1)\\).</li> <li>Bucket sort consists of three steps: data bucketing, sorting within buckets, and merging results. It also embodies the divide-and-conquer strategy, suitable for very large datasets. The key to bucket sort is the even distribution of data.</li> <li>Counting sort is a special case of bucket sort, which sorts by counting the occurrences of each data point. Counting sort is suitable for large datasets with a limited range of data and requires that data can be converted to positive integers.</li> <li>Radix sort sorts data by sorting digit by digit, requiring data to be represented as fixed-length numbers.</li> <li>Overall, we hope to find a sorting algorithm that has high efficiency, stability, in-place operation, and positive adaptability. However, like other data structures and algorithms, no sorting algorithm can meet all these conditions simultaneously. In practical applications, we need to choose the appropriate sorting algorithm based on the characteristics of the data.</li> <li>Figure 11-19 compares mainstream sorting algorithms in terms of efficiency, stability, in-place nature, and adaptability.</li> </ul> <p> Figure 11-19 \u00a0 Sorting Algorithm Comparison </p>"},{"location":"chapter_sorting/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: When is the stability of sorting algorithms necessary?</p> <p>In reality, we might sort based on one attribute of an object. For example, students have names and heights as attributes, and we aim to implement multi-level sorting: first by name to get <code>(A, 180) (B, 185) (C, 170) (D, 170)</code>; then by height. Because the sorting algorithm is unstable, we might end up with <code>(D, 170) (C, 170) (A, 180) (B, 185)</code>.</p> <p>It can be seen that the positions of students D and C have been swapped, disrupting the orderliness of the names, which is undesirable.</p> <p>Q: Can the order of \"searching from right to left\" and \"searching from left to right\" in sentinel partitioning be swapped?</p> <p>No, when using the leftmost element as the pivot, we must first \"search from right to left\" then \"search from left to right\". This conclusion is somewhat counterintuitive, so let's analyze the reason.</p> <p>The last step of the sentinel partition <code>partition()</code> is to swap <code>nums[left]</code> and <code>nums[i]</code>. After the swap, the elements to the left of the pivot are all <code>&lt;=</code> the pivot, which requires that <code>nums[left] &gt;= nums[i]</code> must hold before the last swap. Suppose we \"search from left to right\" first, then if no element larger than the pivot is found, we will exit the loop when <code>i == j</code>, possibly with <code>nums[j] == nums[i] &gt; nums[left]</code>. In other words, the final swap operation will exchange an element larger than the pivot to the left end of the array, causing the sentinel partition to fail.</p> <p>For example, given the array <code>[0, 0, 0, 0, 1]</code>, if we first \"search from left to right\", the array after the sentinel partition is <code>[1, 0, 0, 0, 0]</code>, which is incorrect.</p> <p>Upon further consideration, if we choose <code>nums[right]</code> as the pivot, then exactly the opposite, we must first \"search from left to right\".</p> <p>Q: Regarding tail recursion optimization, why does choosing the shorter array ensure that the recursion depth does not exceed \\(\\log n\\)?</p> <p>The recursion depth is the number of currently unreturned recursive methods. Each round of sentinel partition divides the original array into two subarrays. With tail recursion optimization, the length of the subarray to be recursively followed is at most half of the original array length. Assuming the worst case always halves the length, the final recursion depth will be \\(\\log n\\).</p> <p>Reviewing the original quicksort, we might continuously recursively process larger arrays, in the worst case from \\(n\\), \\(n - 1\\), ..., \\(2\\), \\(1\\), with a recursion depth of \\(n\\). Tail recursion optimization can avoid this scenario.</p> <p>Q: When all elements in the array are equal, is the time complexity of quicksort \\(O(n^2)\\)? How should this degenerate case be handled?</p> <p>Yes. For this situation, consider using sentinel partitioning to divide the array into three parts: less than, equal to, and greater than the pivot. Only recursively proceed with the less than and greater than parts. In this method, an array where all input elements are equal can be sorted in just one round of sentinel partitioning.</p> <p>Q: Why is the worst-case time complexity of bucket sort \\(O(n^2)\\)?</p> <p>In the worst case, all elements are placed in the same bucket. If we use an \\(O(n^2)\\) algorithm to sort these elements, the time complexity will be \\(O(n^2)\\).</p>"},{"location":"chapter_stack_and_queue/","title":"Chapter 5. \u00a0 Stack and queue","text":"<p>Abstract</p> <p>A stack is like cats placed on top of each other, while a queue is like cats lined up one by one.</p> <p>They represent the logical relationships of Last-In-First-Out (LIFO) and First-In-First-Out (FIFO), respectively.</p>"},{"location":"chapter_stack_and_queue/#chapter-contents","title":"Chapter contents","text":"<ul> <li>5.1 \u00a0 Stack</li> <li>5.2 \u00a0 Queue</li> <li>5.3 \u00a0 Double-ended queue</li> <li>5.4 \u00a0 Summary</li> </ul>"},{"location":"chapter_stack_and_queue/deque/","title":"5.3 \u00a0 Double-ended queue","text":"<p>In a queue, we can only delete elements from the head or add elements to the tail. As shown in the following diagram, a double-ended queue (deque) offers more flexibility, allowing the addition or removal of elements at both the head and the tail.</p> <p></p> <p> Figure 5-7 \u00a0 Operations in double-ended queue </p>"},{"location":"chapter_stack_and_queue/deque/#531-common-operations-in-double-ended-queue","title":"5.3.1 \u00a0 Common operations in double-ended queue","text":"<p>The common operations in a double-ended queue are listed below, and the names of specific methods depend on the programming language used.</p> <p> Table 5-3 \u00a0 Efficiency of double-ended queue operations </p> Method Name Description Time Complexity <code>pushFirst()</code> Add an element to the head \\(O(1)\\) <code>pushLast()</code> Add an element to the tail \\(O(1)\\) <code>popFirst()</code> Remove the first element \\(O(1)\\) <code>popLast()</code> Remove the last element \\(O(1)\\) <code>peekFirst()</code> Access the first element \\(O(1)\\) <code>peekLast()</code> Access the last element \\(O(1)\\) <p>Similarly, we can directly use the double-ended queue classes implemented in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig deque.py<pre><code>from collections import deque\n\n# Initialize the deque\ndeq: deque[int] = deque()\n\n# Enqueue elements\ndeq.append(2)      # Add to the tail\ndeq.append(5)\ndeq.append(4)\ndeq.appendleft(3)  # Add to the head\ndeq.appendleft(1)\n\n# Access elements\nfront: int = deq[0]  # The first element\nrear: int = deq[-1]  # The last element\n\n# Dequeue elements\npop_front: int = deq.popleft()  # The first element dequeued\npop_rear: int = deq.pop()       # The last element dequeued\n\n# Get the length of the deque\nsize: int = len(deq)\n\n# Check if the deque is empty\nis_empty: bool = len(deq) == 0\n</code></pre> deque.cpp<pre><code>/* Initialize the deque */\ndeque&lt;int&gt; deque;\n\n/* Enqueue elements */\ndeque.push_back(2);   // Add to the tail\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3);  // Add to the head\ndeque.push_front(1);\n\n/* Access elements */\nint front = deque.front(); // The first element\nint back = deque.back();   // The last element\n\n/* Dequeue elements */\ndeque.pop_front();  // The first element dequeued\ndeque.pop_back();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.size();\n\n/* Check if the deque is empty */\nbool empty = deque.empty();\n</code></pre> deque.java<pre><code>/* Initialize the deque */\nDeque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\ndeque.offerLast(2);   // Add to the tail\ndeque.offerLast(5);\ndeque.offerLast(4);\ndeque.offerFirst(3);  // Add to the head\ndeque.offerFirst(1);\n\n/* Access elements */\nint peekFirst = deque.peekFirst();  // The first element\nint peekLast = deque.peekLast();    // The last element\n\n/* Dequeue elements */\nint popFirst = deque.pollFirst();  // The first element dequeued\nint popLast = deque.pollLast();    // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.size();\n\n/* Check if the deque is empty */\nboolean isEmpty = deque.isEmpty();\n</code></pre> deque.cs<pre><code>/* Initialize the deque */\n// In C#, LinkedList is used as a deque\nLinkedList&lt;int&gt; deque = new();\n\n/* Enqueue elements */\ndeque.AddLast(2);   // Add to the tail\ndeque.AddLast(5);\ndeque.AddLast(4);\ndeque.AddFirst(3);  // Add to the head\ndeque.AddFirst(1);\n\n/* Access elements */\nint peekFirst = deque.First.Value;  // The first element\nint peekLast = deque.Last.Value;    // The last element\n\n/* Dequeue elements */\ndeque.RemoveFirst();  // The first element dequeued\ndeque.RemoveLast();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.Count;\n\n/* Check if the deque is empty */\nbool isEmpty = deque.Count == 0;\n</code></pre> deque_test.go<pre><code>/* Initialize the deque */\n// In Go, use list as a deque\ndeque := list.New()\n\n/* Enqueue elements */\ndeque.PushBack(2)      // Add to the tail\ndeque.PushBack(5)\ndeque.PushBack(4)\ndeque.PushFront(3)     // Add to the head\ndeque.PushFront(1)\n\n/* Access elements */\nfront := deque.Front() // The first element\nrear := deque.Back()   // The last element\n\n/* Dequeue elements */\ndeque.Remove(front)    // The first element dequeued\ndeque.Remove(rear)     // The last element dequeued\n\n/* Get the length of the deque */\nsize := deque.Len()\n\n/* Check if the deque is empty */\nisEmpty := deque.Len() == 0\n</code></pre> deque.swift<pre><code>/* Initialize the deque */\n// Swift does not have a built-in deque class, so Array can be used as a deque\nvar deque: [Int] = []\n\n/* Enqueue elements */\ndeque.append(2) // Add to the tail\ndeque.append(5)\ndeque.append(4)\ndeque.insert(3, at: 0) // Add to the head\ndeque.insert(1, at: 0)\n\n/* Access elements */\nlet peekFirst = deque.first! // The first element\nlet peekLast = deque.last!   // The last element\n\n/* Dequeue elements */\n// Using Array, popFirst has a complexity of O(n)\nlet popFirst = deque.removeFirst() // The first element dequeued\nlet popLast = deque.removeLast()   // The last element dequeued\n\n/* Get the length of the deque */\nlet size = deque.count\n\n/* Check if the deque is empty */\nlet isEmpty = deque.isEmpty\n</code></pre> deque.js<pre><code>/* Initialize the deque */\n// JavaScript does not have a built-in deque, so Array is used as a deque\nconst deque = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Note that unshift() has a time complexity of O(n) as it's an array\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst = deque[0]; // The first element\nconst peekLast = deque[deque.length - 1]; // The last element\n\n/* Dequeue elements */\n// Note that shift() has a time complexity of O(n) as it's an array\nconst popFront = deque.shift(); // The first element dequeued\nconst popBack = deque.pop();    // The last element dequeued\n\n/* Get the length of the deque */\nconst size = deque.length;\n\n/* Check if the deque is empty */\nconst isEmpty = size === 0;\n</code></pre> deque.ts<pre><code>/* Initialize the deque */\n// TypeScript does not have a built-in deque, so Array is used as a deque\nconst deque: number[] = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Note that unshift() has a time complexity of O(n) as it's an array\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst: number = deque[0]; // The first element\nconst peekLast: number = deque[deque.length - 1]; // The last element\n\n/* Dequeue elements */\n// Note that shift() has a time complexity of O(n) as it's an array\nconst popFront: number = deque.shift() as number; // The first element dequeued\nconst popBack: number = deque.pop() as number;    // The last element dequeued\n\n/* Get the length of the deque */\nconst size: number = deque.length;\n\n/* Check if the deque is empty */\nconst isEmpty: boolean = size === 0;\n</code></pre> deque.dart<pre><code>/* Initialize the deque */\n// In Dart, Queue is defined as a deque\nQueue&lt;int&gt; deque = Queue&lt;int&gt;();\n\n/* Enqueue elements */\ndeque.addLast(2);  // Add to the tail\ndeque.addLast(5);\ndeque.addLast(4);\ndeque.addFirst(3); // Add to the head\ndeque.addFirst(1);\n\n/* Access elements */\nint peekFirst = deque.first; // The first element\nint peekLast = deque.last;   // The last element\n\n/* Dequeue elements */\nint popFirst = deque.removeFirst(); // The first element dequeued\nint popLast = deque.removeLast();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.length;\n\n/* Check if the deque is empty */\nbool isEmpty = deque.isEmpty;\n</code></pre> deque.rs<pre><code>/* Initialize the deque */\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(2);  // Add to the tail\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3); // Add to the head\ndeque.push_front(1);\n\n/* Access elements */\nif let Some(front) = deque.front() { // The first element\n}\nif let Some(rear) = deque.back() {   // The last element\n}\n\n/* Dequeue elements */\nif let Some(pop_front) = deque.pop_front() { // The first element dequeued\n}\nif let Some(pop_rear) = deque.pop_back() {   // The last element dequeued\n}\n\n/* Get the length of the deque */\nlet size = deque.len();\n\n/* Check if the deque is empty */\nlet is_empty = deque.is_empty();\n</code></pre> deque.c<pre><code>// C does not provide a built-in deque\n</code></pre> deque.kt<pre><code>\n</code></pre> deque.zig<pre><code>\n</code></pre> Visualizing Code <p>https://pythontutor.com/render.html#code=from%20collections%20import%20deque%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%0A%20%20%20%20deq%20%3D%20deque%28%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F%0A%20%20%20%20deq.append%282%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%98%9F%E5%B0%BE%0A%20%20%20%20deq.append%285%29%0A%20%20%20%20deq.append%284%29%0A%20%20%20%20deq.appendleft%283%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%98%9F%E9%A6%96%0A%20%20%20%20deq.appendleft%281%29%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%20deque%20%3D%22,%20deq%29%0A%0A%20%20%20%20%23%20%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%0A%20%20%20%20front%20%3D%20deq%5B0%5D%20%20%23%20%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%20front%20%3D%22,%20front%29%0A%20%20%20%20rear%20%3D%20deq%5B-1%5D%20%20%23%20%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%20rear%20%3D%22,%20rear%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20pop_front%20%3D%20deq.popleft%28%29%20%20%23%20%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%87%BA%E9%98%9F%E5%85%83%E7%B4%A0%20%20pop_front%20%3D%22,%20pop_front%29%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%87%BA%E9%98%9F%E5%90%8E%20deque%20%3D%22,%20deq%29%0A%20%20%20%20pop_rear%20%3D%20deq.pop%28%29%20%20%23%20%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%87%BA%E9%98%9F%E5%85%83%E7%B4%A0%20%20pop_rear%20%3D%22,%20pop_rear%29%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%87%BA%E9%98%9F%E5%90%8E%20deque%20%3D%22,%20deq%29%0A%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%0A%20%20%20%20size%20%3D%20len%28deq%29%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%20size%20%3D%22,%20size%29%0A%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20len%28deq%29%20%3D%3D%200%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%20%3D%22,%20is_empty%29&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_stack_and_queue/deque/#532-implementing-a-double-ended-queue","title":"5.3.2 \u00a0 Implementing a double-ended queue *","text":"<p>The implementation of a double-ended queue is similar to that of a regular queue, it can be based on either a linked list or an array as the underlying data structure.</p>"},{"location":"chapter_stack_and_queue/deque/#1-implementation-based-on-doubly-linked-list","title":"1. \u00a0 Implementation based on doubly linked list","text":"<p>Recall from the previous section that we used a regular singly linked list to implement a queue, as it conveniently allows for deleting from the head (corresponding to the dequeue operation) and adding new elements after the tail (corresponding to the enqueue operation).</p> <p>For a double-ended queue, both the head and the tail can perform enqueue and dequeue operations. In other words, a double-ended queue needs to implement operations in the opposite direction as well. For this, we use a \"doubly linked list\" as the underlying data structure of the double-ended queue.</p> <p>As shown in Figure 5-8, we treat the head and tail nodes of the doubly linked list as the front and rear of the double-ended queue, respectively, and implement the functionality to add and remove nodes at both ends.</p> LinkedListDequepushLast()pushFirst()popLast()popFirst() <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 5-8 \u00a0 Implementing Double-Ended Queue with Doubly Linked List for Enqueue and Dequeue Operations </p> <p>The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linkedlist_deque.py<pre><code>class ListNode:\n    \"\"\"\u53cc\u5411\u94fe\u8868\u8282\u70b9\"\"\"\n\n    def __init__(self, val: int):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self.val: int = val\n        self.next: ListNode | None = None  # \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n        self.prev: ListNode | None = None  # \u524d\u9a71\u8282\u70b9\u5f15\u7528\n\nclass LinkedListDeque:\n    \"\"\"\u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._front: ListNode | None = None  # \u5934\u8282\u70b9 front\n        self._rear: ListNode | None = None  # \u5c3e\u8282\u70b9 rear\n        self._size: int = 0  # \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self._size == 0\n\n    def push(self, num: int, is_front: bool):\n        \"\"\"\u5165\u961f\u64cd\u4f5c\"\"\"\n        node = ListNode(num)\n        # \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if self.is_empty():\n            self._front = self._rear = node\n        # \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        elif is_front:\n            # \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            self._front.prev = node\n            node.next = self._front\n            self._front = node  # \u66f4\u65b0\u5934\u8282\u70b9\n        # \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        else:\n            # \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            self._rear.next = node\n            node.prev = self._rear\n            self._rear = node  # \u66f4\u65b0\u5c3e\u8282\u70b9\n        self._size += 1  # \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n\n    def push_first(self, num: int):\n        \"\"\"\u961f\u9996\u5165\u961f\"\"\"\n        self.push(num, True)\n\n    def push_last(self, num: int):\n        \"\"\"\u961f\u5c3e\u5165\u961f\"\"\"\n        self.push(num, False)\n\n    def pop(self, is_front: bool) -&gt; int:\n        \"\"\"\u51fa\u961f\u64cd\u4f5c\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        # \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if is_front:\n            val: int = self._front.val  # \u6682\u5b58\u5934\u8282\u70b9\u503c\n            # \u5220\u9664\u5934\u8282\u70b9\n            fnext: ListNode | None = self._front.next\n            if fnext != None:\n                fnext.prev = None\n                self._front.next = None\n            self._front = fnext  # \u66f4\u65b0\u5934\u8282\u70b9\n        # \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        else:\n            val: int = self._rear.val  # \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            # \u5220\u9664\u5c3e\u8282\u70b9\n            rprev: ListNode | None = self._rear.prev\n            if rprev != None:\n                rprev.next = None\n                self._rear.prev = None\n            self._rear = rprev  # \u66f4\u65b0\u5c3e\u8282\u70b9\n        self._size -= 1  # \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return val\n\n    def pop_first(self) -&gt; int:\n        \"\"\"\u961f\u9996\u51fa\u961f\"\"\"\n        return self.pop(True)\n\n    def pop_last(self) -&gt; int:\n        \"\"\"\u961f\u5c3e\u51fa\u961f\"\"\"\n        return self.pop(False)\n\n    def peek_first(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u9996\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        return self._front.val\n\n    def peek_last(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u5c3e\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        return self._rear.val\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370\"\"\"\n        node = self._front\n        res = [0] * self.size()\n        for i in range(self.size()):\n            res[i] = node.val\n            node = node.next\n        return res\n</code></pre> linkedlist_deque.cpp<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nstruct DoublyListNode {\n    int val;              // \u8282\u70b9\u503c\n    DoublyListNode *next; // \u540e\u7ee7\u8282\u70b9\u6307\u9488\n    DoublyListNode *prev; // \u524d\u9a71\u8282\u70b9\u6307\u9488\n    DoublyListNode(int val) : val(val), prev(nullptr), next(nullptr) {\n    }\n};\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n  private:\n    DoublyListNode *front, *rear; // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    int queSize = 0;              // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    LinkedListDeque() : front(nullptr), rear(nullptr) {\n    }\n\n    /* \u6790\u6784\u65b9\u6cd5 */\n    ~LinkedListDeque() {\n        // \u904d\u5386\u94fe\u8868\u5220\u9664\u8282\u70b9\uff0c\u91ca\u653e\u5185\u5b58\n        DoublyListNode *pre, *cur = front;\n        while (cur != nullptr) {\n            pre = cur;\n            cur = cur-&gt;next;\n            delete pre;\n        }\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    void push(int num, bool isFront) {\n        DoublyListNode *node = new DoublyListNode(num);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (isEmpty())\n            front = rear = node;\n        // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        else if (isFront) {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            front-&gt;prev = node;\n            node-&gt;next = front;\n            front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n        // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            rear-&gt;next = node;\n            node-&gt;prev = rear;\n            rear = node; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize++; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    int pop(bool isFront) {\n        if (isEmpty())\n            throw out_of_range(\"\u961f\u5217\u4e3a\u7a7a\");\n        int val;\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if (isFront) {\n            val = front-&gt;val; // \u6682\u5b58\u5934\u8282\u70b9\u503c\n            // \u5220\u9664\u5934\u8282\u70b9\n            DoublyListNode *fNext = front-&gt;next;\n            if (fNext != nullptr) {\n                fNext-&gt;prev = nullptr;\n                front-&gt;next = nullptr;\n            }\n            delete front;\n            front = fNext; // \u66f4\u65b0\u5934\u8282\u70b9\n        // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        } else {\n            val = rear-&gt;val; // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            // \u5220\u9664\u5c3e\u8282\u70b9\n            DoublyListNode *rPrev = rear-&gt;prev;\n            if (rPrev != nullptr) {\n                rPrev-&gt;next = nullptr;\n                rear-&gt;prev = nullptr;\n            }\n            delete rear;\n            rear = rPrev; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize--; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return val;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    int popFirst() {\n        return pop(true);\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    int popLast() {\n        return pop(false);\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n        return front-&gt;val;\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n        return rear-&gt;val;\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    vector&lt;int&gt; toVector() {\n        DoublyListNode *node = front;\n        vector&lt;int&gt; res(size());\n        for (int i = 0; i &lt; res.size(); i++) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_deque.java<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode {\n    int val; // \u8282\u70b9\u503c\n    ListNode next; // \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n    ListNode prev; // \u524d\u9a71\u8282\u70b9\u5f15\u7528\n\n    ListNode(int val) {\n        this.val = val;\n        prev = next = null;\n    }\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    private ListNode front, rear; // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    private int queSize = 0; // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    public LinkedListDeque() {\n        front = rear = null;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    public int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    private void push(int num, boolean isFront) {\n        ListNode node = new ListNode(num);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (isEmpty())\n            front = rear = node;\n        // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        else if (isFront) {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            front.prev = node;\n            node.next = front;\n            front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n        // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            rear.next = node;\n            node.prev = rear;\n            rear = node; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize++; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    public void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    public void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    private int pop(boolean isFront) {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        int val;\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if (isFront) {\n            val = front.val; // \u6682\u5b58\u5934\u8282\u70b9\u503c\n            // \u5220\u9664\u5934\u8282\u70b9\n            ListNode fNext = front.next;\n            if (fNext != null) {\n                fNext.prev = null;\n                front.next = null;\n            }\n            front = fNext; // \u66f4\u65b0\u5934\u8282\u70b9\n        // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        } else {\n            val = rear.val; // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            // \u5220\u9664\u5c3e\u8282\u70b9\n            ListNode rPrev = rear.prev;\n            if (rPrev != null) {\n                rPrev.next = null;\n                rear.prev = null;\n            }\n            rear = rPrev; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize--; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return val;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    public int popFirst() {\n        return pop(true);\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    public int popLast() {\n        return pop(false);\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int peekFirst() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return front.val;\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    public int peekLast() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return rear.val;\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    public int[] toArray() {\n        ListNode node = front;\n        int[] res = new int[size()];\n        for (int i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_deque.cs<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode(int val) {\n    public int val = val;       // \u8282\u70b9\u503c\n    public ListNode? next = null; // \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n    public ListNode? prev = null; // \u524d\u9a71\u8282\u70b9\u5f15\u7528\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    ListNode? front, rear; // \u5934\u8282\u70b9 front, \u5c3e\u8282\u70b9 rear\n    int queSize = 0;      // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    public LinkedListDeque() {\n        front = null;\n        rear = null;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    public int Size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    void Push(int num, bool isFront) {\n        ListNode node = new(num);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (IsEmpty()) {\n            front = node;\n            rear = node;\n        }\n        // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        else if (isFront) {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            front!.prev = node;\n            node.next = front;\n            front = node; // \u66f4\u65b0\u5934\u8282\u70b9                           \n        }\n        // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            rear!.next = node;\n            node.prev = rear;\n            rear = node;  // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n\n        queSize++; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    public void PushFirst(int num) {\n        Push(num, true);\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    public void PushLast(int num) {\n        Push(num, false);\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    int? Pop(bool isFront) {\n        if (IsEmpty())\n            throw new Exception();\n        int? val;\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if (isFront) {\n            val = front?.val; // \u6682\u5b58\u5934\u8282\u70b9\u503c\n            // \u5220\u9664\u5934\u8282\u70b9\n            ListNode? fNext = front?.next;\n            if (fNext != null) {\n                fNext.prev = null;\n                front!.next = null;\n            }\n            front = fNext;   // \u66f4\u65b0\u5934\u8282\u70b9\n        }\n        // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        else {\n            val = rear?.val;  // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            // \u5220\u9664\u5c3e\u8282\u70b9\n            ListNode? rPrev = rear?.prev;\n            if (rPrev != null) {\n                rPrev.next = null;\n                rear!.prev = null;\n            }\n            rear = rPrev;    // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n\n        queSize--; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return val;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    public int? PopFirst() {\n        return Pop(true);\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    public int? PopLast() {\n        return Pop(false);\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int? PeekFirst() {\n        if (IsEmpty())\n            throw new Exception();\n        return front?.val;\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    public int? PeekLast() {\n        if (IsEmpty())\n            throw new Exception();\n        return rear?.val;\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    public int?[] ToArray() {\n        ListNode? node = front;\n        int?[] res = new int?[Size()];\n        for (int i = 0; i &lt; res.Length; i++) {\n            res[i] = node?.val;\n            node = node?.next;\n        }\n\n        return res;\n    }\n}\n</code></pre> linkedlist_deque.go<pre><code>/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\ntype linkedListDeque struct {\n    // \u4f7f\u7528\u5185\u7f6e\u5305 list\n    data *list.List\n}\n\n/* \u521d\u59cb\u5316\u53cc\u7aef\u961f\u5217 */\nfunc newLinkedListDeque() *linkedListDeque {\n    return &amp;linkedListDeque{\n        data: list.New(),\n    }\n}\n\n/* \u961f\u9996\u5143\u7d20\u5165\u961f */\nfunc (s *linkedListDeque) pushFirst(value any) {\n    s.data.PushFront(value)\n}\n\n/* \u961f\u5c3e\u5143\u7d20\u5165\u961f */\nfunc (s *linkedListDeque) pushLast(value any) {\n    s.data.PushBack(value)\n}\n\n/* \u961f\u9996\u5143\u7d20\u51fa\u961f */\nfunc (s *linkedListDeque) popFirst() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* \u961f\u5c3e\u5143\u7d20\u51fa\u961f */\nfunc (s *linkedListDeque) popLast() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nfunc (s *linkedListDeque) peekFirst() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    return e.Value\n}\n\n/* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\nfunc (s *linkedListDeque) peekLast() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    return e.Value\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nfunc (s *linkedListDeque) size() int {\n    return s.data.Len()\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nfunc (s *linkedListDeque) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* \u83b7\u53d6 List \u7528\u4e8e\u6253\u5370 */\nfunc (s *linkedListDeque) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_deque.swift<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode {\n    var val: Int // \u8282\u70b9\u503c\n    var next: ListNode? // \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n    weak var prev: ListNode? // \u524d\u9a71\u8282\u70b9\u5f15\u7528\n\n    init(val: Int) {\n        self.val = val\n    }\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    private var front: ListNode? // \u5934\u8282\u70b9 front\n    private var rear: ListNode? // \u5c3e\u8282\u70b9 rear\n    private var _size: Int // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    init() {\n        _size = 0\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    private func push(num: Int, isFront: Bool) {\n        let node = ListNode(val: num)\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if isEmpty() {\n            front = node\n            rear = node\n        }\n        // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        else if isFront {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            front?.prev = node\n            node.next = front\n            front = node // \u66f4\u65b0\u5934\u8282\u70b9\n        }\n        // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            rear?.next = node\n            node.prev = rear\n            rear = node // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        _size += 1 // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    func pushFirst(num: Int) {\n        push(num: num, isFront: true)\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    func pushLast(num: Int) {\n        push(num: num, isFront: false)\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    private func pop(isFront: Bool) -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        }\n        let val: Int\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if isFront {\n            val = front!.val // \u6682\u5b58\u5934\u8282\u70b9\u503c\n            // \u5220\u9664\u5934\u8282\u70b9\n            let fNext = front?.next\n            if fNext != nil {\n                fNext?.prev = nil\n                front?.next = nil\n            }\n            front = fNext // \u66f4\u65b0\u5934\u8282\u70b9\n        }\n        // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        else {\n            val = rear!.val // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            // \u5220\u9664\u5c3e\u8282\u70b9\n            let rPrev = rear?.prev\n            if rPrev != nil {\n                rPrev?.next = nil\n                rear?.prev = nil\n            }\n            rear = rPrev // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        _size -= 1 // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return val\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    func popFirst() -&gt; Int {\n        pop(isFront: true)\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    func popLast() -&gt; Int {\n        pop(isFront: false)\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    func peekFirst() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        }\n        return front!.val\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    func peekLast() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        }\n        return rear!.val\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    func toArray() -&gt; [Int] {\n        var node = front\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_deque.js<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode {\n    prev; // \u524d\u9a71\u8282\u70b9\u5f15\u7528 (\u6307\u9488)\n    next; // \u540e\u7ee7\u8282\u70b9\u5f15\u7528 (\u6307\u9488)\n    val; // \u8282\u70b9\u503c\n\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    #front; // \u5934\u8282\u70b9 front\n    #rear; // \u5c3e\u8282\u70b9 rear\n    #queSize; // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    constructor() {\n        this.#front = null;\n        this.#rear = null;\n        this.#queSize = 0;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f\u64cd\u4f5c */\n    pushLast(val) {\n        const node = new ListNode(val);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (this.#queSize === 0) {\n            this.#front = node;\n            this.#rear = node;\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            this.#rear.next = node;\n            node.prev = this.#rear;\n            this.#rear = node; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        this.#queSize++;\n    }\n\n    /* \u961f\u9996\u5165\u961f\u64cd\u4f5c */\n    pushFirst(val) {\n        const node = new ListNode(val);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (this.#queSize === 0) {\n            this.#front = node;\n            this.#rear = node;\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            this.#front.prev = node;\n            node.next = this.#front;\n            this.#front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n        }\n        this.#queSize++;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c */\n    popLast() {\n        if (this.#queSize === 0) {\n            return null;\n        }\n        const value = this.#rear.val; // \u5b58\u50a8\u5c3e\u8282\u70b9\u503c\n        // \u5220\u9664\u5c3e\u8282\u70b9\n        let temp = this.#rear.prev;\n        if (temp !== null) {\n            temp.next = null;\n            this.#rear.prev = null;\n        }\n        this.#rear = temp; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        this.#queSize--;\n        return value;\n    }\n\n    /* \u961f\u9996\u51fa\u961f\u64cd\u4f5c */\n    popFirst() {\n        if (this.#queSize === 0) {\n            return null;\n        }\n        const value = this.#front.val; // \u5b58\u50a8\u5c3e\u8282\u70b9\u503c\n        // \u5220\u9664\u5934\u8282\u70b9\n        let temp = this.#front.next;\n        if (temp !== null) {\n            temp.prev = null;\n            this.#front.next = null;\n        }\n        this.#front = temp; // \u66f4\u65b0\u5934\u8282\u70b9\n        this.#queSize--;\n        return value;\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    peekLast() {\n        return this.#queSize === 0 ? null : this.#rear.val;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peekFirst() {\n        return this.#queSize === 0 ? null : this.#front.val;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    size() {\n        return this.#queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* \u6253\u5370\u53cc\u5411\u961f\u5217 */\n    print() {\n        const arr = [];\n        let temp = this.#front;\n        while (temp !== null) {\n            arr.push(temp.val);\n            temp = temp.next;\n        }\n        console.log('[' + arr.join(', ') + ']');\n    }\n}\n</code></pre> linkedlist_deque.ts<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode {\n    prev: ListNode; // \u524d\u9a71\u8282\u70b9\u5f15\u7528 (\u6307\u9488)\n    next: ListNode; // \u540e\u7ee7\u8282\u70b9\u5f15\u7528 (\u6307\u9488)\n    val: number; // \u8282\u70b9\u503c\n\n    constructor(val: number) {\n        this.val = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    private front: ListNode; // \u5934\u8282\u70b9 front\n    private rear: ListNode; // \u5c3e\u8282\u70b9 rear\n    private queSize: number; // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    constructor() {\n        this.front = null;\n        this.rear = null;\n        this.queSize = 0;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f\u64cd\u4f5c */\n    pushLast(val: number): void {\n        const node: ListNode = new ListNode(val);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (this.queSize === 0) {\n            this.front = node;\n            this.rear = node;\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            this.rear.next = node;\n            node.prev = this.rear;\n            this.rear = node; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        this.queSize++;\n    }\n\n    /* \u961f\u9996\u5165\u961f\u64cd\u4f5c */\n    pushFirst(val: number): void {\n        const node: ListNode = new ListNode(val);\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (this.queSize === 0) {\n            this.front = node;\n            this.rear = node;\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            this.front.prev = node;\n            node.next = this.front;\n            this.front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n        }\n        this.queSize++;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c */\n    popLast(): number {\n        if (this.queSize === 0) {\n            return null;\n        }\n        const value: number = this.rear.val; // \u5b58\u50a8\u5c3e\u8282\u70b9\u503c\n        // \u5220\u9664\u5c3e\u8282\u70b9\n        let temp: ListNode = this.rear.prev;\n        if (temp !== null) {\n            temp.next = null;\n            this.rear.prev = null;\n        }\n        this.rear = temp; // \u66f4\u65b0\u5c3e\u8282\u70b9\n        this.queSize--;\n        return value;\n    }\n\n    /* \u961f\u9996\u51fa\u961f\u64cd\u4f5c */\n    popFirst(): number {\n        if (this.queSize === 0) {\n            return null;\n        }\n        const value: number = this.front.val; // \u5b58\u50a8\u5c3e\u8282\u70b9\u503c\n        // \u5220\u9664\u5934\u8282\u70b9\n        let temp: ListNode = this.front.next;\n        if (temp !== null) {\n            temp.prev = null;\n            this.front.next = null;\n        }\n        this.front = temp; // \u66f4\u65b0\u5934\u8282\u70b9\n        this.queSize--;\n        return value;\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    peekLast(): number {\n        return this.queSize === 0 ? null : this.rear.val;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peekFirst(): number {\n        return this.queSize === 0 ? null : this.front.val;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    size(): number {\n        return this.queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* \u6253\u5370\u53cc\u5411\u961f\u5217 */\n    print(): void {\n        const arr: number[] = [];\n        let temp: ListNode = this.front;\n        while (temp !== null) {\n            arr.push(temp.val);\n            temp = temp.next;\n        }\n        console.log('[' + arr.join(', ') + ']');\n    }\n}\n</code></pre> linkedlist_deque.dart<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode {\n  int val; // \u8282\u70b9\u503c\n  ListNode? next; // \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n  ListNode? prev; // \u524d\u9a71\u8282\u70b9\u5f15\u7528\n\n  ListNode(this.val, {this.next, this.prev});\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u5bf9\u5217 */\nclass LinkedListDeque {\n  late ListNode? _front; // \u5934\u8282\u70b9 _front\n  late ListNode? _rear; // \u5c3e\u8282\u70b9 _rear\n  int _queSize = 0; // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n  LinkedListDeque() {\n    this._front = null;\n    this._rear = null;\n  }\n\n  /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u957f\u5ea6 */\n  int size() {\n    return this._queSize;\n  }\n\n  /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return size() == 0;\n  }\n\n  /* \u5165\u961f\u64cd\u4f5c */\n  void push(int _num, bool isFront) {\n    final ListNode node = ListNode(_num);\n    if (isEmpty()) {\n      // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 _front \u548c _rear \u90fd\u6307\u5411 node\n      _front = _rear = node;\n    } else if (isFront) {\n      // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n      // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n      _front!.prev = node;\n      node.next = _front;\n      _front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n    } else {\n      // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n      // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n      _rear!.next = node;\n      node.prev = _rear;\n      _rear = node; // \u66f4\u65b0\u5c3e\u8282\u70b9\n    }\n    _queSize++; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n  }\n\n  /* \u961f\u9996\u5165\u961f */\n  void pushFirst(int _num) {\n    push(_num, true);\n  }\n\n  /* \u961f\u5c3e\u5165\u961f */\n  void pushLast(int _num) {\n    push(_num, false);\n  }\n\n  /* \u51fa\u961f\u64cd\u4f5c */\n  int? pop(bool isFront) {\n    // \u82e5\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u8fd4\u56de null\n    if (isEmpty()) {\n      return null;\n    }\n    final int val;\n    if (isFront) {\n      // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n      val = _front!.val; // \u6682\u5b58\u5934\u8282\u70b9\u503c\n      // \u5220\u9664\u5934\u8282\u70b9\n      ListNode? fNext = _front!.next;\n      if (fNext != null) {\n        fNext.prev = null;\n        _front!.next = null;\n      }\n      _front = fNext; // \u66f4\u65b0\u5934\u8282\u70b9\n    } else {\n      // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n      val = _rear!.val; // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n      // \u5220\u9664\u5c3e\u8282\u70b9\n      ListNode? rPrev = _rear!.prev;\n      if (rPrev != null) {\n        rPrev.next = null;\n        _rear!.prev = null;\n      }\n      _rear = rPrev; // \u66f4\u65b0\u5c3e\u8282\u70b9\n    }\n    _queSize--; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    return val;\n  }\n\n  /* \u961f\u9996\u51fa\u961f */\n  int? popFirst() {\n    return pop(true);\n  }\n\n  /* \u961f\u5c3e\u51fa\u961f */\n  int? popLast() {\n    return pop(false);\n  }\n\n  /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n  int? peekFirst() {\n    return _front?.val;\n  }\n\n  /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n  int? peekLast() {\n    return _rear?.val;\n  }\n\n  /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n  List&lt;int&gt; toArray() {\n    ListNode? node = _front;\n    final List&lt;int&gt; res = [];\n    for (int i = 0; i &lt; _queSize; i++) {\n      res.add(node!.val);\n      node = node.next;\n    }\n    return res;\n  }\n}\n</code></pre> linkedlist_deque.rs<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\npub struct ListNode&lt;T&gt; {\n    pub val: T,                                 // \u8282\u70b9\u503c\n    pub next: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // \u540e\u7ee7\u8282\u70b9\u6307\u9488\n    pub prev: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // \u524d\u9a71\u8282\u70b9\u6307\u9488\n}\n\nimpl&lt;T&gt; ListNode&lt;T&gt; {\n    pub fn new(val: T) -&gt; Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt; {\n        Rc::new(RefCell::new(ListNode {\n            val,\n            next: None,\n            prev: None,\n        }))\n    }\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\n#[allow(dead_code)]\npub struct LinkedListDeque&lt;T&gt; {\n    front: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // \u5934\u8282\u70b9 front\n    rear: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;,  // \u5c3e\u8282\u70b9 rear\n    que_size: usize,                         // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n}\n\nimpl&lt;T: Copy&gt; LinkedListDeque&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            front: None,\n            rear: None,\n            que_size: 0,\n        }\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.que_size;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.size() == 0;\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    pub fn push(&amp;mut self, num: T, is_front: bool) {\n        let node = ListNode::new(num);\n        // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        if is_front {\n            match self.front.take() {\n                // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n                None =&gt; {\n                    self.rear = Some(node.clone());\n                    self.front = Some(node);\n                }\n                // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n                Some(old_front) =&gt; {\n                    old_front.borrow_mut().prev = Some(node.clone());\n                    node.borrow_mut().next = Some(old_front);\n                    self.front = Some(node); // \u66f4\u65b0\u5934\u8282\u70b9\n                }\n            }\n        }\n        // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        else {\n            match self.rear.take() {\n                // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n                None =&gt; {\n                    self.front = Some(node.clone());\n                    self.rear = Some(node);\n                }\n                // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n                Some(old_rear) =&gt; {\n                    old_rear.borrow_mut().next = Some(node.clone());\n                    node.borrow_mut().prev = Some(old_rear);\n                    self.rear = Some(node); // \u66f4\u65b0\u5c3e\u8282\u70b9\n                }\n            }\n        }\n        self.que_size += 1; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    pub fn push_first(&amp;mut self, num: T) {\n        self.push(num, true);\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    pub fn push_last(&amp;mut self, num: T) {\n        self.push(num, false);\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    pub fn pop(&amp;mut self, is_front: bool) -&gt; Option&lt;T&gt; {\n        // \u82e5\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u8fd4\u56de None\n        if self.is_empty() {\n            return None;\n        };\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if is_front {\n            self.front.take().map(|old_front| {\n                match old_front.borrow_mut().next.take() {\n                    Some(new_front) =&gt; {\n                        new_front.borrow_mut().prev.take();\n                        self.front = Some(new_front); // \u66f4\u65b0\u5934\u8282\u70b9\n                    }\n                    None =&gt; {\n                        self.rear.take();\n                    }\n                }\n                self.que_size -= 1; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n                Rc::try_unwrap(old_front).ok().unwrap().into_inner().val\n            })\n        }\n        // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        else {\n            self.rear.take().map(|old_rear| {\n                match old_rear.borrow_mut().prev.take() {\n                    Some(new_rear) =&gt; {\n                        new_rear.borrow_mut().next.take();\n                        self.rear = Some(new_rear); // \u66f4\u65b0\u5c3e\u8282\u70b9\n                    }\n                    None =&gt; {\n                        self.front.take();\n                    }\n                }\n                self.que_size -= 1; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n                Rc::try_unwrap(old_rear).ok().unwrap().into_inner().val\n            })\n        }\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    pub fn pop_first(&amp;mut self) -&gt; Option&lt;T&gt; {\n        return self.pop(true);\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    pub fn pop_last(&amp;mut self) -&gt; Option&lt;T&gt; {\n        return self.pop(false);\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    pub fn peek_first(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.front.as_ref()\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    pub fn peek_last(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.rear.as_ref()\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    pub fn to_array(&amp;self, head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n        if let Some(node) = head {\n            let mut nums = self.to_array(node.borrow().next.as_ref());\n            nums.insert(0, node.borrow().val);\n            return nums;\n        }\n        return Vec::new();\n    }\n}\n</code></pre> linkedlist_deque.c<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\ntypedef struct DoublyListNode {\n    int val;                     // \u8282\u70b9\u503c\n    struct DoublyListNode *next; // \u540e\u7ee7\u8282\u70b9\n    struct DoublyListNode *prev; // \u524d\u9a71\u8282\u70b9\n} DoublyListNode;\n\n/* \u6784\u9020\u51fd\u6570 */\nDoublyListNode *newDoublyListNode(int num) {\n    DoublyListNode *new = (DoublyListNode *)malloc(sizeof(DoublyListNode));\n    new-&gt;val = num;\n    new-&gt;next = NULL;\n    new-&gt;prev = NULL;\n    return new;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delDoublyListNode(DoublyListNode *node) {\n    free(node);\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\ntypedef struct {\n    DoublyListNode *front, *rear; // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    int queSize;                  // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n} LinkedListDeque;\n\n/* \u6784\u9020\u51fd\u6570 */\nLinkedListDeque *newLinkedListDeque() {\n    LinkedListDeque *deque = (LinkedListDeque *)malloc(sizeof(LinkedListDeque));\n    deque-&gt;front = NULL;\n    deque-&gt;rear = NULL;\n    deque-&gt;queSize = 0;\n    return deque;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delLinkedListdeque(LinkedListDeque *deque) {\n    // \u91ca\u653e\u6240\u6709\u8282\u70b9\n    for (int i = 0; i &lt; deque-&gt;queSize &amp;&amp; deque-&gt;front != NULL; i++) {\n        DoublyListNode *tmp = deque-&gt;front;\n        deque-&gt;front = deque-&gt;front-&gt;next;\n        free(tmp);\n    }\n    // \u91ca\u653e deque \u7ed3\u6784\u4f53\n    free(deque);\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nint size(LinkedListDeque *deque) {\n    return deque-&gt;queSize;\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nbool empty(LinkedListDeque *deque) {\n    return (size(deque) == 0);\n}\n\n/* \u5165\u961f */\nvoid push(LinkedListDeque *deque, int num, bool isFront) {\n    DoublyListNode *node = newDoublyListNode(num);\n    // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411node\n    if (empty(deque)) {\n        deque-&gt;front = deque-&gt;rear = node;\n    }\n    // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n    else if (isFront) {\n        // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n        deque-&gt;front-&gt;prev = node;\n        node-&gt;next = deque-&gt;front;\n        deque-&gt;front = node; // \u66f4\u65b0\u5934\u8282\u70b9\n    }\n    // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n    else {\n        // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n        deque-&gt;rear-&gt;next = node;\n        node-&gt;prev = deque-&gt;rear;\n        deque-&gt;rear = node;\n    }\n    deque-&gt;queSize++; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n}\n\n/* \u961f\u9996\u5165\u961f */\nvoid pushFirst(LinkedListDeque *deque, int num) {\n    push(deque, num, true);\n}\n\n/* \u961f\u5c3e\u5165\u961f */\nvoid pushLast(LinkedListDeque *deque, int num) {\n    push(deque, num, false);\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nint peekFirst(LinkedListDeque *deque) {\n    assert(size(deque) &amp;&amp; deque-&gt;front);\n    return deque-&gt;front-&gt;val;\n}\n\n/* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\nint peekLast(LinkedListDeque *deque) {\n    assert(size(deque) &amp;&amp; deque-&gt;rear);\n    return deque-&gt;rear-&gt;val;\n}\n\n/* \u51fa\u961f */\nint pop(LinkedListDeque *deque, bool isFront) {\n    if (empty(deque))\n        return -1;\n    int val;\n    // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n    if (isFront) {\n        val = peekFirst(deque); // \u6682\u5b58\u5934\u8282\u70b9\u503c\n        DoublyListNode *fNext = deque-&gt;front-&gt;next;\n        if (fNext) {\n            fNext-&gt;prev = NULL;\n            deque-&gt;front-&gt;next = NULL;\n        }\n        delDoublyListNode(deque-&gt;front);\n        deque-&gt;front = fNext; // \u66f4\u65b0\u5934\u8282\u70b9\n    }\n    // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n    else {\n        val = peekLast(deque); // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n        DoublyListNode *rPrev = deque-&gt;rear-&gt;prev;\n        if (rPrev) {\n            rPrev-&gt;next = NULL;\n            deque-&gt;rear-&gt;prev = NULL;\n        }\n        delDoublyListNode(deque-&gt;rear);\n        deque-&gt;rear = rPrev; // \u66f4\u65b0\u5c3e\u8282\u70b9\n    }\n    deque-&gt;queSize--; // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    return val;\n}\n\n/* \u961f\u9996\u51fa\u961f */\nint popFirst(LinkedListDeque *deque) {\n    return pop(deque, true);\n}\n\n/* \u961f\u5c3e\u51fa\u961f */\nint popLast(LinkedListDeque *deque) {\n    return pop(deque, false);\n}\n\n/* \u6253\u5370\u961f\u5217 */\nvoid printLinkedListDeque(LinkedListDeque *deque) {\n    int *arr = malloc(sizeof(int) * deque-&gt;queSize);\n    // \u62f7\u8d1d\u94fe\u8868\u4e2d\u7684\u6570\u636e\u5230\u6570\u7ec4\n    int i;\n    DoublyListNode *node;\n    for (i = 0, node = deque-&gt;front; i &lt; deque-&gt;queSize; i++) {\n        arr[i] = node-&gt;val;\n        node = node-&gt;next;\n    }\n    printArray(arr, deque-&gt;queSize);\n    free(arr);\n}\n</code></pre> linkedlist_deque.kt<pre><code>/* \u53cc\u5411\u94fe\u8868\u8282\u70b9 */\nclass ListNode(var _val: Int) {\n    // \u8282\u70b9\u503c\n    var next: ListNode? = null // \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n    var prev: ListNode? = null // \u524d\u9a71\u8282\u70b9\u5f15\u7528\n}\n\n/* \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass LinkedListDeque {\n    private var front: ListNode? = null // \u5934\u8282\u70b9 front\n    private var rear: ListNode? = null // \u5c3e\u8282\u70b9 rear\n    private var queSize: Int = 0 // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* \u5165\u961f\u64cd\u4f5c */\n    fun push(num: Int, isFront: Boolean) {\n        val node = ListNode(num)\n        // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n        if (isEmpty()) {\n            rear = node\n            front = rear\n            // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n        } else if (isFront) {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n            front?.prev = node\n            node.next = front\n            front = node // \u66f4\u65b0\u5934\u8282\u70b9\n            // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n        } else {\n            // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n            rear?.next = node\n            node.prev = rear\n            rear = node // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize++ // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    fun pushFirst(num: Int) {\n        push(num, true)\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    fun pushLast(num: Int) {\n        push(num, false)\n    }\n\n    /* \u51fa\u961f\u64cd\u4f5c */\n    fun pop(isFront: Boolean): Int {\n        if (isEmpty()) \n            throw IndexOutOfBoundsException()\n        val _val: Int\n        // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n        if (isFront) {\n            _val = front!!._val // \u6682\u5b58\u5934\u8282\u70b9\u503c\n            // \u5220\u9664\u5934\u8282\u70b9\n            val fNext = front!!.next\n            if (fNext != null) {\n                fNext.prev = null\n                front!!.next = null\n            }\n            front = fNext // \u66f4\u65b0\u5934\u8282\u70b9\n            // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n        } else {\n            _val = rear!!._val // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n            // \u5220\u9664\u5c3e\u8282\u70b9\n            val rPrev = rear!!.prev\n            if (rPrev != null) {\n                rPrev.next = null\n                rear!!.prev = null\n            }\n            rear = rPrev // \u66f4\u65b0\u5c3e\u8282\u70b9\n        }\n        queSize-- // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        return _val\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    fun popFirst(): Int {\n        return pop(true)\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    fun popLast(): Int {\n        return pop(false)\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fun peekFirst(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return front!!._val\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    fun peekLast(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return rear!!._val\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    fun toArray(): IntArray {\n        var node = front\n        val res = IntArray(size())\n        for (i in res.indices) {\n            res[i] = node!!._val\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_deque.rb<pre><code>=begin\nFile: linkedlist_deque.rb\nCreated Time: 2024-04-06\nAuthor: Xuan Khoa Tu Nguyen (ngxktuzkai2000@gmail.com)\n=end\n\n### \u53cc\u5411\u94fe\u8868\u8282\u70b9\nclass ListNode\n  attr_accessor :val\n  attr_accessor :next # \u540e\u7ee7\u8282\u70b9\u5f15\u7528\n  attr_accessor :prev # \u524d\u8eaf\u8282\u70b9\u5f15\u7528\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize(val)\n    @val = val\n  end\nend\n\n### \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 ###\nclass LinkedListDeque\n  ### \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 ###\n  attr_reader :size\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @front = nil  # \u5934\u8282\u70b9 front\n    @rear = nil   # \u5c3e\u8282\u70b9 rear\n    @size = 0     # \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n  end\n\n  ### \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### \u5165\u961f\u64cd\u4f5c ###\n  def push(num, is_front)\n    node = ListNode.new(num)\n    # \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c \u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n    if is_empty?\n      @front = @rear = node\n    # \u961f\u9996\u5165\u961f\u64cd\u4f5c\n    elsif is_front\n      # \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n      @front.prev = node\n      node.next = @front\n      @front = node # \u66f4\u65b0\u5934\u8282\u70b9\n    # \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n    else\n      # \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n      @rear.next = node\n      node.prev = @rear\n      @rear = node # \u66f4\u65b0\u5c3e\u8282\u70b9\n    end\n    @size += 1 # \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n  end\n\n  ### \u961f\u9996\u5165\u961f ###\n  def push_first(num)\n    push(num, true)\n  end\n\n  ### \u961f\u5c3e\u5165\u961f ###\n  def push_last(num)\n    push(num, false)\n  end\n\n  ### \u51fa\u961f\u64cd\u4f5c ###\n  def pop(is_front)\n    raise IndexError, '\u53cc\u5411\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    # \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n    if is_front\n      val = @front.val # \u6682\u5b58\u5934\u8282\u70b9\u503c\n      # \u5220\u9664\u5934\u8282\u70b9\n      fnext = @front.next\n      unless fnext.nil?\n        fnext.prev = nil\n        @front.next = nil\n      end\n      @front = fnext # \u66f4\u65b0\u5934\u8282\u70b9\n    # \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n    else\n      val = @rear.val # \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n      # \u5220\u9664\u5c3e\u8282\u70b9\n      rprev = @rear.prev\n      unless rprev.nil?\n        rprev.next = nil\n        @rear.prev = nil\n      end\n      @rear = rprev # \u66f4\u65b0\u5c3e\u8282\u70b9\n    end\n    @size -= 1 # \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n\n    val\n  end\n\n  ### \u961f\u9996\u51fa\u961f ###\n  def pop_first\n    pop(true)\n  end\n\n  ### \u961f\u9996\u51fa\u961f ###\n  def pop_last\n    pop(false)\n  end\n\n  ### \u8bbf\u95ee\u961f\u9996\u5143\u7d20 ###\n  def peek_first\n    raise IndexError, '\u53cc\u5411\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    @front.val\n  end\n\n  ### \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 ###\n  def peek_last\n    raise IndexError, '\u53cc\u5411\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    @rear.val\n  end\n\n  ### \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 ###\n  def to_array\n    node = @front\n    res = Array.new(size, 0)\n    for i in 0...size\n      res[i] = node.val\n      node = node.next\n    end\n    res\n  end\nend\n</code></pre> linkedlist_deque.zig<pre><code>// \u53cc\u5411\u94fe\u8868\u8282\u70b9\nfn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = undefined,     // \u8282\u70b9\u503c\n        next: ?*Self = null,    // \u540e\u7ee7\u8282\u70b9\u6307\u9488\n        prev: ?*Self = null,    // \u524d\u9a71\u8282\u70b9\u6307\u9488\n\n        // Initialize a list node with specific value\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n            self.prev = null;\n        }\n    };\n}\n\n// \u57fa\u4e8e\u53cc\u5411\u94fe\u8868\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217\nfn LinkedListDeque(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        front: ?*ListNode(T) = null,                    // \u5934\u8282\u70b9 front\n        rear: ?*ListNode(T) = null,                     // \u5c3e\u8282\u70b9 rear\n        que_size: usize = 0,                             // \u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined,   // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u961f\u5217\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.front = null;\n            self.rear = null;\n            self.que_size = 0;\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\n        pub fn size(self: *Self) usize {\n            return self.que_size;\n        }\n\n        // \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a\n        pub fn isEmpty(self: *Self) bool {\n            return self.size() == 0;\n        }\n\n        // \u5165\u961f\u64cd\u4f5c\n        pub fn push(self: *Self, num: T, is_front: bool) !void {\n            var node = try self.mem_allocator.create(ListNode(T));\n            node.init(num);\n            // \u82e5\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u4ee4 front \u548c rear \u90fd\u6307\u5411 node\n            if (self.isEmpty()) {\n                self.front = node;\n                self.rear = node;\n            // \u961f\u9996\u5165\u961f\u64cd\u4f5c\n            } else if (is_front) {\n                // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5934\u90e8\n                self.front.?.prev = node;\n                node.next = self.front;\n                self.front = node;  // \u66f4\u65b0\u5934\u8282\u70b9\n            // \u961f\u5c3e\u5165\u961f\u64cd\u4f5c\n            } else {\n                // \u5c06 node \u6dfb\u52a0\u81f3\u94fe\u8868\u5c3e\u90e8\n                self.rear.?.next = node;\n                node.prev = self.rear;\n                self.rear = node;   // \u66f4\u65b0\u5c3e\u8282\u70b9\n            }\n            self.que_size += 1;      // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n        } \n\n        // \u961f\u9996\u5165\u961f\n        pub fn pushFirst(self: *Self, num: T) !void {\n            try self.push(num, true);\n        } \n\n        // \u961f\u5c3e\u5165\u961f\n        pub fn pushLast(self: *Self, num: T) !void {\n            try self.push(num, false);\n        } \n\n        // \u51fa\u961f\u64cd\u4f5c\n        pub fn pop(self: *Self, is_front: bool) T {\n            if (self.isEmpty()) @panic(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n            var val: T = undefined;\n            // \u961f\u9996\u51fa\u961f\u64cd\u4f5c\n            if (is_front) {\n                val = self.front.?.val;     // \u6682\u5b58\u5934\u8282\u70b9\u503c\n                // \u5220\u9664\u5934\u8282\u70b9\n                var fNext = self.front.?.next;\n                if (fNext != null) {\n                    fNext.?.prev = null;\n                    self.front.?.next = null;\n                }\n                self.front = fNext;         // \u66f4\u65b0\u5934\u8282\u70b9\n            // \u961f\u5c3e\u51fa\u961f\u64cd\u4f5c\n            } else {\n                val = self.rear.?.val;      // \u6682\u5b58\u5c3e\u8282\u70b9\u503c\n                // \u5220\u9664\u5c3e\u8282\u70b9\n                var rPrev = self.rear.?.prev;\n                if (rPrev != null) {\n                    rPrev.?.next = null;\n                    self.rear.?.prev = null;\n                }\n                self.rear = rPrev;          // \u66f4\u65b0\u5c3e\u8282\u70b9\n            }\n            self.que_size -= 1;              // \u66f4\u65b0\u961f\u5217\u957f\u5ea6\n            return val;\n        } \n\n        // \u961f\u9996\u51fa\u961f\n        pub fn popFirst(self: *Self) T {\n            return self.pop(true);\n        } \n\n        // \u961f\u5c3e\u51fa\u961f\n        pub fn popLast(self: *Self) T {\n            return self.pop(false);\n        } \n\n        // \u8bbf\u95ee\u961f\u9996\u5143\u7d20\n        pub fn peekFirst(self: *Self) T {\n            if (self.isEmpty()) @panic(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n            return self.front.?.val;\n        }  \n\n        // \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20\n        pub fn peekLast(self: *Self) T {\n            if (self.isEmpty()) @panic(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n            return self.rear.?.val;\n        }\n\n        // \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370\n        pub fn toArray(self: *Self) ![]T {\n            var node = self.front;\n            var res = try self.mem_allocator.alloc(T, self.size());\n            @memset(res, @as(T, 0));\n            var i: usize = 0;\n            while (i &lt; res.len) : (i += 1) {\n                res[i] = node.?.val;\n                node = node.?.next;\n            }\n            return res;\n        }\n    };\n}\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#2-implementation-based-on-array","title":"2. \u00a0 Implementation based on array","text":"<p>As shown in Figure 5-9, similar to implementing a queue with an array, we can also use a circular array to implement a double-ended queue.</p> ArrayDequepushLast()pushFirst()popLast()popFirst() <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 5-9 \u00a0 Implementing Double-Ended Queue with Array for Enqueue and Dequeue Operations </p> <p>The implementation only needs to add methods for \"front enqueue\" and \"rear dequeue\":</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array_deque.py<pre><code>class ArrayDeque:\n    \"\"\"\u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217\"\"\"\n\n    def __init__(self, capacity: int):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._nums: list[int] = [0] * capacity\n        self._front: int = 0\n        self._size: int = 0\n\n    def capacity(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf\"\"\"\n        return len(self._nums)\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self._size == 0\n\n    def index(self, i: int) -&gt; int:\n        \"\"\"\u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15\"\"\"\n        # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        # \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        # \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + self.capacity()) % self.capacity()\n\n    def push_first(self, num: int):\n        \"\"\"\u961f\u9996\u5165\u961f\"\"\"\n        if self._size == self.capacity():\n            print(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        # \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        self._front = self.index(self._front - 1)\n        # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        self._nums[self._front] = num\n        self._size += 1\n\n    def push_last(self, num: int):\n        \"\"\"\u961f\u5c3e\u5165\u961f\"\"\"\n        if self._size == self.capacity():\n            print(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        # \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        rear = self.index(self._front + self._size)\n        # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        self._nums[rear] = num\n        self._size += 1\n\n    def pop_first(self) -&gt; int:\n        \"\"\"\u961f\u9996\u51fa\u961f\"\"\"\n        num = self.peek_first()\n        # \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        self._front = self.index(self._front + 1)\n        self._size -= 1\n        return num\n\n    def pop_last(self) -&gt; int:\n        \"\"\"\u961f\u5c3e\u51fa\u961f\"\"\"\n        num = self.peek_last()\n        self._size -= 1\n        return num\n\n    def peek_first(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u9996\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        return self._nums[self._front]\n\n    def peek_last(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u5c3e\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        # \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        last = self.index(self._front + self._size - 1)\n        return self._nums[last]\n\n    def to_array(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370\"\"\"\n        # \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        res = []\n        for i in range(self._size):\n            res.append(self._nums[self.index(self._front + i)])\n        return res\n</code></pre> array_deque.cpp<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n  private:\n    vector&lt;int&gt; nums; // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;        // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize;      // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    ArrayDeque(int capacity) {\n        nums.resize(capacity);\n        front = queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    int capacity() {\n        return nums.size();\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    int index(int i) {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + capacity()) % capacity();\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    void pushFirst(int num) {\n        if (queSize == capacity()) {\n            cout &lt;&lt; \"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\" &lt;&lt; endl;\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        front = index(front - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    void pushLast(int num) {\n        if (queSize == capacity()) {\n            cout &lt;&lt; \"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\" &lt;&lt; endl;\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        int rear = index(front + queSize);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    int popFirst() {\n        int num = peekFirst();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n        return nums[front];\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    vector&lt;int&gt; toVector() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        vector&lt;int&gt; res(queSize);\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n};\n</code></pre> array_deque.java<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n    private int[] nums; // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private int front; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private int queSize; // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public ArrayDeque(int capacity) {\n        this.nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    public int capacity() {\n        return nums.length;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    public int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    private int index(int i) {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + capacity()) % capacity();\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    public void pushFirst(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        front = index(front - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    public void pushLast(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        int rear = index(front + queSize);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    public int popFirst() {\n        int num = peekFirst();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    public int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int peekFirst() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return nums[front];\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    public int peekLast() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    public int[] toArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.cs<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n    int[] nums;  // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;   // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize; // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public ArrayDeque(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    int Capacity() {\n        return nums.Length;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    public int Size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    int Index(int i) {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + Capacity()) % Capacity();\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    public void PushFirst(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        front = Index(front - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    public void PushLast(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        int rear = Index(front + queSize);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    public int PopFirst() {\n        int num = PeekFirst();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        front = Index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    public int PopLast() {\n        int num = PeekLast();\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int PeekFirst() {\n        if (IsEmpty()) {\n            throw new InvalidOperationException();\n        }\n        return nums[front];\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    public int PeekLast() {\n        if (IsEmpty()) {\n            throw new InvalidOperationException();\n        }\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        int last = Index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    public int[] ToArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[Index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.go<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\ntype arrayDeque struct {\n    nums        []int // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    front       int   // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    queSize     int   // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n    queCapacity int   // \u961f\u5217\u5bb9\u91cf\uff08\u5373\u6700\u5927\u5bb9\u7eb3\u5143\u7d20\u6570\u91cf\uff09\n}\n\n/* \u521d\u59cb\u5316\u961f\u5217 */\nfunc newArrayDeque(queCapacity int) *arrayDeque {\n    return &amp;arrayDeque{\n        nums:        make([]int, queCapacity),\n        queCapacity: queCapacity,\n        front:       0,\n        queSize:     0,\n    }\n}\n\n/* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\nfunc (q *arrayDeque) size() int {\n    return q.queSize\n}\n\n/* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nfunc (q *arrayDeque) isEmpty() bool {\n    return q.queSize == 0\n}\n\n/* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\nfunc (q *arrayDeque) index(i int) int {\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n    return (i + q.queCapacity) % q.queCapacity\n}\n\n/* \u961f\u9996\u5165\u961f */\nfunc (q *arrayDeque) pushFirst(num int) {\n    if q.queSize == q.queCapacity {\n        fmt.Println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n        return\n    }\n    // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n    q.front = q.index(q.front - 1)\n    // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n    q.nums[q.front] = num\n    q.queSize++\n}\n\n/* \u961f\u5c3e\u5165\u961f */\nfunc (q *arrayDeque) pushLast(num int) {\n    if q.queSize == q.queCapacity {\n        fmt.Println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n        return\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    rear := q.index(q.front + q.queSize)\n    // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    q.nums[rear] = num\n    q.queSize++\n}\n\n/* \u961f\u9996\u51fa\u961f */\nfunc (q *arrayDeque) popFirst() any {\n    num := q.peekFirst()\n    // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    q.front = q.index(q.front + 1)\n    q.queSize--\n    return num\n}\n\n/* \u961f\u5c3e\u51fa\u961f */\nfunc (q *arrayDeque) popLast() any {\n    num := q.peekLast()\n    q.queSize--\n    return num\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nfunc (q *arrayDeque) peekFirst() any {\n    if q.isEmpty() {\n        return nil\n    }\n    return q.nums[q.front]\n}\n\n/* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\nfunc (q *arrayDeque) peekLast() any {\n    if q.isEmpty() {\n        return nil\n    }\n    // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n    last := q.index(q.front + q.queSize - 1)\n    return q.nums[last]\n}\n\n/* \u83b7\u53d6 Slice \u7528\u4e8e\u6253\u5370 */\nfunc (q *arrayDeque) toSlice() []int {\n    // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    res := make([]int, q.queSize)\n    for i, j := 0, q.front; i &lt; q.queSize; i++ {\n        res[i] = q.nums[q.index(j)]\n        j++\n    }\n    return res\n}\n</code></pre> array_deque.swift<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n    private var nums: [Int] // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private var front: Int // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private var _size: Int // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init(capacity: Int) {\n        nums = Array(repeating: 0, count: capacity)\n        front = 0\n        _size = 0\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    func capacity() -&gt; Int {\n        nums.count\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    private func index(i: Int) -&gt; Int {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        (i + capacity()) % capacity()\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    func pushFirst(num: Int) {\n        if size() == capacity() {\n            print(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        front = index(i: front - 1)\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        nums[front] = num\n        _size += 1\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    func pushLast(num: Int) {\n        if size() == capacity() {\n            print(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        let rear = index(i: front + size())\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num\n        _size += 1\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    func popFirst() -&gt; Int {\n        let num = peekFirst()\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        front = index(i: front + 1)\n        _size -= 1\n        return num\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    func popLast() -&gt; Int {\n        let num = peekLast()\n        _size -= 1\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    func peekFirst() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        }\n        return nums[front]\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    func peekLast() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        }\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        let last = index(i: front + size() - 1)\n        return nums[last]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    func toArray() -&gt; [Int] {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        (front ..&lt; front + size()).map { nums[index(i: $0)] }\n    }\n}\n</code></pre> array_deque.js<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n    #nums; // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    #front; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    #queSize; // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(capacity) {\n        this.#nums = new Array(capacity);\n        this.#front = 0;\n        this.#queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    capacity() {\n        return this.#nums.length;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    size() {\n        return this.#queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    index(i) {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + this.capacity()) % this.capacity();\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    pushFirst(num) {\n        if (this.#queSize === this.capacity()) {\n            console.log('\u53cc\u5411\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        this.#front = this.index(this.#front - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        this.#nums[this.#front] = num;\n        this.#queSize++;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    pushLast(num) {\n        if (this.#queSize === this.capacity()) {\n            console.log('\u53cc\u5411\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        const rear = this.index(this.#front + this.#queSize);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        this.#nums[rear] = num;\n        this.#queSize++;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    popFirst() {\n        const num = this.peekFirst();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        this.#front = this.index(this.#front + 1);\n        this.#queSize--;\n        return num;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    popLast() {\n        const num = this.peekLast();\n        this.#queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peekFirst() {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        return this.#nums[this.#front];\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    peekLast() {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        const last = this.index(this.#front + this.#queSize - 1);\n        return this.#nums[last];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    toArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const res = [];\n        for (let i = 0, j = this.#front; i &lt; this.#queSize; i++, j++) {\n            res[i] = this.#nums[this.index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.ts<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n    private nums: number[]; // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private front: number; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private queSize: number; // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(capacity: number) {\n        this.nums = new Array(capacity);\n        this.front = 0;\n        this.queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    capacity(): number {\n        return this.nums.length;\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    size(): number {\n        return this.queSize;\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    index(i: number): number {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + this.capacity()) % this.capacity();\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    pushFirst(num: number): void {\n        if (this.queSize === this.capacity()) {\n            console.log('\u53cc\u5411\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        this.front = this.index(this.front - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        this.nums[this.front] = num;\n        this.queSize++;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    pushLast(num: number): void {\n        if (this.queSize === this.capacity()) {\n            console.log('\u53cc\u5411\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        const rear: number = this.index(this.front + this.queSize);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        this.nums[rear] = num;\n        this.queSize++;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    popFirst(): number {\n        const num: number = this.peekFirst();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        this.front = this.index(this.front + 1);\n        this.queSize--;\n        return num;\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    popLast(): number {\n        const num: number = this.peekLast();\n        this.queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peekFirst(): number {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        return this.nums[this.front];\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    peekLast(): number {\n        if (this.isEmpty()) throw new Error('The Deque Is Empty.');\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        const last = this.index(this.front + this.queSize - 1);\n        return this.nums[last];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    toArray(): number[] {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const res: number[] = [];\n        for (let i = 0, j = this.front; i &lt; this.queSize; i++, j++) {\n            res[i] = this.nums[this.index(j)];\n        }\n        return res;\n    }\n}\n</code></pre> array_deque.dart<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nclass ArrayDeque {\n  late List&lt;int&gt; _nums; // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n  late int _front; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n  late int _queSize; // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  ArrayDeque(int capacity) {\n    this._nums = List.filled(capacity, 0);\n    this._front = this._queSize = 0;\n  }\n\n  /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n  int capacity() {\n    return _nums.length;\n  }\n\n  /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n  int size() {\n    return _queSize;\n  }\n\n  /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n  int index(int i) {\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n    return (i + capacity()) % capacity();\n  }\n\n  /* \u961f\u9996\u5165\u961f */\n  void pushFirst(int _num) {\n    if (_queSize == capacity()) {\n      throw Exception(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n    }\n    // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 _front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n    _front = index(_front - 1);\n    // \u5c06 _num \u6dfb\u52a0\u81f3\u961f\u9996\n    _nums[_front] = _num;\n    _queSize++;\n  }\n\n  /* \u961f\u5c3e\u5165\u961f */\n  void pushLast(int _num) {\n    if (_queSize == capacity()) {\n      throw Exception(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    int rear = index(_front + _queSize);\n    // \u5c06 _num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    _nums[rear] = _num;\n    _queSize++;\n  }\n\n  /* \u961f\u9996\u51fa\u961f */\n  int popFirst() {\n    int _num = peekFirst();\n    // \u961f\u9996\u6307\u9488\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n    _front = index(_front + 1);\n    _queSize--;\n    return _num;\n  }\n\n  /* \u961f\u5c3e\u51fa\u961f */\n  int popLast() {\n    int _num = peekLast();\n    _queSize--;\n    return _num;\n  }\n\n  /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n  int peekFirst() {\n    if (isEmpty()) {\n      throw Exception(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n    }\n    return _nums[_front];\n  }\n\n  /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n  int peekLast() {\n    if (isEmpty()) {\n      throw Exception(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\");\n    }\n    // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n    int last = index(_front + _queSize - 1);\n    return _nums[last];\n  }\n\n  /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n  List&lt;int&gt; toArray() {\n    // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    List&lt;int&gt; res = List.filled(_queSize, 0);\n    for (int i = 0, j = _front; i &lt; _queSize; i++, j++) {\n      res[i] = _nums[index(j)];\n    }\n    return res;\n  }\n}\n</code></pre> array_deque.rs<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\nstruct ArrayDeque {\n    nums: Vec&lt;i32&gt;,  // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    front: usize,    // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    que_size: usize, // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n}\n\nimpl ArrayDeque {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    pub fn new(capacity: usize) -&gt; Self {\n        Self {\n            nums: vec![0; capacity],\n            front: 0,\n            que_size: 0,\n        }\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    pub fn capacity(&amp;self) -&gt; usize {\n        self.nums.len()\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    pub fn size(&amp;self) -&gt; usize {\n        self.que_size\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        self.que_size == 0\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    fn index(&amp;self, i: i32) -&gt; usize {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return ((i + self.capacity() as i32) % self.capacity() as i32) as usize;\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    pub fn push_first(&amp;mut self, num: i32) {\n        if self.que_size == self.capacity() {\n            println!(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        self.front = self.index(self.front as i32 - 1);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        self.nums[self.front] = num;\n        self.que_size += 1;\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    pub fn push_last(&amp;mut self, num: i32) {\n        if self.que_size == self.capacity() {\n            println!(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        let rear = self.index(self.front as i32 + self.que_size as i32);\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        self.nums[rear] = num;\n        self.que_size += 1;\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    fn pop_first(&amp;mut self) -&gt; i32 {\n        let num = self.peek_first();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        self.front = self.index(self.front as i32 + 1);\n        self.que_size -= 1;\n        num\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    fn pop_last(&amp;mut self) -&gt; i32 {\n        let num = self.peek_last();\n        self.que_size -= 1;\n        num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fn peek_first(&amp;self) -&gt; i32 {\n        if self.is_empty() {\n            panic!(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        };\n        self.nums[self.front]\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    fn peek_last(&amp;self) -&gt; i32 {\n        if self.is_empty() {\n            panic!(\"\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\")\n        };\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        let last = self.index(self.front as i32 + self.que_size as i32 - 1);\n        self.nums[last]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    fn to_array(&amp;self) -&gt; Vec&lt;i32&gt; {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        let mut res = vec![0; self.que_size];\n        let mut j = self.front;\n        for i in 0..self.que_size {\n            res[i] = self.nums[self.index(j as i32)];\n            j += 1;\n        }\n        res\n    }\n}\n</code></pre> array_deque.c<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 */\ntypedef struct {\n    int *nums;       // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;       // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize;     // \u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e + 1\n    int queCapacity; // \u961f\u5217\u5bb9\u91cf\n} ArrayDeque;\n\n/* \u6784\u9020\u51fd\u6570 */\nArrayDeque *newArrayDeque(int capacity) {\n    ArrayDeque *deque = (ArrayDeque *)malloc(sizeof(ArrayDeque));\n    // \u521d\u59cb\u5316\u6570\u7ec4\n    deque-&gt;queCapacity = capacity;\n    deque-&gt;nums = (int *)malloc(sizeof(int) * deque-&gt;queCapacity);\n    deque-&gt;front = deque-&gt;queSize = 0;\n    return deque;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delArrayDeque(ArrayDeque *deque) {\n    free(deque-&gt;nums);\n    free(deque);\n}\n\n/* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\nint capacity(ArrayDeque *deque) {\n    return deque-&gt;queCapacity;\n}\n\n/* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\nint size(ArrayDeque *deque) {\n    return deque-&gt;queSize;\n}\n\n/* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nbool empty(ArrayDeque *deque) {\n    return deque-&gt;queSize == 0;\n}\n\n/* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\nint dequeIndex(ArrayDeque *deque, int i) {\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u65f6\uff0c\u56de\u5230\u5934\u90e8\n    // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n    return ((i + capacity(deque)) % capacity(deque));\n}\n\n/* \u961f\u9996\u5165\u961f */\nvoid pushFirst(ArrayDeque *deque, int num) {\n    if (deque-&gt;queSize == capacity(deque)) {\n        printf(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\\r\\n\");\n        return;\n    }\n    // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u56de\u5230\u5c3e\u90e8\n    deque-&gt;front = dequeIndex(deque, deque-&gt;front - 1);\n    // \u5c06 num \u6dfb\u52a0\u5230\u961f\u9996\n    deque-&gt;nums[deque-&gt;front] = num;\n    deque-&gt;queSize++;\n}\n\n/* \u961f\u5c3e\u5165\u961f */\nvoid pushLast(ArrayDeque *deque, int num) {\n    if (deque-&gt;queSize == capacity(deque)) {\n        printf(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\\r\\n\");\n        return;\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    int rear = dequeIndex(deque, deque-&gt;front + deque-&gt;queSize);\n    // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    deque-&gt;nums[rear] = num;\n    deque-&gt;queSize++;\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nint peekFirst(ArrayDeque *deque) {\n    // \u8bbf\u95ee\u5f02\u5e38\uff1a\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\n    assert(empty(deque) == 0);\n    return deque-&gt;nums[deque-&gt;front];\n}\n\n/* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\nint peekLast(ArrayDeque *deque) {\n    // \u8bbf\u95ee\u5f02\u5e38\uff1a\u53cc\u5411\u961f\u5217\u4e3a\u7a7a\n    assert(empty(deque) == 0);\n    int last = dequeIndex(deque, deque-&gt;front + deque-&gt;queSize - 1);\n    return deque-&gt;nums[last];\n}\n\n/* \u961f\u9996\u51fa\u961f */\nint popFirst(ArrayDeque *deque) {\n    int num = peekFirst(deque);\n    // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    deque-&gt;front = dequeIndex(deque, deque-&gt;front + 1);\n    deque-&gt;queSize--;\n    return num;\n}\n\n/* \u961f\u5c3e\u51fa\u961f */\nint popLast(ArrayDeque *deque) {\n    int num = peekLast(deque);\n    deque-&gt;queSize--;\n    return num;\n}\n</code></pre> array_deque.kt<pre><code>/* \u6784\u9020\u65b9\u6cd5 */\nclass ArrayDeque(capacity: Int) {\n    private var nums: IntArray = IntArray(capacity) // \u7528\u4e8e\u5b58\u50a8\u53cc\u5411\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private var front: Int = 0 // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private var queSize: Int = 0 // \u53cc\u5411\u961f\u5217\u957f\u5ea6\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf */\n    fun capacity(): Int {\n        return nums.size\n    }\n\n    /* \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return queSize == 0\n    }\n\n    /* \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 */\n    private fun index(i: Int): Int {\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n        // \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n        return (i + capacity()) % capacity()\n    }\n\n    /* \u961f\u9996\u5165\u961f */\n    fun pushFirst(num: Int) {\n        if (queSize == capacity()) {\n            println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n        front = index(front - 1)\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n        nums[front] = num\n        queSize++\n    }\n\n    /* \u961f\u5c3e\u5165\u961f */\n    fun pushLast(num: Int) {\n        if (queSize == capacity()) {\n            println(\"\u53cc\u5411\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        val rear = index(front + queSize)\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num\n        queSize++\n    }\n\n    /* \u961f\u9996\u51fa\u961f */\n    fun popFirst(): Int {\n        val num = peekFirst()\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        front = index(front + 1)\n        queSize--\n        return num\n    }\n\n    /* \u961f\u5c3e\u51fa\u961f */\n    fun popLast(): Int {\n        val num = peekLast()\n        queSize--\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fun peekFirst(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return nums[front]\n    }\n\n    /* \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 */\n    fun peekLast(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        // \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n        val last = index(front + queSize - 1)\n        return nums[last]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 */\n    fun toArray(): IntArray {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        val res = IntArray(queSize)\n        var i = 0\n        var j = front\n        while (i &lt; queSize) {\n            res[i] = nums[index(j)]\n            i++\n            j++\n        }\n        return res\n    }\n}\n</code></pre> array_deque.rb<pre><code>### \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u53cc\u5411\u961f\u5217 ###\nclass ArrayDeque\n  ### \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u957f\u5ea6 ###\n  attr_reader :size\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize(capacity)\n    @nums = Array.new(capacity, 0)\n    @front = 0\n    @size = 0\n  end\n\n  ### \u83b7\u53d6\u53cc\u5411\u961f\u5217\u7684\u5bb9\u91cf ###\n  def capacity\n    @nums.length\n  end\n\n  ### \u5224\u65ad\u53cc\u5411\u961f\u5217\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### \u961f\u9996\u5165\u961f ###\n  def push_first(num)\n    if size == capacity\n      puts '\u53cc\u5411\u961f\u5217\u5df2\u6ee1'\n      return\n    end\n\n    # \u961f\u9996\u6307\u9488\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\n    # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 front \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\u56de\u5230\u5c3e\u90e8\n    @front = index(@front - 1)\n    # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u9996\n    @nums[@front] = num\n    @size += 1\n  end\n\n  ### \u961f\u5c3e\u5165\u961f ###\n  def push_last(num)\n    if size == capacity\n      puts '\u53cc\u5411\u961f\u5217\u5df2\u6ee1'\n      return\n    end\n\n    # \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    rear = index(@front + size)\n    # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    @nums[rear] = num\n    @size += 1\n  end\n\n  ### \u961f\u9996\u51fa\u961f ###\n  def pop_first\n    num = peek_first\n    # \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n    @front = index(@front + 1)\n    @size -= 1\n    num\n  end\n\n  ### \u961f\u5c3e\u51fa\u961f ###\n  def pop_last\n    num = peek_last\n    @size -= 1\n    num\n  end\n\n  ### \u8bbf\u95ee\u961f\u9996\u5143\u7d20 ###\n  def peek_first\n    raise IndexError, '\u53cc\u5411\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    @nums[@front]\n  end\n\n  ### \u8bbf\u95ee\u961f\u5c3e\u5143\u7d20 ###\n  def peek_last\n    raise IndexError, '\u53cc\u5411\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    # \u8ba1\u7b97\u5c3e\u5143\u7d20\u7d22\u5f15\n    last = index(@front + size - 1)\n    @nums[last]\n  end\n\n  ### \u8fd4\u56de\u6570\u7ec4\u7528\u4e8e\u6253\u5370 ###\n  def to_array\n    # \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    res = []\n    for i in 0...size\n      res &lt;&lt; @nums[index(@front + i)]\n    end\n    res\n  end\n\n  private\n\n  ### \u8ba1\u7b97\u73af\u5f62\u6570\u7ec4\u7d22\u5f15 ###\n  def index(i)\n    # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0\u6570\u7ec4\u9996\u5c3e\u76f8\u8fde\n    # \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\uff0c\u56de\u5230\u5934\u90e8\n    # \u5f53 i \u8d8a\u8fc7\u6570\u7ec4\u5934\u90e8\u540e\uff0c\u56de\u5230\u5c3e\u90e8\n    (i + capacity) % capacity\n  end\nend\n</code></pre> array_deque.zig<pre><code>[class]{ArrayDeque}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#533-applications-of-double-ended-queue","title":"5.3.3 \u00a0 Applications of double-ended queue","text":"<p>The double-ended queue combines the logic of both stacks and queues, thus, it can implement all their respective use cases while offering greater flexibility.</p> <p>We know that software's \"undo\" feature is typically implemented using a stack: the system <code>pushes</code> each change operation onto the stack and then <code>pops</code> to implement undoing. However, considering the limitations of system resources, software often restricts the number of undo steps (for example, only allowing the last 50 steps). When the stack length exceeds 50, the software needs to perform a deletion operation at the bottom of the stack (the front of the queue). But a regular stack cannot perform this function, where a double-ended queue becomes necessary. Note that the core logic of \"undo\" still follows the Last-In-First-Out principle of a stack, but a double-ended queue can more flexibly implement some additional logic.</p>"},{"location":"chapter_stack_and_queue/queue/","title":"5.2 \u00a0 Queue","text":"<p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) rule. As the name suggests, a queue simulates the phenomenon of lining up, where newcomers join the queue at the rear, and the person at the front leaves the queue first.</p> <p>As shown in Figure 5-4, we call the front of the queue the \"head\" and the back the \"tail.\" The operation of adding elements to the rear of the queue is termed \"enqueue,\" and the operation of removing elements from the front is termed \"dequeue.\"</p> <p></p> <p> Figure 5-4 \u00a0 Queue's first-in-first-out rule </p>"},{"location":"chapter_stack_and_queue/queue/#521-common-operations-on-queue","title":"5.2.1 \u00a0 Common operations on queue","text":"<p>The common operations on a queue are shown in Table 5-2. Note that method names may vary across different programming languages. Here, we use the same naming convention as that used for stacks.</p> <p> Table 5-2 \u00a0 Efficiency of queue operations </p> Method Name Description Time Complexity <code>push()</code> Enqueue an element, add it to the tail \\(O(1)\\) <code>pop()</code> Dequeue the head element \\(O(1)\\) <code>peek()</code> Access the head element \\(O(1)\\) <p>We can directly use the ready-made queue classes in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig queue.py<pre><code>from collections import deque\n\n# Initialize the queue\n# In Python, we generally use the deque class as a queue\n# Although queue.Queue() is a pure queue class, it's not very user-friendly, so it's not recommended\nque: deque[int] = deque()\n\n# Enqueue elements\nque.append(1)\nque.append(3)\nque.append(2)\nque.append(5)\nque.append(4)\n\n# Access the first element\nfront: int = que[0]\n\n# Dequeue an element\npop: int = que.popleft()\n\n# Get the length of the queue\nsize: int = len(que)\n\n# Check if the queue is empty\nis_empty: bool = len(que) == 0\n</code></pre> queue.cpp<pre><code>/* Initialize the queue */\nqueue&lt;int&gt; queue;\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element*/\nint front = queue.front();\n\n/* Dequeue an element */\nqueue.pop();\n\n/* Get the length of the queue */\nint size = queue.size();\n\n/* Check if the queue is empty */\nbool empty = queue.empty();\n</code></pre> queue.java<pre><code>/* Initialize the queue */\nQueue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\nqueue.offer(1);\nqueue.offer(3);\nqueue.offer(2);\nqueue.offer(5);\nqueue.offer(4);\n\n/* Access the first element */\nint peek = queue.peek();\n\n/* Dequeue an element */\nint pop = queue.poll();\n\n/* Get the length of the queue */\nint size = queue.size();\n\n/* Check if the queue is empty */\nboolean isEmpty = queue.isEmpty();\n</code></pre> queue.cs<pre><code>/* Initialize the queue */\nQueue&lt;int&gt; queue = new();\n\n/* Enqueue elements */\nqueue.Enqueue(1);\nqueue.Enqueue(3);\nqueue.Enqueue(2);\nqueue.Enqueue(5);\nqueue.Enqueue(4);\n\n/* Access the first element */\nint peek = queue.Peek();\n\n/* Dequeue an element */\nint pop = queue.Dequeue();\n\n/* Get the length of the queue */\nint size = queue.Count;\n\n/* Check if the queue is empty */\nbool isEmpty = queue.Count == 0;\n</code></pre> queue_test.go<pre><code>/* Initialize the queue */\n// In Go, use list as a queue\nqueue := list.New()\n\n/* Enqueue elements */\nqueue.PushBack(1)\nqueue.PushBack(3)\nqueue.PushBack(2)\nqueue.PushBack(5)\nqueue.PushBack(4)\n\n/* Access the first element */\npeek := queue.Front()\n\n/* Dequeue an element */\npop := queue.Front()\nqueue.Remove(pop)\n\n/* Get the length of the queue */\nsize := queue.Len()\n\n/* Check if the queue is empty */\nisEmpty := queue.Len() == 0\n</code></pre> queue.swift<pre><code>/* Initialize the queue */\n// Swift does not have a built-in queue class, so Array can be used as a queue\nvar queue: [Int] = []\n\n/* Enqueue elements */\nqueue.append(1)\nqueue.append(3)\nqueue.append(2)\nqueue.append(5)\nqueue.append(4)\n\n/* Access the first element */\nlet peek = queue.first!\n\n/* Dequeue an element */\n// Since it's an array, removeFirst has a complexity of O(n)\nlet pool = queue.removeFirst()\n\n/* Get the length of the queue */\nlet size = queue.count\n\n/* Check if the queue is empty */\nlet isEmpty = queue.isEmpty\n</code></pre> queue.js<pre><code>/* Initialize the queue */\n// JavaScript does not have a built-in queue, so Array can be used as a queue\nconst queue = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element */\nconst peek = queue[0];\n\n/* Dequeue an element */\n// Since the underlying structure is an array, shift() method has a time complexity of O(n)\nconst pop = queue.shift();\n\n/* Get the length of the queue */\nconst size = queue.length;\n\n/* Check if the queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.ts<pre><code>/* Initialize the queue */\n// TypeScript does not have a built-in queue, so Array can be used as a queue \nconst queue: number[] = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element */\nconst peek = queue[0];\n\n/* Dequeue an element */\n// Since the underlying structure is an array, shift() method has a time complexity of O(n)\nconst pop = queue.shift();\n\n/* Get the length of the queue */\nconst size = queue.length;\n\n/* Check if the queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.dart<pre><code>/* Initialize the queue */\n// In Dart, the Queue class is a double-ended queue but can be used as a queue\nQueue&lt;int&gt; queue = Queue();\n\n/* Enqueue elements */\nqueue.add(1);\nqueue.add(3);\nqueue.add(2);\nqueue.add(5);\nqueue.add(4);\n\n/* Access the first element */\nint peek = queue.first;\n\n/* Dequeue an element */\nint pop = queue.removeFirst();\n\n/* Get the length of the queue */\nint size = queue.length;\n\n/* Check if the queue is empty */\nbool isEmpty = queue.isEmpty;\n</code></pre> queue.rs<pre><code>/* Initialize the double-ended queue */\n// In Rust, use a double-ended queue as a regular queue\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(1);\ndeque.push_back(3);\ndeque.push_back(2);\ndeque.push_back(5);\ndeque.push_back(4);\n\n/* Access the first element */\nif let Some(front) = deque.front() {\n}\n\n/* Dequeue an element */\nif let Some(pop) = deque.pop_front() {\n}\n\n/* Get the length of the queue */\nlet size = deque.len();\n\n/* Check if the queue is empty */\nlet is_empty = deque.is_empty();\n</code></pre> queue.c<pre><code>// C does not provide a built-in queue\n</code></pre> queue.kt<pre><code>\n</code></pre> queue.zig<pre><code>\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/queue/#522-implementing-a-queue","title":"5.2.2 \u00a0 Implementing a queue","text":"<p>To implement a queue, we need a data structure that allows adding elements at one end and removing them at the other. Both linked lists and arrays meet this requirement.</p>"},{"location":"chapter_stack_and_queue/queue/#1-implementation-based-on-a-linked-list","title":"1. \u00a0 Implementation based on a linked list","text":"<p>As shown in Figure 5-5, we can consider the \"head node\" and \"tail node\" of a linked list as the \"front\" and \"rear\" of the queue, respectively. It is stipulated that nodes can only be added at the rear and removed at the front.</p> LinkedListQueuepush()pop() <p></p> <p></p> <p></p> <p> Figure 5-5 \u00a0 Implementing Queue with Linked List for Enqueue and Dequeue Operations </p> <p>Below is the code for implementing a queue using a linked list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linkedlist_queue.py<pre><code>class LinkedListQueue:\n    \"\"\"\u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._front: ListNode | None = None  # \u5934\u8282\u70b9 front\n        self._rear: ListNode | None = None  # \u5c3e\u8282\u70b9 rear\n        self._size: int = 0\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self._size == 0\n\n    def push(self, num: int):\n        \"\"\"\u5165\u961f\"\"\"\n        # \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        node = ListNode(num)\n        # \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if self._front is None:\n            self._front = node\n            self._rear = node\n        # \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        else:\n            self._rear.next = node\n            self._rear = node\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"\u51fa\u961f\"\"\"\n        num = self.peek()\n        # \u5220\u9664\u5934\u8282\u70b9\n        self._front = self._front.next\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u9996\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u961f\u5217\u4e3a\u7a7a\")\n        return self._front.val\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"\u8f6c\u5316\u4e3a\u5217\u8868\u7528\u4e8e\u6253\u5370\"\"\"\n        queue = []\n        temp = self._front\n        while temp:\n            queue.append(temp.val)\n            temp = temp.next\n        return queue\n</code></pre> linkedlist_queue.cpp<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n  private:\n    ListNode *front, *rear; // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    int queSize;\n\n  public:\n    LinkedListQueue() {\n        front = nullptr;\n        rear = nullptr;\n        queSize = 0;\n    }\n\n    ~LinkedListQueue() {\n        // \u904d\u5386\u94fe\u8868\u5220\u9664\u8282\u70b9\uff0c\u91ca\u653e\u5185\u5b58\n        freeMemoryLinkedList(front);\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u5165\u961f */\n    void push(int num) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        ListNode *node = new ListNode(num);\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (front == nullptr) {\n            front = node;\n            rear = node;\n        }\n        // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        else {\n            rear-&gt;next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    int pop() {\n        int num = peek();\n        // \u5220\u9664\u5934\u8282\u70b9\n        ListNode *tmp = front;\n        front = front-&gt;next;\n        // \u91ca\u653e\u5185\u5b58\n        delete tmp;\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    int peek() {\n        if (size() == 0)\n            throw out_of_range(\"\u961f\u5217\u4e3a\u7a7a\");\n        return front-&gt;val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Vector \u5e76\u8fd4\u56de */\n    vector&lt;int&gt; toVector() {\n        ListNode *node = front;\n        vector&lt;int&gt; res(size());\n        for (int i = 0; i &lt; res.size(); i++) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_queue.java<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n    private ListNode front, rear; // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    private int queSize = 0;\n\n    public LinkedListQueue() {\n        front = null;\n        rear = null;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    public int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u961f */\n    public void push(int num) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        ListNode node = new ListNode(num);\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (front == null) {\n            front = node;\n            rear = node;\n        // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        } else {\n            rear.next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    public int pop() {\n        int num = peek();\n        // \u5220\u9664\u5934\u8282\u70b9\n        front = front.next;\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return front.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public int[] toArray() {\n        ListNode node = front;\n        int[] res = new int[size()];\n        for (int i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.cs<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n    ListNode? front, rear;  // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear \n    int queSize = 0;\n\n    public LinkedListQueue() {\n        front = null;\n        rear = null;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    public int Size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* \u5165\u961f */\n    public void Push(int num) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        ListNode node = new(num);\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (front == null) {\n            front = node;\n            rear = node;\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        } else if (rear != null) {\n            rear.next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    public int Pop() {\n        int num = Peek();\n        // \u5220\u9664\u5934\u8282\u70b9\n        front = front?.next;\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return front!.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public int[] ToArray() {\n        if (front == null)\n            return [];\n\n        ListNode? node = front;\n        int[] res = new int[Size()];\n        for (int i = 0; i &lt; res.Length; i++) {\n            res[i] = node!.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.go<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\ntype linkedListQueue struct {\n    // \u4f7f\u7528\u5185\u7f6e\u5305 list \u6765\u5b9e\u73b0\u961f\u5217\n    data *list.List\n}\n\n/* \u521d\u59cb\u5316\u961f\u5217 */\nfunc newLinkedListQueue() *linkedListQueue {\n    return &amp;linkedListQueue{\n        data: list.New(),\n    }\n}\n\n/* \u5165\u961f */\nfunc (s *linkedListQueue) push(value any) {\n    s.data.PushBack(value)\n}\n\n/* \u51fa\u961f */\nfunc (s *linkedListQueue) pop() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nfunc (s *linkedListQueue) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Front()\n    return e.Value\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nfunc (s *linkedListQueue) size() int {\n    return s.data.Len()\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nfunc (s *linkedListQueue) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* \u83b7\u53d6 List \u7528\u4e8e\u6253\u5370 */\nfunc (s *linkedListQueue) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_queue.swift<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n    private var front: ListNode? // \u5934\u8282\u70b9\n    private var rear: ListNode? // \u5c3e\u8282\u70b9\n    private var _size: Int\n\n    init() {\n        _size = 0\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* \u5165\u961f */\n    func push(num: Int) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        let node = ListNode(x: num)\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if front == nil {\n            front = node\n            rear = node\n        }\n        // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        else {\n            rear?.next = node\n            rear = node\n        }\n        _size += 1\n    }\n\n    /* \u51fa\u961f */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        // \u5220\u9664\u5934\u8282\u70b9\n        front = front?.next\n        _size -= 1\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u961f\u5217\u4e3a\u7a7a\")\n        }\n        return front!.val\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    func toArray() -&gt; [Int] {\n        var node = front\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_queue.js<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n    #front; // \u5934\u8282\u70b9 #front\n    #rear; // \u5c3e\u8282\u70b9 #rear\n    #queSize = 0;\n\n    constructor() {\n        this.#front = null;\n        this.#rear = null;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    get size() {\n        return this.#queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    /* \u5165\u961f */\n    push(num) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        const node = new ListNode(num);\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (!this.#front) {\n            this.#front = node;\n            this.#rear = node;\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        } else {\n            this.#rear.next = node;\n            this.#rear = node;\n        }\n        this.#queSize++;\n    }\n\n    /* \u51fa\u961f */\n    pop() {\n        const num = this.peek();\n        // \u5220\u9664\u5934\u8282\u70b9\n        this.#front = this.#front.next;\n        this.#queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peek() {\n        if (this.size === 0) throw new Error('\u961f\u5217\u4e3a\u7a7a');\n        return this.#front.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    toArray() {\n        let node = this.#front;\n        const res = new Array(this.size);\n        for (let i = 0; i &lt; res.length; i++) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.ts<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n    private front: ListNode | null; // \u5934\u8282\u70b9 front\n    private rear: ListNode | null; // \u5c3e\u8282\u70b9 rear\n    private queSize: number = 0;\n\n    constructor() {\n        this.front = null;\n        this.rear = null;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    get size(): number {\n        return this.queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.size === 0;\n    }\n\n    /* \u5165\u961f */\n    push(num: number): void {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        const node = new ListNode(num);\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (!this.front) {\n            this.front = node;\n            this.rear = node;\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        } else {\n            this.rear!.next = node;\n            this.rear = node;\n        }\n        this.queSize++;\n    }\n\n    /* \u51fa\u961f */\n    pop(): number {\n        const num = this.peek();\n        if (!this.front) throw new Error('\u961f\u5217\u4e3a\u7a7a');\n        // \u5220\u9664\u5934\u8282\u70b9\n        this.front = this.front.next;\n        this.queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peek(): number {\n        if (this.size === 0) throw new Error('\u961f\u5217\u4e3a\u7a7a');\n        return this.front!.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    toArray(): number[] {\n        let node = this.front;\n        const res = new Array&lt;number&gt;(this.size);\n        for (let i = 0; i &lt; res.length; i++) {\n            res[i] = node!.val;\n            node = node!.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_queue.dart<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue {\n  ListNode? _front; // \u5934\u8282\u70b9 _front\n  ListNode? _rear; // \u5c3e\u8282\u70b9 _rear\n  int _queSize = 0; // \u961f\u5217\u957f\u5ea6\n\n  LinkedListQueue() {\n    _front = null;\n    _rear = null;\n  }\n\n  /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n  int size() {\n    return _queSize;\n  }\n\n  /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* \u5165\u961f */\n  void push(int _num) {\n    // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 _num\n    final node = ListNode(_num);\n    // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n    if (_front == null) {\n      _front = node;\n      _rear = node;\n    } else {\n      // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n      _rear!.next = node;\n      _rear = node;\n    }\n    _queSize++;\n  }\n\n  /* \u51fa\u961f */\n  int pop() {\n    final int _num = peek();\n    // \u5220\u9664\u5934\u8282\u70b9\n    _front = _front!.next;\n    _queSize--;\n    return _num;\n  }\n\n  /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n  int peek() {\n    if (_queSize == 0) {\n      throw Exception('\u961f\u5217\u4e3a\u7a7a');\n    }\n    return _front!.val;\n  }\n\n  /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n  List&lt;int&gt; toArray() {\n    ListNode? node = _front;\n    final List&lt;int&gt; queue = [];\n    while (node != null) {\n      queue.add(node.val);\n      node = node.next;\n    }\n    return queue;\n  }\n}\n</code></pre> linkedlist_queue.rs<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\n#[allow(dead_code)]\npub struct LinkedListQueue&lt;T&gt; {\n    front: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // \u5934\u8282\u70b9 front\n    rear: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;,  // \u5c3e\u8282\u70b9 rear\n    que_size: usize,                         // \u961f\u5217\u7684\u957f\u5ea6\n}\n\nimpl&lt;T: Copy&gt; LinkedListQueue&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            front: None,\n            rear: None,\n            que_size: 0,\n        }\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.que_size;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.size() == 0;\n    }\n\n    /* \u5165\u961f */\n    pub fn push(&amp;mut self, num: T) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        let new_rear = ListNode::new(num);\n        match self.rear.take() {\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n            Some(old_rear) =&gt; {\n                old_rear.borrow_mut().next = Some(new_rear.clone());\n                self.rear = Some(new_rear);\n            }\n            // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n            None =&gt; {\n                self.front = Some(new_rear.clone());\n                self.rear = Some(new_rear);\n            }\n        }\n        self.que_size += 1;\n    }\n\n    /* \u51fa\u961f */\n    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.front.take().map(|old_front| {\n            match old_front.borrow_mut().next.take() {\n                Some(new_front) =&gt; {\n                    self.front = Some(new_front);\n                }\n                None =&gt; {\n                    self.rear.take();\n                }\n            }\n            self.que_size -= 1;\n            Rc::try_unwrap(old_front).ok().unwrap().into_inner().val\n        })\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    pub fn peek(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.front.as_ref()\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    pub fn to_array(&amp;self, head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n        if let Some(node) = head {\n            let mut nums = self.to_array(node.borrow().next.as_ref());\n            nums.insert(0, node.borrow().val);\n            return nums;\n        }\n        return Vec::new();\n    }\n}\n</code></pre> linkedlist_queue.c<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\ntypedef struct {\n    ListNode *front, *rear;\n    int queSize;\n} LinkedListQueue;\n\n/* \u6784\u9020\u51fd\u6570 */\nLinkedListQueue *newLinkedListQueue() {\n    LinkedListQueue *queue = (LinkedListQueue *)malloc(sizeof(LinkedListQueue));\n    queue-&gt;front = NULL;\n    queue-&gt;rear = NULL;\n    queue-&gt;queSize = 0;\n    return queue;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delLinkedListQueue(LinkedListQueue *queue) {\n    // \u91ca\u653e\u6240\u6709\u8282\u70b9\n    while (queue-&gt;front != NULL) {\n        ListNode *tmp = queue-&gt;front;\n        queue-&gt;front = queue-&gt;front-&gt;next;\n        free(tmp);\n    }\n    // \u91ca\u653e queue \u7ed3\u6784\u4f53\n    free(queue);\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nint size(LinkedListQueue *queue) {\n    return queue-&gt;queSize;\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nbool empty(LinkedListQueue *queue) {\n    return (size(queue) == 0);\n}\n\n/* \u5165\u961f */\nvoid push(LinkedListQueue *queue, int num) {\n    // \u5c3e\u8282\u70b9\u5904\u6dfb\u52a0 node\n    ListNode *node = newListNode(num);\n    // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n    if (queue-&gt;front == NULL) {\n        queue-&gt;front = node;\n        queue-&gt;rear = node;\n    }\n    // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n    else {\n        queue-&gt;rear-&gt;next = node;\n        queue-&gt;rear = node;\n    }\n    queue-&gt;queSize++;\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nint peek(LinkedListQueue *queue) {\n    assert(size(queue) &amp;&amp; queue-&gt;front);\n    return queue-&gt;front-&gt;val;\n}\n\n/* \u51fa\u961f */\nint pop(LinkedListQueue *queue) {\n    int num = peek(queue);\n    ListNode *tmp = queue-&gt;front;\n    queue-&gt;front = queue-&gt;front-&gt;next;\n    free(tmp);\n    queue-&gt;queSize--;\n    return num;\n}\n\n/* \u6253\u5370\u961f\u5217 */\nvoid printLinkedListQueue(LinkedListQueue *queue) {\n    int *arr = malloc(sizeof(int) * queue-&gt;queSize);\n    // \u62f7\u8d1d\u94fe\u8868\u4e2d\u7684\u6570\u636e\u5230\u6570\u7ec4\n    int i;\n    ListNode *node;\n    for (i = 0, node = queue-&gt;front; i &lt; queue-&gt;queSize; i++) {\n        arr[i] = node-&gt;val;\n        node = node-&gt;next;\n    }\n    printArray(arr, queue-&gt;queSize);\n    free(arr);\n}\n</code></pre> linkedlist_queue.kt<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217 */\nclass LinkedListQueue(\n    // \u5934\u8282\u70b9 front \uff0c\u5c3e\u8282\u70b9 rear\n    private var front: ListNode? = null,\n    private var rear: ListNode? = null,\n    private var queSize: Int = 0\n) {\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* \u5165\u961f */\n    fun push(num: Int) {\n        // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n        val node = ListNode(num)\n        // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n        if (front == null) {\n            front = node\n            rear = node\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n        } else {\n            rear?.next = node\n            rear = node\n        }\n        queSize++\n    }\n\n    /* \u51fa\u961f */\n    fun pop(): Int {\n        val num = peek()\n        // \u5220\u9664\u5934\u8282\u70b9\n        front = front?.next\n        queSize--\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return front!!._val\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    fun toArray(): IntArray {\n        var node = front\n        val res = IntArray(size())\n        for (i in res.indices) {\n            res[i] = node!!._val\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_queue.rb<pre><code>### \u57fa\u4e8e\u94fe\u8868\u5934\u73b0\u7684\u961f\u5217 ###\nclass LinkedListQueue\n  ### \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 ###\n  attr_reader :size\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @front = nil  # \u5934\u8282\u70b9 front\n    @rear = nil   # \u5c3e\u8282\u70b9 rear\n    @size = 0\n  end\n\n  ### \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    @front.nil?\n  end\n\n  ### \u5165\u961f ###\n  def push(num)\n    # \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n    node = ListNode.new(num)\n\n    # \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\uff0c\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n    if @front.nil?\n      @front = node\n      @rear = node\n    # \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u4ee4\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n    else\n      @rear.next = node\n      @rear = node\n    end\n\n    @size += 1\n  end\n\n  ### \u51fa\u961f ###\n  def pop\n    num = peek\n    # \u5220\u9664\u5934\u8282\u70b9\n    @front = @front.next\n    @size -= 1\n    num\n  end\n\n  ### \u8bbf\u95ee\u961f\u9996\u5143\u7d20 ###\n  def peek\n    raise IndexError, '\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    @front.val\n  end\n\n  ### \u5c06\u94fe\u8868\u4e3a Array \u5e76\u8fd4\u56de ###\n  def to_array\n    queue = []\n    temp = @front\n    while temp\n      queue &lt;&lt; temp.val\n      temp = temp.next\n    end\n    queue\n  end\nend\n</code></pre> linkedlist_queue.zig<pre><code>// \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217\nfn LinkedListQueue(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        front: ?*inc.ListNode(T) = null,                // \u5934\u8282\u70b9 front\n        rear: ?*inc.ListNode(T) = null,                 // \u5c3e\u8282\u70b9 rear\n        que_size: usize = 0,                            // \u961f\u5217\u7684\u957f\u5ea6\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined,   // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u961f\u5217\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.front = null;\n            self.rear = null;\n            self.que_size = 0;\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6\n        pub fn size(self: *Self) usize {\n            return self.que_size;\n        }\n\n        // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\n        pub fn isEmpty(self: *Self) bool {\n            return self.size() == 0;\n        }\n\n        // \u8bbf\u95ee\u961f\u9996\u5143\u7d20\n        pub fn peek(self: *Self) T {\n            if (self.size() == 0) @panic(\"\u961f\u5217\u4e3a\u7a7a\");\n            return self.front.?.val;\n        }  \n\n        // \u5165\u961f\n        pub fn push(self: *Self, num: T) !void {\n            // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n            var node = try self.mem_allocator.create(inc.ListNode(T));\n            node.init(num);\n            // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u4ee4\u5934\u3001\u5c3e\u8282\u70b9\u90fd\u6307\u5411\u8be5\u8282\u70b9\n            if (self.front == null) {\n                self.front = node;\n                self.rear = node;\n            // \u5982\u679c\u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u8be5\u8282\u70b9\u6dfb\u52a0\u5230\u5c3e\u8282\u70b9\u540e\n            } else {\n                self.rear.?.next = node;\n                self.rear = node;\n            }\n            self.que_size += 1;\n        } \n\n        // \u51fa\u961f\n        pub fn pop(self: *Self) T {\n            var num = self.peek();\n            // \u5220\u9664\u5934\u8282\u70b9\n            self.front = self.front.?.next;\n            self.que_size -= 1;\n            return num;\n        } \n\n        // \u5c06\u94fe\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4\n        pub fn toArray(self: *Self) ![]T {\n            var node = self.front;\n            var res = try self.mem_allocator.alloc(T, self.size());\n            @memset(res, @as(T, 0));\n            var i: usize = 0;\n            while (i &lt; res.len) : (i += 1) {\n                res[i] = node.?.val;\n                node = node.?.next;\n            }\n            return res;\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/queue/#2-implementation-based-on-an-array","title":"2. \u00a0 Implementation based on an array","text":"<p>Deleting the first element in an array has a time complexity of \\(O(n)\\), which would make the dequeue operation inefficient. However, this problem can be cleverly avoided as follows.</p> <p>We use a variable <code>front</code> to indicate the index of the front element and maintain a variable <code>size</code> to record the queue's length. Define <code>rear = front + size</code>, which points to the position immediately following the tail element.</p> <p>With this design, the effective interval of elements in the array is <code>[front, rear - 1]</code>. The implementation methods for various operations are shown in Figure 5-6.</p> <ul> <li>Enqueue operation: Assign the input element to the <code>rear</code> index and increase <code>size</code> by 1.</li> <li>Dequeue operation: Simply increase <code>front</code> by 1 and decrease <code>size</code> by 1.</li> </ul> <p>Both enqueue and dequeue operations only require a single operation, each with a time complexity of \\(O(1)\\).</p> ArrayQueuepush()pop() <p></p> <p></p> <p></p> <p> Figure 5-6 \u00a0 Implementing Queue with Array for Enqueue and Dequeue Operations </p> <p>You might notice a problem: as enqueue and dequeue operations are continuously performed, both <code>front</code> and <code>rear</code> move to the right and will eventually reach the end of the array and can't move further. To resolve this, we can treat the array as a \"circular array\" where connecting the end of the array back to its beginning.</p> <p>In a circular array, <code>front</code> or <code>rear</code> needs to loop back to the start of the array upon reaching the end. This cyclical pattern can be achieved with a \"modulo operation\" as shown in the code below:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array_queue.py<pre><code>class ArrayQueue:\n    \"\"\"\u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217\"\"\"\n\n    def __init__(self, size: int):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._nums: list[int] = [0] * size  # \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n        self._front: int = 0  # \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n        self._size: int = 0  # \u961f\u5217\u957f\u5ea6\n\n    def capacity(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf\"\"\"\n        return len(self._nums)\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self._size == 0\n\n    def push(self, num: int):\n        \"\"\"\u5165\u961f\"\"\"\n        if self._size == self.capacity():\n            raise IndexError(\"\u961f\u5217\u5df2\u6ee1\")\n        # \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        rear: int = (self._front + self._size) % self.capacity()\n        # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        self._nums[rear] = num\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"\u51fa\u961f\"\"\"\n        num: int = self.peek()\n        # \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        self._front = (self._front + 1) % self.capacity()\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u961f\u9996\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u961f\u5217\u4e3a\u7a7a\")\n        return self._nums[self._front]\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u5217\u8868\u7528\u4e8e\u6253\u5370\"\"\"\n        res = [0] * self.size()\n        j: int = self._front\n        for i in range(self.size()):\n            res[i] = self._nums[(j % self.capacity())]\n            j += 1\n        return res\n</code></pre> array_queue.cpp<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n  private:\n    int *nums;       // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;       // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize;     // \u961f\u5217\u957f\u5ea6\n    int queCapacity; // \u961f\u5217\u5bb9\u91cf\n\n  public:\n    ArrayQueue(int capacity) {\n        // \u521d\u59cb\u5316\u6570\u7ec4\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u961f */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout &lt;&lt; \"\u961f\u5217\u5df2\u6ee1\" &lt;&lt; endl;\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        int rear = (front + queSize) % queCapacity;\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    int pop() {\n        int num = peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"\u961f\u5217\u4e3a\u7a7a\");\n        return nums[front];\n    }\n\n    /* \u5c06\u6570\u7ec4\u8f6c\u5316\u4e3a Vector \u5e76\u8fd4\u56de */\n    vector&lt;int&gt; toVector() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        vector&lt;int&gt; arr(queSize);\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n</code></pre> array_queue.java<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n    private int[] nums; // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private int front; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private int queSize; // \u961f\u5217\u957f\u5ea6\n\n    public ArrayQueue(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    public int capacity() {\n        return nums.length;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    public int size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u5165\u961f */\n    public void push(int num) {\n        if (queSize == capacity()) {\n            System.out.println(\"\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        int rear = (front + queSize) % capacity();\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    public int pop() {\n        int num = peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        front = (front + 1) % capacity();\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return nums[front];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4 */\n    public int[] toArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[j % capacity()];\n        }\n        return res;\n    }\n}\n</code></pre> array_queue.cs<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n    int[] nums;  // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;   // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize; // \u961f\u5217\u957f\u5ea6\n\n    public ArrayQueue(int capacity) {\n        nums = new int[capacity];\n        front = queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    int Capacity() {\n        return nums.Length;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    public int Size() {\n        return queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return queSize == 0;\n    }\n\n    /* \u5165\u961f */\n    public void Push(int num) {\n        if (queSize == Capacity()) {\n            Console.WriteLine(\"\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        int rear = (front + queSize) % Capacity();\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* \u51fa\u961f */\n    public int Pop() {\n        int num = Peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        front = (front + 1) % Capacity();\n        queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return nums[front];\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4 */\n    public int[] ToArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        int[] res = new int[queSize];\n        for (int i = 0, j = front; i &lt; queSize; i++, j++) {\n            res[i] = nums[j % this.Capacity()];\n        }\n        return res;\n    }\n}\n</code></pre> array_queue.go<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\ntype arrayQueue struct {\n    nums        []int // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    front       int   // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    queSize     int   // \u961f\u5217\u957f\u5ea6\n    queCapacity int   // \u961f\u5217\u5bb9\u91cf\uff08\u5373\u6700\u5927\u5bb9\u7eb3\u5143\u7d20\u6570\u91cf\uff09\n}\n\n/* \u521d\u59cb\u5316\u961f\u5217 */\nfunc newArrayQueue(queCapacity int) *arrayQueue {\n    return &amp;arrayQueue{\n        nums:        make([]int, queCapacity),\n        queCapacity: queCapacity,\n        front:       0,\n        queSize:     0,\n    }\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nfunc (q *arrayQueue) size() int {\n    return q.queSize\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nfunc (q *arrayQueue) isEmpty() bool {\n    return q.queSize == 0\n}\n\n/* \u5165\u961f */\nfunc (q *arrayQueue) push(num int) {\n    // \u5f53 rear == queCapacity \u8868\u793a\u961f\u5217\u5df2\u6ee1\n    if q.queSize == q.queCapacity {\n        return\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n    rear := (q.front + q.queSize) % q.queCapacity\n    // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    q.nums[rear] = num\n    q.queSize++\n}\n\n/* \u51fa\u961f */\nfunc (q *arrayQueue) pop() any {\n    num := q.peek()\n    // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n    q.front = (q.front + 1) % q.queCapacity\n    q.queSize--\n    return num\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nfunc (q *arrayQueue) peek() any {\n    if q.isEmpty() {\n        return nil\n    }\n    return q.nums[q.front]\n}\n\n/* \u83b7\u53d6 Slice \u7528\u4e8e\u6253\u5370 */\nfunc (q *arrayQueue) toSlice() []int {\n    rear := (q.front + q.queSize)\n    if rear &gt;= q.queCapacity {\n        rear %= q.queCapacity\n        return append(q.nums[q.front:], q.nums[:rear]...)\n    }\n    return q.nums[q.front:rear]\n}\n</code></pre> array_queue.swift<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n    private var nums: [Int] // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private var front: Int // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private var _size: Int // \u961f\u5217\u957f\u5ea6\n\n    init(capacity: Int) {\n        // \u521d\u59cb\u5316\u6570\u7ec4\n        nums = Array(repeating: 0, count: capacity)\n        front = 0\n        _size = 0\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    func capacity() -&gt; Int {\n        nums.count\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* \u5165\u961f */\n    func push(num: Int) {\n        if size() == capacity() {\n            print(\"\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        let rear = (front + size()) % capacity()\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num\n        _size += 1\n    }\n\n    /* \u51fa\u961f */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        front = (front + 1) % capacity()\n        _size -= 1\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u961f\u5217\u4e3a\u7a7a\")\n        }\n        return nums[front]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4 */\n    func toArray() -&gt; [Int] {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        (front ..&lt; front + size()).map { nums[$0 % capacity()] }\n    }\n}\n</code></pre> array_queue.js<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n    #nums; // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    #front = 0; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    #queSize = 0; // \u961f\u5217\u957f\u5ea6\n\n    constructor(capacity) {\n        this.#nums = new Array(capacity);\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    get capacity() {\n        return this.#nums.length;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    get size() {\n        return this.#queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.#queSize === 0;\n    }\n\n    /* \u5165\u961f */\n    push(num) {\n        if (this.size === this.capacity) {\n            console.log('\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        const rear = (this.#front + this.size) % this.capacity;\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        this.#nums[rear] = num;\n        this.#queSize++;\n    }\n\n    /* \u51fa\u961f */\n    pop() {\n        const num = this.peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        this.#front = (this.#front + 1) % this.capacity;\n        this.#queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peek() {\n        if (this.isEmpty()) throw new Error('\u961f\u5217\u4e3a\u7a7a');\n        return this.#nums[this.#front];\n    }\n\n    /* \u8fd4\u56de Array */\n    toArray() {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(this.size);\n        for (let i = 0, j = this.#front; i &lt; this.size; i++, j++) {\n            arr[i] = this.#nums[j % this.capacity];\n        }\n        return arr;\n    }\n}\n</code></pre> array_queue.ts<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n    private nums: number[]; // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private front: number; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private queSize: number; // \u961f\u5217\u957f\u5ea6\n\n    constructor(capacity: number) {\n        this.nums = new Array(capacity);\n        this.front = this.queSize = 0;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    get capacity(): number {\n        return this.nums.length;\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    get size(): number {\n        return this.queSize;\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.queSize === 0;\n    }\n\n    /* \u5165\u961f */\n    push(num: number): void {\n        if (this.size === this.capacity) {\n            console.log('\u961f\u5217\u5df2\u6ee1');\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        const rear = (this.front + this.queSize) % this.capacity;\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        this.nums[rear] = num;\n        this.queSize++;\n    }\n\n    /* \u51fa\u961f */\n    pop(): number {\n        const num = this.peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        this.front = (this.front + 1) % this.capacity;\n        this.queSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    peek(): number {\n        if (this.isEmpty()) throw new Error('\u961f\u5217\u4e3a\u7a7a');\n        return this.nums[this.front];\n    }\n\n    /* \u8fd4\u56de Array */\n    toArray(): number[] {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        const arr = new Array(this.size);\n        for (let i = 0, j = this.front; i &lt; this.size; i++, j++) {\n            arr[i] = this.nums[j % this.capacity];\n        }\n        return arr;\n    }\n}\n</code></pre> array_queue.dart<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue {\n  late List&lt;int&gt; _nums; // \u7528\u4e8e\u50a8\u5b58\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n  late int _front; // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n  late int _queSize; // \u961f\u5217\u957f\u5ea6\n\n  ArrayQueue(int capacity) {\n    _nums = List.filled(capacity, 0);\n    _front = _queSize = 0;\n  }\n\n  /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n  int capaCity() {\n    return _nums.length;\n  }\n\n  /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n  int size() {\n    return _queSize;\n  }\n\n  /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return _queSize == 0;\n  }\n\n  /* \u5165\u961f */\n  void push(int _num) {\n    if (_queSize == capaCity()) {\n      throw Exception(\"\u961f\u5217\u5df2\u6ee1\");\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n    int rear = (_front + _queSize) % capaCity();\n    // \u5c06 _num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    _nums[rear] = _num;\n    _queSize++;\n  }\n\n  /* \u51fa\u961f */\n  int pop() {\n    int _num = peek();\n    // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n    _front = (_front + 1) % capaCity();\n    _queSize--;\n    return _num;\n  }\n\n  /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n  int peek() {\n    if (isEmpty()) {\n      throw Exception(\"\u961f\u5217\u4e3a\u7a7a\");\n    }\n    return _nums[_front];\n  }\n\n  /* \u8fd4\u56de Array */\n  List&lt;int&gt; toArray() {\n    // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n    final List&lt;int&gt; res = List.filled(_queSize, 0);\n    for (int i = 0, j = _front; i &lt; _queSize; i++, j++) {\n      res[i] = _nums[j % capaCity()];\n    }\n    return res;\n  }\n}\n</code></pre> array_queue.rs<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nstruct ArrayQueue {\n    nums: Vec&lt;i32&gt;,    // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    front: i32,        // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    que_size: i32,     // \u961f\u5217\u957f\u5ea6\n    que_capacity: i32, // \u961f\u5217\u5bb9\u91cf\n}\n\nimpl ArrayQueue {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    fn new(capacity: i32) -&gt; ArrayQueue {\n        ArrayQueue {\n            nums: vec![0; capacity as usize],\n            front: 0,\n            que_size: 0,\n            que_capacity: capacity,\n        }\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    fn capacity(&amp;self) -&gt; i32 {\n        self.que_capacity\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    fn size(&amp;self) -&gt; i32 {\n        self.que_size\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    fn is_empty(&amp;self) -&gt; bool {\n        self.que_size == 0\n    }\n\n    /* \u5165\u961f */\n    fn push(&amp;mut self, num: i32) {\n        if self.que_size == self.capacity() {\n            println!(\"\u961f\u5217\u5df2\u6ee1\");\n            return;\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        let rear = (self.front + self.que_size) % self.que_capacity;\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        self.nums[rear as usize] = num;\n        self.que_size += 1;\n    }\n\n    /* \u51fa\u961f */\n    fn pop(&amp;mut self) -&gt; i32 {\n        let num = self.peek();\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        self.front = (self.front + 1) % self.que_capacity;\n        self.que_size -= 1;\n        num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fn peek(&amp;self) -&gt; i32 {\n        if self.is_empty() {\n            panic!(\"index out of bounds\");\n        }\n        self.nums[self.front as usize]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4 */\n    fn to_vector(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let cap = self.que_capacity;\n        let mut j = self.front;\n        let mut arr = vec![0; self.que_size as usize];\n        for i in 0..self.que_size {\n            arr[i as usize] = self.nums[(j % cap) as usize];\n            j += 1;\n        }\n        arr\n    }\n}\n</code></pre> array_queue.c<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\ntypedef struct {\n    int *nums;       // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    int front;       // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    int queSize;     // \u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e + 1\n    int queCapacity; // \u961f\u5217\u5bb9\u91cf\n} ArrayQueue;\n\n/* \u6784\u9020\u51fd\u6570 */\nArrayQueue *newArrayQueue(int capacity) {\n    ArrayQueue *queue = (ArrayQueue *)malloc(sizeof(ArrayQueue));\n    // \u521d\u59cb\u5316\u6570\u7ec4\n    queue-&gt;queCapacity = capacity;\n    queue-&gt;nums = (int *)malloc(sizeof(int) * queue-&gt;queCapacity);\n    queue-&gt;front = queue-&gt;queSize = 0;\n    return queue;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delArrayQueue(ArrayQueue *queue) {\n    free(queue-&gt;nums);\n    free(queue);\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\nint capacity(ArrayQueue *queue) {\n    return queue-&gt;queCapacity;\n}\n\n/* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\nint size(ArrayQueue *queue) {\n    return queue-&gt;queSize;\n}\n\n/* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\nbool empty(ArrayQueue *queue) {\n    return queue-&gt;queSize == 0;\n}\n\n/* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\nint peek(ArrayQueue *queue) {\n    assert(size(queue) != 0);\n    return queue-&gt;nums[queue-&gt;front];\n}\n\n/* \u5165\u961f */\nvoid push(ArrayQueue *queue, int num) {\n    if (size(queue) == capacity(queue)) {\n        printf(\"\u961f\u5217\u5df2\u6ee1\\r\\n\");\n        return;\n    }\n    // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n    int rear = (queue-&gt;front + queue-&gt;queSize) % queue-&gt;queCapacity;\n    // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    queue-&gt;nums[rear] = num;\n    queue-&gt;queSize++;\n}\n\n/* \u51fa\u961f */\nint pop(ArrayQueue *queue) {\n    int num = peek(queue);\n    // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;queCapacity;\n    queue-&gt;queSize--;\n    return num;\n}\n</code></pre> array_queue.kt<pre><code>/* \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 */\nclass ArrayQueue(capacity: Int) {\n    private val nums: IntArray = IntArray(capacity) // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    private var front: Int = 0 // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    private var queSize: Int = 0 // \u961f\u5217\u957f\u5ea6\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf */\n    fun capacity(): Int {\n        return nums.size\n    }\n\n    /* \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return queSize\n    }\n\n    /* \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return queSize == 0\n    }\n\n    /* \u5165\u961f */\n    fun push(num: Int) {\n        if (queSize == capacity()) {\n            println(\"\u961f\u5217\u5df2\u6ee1\")\n            return\n        }\n        // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n        // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n        val rear = (front + queSize) % capacity()\n        // \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n        nums[rear] = num\n        queSize++\n    }\n\n    /* \u51fa\u961f */\n    fun pop(): Int {\n        val num = peek()\n        // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n        front = (front + 1) % capacity()\n        queSize--\n        return num\n    }\n\n    /* \u8bbf\u95ee\u961f\u9996\u5143\u7d20 */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return nums[front]\n    }\n\n    /* \u8fd4\u56de\u6570\u7ec4 */\n    fun toArray(): IntArray {\n        // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n        val res = IntArray(queSize)\n        var i = 0\n        var j = front\n        while (i &lt; queSize) {\n            res[i] = nums[j % capacity()]\n            i++\n            j++\n        }\n        return res\n    }\n}\n</code></pre> array_queue.rb<pre><code>### \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217 ###\nclass ArrayQueue\n  ### \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6 ###\n  attr_reader :size\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize(size)\n    @nums = Array.new(size, 0) # \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4\n    @front = 0 # \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n    @size = 0 # \u961f\u5217\u957f\u5ea6\n  end\n\n  ### \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf ###\n  def capacity\n    @nums.length\n  end\n\n  ### \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    size.zero?\n  end\n\n  ### \u5165\u961f ###\n  def push(num)\n    raise IndexError, '\u961f\u5217\u5df2\u6ee1' if size == capacity\n\n    # \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n    # \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n    rear = (@front + size) % capacity\n    # \u5c06 num \u6dfb\u52a0\u81f3\u961f\u5c3e\n    @nums[rear] = num\n    @size += 1\n  end\n\n  ### \u51fa\u961f ###\n  def pop\n    num = peek\n    # \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n    @front = (@front + 1) % capacity\n    @size -= 1\n    num\n  end\n\n  ### \u8bbf\u95ee\u961f\u9996\u5143\u7d20 ###\n  def peek\n    raise IndexError, '\u961f\u5217\u4e3a\u7a7a' if is_empty?\n\n    @nums[@front]\n  end\n\n  ### \u8fd4\u56de\u5217\u8868\u7528\u4e8e\u6253\u5370 ###\n  def to_array\n    res = Array.new(size, 0)\n    j = @front\n\n    for i in 0...size\n      res[i] = @nums[j % capacity]\n      j += 1\n    end\n\n    res\n  end\nend\n</code></pre> array_queue.zig<pre><code>// \u57fa\u4e8e\u73af\u5f62\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217\nfn ArrayQueue(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        nums: []T = undefined,                          // \u7528\u4e8e\u5b58\u50a8\u961f\u5217\u5143\u7d20\u7684\u6570\u7ec4     \n        cap: usize = 0,                                 // \u961f\u5217\u5bb9\u91cf\n        front: usize = 0,                               // \u961f\u9996\u6307\u9488\uff0c\u6307\u5411\u961f\u9996\u5143\u7d20\n        queSize: usize = 0,                             // \u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e + 1\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined,   // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u6570\u7ec4\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator, cap: usize) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.cap = cap;\n            self.nums = try self.mem_allocator.alloc(T, self.cap);\n            @memset(self.nums, @as(T, 0));\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u961f\u5217\u7684\u5bb9\u91cf\n        pub fn capacity(self: *Self) usize {\n            return self.cap;\n        }\n\n        // \u83b7\u53d6\u961f\u5217\u7684\u957f\u5ea6\n        pub fn size(self: *Self) usize {\n            return self.queSize;\n        }\n\n        // \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\n        pub fn isEmpty(self: *Self) bool {\n            return self.queSize == 0;\n        }\n\n        // \u5165\u961f\n        pub fn push(self: *Self, num: T) !void {\n            if (self.size() == self.capacity()) {\n                std.debug.print(\"\u961f\u5217\u5df2\u6ee1\\n\", .{});\n                return;\n            }\n            // \u8ba1\u7b97\u961f\u5c3e\u6307\u9488\uff0c\u6307\u5411\u961f\u5c3e\u7d22\u5f15 + 1\n            // \u901a\u8fc7\u53d6\u4f59\u64cd\u4f5c\u5b9e\u73b0 rear \u8d8a\u8fc7\u6570\u7ec4\u5c3e\u90e8\u540e\u56de\u5230\u5934\u90e8\n            var rear = (self.front + self.queSize) % self.capacity();\n            // \u5728\u5c3e\u8282\u70b9\u540e\u6dfb\u52a0 num\n            self.nums[rear] = num;\n            self.queSize += 1;\n        } \n\n        // \u51fa\u961f\n        pub fn pop(self: *Self) T {\n            var num = self.peek();\n            // \u961f\u9996\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u82e5\u8d8a\u8fc7\u5c3e\u90e8\uff0c\u5219\u8fd4\u56de\u5230\u6570\u7ec4\u5934\u90e8\n            self.front = (self.front + 1) % self.capacity();\n            self.queSize -= 1;\n            return num;\n        } \n\n        // \u8bbf\u95ee\u961f\u9996\u5143\u7d20\n        pub fn peek(self: *Self) T {\n            if (self.isEmpty()) @panic(\"\u961f\u5217\u4e3a\u7a7a\");\n            return self.nums[self.front];\n        } \n\n        // \u8fd4\u56de\u6570\u7ec4\n        pub fn toArray(self: *Self) ![]T {\n            // \u4ec5\u8f6c\u6362\u6709\u6548\u957f\u5ea6\u8303\u56f4\u5185\u7684\u5217\u8868\u5143\u7d20\n            var res = try self.mem_allocator.alloc(T, self.size());\n            @memset(res, @as(T, 0));\n            var i: usize = 0;\n            var j: usize = self.front;\n            while (i &lt; self.size()) : ({ i += 1; j += 1; }) {\n                res[i] = self.nums[j % self.capacity()];\n            }\n            return res;\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>The above implementation of the queue still has its limitations: its length is fixed. However, this issue is not difficult to resolve. We can replace the array with a dynamic array that can expand itself if needed. Interested readers can try to implement this themselves.</p> <p>The comparison of the two implementations is consistent with that of the stack and is not repeated here.</p>"},{"location":"chapter_stack_and_queue/queue/#523-typical-applications-of-queue","title":"5.2.3 \u00a0 Typical applications of queue","text":"<ul> <li>Amazon orders: After shoppers place orders, these orders join a queue, and the system processes them in order. During events like Singles' Day, a massive number of orders are generated in a short time, making high concurrency a key challenge for engineers.</li> <li>Various to-do lists: Any scenario requiring a \"first-come, first-served\" functionality, such as a printer's task queue or a restaurant's food delivery queue, can effectively maintain the order of processing with a queue.</li> </ul>"},{"location":"chapter_stack_and_queue/stack/","title":"5.1 \u00a0 Stack","text":"<p>A stack is a linear data structure that follows the principle of Last-In-First-Out (LIFO).</p> <p>We can compare a stack to a pile of plates on a table. To access the bottom plate, one must first remove the plates on top. By replacing the plates with various types of elements (such as integers, characters, objects, etc.), we obtain the data structure known as a stack.</p> <p>As shown in Figure 5-1, we refer to the top of the pile of elements as the \"top of the stack\" and the bottom as the \"bottom of the stack.\" The operation of adding elements to the top of the stack is called \"push,\" and the operation of removing the top element is called \"pop.\"</p> <p></p> <p> Figure 5-1 \u00a0 Stack's last-in-first-out rule </p>"},{"location":"chapter_stack_and_queue/stack/#511-common-operations-on-stack","title":"5.1.1 \u00a0 Common operations on stack","text":"<p>The common operations on a stack are shown in Table 5-1. The specific method names depend on the programming language used. Here, we use <code>push()</code>, <code>pop()</code>, and <code>peek()</code> as examples.</p> <p> Table 5-1 \u00a0 Efficiency of stack operations </p> Method Description Time Complexity <code>push()</code> Push an element onto the stack (add to the top) \\(O(1)\\) <code>pop()</code> Pop the top element from the stack \\(O(1)\\) <code>peek()</code> Access the top element of the stack \\(O(1)\\) <p>Typically, we can directly use the stack class built into the programming language. However, some languages may not specifically provide a stack class. In these cases, we can use the language's \"array\" or \"linked list\" as a stack and ignore operations that are not related to stack logic in the program.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig stack.py<pre><code># Initialize the stack\n# Python does not have a built-in stack class, so a list can be used as a stack\nstack: list[int] = []\n\n# Push elements onto the stack\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n# Access the top element of the stack\npeek: int = stack[-1]\n\n# Pop an element from the stack\npop: int = stack.pop()\n\n# Get the length of the stack\nsize: int = len(stack)\n\n# Check if the stack is empty\nis_empty: bool = len(stack) == 0\n</code></pre> stack.cpp<pre><code>/* Initialize the stack */\nstack&lt;int&gt; stack;\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nint top = stack.top();\n\n/* Pop an element from the stack */\nstack.pop(); // No return value\n\n/* Get the length of the stack */\nint size = stack.size();\n\n/* Check if the stack is empty */\nbool empty = stack.empty();\n</code></pre> stack.java<pre><code>/* Initialize the stack */\nStack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nint peek = stack.peek();\n\n/* Pop an element from the stack */\nint pop = stack.pop();\n\n/* Get the length of the stack */\nint size = stack.size();\n\n/* Check if the stack is empty */\nboolean isEmpty = stack.isEmpty();\n</code></pre> stack.cs<pre><code>/* Initialize the stack */\nStack&lt;int&gt; stack = new();\n\n/* Push elements onto the stack */\nstack.Push(1);\nstack.Push(3);\nstack.Push(2);\nstack.Push(5);\nstack.Push(4);\n\n/* Access the top element of the stack */\nint peek = stack.Peek();\n\n/* Pop an element from the stack */\nint pop = stack.Pop();\n\n/* Get the length of the stack */\nint size = stack.Count;\n\n/* Check if the stack is empty */\nbool isEmpty = stack.Count == 0;\n</code></pre> stack_test.go<pre><code>/* Initialize the stack */\n// In Go, it is recommended to use a Slice as a stack\nvar stack []int\n\n/* Push elements onto the stack */\nstack = append(stack, 1)\nstack = append(stack, 3)\nstack = append(stack, 2)\nstack = append(stack, 5)\nstack = append(stack, 4)\n\n/* Access the top element of the stack */\npeek := stack[len(stack)-1]\n\n/* Pop an element from the stack */\npop := stack[len(stack)-1]\nstack = stack[:len(stack)-1]\n\n/* Get the length of the stack */\nsize := len(stack)\n\n/* Check if the stack is empty */\nisEmpty := len(stack) == 0\n</code></pre> stack.swift<pre><code>/* Initialize the stack */\n// Swift does not have a built-in stack class, so Array can be used as a stack\nvar stack: [Int] = []\n\n/* Push elements onto the stack */\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n/* Access the top element of the stack */\nlet peek = stack.last!\n\n/* Pop an element from the stack */\nlet pop = stack.removeLast()\n\n/* Get the length of the stack */\nlet size = stack.count\n\n/* Check if the stack is empty */\nlet isEmpty = stack.isEmpty\n</code></pre> stack.js<pre><code>/* Initialize the stack */\n// JavaScript does not have a built-in stack class, so Array can be used as a stack\nconst stack = [];\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nconst peek = stack[stack.length-1];\n\n/* Pop an element from the stack */\nconst pop = stack.pop();\n\n/* Get the length of the stack */\nconst size = stack.length;\n\n/* Check if the stack is empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.ts<pre><code>/* Initialize the stack */\n// TypeScript does not have a built-in stack class, so Array can be used as a stack\nconst stack: number[] = [];\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nconst peek = stack[stack.length - 1];\n\n/* Pop an element from the stack */\nconst pop = stack.pop();\n\n/* Get the length of the stack */\nconst size = stack.length;\n\n/* Check if the stack is empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.dart<pre><code>/* Initialize the stack */\n// Dart does not have a built-in stack class, so List can be used as a stack\nList&lt;int&gt; stack = [];\n\n/* Push elements onto the stack */\nstack.add(1);\nstack.add(3);\nstack.add(2);\nstack.add(5);\nstack.add(4);\n\n/* Access the top element of the stack */\nint peek = stack.last;\n\n/* Pop an element from the stack */\nint pop = stack.removeLast();\n\n/* Get the length of the stack */\nint size = stack.length;\n\n/* Check if the stack is empty */\nbool isEmpty = stack.isEmpty;\n</code></pre> stack.rs<pre><code>/* Initialize the stack */\n// Use Vec as a stack\nlet mut stack: Vec&lt;i32&gt; = Vec::new();\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nlet top = stack.last().unwrap();\n\n/* Pop an element from the stack */\nlet pop = stack.pop().unwrap();\n\n/* Get the length of the stack */\nlet size = stack.len();\n\n/* Check if the stack is empty */\nlet is_empty = stack.is_empty();\n</code></pre> stack.c<pre><code>// C does not provide a built-in stack\n</code></pre> stack.kt<pre><code>\n</code></pre> stack.zig<pre><code>\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/stack/#512-implementing-a-stack","title":"5.1.2 \u00a0 Implementing a stack","text":"<p>To gain a deeper understanding of how a stack operates, let's try implementing a stack class ourselves.</p> <p>A stack follows the principle of Last-In-First-Out, which means we can only add or remove elements at the top of the stack. However, both arrays and linked lists allow adding and removing elements at any position, therefore a stack can be seen as a restricted array or linked list. In other words, we can \"shield\" certain irrelevant operations of an array or linked list, aligning their external behavior with the characteristics of a stack.</p>"},{"location":"chapter_stack_and_queue/stack/#1-implementation-based-on-a-linked-list","title":"1. \u00a0 Implementation based on a linked list","text":"<p>When implementing a stack using a linked list, we can consider the head node of the list as the top of the stack and the tail node as the bottom of the stack.</p> <p>As shown in Figure 5-2, for the push operation, we simply insert elements at the head of the linked list. This method of node insertion is known as \"head insertion.\" For the pop operation, we just need to remove the head node from the list.</p> LinkedListStackpush()pop() <p></p> <p></p> <p></p> <p> Figure 5-2 \u00a0 Implementing Stack with Linked List for Push and Pop Operations </p> <p>Below is an example code for implementing a stack based on a linked list:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig linkedlist_stack.py<pre><code>class LinkedListStack:\n    \"\"\"\u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._peek: ListNode | None = None\n        self._size: int = 0\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u6808\u7684\u957f\u5ea6\"\"\"\n        return self._size\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self._size == 0\n\n    def push(self, val: int):\n        \"\"\"\u5165\u6808\"\"\"\n        node = ListNode(val)\n        node.next = self._peek\n        self._peek = node\n        self._size += 1\n\n    def pop(self) -&gt; int:\n        \"\"\"\u51fa\u6808\"\"\"\n        num = self.peek()\n        self._peek = self._peek.next\n        self._size -= 1\n        return num\n\n    def peek(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u6808\u9876\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u6808\u4e3a\u7a7a\")\n        return self._peek.val\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"\u8f6c\u5316\u4e3a\u5217\u8868\u7528\u4e8e\u6253\u5370\"\"\"\n        arr = []\n        node = self._peek\n        while node:\n            arr.append(node.val)\n            node = node.next\n        arr.reverse()\n        return arr\n</code></pre> linkedlist_stack.cpp<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n  private:\n    ListNode *stackTop; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    int stkSize;        // \u6808\u7684\u957f\u5ea6\n\n  public:\n    LinkedListStack() {\n        stackTop = nullptr;\n        stkSize = 0;\n    }\n\n    ~LinkedListStack() {\n        // \u904d\u5386\u94fe\u8868\u5220\u9664\u8282\u70b9\uff0c\u91ca\u653e\u5185\u5b58\n        freeMemoryLinkedList(stackTop);\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    int size() {\n        return stkSize;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    void push(int num) {\n        ListNode *node = new ListNode(num);\n        node-&gt;next = stackTop;\n        stackTop = node;\n        stkSize++;\n    }\n\n    /* \u51fa\u6808 */\n    int pop() {\n        int num = top();\n        ListNode *tmp = stackTop;\n        stackTop = stackTop-&gt;next;\n        // \u91ca\u653e\u5185\u5b58\n        delete tmp;\n        stkSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"\u6808\u4e3a\u7a7a\");\n        return stackTop-&gt;val;\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    vector&lt;int&gt; toVector() {\n        ListNode *node = stackTop;\n        vector&lt;int&gt; res(size());\n        for (int i = res.size() - 1; i &gt;= 0; i--) {\n            res[i] = node-&gt;val;\n            node = node-&gt;next;\n        }\n        return res;\n    }\n};\n</code></pre> linkedlist_stack.java<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n    private ListNode stackPeek; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    private int stkSize = 0; // \u6808\u7684\u957f\u5ea6\n\n    public LinkedListStack() {\n        stackPeek = null;\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    public int size() {\n        return stkSize;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    public void push(int num) {\n        ListNode node = new ListNode(num);\n        node.next = stackPeek;\n        stackPeek = node;\n        stkSize++;\n    }\n\n    /* \u51fa\u6808 */\n    public int pop() {\n        int num = peek();\n        stackPeek = stackPeek.next;\n        stkSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stackPeek.val;\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public int[] toArray() {\n        ListNode node = stackPeek;\n        int[] res = new int[size()];\n        for (int i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.cs<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n    ListNode? stackPeek;  // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    int stkSize = 0;   // \u6808\u7684\u957f\u5ea6\n\n    public LinkedListStack() {\n        stackPeek = null;\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    public int Size() {\n        return stkSize;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    public void Push(int num) {\n        ListNode node = new(num) {\n            next = stackPeek\n        };\n        stackPeek = node;\n        stkSize++;\n    }\n\n    /* \u51fa\u6808 */\n    public int Pop() {\n        int num = Peek();\n        stackPeek = stackPeek!.next;\n        stkSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return stackPeek!.val;\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public int[] ToArray() {\n        if (stackPeek == null)\n            return [];\n\n        ListNode? node = stackPeek;\n        int[] res = new int[Size()];\n        for (int i = res.Length - 1; i &gt;= 0; i--) {\n            res[i] = node!.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.go<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\ntype linkedListStack struct {\n    // \u4f7f\u7528\u5185\u7f6e\u5305 list \u6765\u5b9e\u73b0\u6808\n    data *list.List\n}\n\n/* \u521d\u59cb\u5316\u6808 */\nfunc newLinkedListStack() *linkedListStack {\n    return &amp;linkedListStack{\n        data: list.New(),\n    }\n}\n\n/* \u5165\u6808 */\nfunc (s *linkedListStack) push(value int) {\n    s.data.PushBack(value)\n}\n\n/* \u51fa\u6808 */\nfunc (s *linkedListStack) pop() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    s.data.Remove(e)\n    return e.Value\n}\n\n/* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\nfunc (s *linkedListStack) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    e := s.data.Back()\n    return e.Value\n}\n\n/* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\nfunc (s *linkedListStack) size() int {\n    return s.data.Len()\n}\n\n/* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\nfunc (s *linkedListStack) isEmpty() bool {\n    return s.data.Len() == 0\n}\n\n/* \u83b7\u53d6 List \u7528\u4e8e\u6253\u5370 */\nfunc (s *linkedListStack) toList() *list.List {\n    return s.data\n}\n</code></pre> linkedlist_stack.swift<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n    private var _peek: ListNode? // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    private var _size: Int // \u6808\u7684\u957f\u5ea6\n\n    init() {\n        _size = 0\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        _size\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        size() == 0\n    }\n\n    /* \u5165\u6808 */\n    func push(num: Int) {\n        let node = ListNode(x: num)\n        node.next = _peek\n        _peek = node\n        _size += 1\n    }\n\n    /* \u51fa\u6808 */\n    @discardableResult\n    func pop() -&gt; Int {\n        let num = peek()\n        _peek = _peek?.next\n        _size -= 1\n        return num\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u6808\u4e3a\u7a7a\")\n        }\n        return _peek!.val\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    func toArray() -&gt; [Int] {\n        var node = _peek\n        var res = Array(repeating: 0, count: size())\n        for i in res.indices.reversed() {\n            res[i] = node!.val\n            node = node?.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_stack.js<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n    #stackPeek; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    #stkSize = 0; // \u6808\u7684\u957f\u5ea6\n\n    constructor() {\n        this.#stackPeek = null;\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    get size() {\n        return this.#stkSize;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    /* \u5165\u6808 */\n    push(num) {\n        const node = new ListNode(num);\n        node.next = this.#stackPeek;\n        this.#stackPeek = node;\n        this.#stkSize++;\n    }\n\n    /* \u51fa\u6808 */\n    pop() {\n        const num = this.peek();\n        this.#stackPeek = this.#stackPeek.next;\n        this.#stkSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    peek() {\n        if (!this.#stackPeek) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.#stackPeek.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    toArray() {\n        let node = this.#stackPeek;\n        const res = new Array(this.size);\n        for (let i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node.val;\n            node = node.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.ts<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n    private stackPeek: ListNode | null; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    private stkSize: number = 0; // \u6808\u7684\u957f\u5ea6\n\n    constructor() {\n        this.stackPeek = null;\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    get size(): number {\n        return this.stkSize;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.size === 0;\n    }\n\n    /* \u5165\u6808 */\n    push(num: number): void {\n        const node = new ListNode(num);\n        node.next = this.stackPeek;\n        this.stackPeek = node;\n        this.stkSize++;\n    }\n\n    /* \u51fa\u6808 */\n    pop(): number {\n        const num = this.peek();\n        if (!this.stackPeek) throw new Error('\u6808\u4e3a\u7a7a');\n        this.stackPeek = this.stackPeek.next;\n        this.stkSize--;\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    peek(): number {\n        if (!this.stackPeek) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.stackPeek.val;\n    }\n\n    /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    toArray(): number[] {\n        let node = this.stackPeek;\n        const res = new Array&lt;number&gt;(this.size);\n        for (let i = res.length - 1; i &gt;= 0; i--) {\n            res[i] = node!.val;\n            node = node!.next;\n        }\n        return res;\n    }\n}\n</code></pre> linkedlist_stack.dart<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u7c7b\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack {\n  ListNode? _stackPeek; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n  int _stkSize = 0; // \u6808\u7684\u957f\u5ea6\n\n  LinkedListStack() {\n    _stackPeek = null;\n  }\n\n  /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n  int size() {\n    return _stkSize;\n  }\n\n  /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return _stkSize == 0;\n  }\n\n  /* \u5165\u6808 */\n  void push(int _num) {\n    final ListNode node = ListNode(_num);\n    node.next = _stackPeek;\n    _stackPeek = node;\n    _stkSize++;\n  }\n\n  /* \u51fa\u6808 */\n  int pop() {\n    final int _num = peek();\n    _stackPeek = _stackPeek!.next;\n    _stkSize--;\n    return _num;\n  }\n\n  /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n  int peek() {\n    if (_stackPeek == null) {\n      throw Exception(\"\u6808\u4e3a\u7a7a\");\n    }\n    return _stackPeek!.val;\n  }\n\n  /* \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a List \u5e76\u8fd4\u56de */\n  List&lt;int&gt; toList() {\n    ListNode? node = _stackPeek;\n    List&lt;int&gt; list = [];\n    while (node != null) {\n      list.add(node.val);\n      node = node.next;\n    }\n    list = list.reversed.toList();\n    return list;\n  }\n}\n</code></pre> linkedlist_stack.rs<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\n#[allow(dead_code)]\npub struct LinkedListStack&lt;T&gt; {\n    stack_peek: Option&lt;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;, // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    stk_size: usize,                              // \u6808\u7684\u957f\u5ea6\n}\n\nimpl&lt;T: Copy&gt; LinkedListStack&lt;T&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            stack_peek: None,\n            stk_size: 0,\n        }\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    pub fn size(&amp;self) -&gt; usize {\n        return self.stk_size;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    pub fn is_empty(&amp;self) -&gt; bool {\n        return self.size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    pub fn push(&amp;mut self, num: T) {\n        let node = ListNode::new(num);\n        node.borrow_mut().next = self.stack_peek.take();\n        self.stack_peek = Some(node);\n        self.stk_size += 1;\n    }\n\n    /* \u51fa\u6808 */\n    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.stack_peek.take().map(|old_head| {\n            match old_head.borrow_mut().next.take() {\n                Some(new_head) =&gt; {\n                    self.stack_peek = Some(new_head);\n                }\n                None =&gt; {\n                    self.stack_peek = None;\n                }\n            }\n            self.stk_size -= 1;\n            Rc::try_unwrap(old_head).ok().unwrap().into_inner().val\n        })\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    pub fn peek(&amp;self) -&gt; Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt; {\n        self.stack_peek.as_ref()\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    pub fn to_array(&amp;self, head: Option&lt;&amp;Rc&lt;RefCell&lt;ListNode&lt;T&gt;&gt;&gt;&gt;) -&gt; Vec&lt;T&gt; {\n        if let Some(node) = head {\n            let mut nums = self.to_array(node.borrow().next.as_ref());\n            nums.push(node.borrow().val);\n            return nums;\n        }\n        return Vec::new();\n    }\n}\n</code></pre> linkedlist_stack.c<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\ntypedef struct {\n    ListNode *top; // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    int size;      // \u6808\u7684\u957f\u5ea6\n} LinkedListStack;\n\n/* \u6784\u9020\u51fd\u6570 */\nLinkedListStack *newLinkedListStack() {\n    LinkedListStack *s = malloc(sizeof(LinkedListStack));\n    s-&gt;top = NULL;\n    s-&gt;size = 0;\n    return s;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delLinkedListStack(LinkedListStack *s) {\n    while (s-&gt;top) {\n        ListNode *n = s-&gt;top-&gt;next;\n        free(s-&gt;top);\n        s-&gt;top = n;\n    }\n    free(s);\n}\n\n/* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\nint size(LinkedListStack *s) {\n    return s-&gt;size;\n}\n\n/* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\nbool isEmpty(LinkedListStack *s) {\n    return size(s) == 0;\n}\n\n/* \u5165\u6808 */\nvoid push(LinkedListStack *s, int num) {\n    ListNode *node = (ListNode *)malloc(sizeof(ListNode));\n    node-&gt;next = s-&gt;top; // \u66f4\u65b0\u65b0\u52a0\u8282\u70b9\u6307\u9488\u57df\n    node-&gt;val = num;     // \u66f4\u65b0\u65b0\u52a0\u8282\u70b9\u6570\u636e\u57df\n    s-&gt;top = node;       // \u66f4\u65b0\u6808\u9876\n    s-&gt;size++;           // \u66f4\u65b0\u6808\u5927\u5c0f\n}\n\n/* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\nint peek(LinkedListStack *s) {\n    if (s-&gt;size == 0) {\n        printf(\"\u6808\u4e3a\u7a7a\\n\");\n        return INT_MAX;\n    }\n    return s-&gt;top-&gt;val;\n}\n\n/* \u51fa\u6808 */\nint pop(LinkedListStack *s) {\n    int val = peek(s);\n    ListNode *tmp = s-&gt;top;\n    s-&gt;top = s-&gt;top-&gt;next;\n    // \u91ca\u653e\u5185\u5b58\n    free(tmp);\n    s-&gt;size--;\n    return val;\n}\n</code></pre> linkedlist_stack.kt<pre><code>/* \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 */\nclass LinkedListStack(\n    private var stackPeek: ListNode? = null, // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n    private var stkSize: Int = 0 // \u6808\u7684\u957f\u5ea6\n) {\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return stkSize\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* \u5165\u6808 */\n    fun push(num: Int) {\n        val node = ListNode(num)\n        node.next = stackPeek\n        stackPeek = node\n        stkSize++\n    }\n\n    /* \u51fa\u6808 */\n    fun pop(): Int? {\n        val num = peek()\n        stackPeek = stackPeek?.next\n        stkSize--\n        return num\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    fun peek(): Int? {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stackPeek?._val\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    fun toArray(): IntArray {\n        var node = stackPeek\n        val res = IntArray(size())\n        for (i in res.size - 1 downTo 0) {\n            res[i] = node?._val!!\n            node = node.next\n        }\n        return res\n    }\n}\n</code></pre> linkedlist_stack.rb<pre><code>### \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808 ###\nclass LinkedListStack\n  attr_reader :size\n\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @size = 0\n  end\n\n  ### \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    @peek.nil?\n  end\n\n  ### \u5165\u6808 ###\n  def push(val)\n    node = ListNode.new(val)\n    node.next = @peek\n    @peek = node\n    @size += 1\n  end\n\n  ### \u51fa\u6808 ###\n  def pop\n    num = peek\n    @peek = @peek.next\n    @size -= 1\n    num\n  end\n\n  ### \u8bbf\u95ee\u6808\u9876\u5143\u7d20 ###\n  def peek\n    raise IndexError, '\u6808\u4e3a\u7a7a' if is_empty?\n\n    @peek.val\n  end\n\n  ### \u5c06\u94fe\u8868\u8f6c\u5316\u4e3a Array \u5e76\u53cd\u56de ###\n  def to_array\n    arr = []\n    node = @peek\n    while node\n      arr &lt;&lt; node.val\n      node = node.next\n    end\n    arr.reverse\n  end\nend\n</code></pre> linkedlist_stack.zig<pre><code>// \u57fa\u4e8e\u94fe\u8868\u5b9e\u73b0\u7684\u6808\nfn LinkedListStack(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        stack_top: ?*inc.ListNode(T) = null,             // \u5c06\u5934\u8282\u70b9\u4f5c\u4e3a\u6808\u9876\n        stk_size: usize = 0,                             // \u6808\u7684\u957f\u5ea6\n        mem_arena: ?std.heap.ArenaAllocator = null,\n        mem_allocator: std.mem.Allocator = undefined,    // \u5185\u5b58\u5206\u914d\u5668\n\n        // \u6784\u9020\u51fd\u6570\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u6808\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n            if (self.mem_arena == null) {\n                self.mem_arena = std.heap.ArenaAllocator.init(allocator);\n                self.mem_allocator = self.mem_arena.?.allocator();\n            }\n            self.stack_top = null;\n            self.stk_size = 0;\n        }\n\n        // \u6790\u6784\u51fd\u6570\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.mem_arena == null) return;\n            self.mem_arena.?.deinit();\n        }\n\n        // \u83b7\u53d6\u6808\u7684\u957f\u5ea6\n        pub fn size(self: *Self) usize {\n            return self.stk_size;\n        }\n\n        // \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\n        pub fn isEmpty(self: *Self) bool {\n            return self.size() == 0;\n        }\n\n        // \u8bbf\u95ee\u6808\u9876\u5143\u7d20\n        pub fn peek(self: *Self) T {\n            if (self.size() == 0) @panic(\"\u6808\u4e3a\u7a7a\");\n            return self.stack_top.?.val;\n        }  \n\n        // \u5165\u6808\n        pub fn push(self: *Self, num: T) !void {\n            var node = try self.mem_allocator.create(inc.ListNode(T));\n            node.init(num);\n            node.next = self.stack_top;\n            self.stack_top = node;\n            self.stk_size += 1;\n        } \n\n        // \u51fa\u6808\n        pub fn pop(self: *Self) T {\n            var num = self.peek();\n            self.stack_top = self.stack_top.?.next;\n            self.stk_size -= 1;\n            return num;\n        } \n\n        // \u5c06\u6808\u8f6c\u6362\u4e3a\u6570\u7ec4\n        pub fn toArray(self: *Self) ![]T {\n            var node = self.stack_top;\n            var res = try self.mem_allocator.alloc(T, self.size());\n            @memset(res, @as(T, 0));\n            var i: usize = 0;\n            while (i &lt; res.len) : (i += 1) {\n                res[res.len - i - 1] = node.?.val;\n                node = node.?.next;\n            }\n            return res;\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/stack/#2-implementation-based-on-an-array","title":"2. \u00a0 Implementation based on an array","text":"<p>When implementing a stack using an array, we can consider the end of the array as the top of the stack. As shown in Figure 5-3, push and pop operations correspond to adding and removing elements at the end of the array, respectively, both with a time complexity of \\(O(1)\\).</p> ArrayStackpush()pop() <p></p> <p></p> <p></p> <p> Figure 5-3 \u00a0 Implementing Stack with Array for Push and Pop Operations </p> <p>Since the elements to be pushed onto the stack may continuously increase, we can use a dynamic array, thus avoiding the need to handle array expansion ourselves. Here is an example code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array_stack.py<pre><code>class ArrayStack:\n    \"\"\"\u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808\"\"\"\n\n    def __init__(self):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._stack: list[int] = []\n\n    def size(self) -&gt; int:\n        \"\"\"\u83b7\u53d6\u6808\u7684\u957f\u5ea6\"\"\"\n        return len(self._stack)\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self.size() == 0\n\n    def push(self, item: int):\n        \"\"\"\u5165\u6808\"\"\"\n        self._stack.append(item)\n\n    def pop(self) -&gt; int:\n        \"\"\"\u51fa\u6808\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u6808\u4e3a\u7a7a\")\n        return self._stack.pop()\n\n    def peek(self) -&gt; int:\n        \"\"\"\u8bbf\u95ee\u6808\u9876\u5143\u7d20\"\"\"\n        if self.is_empty():\n            raise IndexError(\"\u6808\u4e3a\u7a7a\")\n        return self._stack[-1]\n\n    def to_list(self) -&gt; list[int]:\n        \"\"\"\u8fd4\u56de\u5217\u8868\u7528\u4e8e\u6253\u5370\"\"\"\n        return self._stack\n</code></pre> array_stack.cpp<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n  private:\n    vector&lt;int&gt; stack;\n\n  public:\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    int size() {\n        return stack.size();\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    bool isEmpty() {\n        return stack.size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    void push(int num) {\n        stack.push_back(num);\n    }\n\n    /* \u51fa\u6808 */\n    int pop() {\n        int num = top();\n        stack.pop_back();\n        return num;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"\u6808\u4e3a\u7a7a\");\n        return stack.back();\n    }\n\n    /* \u8fd4\u56de Vector */\n    vector&lt;int&gt; toVector() {\n        return stack;\n    }\n};\n</code></pre> array_stack.java<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    private ArrayList&lt;Integer&gt; stack;\n\n    public ArrayStack() {\n        // \u521d\u59cb\u5316\u5217\u8868\uff08\u52a8\u6001\u6570\u7ec4\uff09\n        stack = new ArrayList&lt;&gt;();\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    public int size() {\n        return stack.size();\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    public void push(int num) {\n        stack.add(num);\n    }\n\n    /* \u51fa\u6808 */\n    public int pop() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stack.remove(size() - 1);\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    public int peek() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        return stack.get(size() - 1);\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public Object[] toArray() {\n        return stack.toArray();\n    }\n}\n</code></pre> array_stack.cs<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    List&lt;int&gt; stack;\n    public ArrayStack() {\n        // \u521d\u59cb\u5316\u5217\u8868\uff08\u52a8\u6001\u6570\u7ec4\uff09\n        stack = [];\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    public int Size() {\n        return stack.Count;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    public bool IsEmpty() {\n        return Size() == 0;\n    }\n\n    /* \u5165\u6808 */\n    public void Push(int num) {\n        stack.Add(num);\n    }\n\n    /* \u51fa\u6808 */\n    public int Pop() {\n        if (IsEmpty())\n            throw new Exception();\n        var val = Peek();\n        stack.RemoveAt(Size() - 1);\n        return val;\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    public int Peek() {\n        if (IsEmpty())\n            throw new Exception();\n        return stack[Size() - 1];\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    public int[] ToArray() {\n        return [.. stack];\n    }\n}\n</code></pre> array_stack.go<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\ntype arrayStack struct {\n    data []int // \u6570\u636e\n}\n\n/* \u521d\u59cb\u5316\u6808 */\nfunc newArrayStack() *arrayStack {\n    return &amp;arrayStack{\n        // \u8bbe\u7f6e\u6808\u7684\u957f\u5ea6\u4e3a 0\uff0c\u5bb9\u91cf\u4e3a 16\n        data: make([]int, 0, 16),\n    }\n}\n\n/* \u6808\u7684\u957f\u5ea6 */\nfunc (s *arrayStack) size() int {\n    return len(s.data)\n}\n\n/* \u6808\u662f\u5426\u4e3a\u7a7a */\nfunc (s *arrayStack) isEmpty() bool {\n    return s.size() == 0\n}\n\n/* \u5165\u6808 */\nfunc (s *arrayStack) push(v int) {\n    // \u5207\u7247\u4f1a\u81ea\u52a8\u6269\u5bb9\n    s.data = append(s.data, v)\n}\n\n/* \u51fa\u6808 */\nfunc (s *arrayStack) pop() any {\n    val := s.peek()\n    s.data = s.data[:len(s.data)-1]\n    return val\n}\n\n/* \u83b7\u53d6\u6808\u9876\u5143\u7d20 */\nfunc (s *arrayStack) peek() any {\n    if s.isEmpty() {\n        return nil\n    }\n    val := s.data[len(s.data)-1]\n    return val\n}\n\n/* \u83b7\u53d6 Slice \u7528\u4e8e\u6253\u5370 */\nfunc (s *arrayStack) toSlice() []int {\n    return s.data\n}\n</code></pre> array_stack.swift<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    private var stack: [Int]\n\n    init() {\n        // \u521d\u59cb\u5316\u5217\u8868\uff08\u52a8\u6001\u6570\u7ec4\uff09\n        stack = []\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    func size() -&gt; Int {\n        stack.count\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    func isEmpty() -&gt; Bool {\n        stack.isEmpty\n    }\n\n    /* \u5165\u6808 */\n    func push(num: Int) {\n        stack.append(num)\n    }\n\n    /* \u51fa\u6808 */\n    @discardableResult\n    func pop() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u6808\u4e3a\u7a7a\")\n        }\n        return stack.removeLast()\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    func peek() -&gt; Int {\n        if isEmpty() {\n            fatalError(\"\u6808\u4e3a\u7a7a\")\n        }\n        return stack.last!\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    func toArray() -&gt; [Int] {\n        stack\n    }\n}\n</code></pre> array_stack.js<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    #stack;\n    constructor() {\n        this.#stack = [];\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    get size() {\n        return this.#stack.length;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    isEmpty() {\n        return this.#stack.length === 0;\n    }\n\n    /* \u5165\u6808 */\n    push(num) {\n        this.#stack.push(num);\n    }\n\n    /* \u51fa\u6808 */\n    pop() {\n        if (this.isEmpty()) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.#stack.pop();\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    top() {\n        if (this.isEmpty()) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.#stack[this.#stack.length - 1];\n    }\n\n    /* \u8fd4\u56de Array */\n    toArray() {\n        return this.#stack;\n    }\n}\n</code></pre> array_stack.ts<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    private stack: number[];\n    constructor() {\n        this.stack = [];\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    get size(): number {\n        return this.stack.length;\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    isEmpty(): boolean {\n        return this.stack.length === 0;\n    }\n\n    /* \u5165\u6808 */\n    push(num: number): void {\n        this.stack.push(num);\n    }\n\n    /* \u51fa\u6808 */\n    pop(): number | undefined {\n        if (this.isEmpty()) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.stack.pop();\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    top(): number | undefined {\n        if (this.isEmpty()) throw new Error('\u6808\u4e3a\u7a7a');\n        return this.stack[this.stack.length - 1];\n    }\n\n    /* \u8fd4\u56de Array */\n    toArray() {\n        return this.stack;\n    }\n}\n</code></pre> array_stack.dart<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n  late List&lt;int&gt; _stack;\n  ArrayStack() {\n    _stack = [];\n  }\n\n  /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n  int size() {\n    return _stack.length;\n  }\n\n  /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n  bool isEmpty() {\n    return _stack.isEmpty;\n  }\n\n  /* \u5165\u6808 */\n  void push(int _num) {\n    _stack.add(_num);\n  }\n\n  /* \u51fa\u6808 */\n  int pop() {\n    if (isEmpty()) {\n      throw Exception(\"\u6808\u4e3a\u7a7a\");\n    }\n    return _stack.removeLast();\n  }\n\n  /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n  int peek() {\n    if (isEmpty()) {\n      throw Exception(\"\u6808\u4e3a\u7a7a\");\n    }\n    return _stack.last;\n  }\n\n  /* \u5c06\u6808\u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n  List&lt;int&gt; toArray() =&gt; _stack;\n}\n</code></pre> array_stack.rs<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nstruct ArrayStack&lt;T&gt; {\n    stack: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ArrayStack&lt;T&gt; {\n    /* \u521d\u59cb\u5316\u6808 */\n    fn new() -&gt; ArrayStack&lt;T&gt; {\n        ArrayStack::&lt;T&gt; {\n            stack: Vec::&lt;T&gt;::new(),\n        }\n    }\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    fn size(&amp;self) -&gt; usize {\n        self.stack.len()\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    fn is_empty(&amp;self) -&gt; bool {\n        self.size() == 0\n    }\n\n    /* \u5165\u6808 */\n    fn push(&amp;mut self, num: T) {\n        self.stack.push(num);\n    }\n\n    /* \u51fa\u6808 */\n    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {\n        self.stack.pop()\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {\n        if self.is_empty() {\n            panic!(\"\u6808\u4e3a\u7a7a\")\n        };\n        self.stack.last()\n    }\n\n    /* \u8fd4\u56de &amp;Vec */\n    fn to_array(&amp;self) -&gt; &amp;Vec&lt;T&gt; {\n        &amp;self.stack\n    }\n}\n</code></pre> array_stack.c<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\ntypedef struct {\n    int *data;\n    int size;\n} ArrayStack;\n\n/* \u6784\u9020\u51fd\u6570 */\nArrayStack *newArrayStack() {\n    ArrayStack *stack = malloc(sizeof(ArrayStack));\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5927\u5bb9\u91cf\uff0c\u907f\u514d\u6269\u5bb9\n    stack-&gt;data = malloc(sizeof(int) * MAX_SIZE);\n    stack-&gt;size = 0;\n    return stack;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delArrayStack(ArrayStack *stack) {\n    free(stack-&gt;data);\n    free(stack);\n}\n\n/* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\nint size(ArrayStack *stack) {\n    return stack-&gt;size;\n}\n\n/* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\nbool isEmpty(ArrayStack *stack) {\n    return stack-&gt;size == 0;\n}\n\n/* \u5165\u6808 */\nvoid push(ArrayStack *stack, int num) {\n    if (stack-&gt;size == MAX_SIZE) {\n        printf(\"\u6808\u5df2\u6ee1\\n\");\n        return;\n    }\n    stack-&gt;data[stack-&gt;size] = num;\n    stack-&gt;size++;\n}\n\n/* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\nint peek(ArrayStack *stack) {\n    if (stack-&gt;size == 0) {\n        printf(\"\u6808\u4e3a\u7a7a\\n\");\n        return INT_MAX;\n    }\n    return stack-&gt;data[stack-&gt;size - 1];\n}\n\n/* \u51fa\u6808 */\nint pop(ArrayStack *stack) {\n    int val = peek(stack);\n    stack-&gt;size--;\n    return val;\n}\n</code></pre> array_stack.kt<pre><code>/* \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 */\nclass ArrayStack {\n    // \u521d\u59cb\u5316\u5217\u8868\uff08\u52a8\u6001\u6570\u7ec4\uff09\n    private val stack = mutableListOf&lt;Int&gt;()\n\n    /* \u83b7\u53d6\u6808\u7684\u957f\u5ea6 */\n    fun size(): Int {\n        return stack.size\n    }\n\n    /* \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a */\n    fun isEmpty(): Boolean {\n        return size() == 0\n    }\n\n    /* \u5165\u6808 */\n    fun push(num: Int) {\n        stack.add(num)\n    }\n\n    /* \u51fa\u6808 */\n    fun pop(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stack.removeAt(size() - 1)\n    }\n\n    /* \u8bbf\u95ee\u6808\u9876\u5143\u7d20 */\n    fun peek(): Int {\n        if (isEmpty()) throw IndexOutOfBoundsException()\n        return stack[size() - 1]\n    }\n\n    /* \u5c06 List \u8f6c\u5316\u4e3a Array \u5e76\u8fd4\u56de */\n    fun toArray(): Array&lt;Any&gt; {\n        return stack.toTypedArray()\n    }\n}\n</code></pre> array_stack.rb<pre><code>### \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808 ###\nclass ArrayStack\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize\n    @stack = []\n  end\n\n  ### \u83b7\u53d6\u6808\u7684\u957f\u5ea6 ###\n  def size\n    @stack.length\n  end\n\n  ### \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a ###\n  def is_empty?\n    @stack.empty?\n  end\n\n  ### \u5165\u6808 ###\n  def push(item)\n    @stack &lt;&lt; item\n  end\n\n  ### \u51fa\u6808 ###\n  def pop\n    raise IndexError, '\u6808\u4e3a\u7a7a' if is_empty?\n\n    @stack.pop\n  end\n\n  ### \u8bbf\u95ee\u6808\u9876\u5143\u7d20 ###\n  def peek\n    raise IndexError, '\u6808\u4e3a\u7a7a' if is_empty?\n\n    @stack.last\n  end\n\n  ### \u8fd4\u56de\u5217\u8868\u7528\u4e8e\u6253\u5370 ###\n  def to_array\n    @stack\n  end\nend\n</code></pre> array_stack.zig<pre><code>// \u57fa\u4e8e\u6570\u7ec4\u5b9e\u73b0\u7684\u6808\nfn ArrayStack(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        stack: ?std.ArrayList(T) = null,     \n\n        // \u6784\u9020\u65b9\u6cd5\uff08\u5206\u914d\u5185\u5b58+\u521d\u59cb\u5316\u6808\uff09\n        pub fn init(self: *Self, allocator: std.mem.Allocator) void {\n            if (self.stack == null) {\n                self.stack = std.ArrayList(T).init(allocator);\n            }\n        }\n\n        // \u6790\u6784\u65b9\u6cd5\uff08\u91ca\u653e\u5185\u5b58\uff09\n        pub fn deinit(self: *Self) void {\n            if (self.stack == null) return;\n            self.stack.?.deinit();\n        }\n\n        // \u83b7\u53d6\u6808\u7684\u957f\u5ea6\n        pub fn size(self: *Self) usize {\n            return self.stack.?.items.len;\n        }\n\n        // \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\n        pub fn isEmpty(self: *Self) bool {\n            return self.size() == 0;\n        }\n\n        // \u8bbf\u95ee\u6808\u9876\u5143\u7d20\n        pub fn peek(self: *Self) T {\n            if (self.isEmpty()) @panic(\"\u6808\u4e3a\u7a7a\");\n            return self.stack.?.items[self.size() - 1];\n        }  \n\n        // \u5165\u6808\n        pub fn push(self: *Self, num: T) !void {\n            try self.stack.?.append(num);\n        } \n\n        // \u51fa\u6808\n        pub fn pop(self: *Self) T {\n            var num = self.stack.?.pop();\n            return num;\n        } \n\n        // \u8fd4\u56de ArrayList\n        pub fn toList(self: *Self) std.ArrayList(T) {\n            return self.stack.?;\n        }\n    };\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_stack_and_queue/stack/#513-comparison-of-the-two-implementations","title":"5.1.3 \u00a0 Comparison of the two implementations","text":"<p>Supported Operations</p> <p>Both implementations support all the operations defined in a stack. The array implementation additionally supports random access, but this is beyond the scope of a stack definition and is generally not used.</p> <p>Time Efficiency</p> <p>In the array-based implementation, both push and pop operations occur in pre-allocated contiguous memory, which has good cache locality and therefore higher efficiency. However, if the push operation exceeds the array capacity, it triggers a resizing mechanism, making the time complexity of that push operation \\(O(n)\\).</p> <p>In the linked list implementation, list expansion is very flexible, and there is no efficiency decrease issue as in array expansion. However, the push operation requires initializing a node object and modifying pointers, so its efficiency is relatively lower. If the elements being pushed are already node objects, then the initialization step can be skipped, improving efficiency.</p> <p>Thus, when the elements for push and pop operations are basic data types like <code>int</code> or <code>double</code>, we can draw the following conclusions:</p> <ul> <li>The array-based stack implementation's efficiency decreases during expansion, but since expansion is a low-frequency operation, its average efficiency is higher.</li> <li>The linked list-based stack implementation provides more stable efficiency performance.</li> </ul> <p>Space Efficiency</p> <p>When initializing a list, the system allocates an \"initial capacity,\" which might exceed the actual need; moreover, the expansion mechanism usually increases capacity by a specific factor (like doubling), which may also exceed the actual need. Therefore, the array-based stack might waste some space.</p> <p>However, since linked list nodes require extra space for storing pointers, the space occupied by linked list nodes is relatively larger.</p> <p>In summary, we cannot simply determine which implementation is more memory-efficient. It requires analysis based on specific circumstances.</p>"},{"location":"chapter_stack_and_queue/stack/#514-typical-applications-of-stack","title":"5.1.4 \u00a0 Typical applications of stack","text":"<ul> <li>Back and forward in browsers, undo and redo in software. Every time we open a new webpage, the browser pushes the previous page onto the stack, allowing us to go back to the previous page through the back operation, which is essentially a pop operation. To support both back and forward, two stacks are needed to work together.</li> <li>Memory management in programs. Each time a function is called, the system adds a stack frame at the top of the stack to record the function's context information. In recursive functions, the downward recursion phase keeps pushing onto the stack, while the upward backtracking phase keeps popping from the stack.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/","title":"5.4 \u00a0 Summary","text":""},{"location":"chapter_stack_and_queue/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>Stack is a data structure that follows the Last-In-First-Out (LIFO) principle and can be implemented using arrays or linked lists.</li> <li>In terms of time efficiency, the array implementation of the stack has a higher average efficiency. However, during expansion, the time complexity for a single push operation can degrade to \\(O(n)\\). In contrast, the linked list implementation of a stack offers more stable efficiency.</li> <li>Regarding space efficiency, the array implementation of the stack may lead to a certain degree of space wastage. However, it's important to note that the memory space occupied by nodes in a linked list is generally larger than that for elements in an array.</li> <li>A queue is a data structure that follows the First-In-First-Out (FIFO) principle, and it can also be implemented using arrays or linked lists. The conclusions regarding time and space efficiency for queues are similar to those for stacks.</li> <li>A double-ended queue (deque) is a more flexible type of queue that allows adding and removing elements at both ends.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: Is the browser's forward and backward functionality implemented with a doubly linked list?</p> <p>A browser's forward and backward navigation is essentially a manifestation of the \"stack\" concept. When a user visits a new page, the page is added to the top of the stack; when they click the back button, the page is popped from the top of the stack. A double-ended queue (deque) can conveniently implement some additional operations, as mentioned in the \"Double-Ended Queue\" section.</p> <p>Q: After popping from a stack, is it necessary to free the memory of the popped node?</p> <p>If the popped node will still be used later, it's not necessary to free its memory. In languages like Java and Python that have automatic garbage collection, manual memory release is not necessary; in C and C++, manual memory release is required.</p> <p>Q: A double-ended queue seems like two stacks joined together. What are its uses?</p> <p>A double-ended queue, which is a combination of a stack and a queue or two stacks joined together, exhibits both stack and queue logic. Thus, it can implement all applications of stacks and queues while offering more flexibility.</p> <p>Q: How exactly are undo and redo implemented?</p> <p>Undo and redo operations are implemented using two stacks: Stack <code>A</code> for undo and Stack <code>B</code> for redo.</p> <ol> <li>Each time a user performs an operation, it is pushed onto Stack <code>A</code>, and Stack <code>B</code> is cleared.</li> <li>When the user executes an \"undo\", the most recent operation is popped from Stack <code>A</code> and pushed onto Stack <code>B</code>.</li> <li>When the user executes a \"redo\", the most recent operation is popped from Stack <code>B</code> and pushed back onto Stack <code>A</code>.</li> </ol>"},{"location":"chapter_tree/","title":"Chapter 7. \u00a0 Tree","text":"<p>Abstract</p> <p>The towering tree, vibrant with it's deep roots and lush leaves, branches spreading wide.</p> <p>It vividly illustrates the concept of divide-and-conquer in data.</p>"},{"location":"chapter_tree/#chapter-contents","title":"Chapter contents","text":"<ul> <li>7.1 \u00a0 Binary tree</li> <li>7.2 \u00a0 Binary tree traversal</li> <li>7.3 \u00a0 Array Representation of tree</li> <li>7.4 \u00a0 Binary Search tree</li> <li>7.5 \u00a0 AVL tree *</li> <li>7.6 \u00a0 Summary</li> </ul>"},{"location":"chapter_tree/array_representation_of_tree/","title":"7.3 \u00a0 Array representation of binary trees","text":"<p>Under the linked list representation, the storage unit of a binary tree is a node <code>TreeNode</code>, with nodes connected by pointers. The basic operations of binary trees under the linked list representation were introduced in the previous section.</p> <p>So, can we use an array to represent a binary tree? The answer is yes.</p>"},{"location":"chapter_tree/array_representation_of_tree/#731-representing-perfect-binary-trees","title":"7.3.1 \u00a0 Representing perfect binary trees","text":"<p>Let's analyze a simple case first. Given a perfect binary tree, we store all nodes in an array according to the order of level-order traversal, where each node corresponds to a unique array index.</p> <p>Based on the characteristics of level-order traversal, we can deduce a \"mapping formula\" between the index of a parent node and its children: If a node's index is \\(i\\), then the index of its left child is \\(2i + 1\\) and the right child is \\(2i + 2\\). Figure 7-12 shows the mapping relationship between the indices of various nodes.</p> <p></p> <p> Figure 7-12 \u00a0 Array representation of a perfect binary tree </p> <p>The mapping formula plays a role similar to the node references (pointers) in linked lists. Given any node in the array, we can access its left (right) child node using the mapping formula.</p>"},{"location":"chapter_tree/array_representation_of_tree/#732-representing-any-binary-tree","title":"7.3.2 \u00a0 Representing any binary tree","text":"<p>Perfect binary trees are a special case; there are often many <code>None</code> values in the middle levels of a binary tree. Since the sequence of level-order traversal does not include these <code>None</code> values, we cannot solely rely on this sequence to deduce the number and distribution of <code>None</code> values. This means that multiple binary tree structures can match the same level-order traversal sequence.</p> <p>As shown in Figure 7-13, given a non-perfect binary tree, the above method of array representation fails.</p> <p></p> <p> Figure 7-13 \u00a0 Level-order traversal sequence corresponds to multiple binary tree possibilities </p> <p>To solve this problem, we can consider explicitly writing out all <code>None</code> values in the level-order traversal sequence. As shown in Figure 7-14, after this treatment, the level-order traversal sequence can uniquely represent a binary tree. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code># Array representation of a binary tree\n# Using None to represent empty slots\ntree = [1, 2, 3, 4, None, 6, 7, 8, 9, None, None, 12, None, None, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum integer value INT_MAX to mark empty slots\nvector&lt;int&gt; tree = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the Integer wrapper class allows for using null to mark empty slots\nInteger[] tree = { 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 };\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nint?[] tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using an any type slice, allowing for nil to mark empty slots\ntree := []any{1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15}\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using optional Int (Int?) allows for using nil to mark empty slots\nlet tree: [Int?] = [1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree: (number | null)[] = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nList&lt;int?&gt; tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using None to mark empty slots\nlet tree = [Some(1), Some(2), Some(3), Some(4), None, Some(6), Some(7), Some(8), Some(9), None, None, Some(12), None, None, Some(15)];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum int value to mark empty slots, therefore, node values must not be INT_MAX\nint tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nval tree = mutableListOf( 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 )\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p></p> <p> Figure 7-14 \u00a0 Array representation of any type of binary tree </p> <p>It's worth noting that complete binary trees are very suitable for array representation. Recalling the definition of a complete binary tree, <code>None</code> appears only at the bottom level and towards the right, meaning all <code>None</code> values definitely appear at the end of the level-order traversal sequence.</p> <p>This means that when using an array to represent a complete binary tree, it's possible to omit storing all <code>None</code> values, which is very convenient. Figure 7-15 gives an example.</p> <p></p> <p> Figure 7-15 \u00a0 Array representation of a complete binary tree </p> <p>The following code implements a binary tree based on array representation, including the following operations:</p> <ul> <li>Given a node, obtain its value, left (right) child node, and parent node.</li> <li>Obtain the preorder, inorder, postorder, and level-order traversal sequences.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig array_binary_tree.py<pre><code>class ArrayBinaryTree:\n    \"\"\"\u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b\"\"\"\n\n    def __init__(self, arr: list[int | None]):\n        \"\"\"\u6784\u9020\u65b9\u6cd5\"\"\"\n        self._tree = list(arr)\n\n    def size(self):\n        \"\"\"\u5217\u8868\u5bb9\u91cf\"\"\"\n        return len(self._tree)\n\n    def val(self, i: int) -&gt; int | None:\n        \"\"\"\u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c\"\"\"\n        # \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de None \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if i &lt; 0 or i &gt;= self.size():\n            return None\n        return self._tree[i]\n\n    def left(self, i: int) -&gt; int | None:\n        \"\"\"\u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n        return 2 * i + 1\n\n    def right(self, i: int) -&gt; int | None:\n        \"\"\"\u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n        return 2 * i + 2\n\n    def parent(self, i: int) -&gt; int | None:\n        \"\"\"\u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15\"\"\"\n        return (i - 1) // 2\n\n    def level_order(self) -&gt; list[int]:\n        \"\"\"\u5c42\u5e8f\u904d\u5386\"\"\"\n        self.res = []\n        # \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for i in range(self.size()):\n            if self.val(i) is not None:\n                self.res.append(self.val(i))\n        return self.res\n\n    def dfs(self, i: int, order: str):\n        \"\"\"\u6df1\u5ea6\u4f18\u5148\u904d\u5386\"\"\"\n        if self.val(i) is None:\n            return\n        # \u524d\u5e8f\u904d\u5386\n        if order == \"pre\":\n            self.res.append(self.val(i))\n        self.dfs(self.left(i), order)\n        # \u4e2d\u5e8f\u904d\u5386\n        if order == \"in\":\n            self.res.append(self.val(i))\n        self.dfs(self.right(i), order)\n        # \u540e\u5e8f\u904d\u5386\n        if order == \"post\":\n            self.res.append(self.val(i))\n\n    def pre_order(self) -&gt; list[int]:\n        \"\"\"\u524d\u5e8f\u904d\u5386\"\"\"\n        self.res = []\n        self.dfs(0, order=\"pre\")\n        return self.res\n\n    def in_order(self) -&gt; list[int]:\n        \"\"\"\u4e2d\u5e8f\u904d\u5386\"\"\"\n        self.res = []\n        self.dfs(0, order=\"in\")\n        return self.res\n\n    def post_order(self) -&gt; list[int]:\n        \"\"\"\u540e\u5e8f\u904d\u5386\"\"\"\n        self.res = []\n        self.dfs(0, order=\"post\")\n        return self.res\n</code></pre> array_binary_tree.cpp<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n  public:\n    /* \u6784\u9020\u65b9\u6cd5 */\n    ArrayBinaryTree(vector&lt;int&gt; arr) {\n        tree = arr;\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    int size() {\n        return tree.size();\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    int val(int i) {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de INT_MAX \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= size())\n            return INT_MAX;\n        return tree[i];\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    int left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    int right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    int parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    vector&lt;int&gt; levelOrder() {\n        vector&lt;int&gt; res;\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (int i = 0; i &lt; size(); i++) {\n            if (val(i) != INT_MAX)\n                res.push_back(val(i));\n        }\n        return res;\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    vector&lt;int&gt; preOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"pre\", res);\n        return res;\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    vector&lt;int&gt; inOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"in\", res);\n        return res;\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    vector&lt;int&gt; postOrder() {\n        vector&lt;int&gt; res;\n        dfs(0, \"post\", res);\n        return res;\n    }\n\n  private:\n    vector&lt;int&gt; tree;\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    void dfs(int i, string order, vector&lt;int&gt; &amp;res) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (val(i) == INT_MAX)\n            return;\n        // \u524d\u5e8f\u904d\u5386\n        if (order == \"pre\")\n            res.push_back(val(i));\n        dfs(left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if (order == \"in\")\n            res.push_back(val(i));\n        dfs(right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if (order == \"post\")\n            res.push_back(val(i));\n    }\n};\n</code></pre> array_binary_tree.java<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n    private List&lt;Integer&gt; tree;\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    public ArrayBinaryTree(List&lt;Integer&gt; arr) {\n        tree = new ArrayList&lt;&gt;(arr);\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    public int size() {\n        return tree.size();\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    public Integer val(int i) {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= size())\n            return null;\n        return tree.get(i);\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    public Integer left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    public Integer right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    public Integer parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    public List&lt;Integer&gt; levelOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (int i = 0; i &lt; size(); i++) {\n            if (val(i) != null)\n                res.add(val(i));\n        }\n        return res;\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    private void dfs(Integer i, String order, List&lt;Integer&gt; res) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (val(i) == null)\n            return;\n        // \u524d\u5e8f\u904d\u5386\n        if (\"pre\".equals(order))\n            res.add(val(i));\n        dfs(left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if (\"in\".equals(order))\n            res.add(val(i));\n        dfs(right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if (\"post\".equals(order))\n            res.add(val(i));\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    public List&lt;Integer&gt; preOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"pre\", res);\n        return res;\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    public List&lt;Integer&gt; inOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"in\", res);\n        return res;\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    public List&lt;Integer&gt; postOrder() {\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        dfs(0, \"post\", res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.cs<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree(List&lt;int?&gt; arr) {\n    List&lt;int?&gt; tree = new(arr);\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    public int Size() {\n        return tree.Count;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    public int? Val(int i) {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= Size())\n            return null;\n        return tree[i];\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    public int Left(int i) {\n        return 2 * i + 1;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    public int Right(int i) {\n        return 2 * i + 2;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    public int Parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    public List&lt;int&gt; LevelOrder() {\n        List&lt;int&gt; res = [];\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (int i = 0; i &lt; Size(); i++) {\n            if (Val(i).HasValue)\n                res.Add(Val(i)!.Value);\n        }\n        return res;\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    void DFS(int i, string order, List&lt;int&gt; res) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (!Val(i).HasValue)\n            return;\n        // \u524d\u5e8f\u904d\u5386\n        if (order == \"pre\")\n            res.Add(Val(i)!.Value);\n        DFS(Left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if (order == \"in\")\n            res.Add(Val(i)!.Value);\n        DFS(Right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if (order == \"post\")\n            res.Add(Val(i)!.Value);\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    public List&lt;int&gt; PreOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"pre\", res);\n        return res;\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    public List&lt;int&gt; InOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"in\", res);\n        return res;\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    public List&lt;int&gt; PostOrder() {\n        List&lt;int&gt; res = [];\n        DFS(0, \"post\", res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.go<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\ntype arrayBinaryTree struct {\n    tree []any\n}\n\n/* \u6784\u9020\u65b9\u6cd5 */\nfunc newArrayBinaryTree(arr []any) *arrayBinaryTree {\n    return &amp;arrayBinaryTree{\n        tree: arr,\n    }\n}\n\n/* \u5217\u8868\u5bb9\u91cf */\nfunc (abt *arrayBinaryTree) size() int {\n    return len(abt.tree)\n}\n\n/* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\nfunc (abt *arrayBinaryTree) val(i int) any {\n    // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n    if i &lt; 0 || i &gt;= abt.size() {\n        return nil\n    }\n    return abt.tree[i]\n}\n\n/* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (abt *arrayBinaryTree) left(i int) int {\n    return 2*i + 1\n}\n\n/* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (abt *arrayBinaryTree) right(i int) int {\n    return 2*i + 2\n}\n\n/* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\nfunc (abt *arrayBinaryTree) parent(i int) int {\n    return (i - 1) / 2\n}\n\n/* \u5c42\u5e8f\u904d\u5386 */\nfunc (abt *arrayBinaryTree) levelOrder() []any {\n    var res []any\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n    for i := 0; i &lt; abt.size(); i++ {\n        if abt.val(i) != nil {\n            res = append(res, abt.val(i))\n        }\n    }\n    return res\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\nfunc (abt *arrayBinaryTree) dfs(i int, order string, res *[]any) {\n    // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n    if abt.val(i) == nil {\n        return\n    }\n    // \u524d\u5e8f\u904d\u5386\n    if order == \"pre\" {\n        *res = append(*res, abt.val(i))\n    }\n    abt.dfs(abt.left(i), order, res)\n    // \u4e2d\u5e8f\u904d\u5386\n    if order == \"in\" {\n        *res = append(*res, abt.val(i))\n    }\n    abt.dfs(abt.right(i), order, res)\n    // \u540e\u5e8f\u904d\u5386\n    if order == \"post\" {\n        *res = append(*res, abt.val(i))\n    }\n}\n\n/* \u524d\u5e8f\u904d\u5386 */\nfunc (abt *arrayBinaryTree) preOrder() []any {\n    var res []any\n    abt.dfs(0, \"pre\", &amp;res)\n    return res\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfunc (abt *arrayBinaryTree) inOrder() []any {\n    var res []any\n    abt.dfs(0, \"in\", &amp;res)\n    return res\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfunc (abt *arrayBinaryTree) postOrder() []any {\n    var res []any\n    abt.dfs(0, \"post\", &amp;res)\n    return res\n}\n</code></pre> array_binary_tree.swift<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n    private var tree: [Int?]\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    init(arr: [Int?]) {\n        tree = arr\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    func size() -&gt; Int {\n        tree.count\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    func val(i: Int) -&gt; Int? {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if i &lt; 0 || i &gt;= size() {\n            return nil\n        }\n        return tree[i]\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    func left(i: Int) -&gt; Int {\n        2 * i + 1\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    func right(i: Int) -&gt; Int {\n        2 * i + 2\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    func parent(i: Int) -&gt; Int {\n        (i - 1) / 2\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    func levelOrder() -&gt; [Int] {\n        var res: [Int] = []\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for i in 0 ..&lt; size() {\n            if let val = val(i: i) {\n                res.append(val)\n            }\n        }\n        return res\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    private func dfs(i: Int, order: String, res: inout [Int]) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        guard let val = val(i: i) else {\n            return\n        }\n        // \u524d\u5e8f\u904d\u5386\n        if order == \"pre\" {\n            res.append(val)\n        }\n        dfs(i: left(i: i), order: order, res: &amp;res)\n        // \u4e2d\u5e8f\u904d\u5386\n        if order == \"in\" {\n            res.append(val)\n        }\n        dfs(i: right(i: i), order: order, res: &amp;res)\n        // \u540e\u5e8f\u904d\u5386\n        if order == \"post\" {\n            res.append(val)\n        }\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    func preOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"pre\", res: &amp;res)\n        return res\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    func inOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"in\", res: &amp;res)\n        return res\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    func postOrder() -&gt; [Int] {\n        var res: [Int] = []\n        dfs(i: 0, order: \"post\", res: &amp;res)\n        return res\n    }\n}\n</code></pre> array_binary_tree.js<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n    #tree;\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(arr) {\n        this.#tree = arr;\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    size() {\n        return this.#tree.length;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    val(i) {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= this.size()) return null;\n        return this.#tree[i];\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    left(i) {\n        return 2 * i + 1;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    right(i) {\n        return 2 * i + 2;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    parent(i) {\n        return Math.floor((i - 1) / 2); // \u5411\u4e0b\u6574\u9664\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    levelOrder() {\n        let res = [];\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (let i = 0; i &lt; this.size(); i++) {\n            if (this.val(i) !== null) res.push(this.val(i));\n        }\n        return res;\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    #dfs(i, order, res) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (this.val(i) === null) return;\n        // \u524d\u5e8f\u904d\u5386\n        if (order === 'pre') res.push(this.val(i));\n        this.#dfs(this.left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if (order === 'in') res.push(this.val(i));\n        this.#dfs(this.right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if (order === 'post') res.push(this.val(i));\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    preOrder() {\n        const res = [];\n        this.#dfs(0, 'pre', res);\n        return res;\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    inOrder() {\n        const res = [];\n        this.#dfs(0, 'in', res);\n        return res;\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    postOrder() {\n        const res = [];\n        this.#dfs(0, 'post', res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.ts<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n    #tree: (number | null)[];\n\n    /* \u6784\u9020\u65b9\u6cd5 */\n    constructor(arr: (number | null)[]) {\n        this.#tree = arr;\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    size(): number {\n        return this.#tree.length;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    val(i: number): number | null {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= this.size()) return null;\n        return this.#tree[i];\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    left(i: number): number {\n        return 2 * i + 1;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    right(i: number): number {\n        return 2 * i + 2;\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    parent(i: number): number {\n        return Math.floor((i - 1) / 2); // \u5411\u4e0b\u6574\u9664\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    levelOrder(): number[] {\n        let res = [];\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (let i = 0; i &lt; this.size(); i++) {\n            if (this.val(i) !== null) res.push(this.val(i));\n        }\n        return res;\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    #dfs(i: number, order: Order, res: (number | null)[]): void {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (this.val(i) === null) return;\n        // \u524d\u5e8f\u904d\u5386\n        if (order === 'pre') res.push(this.val(i));\n        this.#dfs(this.left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if (order === 'in') res.push(this.val(i));\n        this.#dfs(this.right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if (order === 'post') res.push(this.val(i));\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    preOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'pre', res);\n        return res;\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    inOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'in', res);\n        return res;\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    postOrder(): (number | null)[] {\n        const res = [];\n        this.#dfs(0, 'post', res);\n        return res;\n    }\n}\n</code></pre> array_binary_tree.dart<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree {\n  late List&lt;int?&gt; _tree;\n\n  /* \u6784\u9020\u65b9\u6cd5 */\n  ArrayBinaryTree(this._tree);\n\n  /* \u5217\u8868\u5bb9\u91cf */\n  int size() {\n    return _tree.length;\n  }\n\n  /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n  int? val(int i) {\n    // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n    if (i &lt; 0 || i &gt;= size()) {\n      return null;\n    }\n    return _tree[i];\n  }\n\n  /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n  int? left(int i) {\n    return 2 * i + 1;\n  }\n\n  /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n  int? right(int i) {\n    return 2 * i + 2;\n  }\n\n  /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n  int? parent(int i) {\n    return (i - 1) ~/ 2;\n  }\n\n  /* \u5c42\u5e8f\u904d\u5386 */\n  List&lt;int&gt; levelOrder() {\n    List&lt;int&gt; res = [];\n    for (int i = 0; i &lt; size(); i++) {\n      if (val(i) != null) {\n        res.add(val(i)!);\n      }\n    }\n    return res;\n  }\n\n  /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n  void dfs(int i, String order, List&lt;int?&gt; res) {\n    // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n    if (val(i) == null) {\n      return;\n    }\n    // \u524d\u5e8f\u904d\u5386\n    if (order == 'pre') {\n      res.add(val(i));\n    }\n    dfs(left(i)!, order, res);\n    // \u4e2d\u5e8f\u904d\u5386\n    if (order == 'in') {\n      res.add(val(i));\n    }\n    dfs(right(i)!, order, res);\n    // \u540e\u5e8f\u904d\u5386\n    if (order == 'post') {\n      res.add(val(i));\n    }\n  }\n\n  /* \u524d\u5e8f\u904d\u5386 */\n  List&lt;int?&gt; preOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'pre', res);\n    return res;\n  }\n\n  /* \u4e2d\u5e8f\u904d\u5386 */\n  List&lt;int?&gt; inOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'in', res);\n    return res;\n  }\n\n  /* \u540e\u5e8f\u904d\u5386 */\n  List&lt;int?&gt; postOrder() {\n    List&lt;int?&gt; res = [];\n    dfs(0, 'post', res);\n    return res;\n  }\n}\n</code></pre> array_binary_tree.rs<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nstruct ArrayBinaryTree {\n    tree: Vec&lt;Option&lt;i32&gt;&gt;,\n}\n\nimpl ArrayBinaryTree {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    fn new(arr: Vec&lt;Option&lt;i32&gt;&gt;) -&gt; Self {\n        Self { tree: arr }\n    }\n\n    /* \u5217\u8868\u5bb9\u91cf */\n    fn size(&amp;self) -&gt; i32 {\n        self.tree.len() as i32\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    fn val(&amp;self, i: i32) -&gt; Option&lt;i32&gt; {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de None \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if i &lt; 0 || i &gt;= self.size() {\n            None\n        } else {\n            self.tree[i as usize]\n        }\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    fn left(&amp;self, i: i32) -&gt; i32 {\n        2 * i + 1\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    fn right(&amp;self, i: i32) -&gt; i32 {\n        2 * i + 2\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    fn parent(&amp;self, i: i32) -&gt; i32 {\n        (i - 1) / 2\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    fn level_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for i in 0..self.size() {\n            if let Some(val) = self.val(i) {\n                res.push(val)\n            }\n        }\n        res\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    fn dfs(&amp;self, i: i32, order: &amp;str, res: &amp;mut Vec&lt;i32&gt;) {\n        if self.val(i).is_none() {\n            return;\n        }\n        let val = self.val(i).unwrap();\n        // \u524d\u5e8f\u904d\u5386\n        if order == \"pre\" {\n            res.push(val);\n        }\n        self.dfs(self.left(i), order, res);\n        // \u4e2d\u5e8f\u904d\u5386\n        if order == \"in\" {\n            res.push(val);\n        }\n        self.dfs(self.right(i), order, res);\n        // \u540e\u5e8f\u904d\u5386\n        if order == \"post\" {\n            res.push(val);\n        }\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    fn pre_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"pre\", &amp;mut res);\n        res\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    fn in_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"in\", &amp;mut res);\n        res\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    fn post_order(&amp;self) -&gt; Vec&lt;i32&gt; {\n        let mut res = vec![];\n        self.dfs(0, \"post\", &amp;mut res);\n        res\n    }\n}\n</code></pre> array_binary_tree.c<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7ed3\u6784\u4f53 */\ntypedef struct {\n    int *tree;\n    int size;\n} ArrayBinaryTree;\n\n/* \u6784\u9020\u51fd\u6570 */\nArrayBinaryTree *newArrayBinaryTree(int *arr, int arrSize) {\n    ArrayBinaryTree *abt = (ArrayBinaryTree *)malloc(sizeof(ArrayBinaryTree));\n    abt-&gt;tree = malloc(sizeof(int) * arrSize);\n    memcpy(abt-&gt;tree, arr, sizeof(int) * arrSize);\n    abt-&gt;size = arrSize;\n    return abt;\n}\n\n/* \u6790\u6784\u51fd\u6570 */\nvoid delArrayBinaryTree(ArrayBinaryTree *abt) {\n    free(abt-&gt;tree);\n    free(abt);\n}\n\n/* \u5217\u8868\u5bb9\u91cf */\nint size(ArrayBinaryTree *abt) {\n    return abt-&gt;size;\n}\n\n/* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\nint val(ArrayBinaryTree *abt, int i) {\n    // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de INT_MAX \uff0c\u4ee3\u8868\u7a7a\u4f4d\n    if (i &lt; 0 || i &gt;= size(abt))\n        return INT_MAX;\n    return abt-&gt;tree[i];\n}\n\n/* \u5c42\u5e8f\u904d\u5386 */\nint *levelOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n    for (int i = 0; i &lt; size(abt); i++) {\n        if (val(abt, i) != INT_MAX)\n            res[index++] = val(abt, i);\n    }\n    *returnSize = index;\n    return res;\n}\n\n/* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\nvoid dfs(ArrayBinaryTree *abt, int i, char *order, int *res, int *index) {\n    // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n    if (val(abt, i) == INT_MAX)\n        return;\n    // \u524d\u5e8f\u904d\u5386\n    if (strcmp(order, \"pre\") == 0)\n        res[(*index)++] = val(abt, i);\n    dfs(abt, left(i), order, res, index);\n    // \u4e2d\u5e8f\u904d\u5386\n    if (strcmp(order, \"in\") == 0)\n        res[(*index)++] = val(abt, i);\n    dfs(abt, right(i), order, res, index);\n    // \u540e\u5e8f\u904d\u5386\n    if (strcmp(order, \"post\") == 0)\n        res[(*index)++] = val(abt, i);\n}\n\n/* \u524d\u5e8f\u904d\u5386 */\nint *preOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"pre\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nint *inOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"in\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nint *postOrder(ArrayBinaryTree *abt, int *returnSize) {\n    int *res = (int *)malloc(sizeof(int) * size(abt));\n    int index = 0;\n    dfs(abt, 0, \"post\", res, &amp;index);\n    *returnSize = index;\n    return res;\n}\n</code></pre> array_binary_tree.kt<pre><code>/* \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b */\nclass ArrayBinaryTree(val tree: MutableList&lt;Int?&gt;) {\n    /* \u5217\u8868\u5bb9\u91cf */\n    fun size(): Int {\n        return tree.size\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c */\n    fun _val(i: Int): Int? {\n        // \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de null \uff0c\u4ee3\u8868\u7a7a\u4f4d\n        if (i &lt; 0 || i &gt;= size()) return null\n        return tree[i]\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    fun left(i: Int): Int {\n        return 2 * i + 1\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 */\n    fun right(i: Int): Int {\n        return 2 * i + 2\n    }\n\n    /* \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 */\n    fun parent(i: Int): Int {\n        return (i - 1) / 2\n    }\n\n    /* \u5c42\u5e8f\u904d\u5386 */\n    fun levelOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        // \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n        for (i in 0..&lt;size()) {\n            if (_val(i) != null)\n                res.add(_val(i))\n        }\n        return res\n    }\n\n    /* \u6df1\u5ea6\u4f18\u5148\u904d\u5386 */\n    fun dfs(i: Int, order: String, res: MutableList&lt;Int?&gt;) {\n        // \u82e5\u4e3a\u7a7a\u4f4d\uff0c\u5219\u8fd4\u56de\n        if (_val(i) == null)\n            return\n        // \u524d\u5e8f\u904d\u5386\n        if (\"pre\" == order)\n            res.add(_val(i))\n        dfs(left(i), order, res)\n        // \u4e2d\u5e8f\u904d\u5386\n        if (\"in\" == order)\n            res.add(_val(i))\n        dfs(right(i), order, res)\n        // \u540e\u5e8f\u904d\u5386\n        if (\"post\" == order)\n            res.add(_val(i))\n    }\n\n    /* \u524d\u5e8f\u904d\u5386 */\n    fun preOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"pre\", res)\n        return res\n    }\n\n    /* \u4e2d\u5e8f\u904d\u5386 */\n    fun inOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"in\", res)\n        return res\n    }\n\n    /* \u540e\u5e8f\u904d\u5386 */\n    fun postOrder(): MutableList&lt;Int?&gt; {\n        val res = mutableListOf&lt;Int?&gt;()\n        dfs(0, \"post\", res)\n        return res\n    }\n}\n</code></pre> array_binary_tree.rb<pre><code>### \u6570\u7ec4\u8868\u793a\u4e0b\u7684\u4e8c\u53c9\u6811\u7c7b ###\nclass ArrayBinaryTree\n  ### \u6784\u9020\u65b9\u6cd5 ###\n  def initialize(arr)\n    @tree = arr.to_a\n  end\n\n  ### \u5217\u8868\u5bb9\u91cf ###\n  def size\n    @tree.length\n  end\n\n  ### \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u503c ###\n  def val(i)\n    # \u82e5\u7d22\u5f15\u8d8a\u754c\uff0c\u5219\u8fd4\u56de nil \uff0c\u4ee3\u8868\u7a7a\u4f4d\n    return if i &lt; 0 || i &gt;= size\n\n    @tree[i]\n  end\n\n  ### \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15 ###\n  def left(i)\n    2 * i + 1\n  end\n\n  ### \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15 ###\n  def right(i)\n    2 * i + 2\n  end\n\n  ### \u83b7\u53d6\u7d22\u5f15\u4e3a i \u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u7d22\u5f15 ###\n  def parent(i)\n    (i - 1) / 2\n  end\n\n  ### \u5c42\u5e8f\u904d\u5386 ###\n  def level_order\n    @res = []\n\n    # \u76f4\u63a5\u904d\u5386\u6570\u7ec4\n    for i in 0...size\n      @res &lt;&lt; val(i) unless val(i).nil?\n    end\n\n    @res\n  end\n\n  ### \u6df1\u5ea6\u4f18\u5148\u904d\u5386 ###\n  def dfs(i, order)\n    return if val(i).nil?\n    # \u524d\u5e8f\u904d\u5386\n    @res &lt;&lt; val(i) if order == :pre\n    dfs(left(i), order)\n    # \u4e2d\u5e8f\u904d\u5386\n    @res &lt;&lt; val(i) if order == :in\n    dfs(right(i), order)\n    # \u540e\u5e8f\u904d\u5386\n    @res &lt;&lt; val(i) if order == :post\n  end\n\n  ### \u524d\u5e8f\u904d\u5386 ###\n  def pre_order\n    @res = []\n    dfs(0, :pre)\n    @res\n  end\n\n  ### \u4e2d\u5e8f\u904d\u5386 ###\n  def in_order\n    @res = []\n    dfs(0, :in)\n    @res\n  end\n\n  ### \u540e\u5e8f\u904d\u5386 ###\n  def post_order\n    @res = []\n    dfs(0, :post)\n    @res\n  end\nend\n</code></pre> array_binary_tree.zig<pre><code>[class]{ArrayBinaryTree}-[func]{}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_tree/array_representation_of_tree/#733-advantages-and-limitations","title":"7.3.3 \u00a0 Advantages and limitations","text":"<p>The array representation of binary trees has the following advantages:</p> <ul> <li>Arrays are stored in contiguous memory spaces, which is cache-friendly and allows for faster access and traversal.</li> <li>It does not require storing pointers, which saves space.</li> <li>It allows random access to nodes.</li> </ul> <p>However, the array representation also has some limitations:</p> <ul> <li>Array storage requires contiguous memory space, so it is not suitable for storing trees with a large amount of data.</li> <li>Adding or deleting nodes requires array insertion and deletion operations, which are less efficient.</li> <li>When there are many <code>None</code> values in the binary tree, the proportion of node data contained in the array is low, leading to lower space utilization.</li> </ul>"},{"location":"chapter_tree/avl_tree/","title":"7.5 \u00a0 AVL tree *","text":"<p>In the \"Binary Search Tree\" section, we mentioned that after multiple insertions and removals, a binary search tree might degrade to a linked list. In such cases, the time complexity of all operations degrades from \\(O(\\log n)\\) to \\(O(n)\\).</p> <p>As shown in Figure 7-24, after two node removal operations, this binary search tree will degrade into a linked list.</p> <p></p> <p> Figure 7-24 \u00a0 Degradation of an AVL tree after removing nodes </p> <p>For example, in the perfect binary tree shown in Figure 7-25, after inserting two nodes, the tree will lean heavily to the left, and the time complexity of search operations will also degrade.</p> <p></p> <p> Figure 7-25 \u00a0 Degradation of an AVL tree after inserting nodes </p> <p>In 1962, G. M. Adelson-Velsky and E. M. Landis proposed the AVL Tree in their paper \"An algorithm for the organization of information\". The paper detailed a series of operations to ensure that after continuously adding and removing nodes, the AVL tree would not degrade, thus maintaining the time complexity of various operations at \\(O(\\log n)\\) level. In other words, in scenarios where frequent additions, removals, searches, and modifications are needed, the AVL tree can always maintain efficient data operation performance, which has great application value.</p>"},{"location":"chapter_tree/avl_tree/#751-common-terminology-in-avl-trees","title":"7.5.1 \u00a0 Common terminology in AVL trees","text":"<p>An AVL tree is both a binary search tree and a balanced binary tree, satisfying all properties of these two types of binary trees, hence it is a balanced binary search tree.</p>"},{"location":"chapter_tree/avl_tree/#1-node-height","title":"1. \u00a0 Node height","text":"<p>Since the operations related to AVL trees require obtaining node heights, we need to add a <code>height</code> variable to the node class:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>class TreeNode:\n    \"\"\"AVL tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                 # Node value\n        self.height: int = 0                # Node height\n        self.left: TreeNode | None = None   # Left child reference\n        self.right: TreeNode | None = None  # Right child reference\n</code></pre> <pre><code>/* AVL tree node */\nstruct TreeNode {\n    int val{};          // Node value\n    int height = 0;     // Node height\n    TreeNode *left{};   // Left child\n    TreeNode *right{};  // Right child\n    TreeNode() = default;\n    explicit TreeNode(int x) : val(x){}\n};\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    public int val;        // Node value\n    public int height;     // Node height\n    public TreeNode left;  // Left child\n    public TreeNode right; // Right child\n    public TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public int height;      // Node height\n    public TreeNode? left;  // Left child reference\n    public TreeNode? right; // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\ntype TreeNode struct {\n    Val    int       // Node value\n    Height int       // Node height\n    Left   *TreeNode // Left child reference\n    Right  *TreeNode // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var height: Int // Node height\n    var left: TreeNode? // Left child\n    var right: TreeNode? // Right child\n\n    init(x: Int) {\n        val = x\n        height = 0\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val; // Node value\n    height; // Node height\n    left; // Left child pointer\n    right; // Right child pointer\n    constructor(val, left, right, height) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val: number;            // Node value\n    height: number;         // Node height\n    left: TreeNode | null;  // Left child pointer\n    right: TreeNode | null; // Right child pointer\n    constructor(val?: number, height?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height; \n        this.left = left === undefined ? null : left; \n        this.right = right === undefined ? null : right; \n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n  int val;         // Node value\n  int height;      // Node height\n  TreeNode? left;  // Left child\n  TreeNode? right; // Right child\n  TreeNode(this.val, [this.height = 0, this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* AVL tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    height: i32,                            // Node height\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Left child\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Right child\n}\n\nimpl TreeNode {\n    /* Constructor */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            height: 0,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nTreeNode struct TreeNode {\n    int val;\n    int height;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\n/* Constructor */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val height: Int = 0          // Node height\n    val left: TreeNode? = null   // Left child\n    val right: TreeNode? = null  // Right child\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>The \"node height\" refers to the distance from that node to its farthest leaf node, i.e., the number of \"edges\" passed. It is important to note that the height of a leaf node is \\(0\\), and the height of a null node is \\(-1\\). We will create two utility functions for getting and updating the height of a node:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def height(self, node: TreeNode | None) -&gt; int:\n    \"\"\"\u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6\"\"\"\n    # \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    if node is not None:\n        return node.height\n    return -1\n\ndef update_height(self, node: TreeNode | None):\n    \"\"\"\u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\"\"\"\n    # \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.height = max([self.height(node.left), self.height(node.right)]) + 1\n</code></pre> avl_tree.cpp<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nint height(TreeNode *node) {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node == nullptr ? -1 : node-&gt;height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nvoid updateHeight(TreeNode *node) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node-&gt;height = max(height(node-&gt;left), height(node-&gt;right)) + 1;\n}\n</code></pre> avl_tree.java<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nint height(TreeNode node) {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node == null ? -1 : node.height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nvoid updateHeight(TreeNode node) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.height = Math.max(height(node.left), height(node.right)) + 1;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nint Height(TreeNode? node) {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node == null ? -1 : node.height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nvoid UpdateHeight(TreeNode node) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.height = Math.Max(Height(node.left), Height(node.right)) + 1;\n}\n</code></pre> avl_tree.go<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nfunc (t *aVLTree) height(node *TreeNode) int {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    if node != nil {\n        return node.Height\n    }\n    return -1\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nfunc (t *aVLTree) updateHeight(node *TreeNode) {\n    lh := t.height(node.Left)\n    rh := t.height(node.Right)\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    if lh &gt; rh {\n        node.Height = lh + 1\n    } else {\n        node.Height = rh + 1\n    }\n}\n</code></pre> avl_tree.swift<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nfunc height(node: TreeNode?) -&gt; Int {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    node?.height ?? -1\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nfunc updateHeight(node: TreeNode?) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node?.height = max(height(node: node?.left), height(node: node?.right)) + 1\n}\n</code></pre> avl_tree.js<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nheight(node) {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node === null ? -1 : node.height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\n#updateHeight(node) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.height =\n        Math.max(this.height(node.left), this.height(node.right)) + 1;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nheight(node: TreeNode): number {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node === null ? -1 : node.height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nupdateHeight(node: TreeNode): void {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.height =\n        Math.max(this.height(node.left), this.height(node.right)) + 1;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nint height(TreeNode? node) {\n  // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n  return node == null ? -1 : node.height;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nvoid updateHeight(TreeNode? node) {\n  // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n  node!.height = max(height(node.left), height(node.right)) + 1;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nfn height(node: OptionTreeNodeRc) -&gt; i32 {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    match node {\n        Some(node) =&gt; node.borrow().height,\n        None =&gt; -1,\n    }\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nfn update_height(node: OptionTreeNodeRc) {\n    if let Some(node) = node {\n        let left = node.borrow().left.clone();\n        let right = node.borrow().right.clone();\n        // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n        node.borrow_mut().height = std::cmp::max(Self::height(left), Self::height(right)) + 1;\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nint height(TreeNode *node) {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    if (node != NULL) {\n        return node-&gt;height;\n    }\n    return -1;\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nvoid updateHeight(TreeNode *node) {\n    int lh = height(node-&gt;left);\n    int rh = height(node-&gt;right);\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    if (lh &gt; rh) {\n        node-&gt;height = lh + 1;\n    } else {\n        node-&gt;height = rh + 1;\n    }\n}\n</code></pre> avl_tree.kt<pre><code>/* \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 */\nfun height(node: TreeNode?): Int {\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return node?.height ?: -1\n}\n\n/* \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 */\nfun updateHeight(node: TreeNode?) {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node?.height = max(height(node?.left), height(node?.right)) + 1\n}\n</code></pre> avl_tree.rb<pre><code>### \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6 ###\ndef height(node)\n  # \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n  return node.height unless node.nil?\n\n  -1\nend\n\n### \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6 ###\ndef update_height(node)\n  # \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n  node.height = [height(node.left), height(node.right)].max + 1\nend\n</code></pre> avl_tree.zig<pre><code>// \u83b7\u53d6\u8282\u70b9\u9ad8\u5ea6\nfn height(self: *Self, node: ?*inc.TreeNode(T)) i32 {\n    _ = self;\n    // \u7a7a\u8282\u70b9\u9ad8\u5ea6\u4e3a -1 \uff0c\u53f6\u8282\u70b9\u9ad8\u5ea6\u4e3a 0\n    return if (node == null) -1 else node.?.height;\n}\n\n// \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\nfn updateHeight(self: *Self, node: ?*inc.TreeNode(T)) void {\n    // \u8282\u70b9\u9ad8\u5ea6\u7b49\u4e8e\u6700\u9ad8\u5b50\u6811\u9ad8\u5ea6 + 1\n    node.?.height = @max(self.height(node.?.left), self.height(node.?.right)) + 1;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-node-balance-factor","title":"2. \u00a0 Node balance factor","text":"<p>The balance factor of a node is defined as the height of the node's left subtree minus the height of its right subtree, with the balance factor of a null node defined as \\(0\\). We will also encapsulate the functionality of obtaining the node balance factor into a function for easy use later on:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def balance_factor(self, node: TreeNode | None) -&gt; int:\n    \"\"\"\u83b7\u53d6\u5e73\u8861\u56e0\u5b50\"\"\"\n    # \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if node is None:\n        return 0\n    # \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return self.height(node.left) - self.height(node.right)\n</code></pre> avl_tree.cpp<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nint balanceFactor(TreeNode *node) {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == nullptr)\n        return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return height(node-&gt;left) - height(node-&gt;right);\n}\n</code></pre> avl_tree.java<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nint balanceFactor(TreeNode node) {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == null)\n        return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return height(node.left) - height(node.right);\n}\n</code></pre> avl_tree.cs<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nint BalanceFactor(TreeNode? node) {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == null) return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return Height(node.left) - Height(node.right);\n}\n</code></pre> avl_tree.go<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nfunc (t *aVLTree) balanceFactor(node *TreeNode) int {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if node == nil {\n        return 0\n    }\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return t.height(node.Left) - t.height(node.Right)\n}\n</code></pre> avl_tree.swift<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nfunc balanceFactor(node: TreeNode?) -&gt; Int {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    guard let node = node else { return 0 }\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return height(node: node.left) - height(node: node.right)\n}\n</code></pre> avl_tree.js<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nbalanceFactor(node) {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node === null) return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return this.height(node.left) - this.height(node.right);\n}\n</code></pre> avl_tree.ts<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nbalanceFactor(node: TreeNode): number {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node === null) return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return this.height(node.left) - this.height(node.right);\n}\n</code></pre> avl_tree.dart<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nint balanceFactor(TreeNode? node) {\n  // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n  if (node == null) return 0;\n  // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n  return height(node.left) - height(node.right);\n}\n</code></pre> avl_tree.rs<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nfn balance_factor(node: OptionTreeNodeRc) -&gt; i32 {\n    match node {\n        // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n        None =&gt; 0,\n        // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n        Some(node) =&gt; {\n            Self::height(node.borrow().left.clone()) - Self::height(node.borrow().right.clone())\n        }\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nint balanceFactor(TreeNode *node) {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == NULL) {\n        return 0;\n    }\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return height(node-&gt;left) - height(node-&gt;right);\n}\n</code></pre> avl_tree.kt<pre><code>/* \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 */\nfun balanceFactor(node: TreeNode?): Int {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == null) return 0\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return height(node.left) - height(node.right)\n}\n</code></pre> avl_tree.rb<pre><code>### \u83b7\u53d6\u5e73\u8861\u56e0\u5b50 ###\ndef balance_factor(node)\n  # \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n  return 0 if node.nil?\n\n  # \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n  height(node.left) - height(node.right)\nend\n</code></pre> avl_tree.zig<pre><code>// \u83b7\u53d6\u5e73\u8861\u56e0\u5b50\nfn balanceFactor(self: *Self, node: ?*inc.TreeNode(T)) i32 {\n    // \u7a7a\u8282\u70b9\u5e73\u8861\u56e0\u5b50\u4e3a 0\n    if (node == null) return 0;\n    // \u8282\u70b9\u5e73\u8861\u56e0\u5b50 = \u5de6\u5b50\u6811\u9ad8\u5ea6 - \u53f3\u5b50\u6811\u9ad8\u5ea6\n    return self.height(node.?.left) - self.height(node.?.right);\n}\n</code></pre> <p>Tip</p> <p>Let the balance factor be \\(f\\), then the balance factor of any node in an AVL tree satisfies \\(-1 \\le f \\le 1\\).</p>"},{"location":"chapter_tree/avl_tree/#752-rotations-in-avl-trees","title":"7.5.2 \u00a0 Rotations in AVL trees","text":"<p>The characteristic feature of an AVL tree is the \"rotation\" operation, which can restore balance to an unbalanced node without affecting the in-order traversal sequence of the binary tree. In other words, the rotation operation can maintain the property of a \"binary search tree\" while also turning the tree back into a \"balanced binary tree\".</p> <p>We call nodes with an absolute balance factor \\(&gt; 1\\) \"unbalanced nodes\". Depending on the type of imbalance, there are four kinds of rotations: right rotation, left rotation, right-left rotation, and left-right rotation. Below, we detail these rotation operations.</p>"},{"location":"chapter_tree/avl_tree/#1-right-rotation","title":"1. \u00a0 Right rotation","text":"<p>As shown in Figure 7-26, the first unbalanced node from the bottom up in the binary tree is \"node 3\". Focusing on the subtree with this unbalanced node as the root, denoted as <code>node</code>, and its left child as <code>child</code>, perform a \"right rotation\". After the right rotation, the subtree is balanced again while still maintaining the properties of a binary search tree.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-26 \u00a0 Steps of right rotation </p> <p>As shown in Figure 7-27, when the <code>child</code> node has a right child (denoted as <code>grand_child</code>), a step needs to be added in the right rotation: set <code>grand_child</code> as the left child of <code>node</code>.</p> <p></p> <p> Figure 7-27 \u00a0 Right rotation with grand_child </p> <p>\"Right rotation\" is a figurative term; in practice, it is achieved by modifying node pointers, as shown in the following code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def right_rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"\u53f3\u65cb\u64cd\u4f5c\"\"\"\n    child = node.left\n    grand_child = child.right\n    # \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node\n    node.left = grand_child\n    # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.update_height(node)\n    self.update_height(child)\n    # \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n</code></pre> avl_tree.cpp<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nTreeNode *rightRotate(TreeNode *node) {\n    TreeNode *child = node-&gt;left;\n    TreeNode *grandChild = child-&gt;right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child-&gt;right = node;\n    node-&gt;left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.java<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nTreeNode rightRotate(TreeNode node) {\n    TreeNode child = node.left;\n    TreeNode grandChild = child.right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node;\n    node.left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nTreeNode? RightRotate(TreeNode? node) {\n    TreeNode? child = node?.left;\n    TreeNode? grandChild = child?.right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node;\n    node.left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    UpdateHeight(node);\n    UpdateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.go<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nfunc (t *aVLTree) rightRotate(node *TreeNode) *TreeNode {\n    child := node.Left\n    grandChild := child.Right\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.Right = node\n    node.Left = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    t.updateHeight(node)\n    t.updateHeight(child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.swift<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nfunc rightRotate(node: TreeNode?) -&gt; TreeNode? {\n    let child = node?.left\n    let grandChild = child?.right\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child?.right = node\n    node?.left = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node: node)\n    updateHeight(node: child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.js<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\n#rightRotate(node) {\n    const child = node.left;\n    const grandChild = child.right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node;\n    node.left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    this.#updateHeight(node);\n    this.#updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nrightRotate(node: TreeNode): TreeNode {\n    const child = node.left;\n    const grandChild = child.right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node;\n    node.left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    this.updateHeight(node);\n    this.updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nTreeNode? rightRotate(TreeNode? node) {\n  TreeNode? child = node!.left;\n  TreeNode? grandChild = child!.right;\n  // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n  child.right = node;\n  node.left = grandChild;\n  // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  updateHeight(node);\n  updateHeight(child);\n  // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n  return child;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nfn right_rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(node) =&gt; {\n            let child = node.borrow().left.clone().unwrap();\n            let grand_child = child.borrow().right.clone();\n            // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n            child.borrow_mut().right = Some(node.clone());\n            node.borrow_mut().left = grand_child;\n            // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n            Self::update_height(Some(node));\n            Self::update_height(Some(child.clone()));\n            // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n            Some(child)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nTreeNode *rightRotate(TreeNode *node) {\n    TreeNode *child, *grandChild;\n    child = node-&gt;left;\n    grandChild = child-&gt;right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child-&gt;right = node;\n    node-&gt;left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.kt<pre><code>/* \u53f3\u65cb\u64cd\u4f5c */\nfun rightRotate(node: TreeNode?): TreeNode {\n    val child = node!!.left\n    val grandChild = child!!.right\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.right = node\n    node.left = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node)\n    updateHeight(child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.rb<pre><code>### \u53f3\u65cb\u64cd\u4f5c ###\ndef right_rotate(node)\n  child = node.left\n  grand_child = child.right\n  # \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n  child.right = node\n  node.left = grand_child\n  # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  update_height(node)\n  update_height(child)\n  # \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n  child\nend\n</code></pre> avl_tree.zig<pre><code>// \u53f3\u65cb\u64cd\u4f5c\nfn rightRotate(self: *Self, node: ?*inc.TreeNode(T)) ?*inc.TreeNode(T) {\n    var child = node.?.left;\n    var grandChild = child.?.right;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u53f3\u65cb\u8f6c\n    child.?.right = node;\n    node.?.left = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.updateHeight(node);\n    self.updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-left-rotation","title":"2. \u00a0 Left rotation","text":"<p>Correspondingly, if considering the \"mirror\" of the above unbalanced binary tree, the \"left rotation\" operation shown in Figure 7-28 needs to be performed.</p> <p></p> <p> Figure 7-28 \u00a0 Left rotation operation </p> <p>Similarly, as shown in Figure 7-29, when the <code>child</code> node has a left child (denoted as <code>grand_child</code>), a step needs to be added in the left rotation: set <code>grand_child</code> as the right child of <code>node</code>.</p> <p></p> <p> Figure 7-29 \u00a0 Left rotation with grand_child </p> <p>It can be observed that the right and left rotation operations are logically symmetrical, and they solve two symmetrical types of imbalance. Based on symmetry, by replacing all <code>left</code> with <code>right</code>, and all <code>right</code> with <code>left</code> in the implementation code of right rotation, we can get the implementation code for left rotation:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def left_rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"\u5de6\u65cb\u64cd\u4f5c\"\"\"\n    child = node.right\n    grand_child = child.left\n    # \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node\n    node.right = grand_child\n    # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.update_height(node)\n    self.update_height(child)\n    # \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n</code></pre> avl_tree.cpp<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nTreeNode *leftRotate(TreeNode *node) {\n    TreeNode *child = node-&gt;right;\n    TreeNode *grandChild = child-&gt;left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child-&gt;left = node;\n    node-&gt;right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.java<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nTreeNode leftRotate(TreeNode node) {\n    TreeNode child = node.right;\n    TreeNode grandChild = child.left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node;\n    node.right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nTreeNode? LeftRotate(TreeNode? node) {\n    TreeNode? child = node?.right;\n    TreeNode? grandChild = child?.left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node;\n    node.right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    UpdateHeight(node);\n    UpdateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.go<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nfunc (t *aVLTree) leftRotate(node *TreeNode) *TreeNode {\n    child := node.Right\n    grandChild := child.Left\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.Left = node\n    node.Right = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    t.updateHeight(node)\n    t.updateHeight(child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.swift<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nfunc leftRotate(node: TreeNode?) -&gt; TreeNode? {\n    let child = node?.right\n    let grandChild = child?.left\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child?.left = node\n    node?.right = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node: node)\n    updateHeight(node: child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.js<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\n#leftRotate(node) {\n    const child = node.right;\n    const grandChild = child.left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node;\n    node.right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    this.#updateHeight(node);\n    this.#updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nleftRotate(node: TreeNode): TreeNode {\n    const child = node.right;\n    const grandChild = child.left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node;\n    node.right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    this.updateHeight(node);\n    this.updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nTreeNode? leftRotate(TreeNode? node) {\n  TreeNode? child = node!.right;\n  TreeNode? grandChild = child!.left;\n  // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n  child.left = node;\n  node.right = grandChild;\n  // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  updateHeight(node);\n  updateHeight(child);\n  // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n  return child;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nfn left_rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(node) =&gt; {\n            let child = node.borrow().right.clone().unwrap();\n            let grand_child = child.borrow().left.clone();\n            // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n            child.borrow_mut().left = Some(node.clone());\n            node.borrow_mut().right = grand_child;\n            // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n            Self::update_height(Some(node));\n            Self::update_height(Some(child.clone()));\n            // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n            Some(child)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nTreeNode *leftRotate(TreeNode *node) {\n    TreeNode *child, *grandChild;\n    child = node-&gt;right;\n    grandChild = child-&gt;left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child-&gt;left = node;\n    node-&gt;right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre> avl_tree.kt<pre><code>/* \u5de6\u65cb\u64cd\u4f5c */\nfun leftRotate(node: TreeNode?): TreeNode {\n    val child = node!!.right\n    val grandChild = child!!.left\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.left = node\n    node.right = grandChild\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node)\n    updateHeight(child)\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child\n}\n</code></pre> avl_tree.rb<pre><code>### \u5de6\u65cb\u64cd\u4f5c ###\ndef left_rotate(node)\n  child = node.right\n  grand_child = child.left\n  # \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n  child.left = node\n  node.right = grand_child\n  # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  update_height(node)\n  update_height(child)\n  # \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n  child\nend\n</code></pre> avl_tree.zig<pre><code>// \u5de6\u65cb\u64cd\u4f5c\nfn leftRotate(self: *Self, node: ?*inc.TreeNode(T)) ?*inc.TreeNode(T) {\n    var child = node.?.right;\n    var grandChild = child.?.left;\n    // \u4ee5 child \u4e3a\u539f\u70b9\uff0c\u5c06 node \u5411\u5de6\u65cb\u8f6c\n    child.?.left = node;\n    node.?.right = grandChild;\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.updateHeight(node);\n    self.updateHeight(child);\n    // \u8fd4\u56de\u65cb\u8f6c\u540e\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return child;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#3-right-left-rotation","title":"3. \u00a0 Right-left rotation","text":"<p>For the unbalanced node 3 shown in Figure 7-30, using either left or right rotation alone cannot restore balance to the subtree. In this case, a \"left rotation\" needs to be performed on <code>child</code> first, followed by a \"right rotation\" on <code>node</code>.</p> <p></p> <p> Figure 7-30 \u00a0 Right-left rotation </p>"},{"location":"chapter_tree/avl_tree/#4-left-right-rotation","title":"4. \u00a0 Left-right rotation","text":"<p>As shown in Figure 7-31, for the mirror case of the above unbalanced binary tree, a \"right rotation\" needs to be performed on <code>child</code> first, followed by a \"left rotation\" on <code>node</code>.</p> <p></p> <p> Figure 7-31 \u00a0 Left-right rotation </p>"},{"location":"chapter_tree/avl_tree/#5-choice-of-rotation","title":"5. \u00a0 Choice of rotation","text":"<p>The four kinds of imbalances shown in Figure 7-32 correspond to the cases described above, respectively requiring right rotation, left-right rotation, right-left rotation, and left rotation.</p> <p></p> <p> Figure 7-32 \u00a0 The four rotation cases of AVL tree </p> <p>As shown in Table 7-3, we determine which of the above cases an unbalanced node belongs to by judging the sign of the balance factor of the unbalanced node and its higher-side child's balance factor.</p> <p> Table 7-3 \u00a0 Conditions for Choosing Among the Four Rotation Cases </p> Balance factor of unbalanced node Balance factor of child node Rotation method to use \\(&gt; 1\\) (Left-leaning tree) \\(\\geq 0\\) Right rotation \\(&gt; 1\\) (Left-leaning tree) \\(&lt;0\\) Left rotation then right rotation \\(&lt; -1\\) (Right-leaning tree) \\(\\leq 0\\) Left rotation \\(&lt; -1\\) (Right-leaning tree) \\(&gt;0\\) Right rotation then left rotation <p>For convenience, we encapsulate the rotation operations into a function. With this function, we can perform rotations on various kinds of imbalances, restoring balance to unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def rotate(self, node: TreeNode | None) -&gt; TreeNode | None:\n    \"\"\"\u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\"\"\"\n    # \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    balance_factor = self.balance_factor(node)\n    # \u5de6\u504f\u6811\n    if balance_factor &gt; 1:\n        if self.balance_factor(node.left) &gt;= 0:\n            # \u53f3\u65cb\n            return self.right_rotate(node)\n        else:\n            # \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.left = self.left_rotate(node.left)\n            return self.right_rotate(node)\n    # \u53f3\u504f\u6811\n    elif balance_factor &lt; -1:\n        if self.balance_factor(node.right) &lt;= 0:\n            # \u5de6\u65cb\n            return self.left_rotate(node)\n        else:\n            # \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.right = self.right_rotate(node.right)\n            return self.left_rotate(node)\n    # \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node\n</code></pre> avl_tree.cpp<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nTreeNode *rotate(TreeNode *node) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    int _balanceFactor = balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (_balanceFactor &gt; 1) {\n        if (balanceFactor(node-&gt;left) &gt;= 0) {\n            // \u53f3\u65cb\n            return rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node-&gt;left = leftRotate(node-&gt;left);\n            return rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (_balanceFactor &lt; -1) {\n        if (balanceFactor(node-&gt;right) &lt;= 0) {\n            // \u5de6\u65cb\n            return leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node-&gt;right = rightRotate(node-&gt;right);\n            return leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nTreeNode rotate(TreeNode node) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    int balanceFactor = balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (balanceFactor &gt; 1) {\n        if (balanceFactor(node.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.left = leftRotate(node.left);\n            return rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balanceFactor &lt; -1) {\n        if (balanceFactor(node.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.right = rightRotate(node.right);\n            return leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nTreeNode? Rotate(TreeNode? node) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    int balanceFactorInt = BalanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (balanceFactorInt &gt; 1) {\n        if (BalanceFactor(node?.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return RightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node!.left = LeftRotate(node!.left);\n            return RightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balanceFactorInt &lt; -1) {\n        if (BalanceFactor(node?.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return LeftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node!.right = RightRotate(node!.right);\n            return LeftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nfunc (t *aVLTree) rotate(node *TreeNode) *TreeNode {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    // Go \u63a8\u8350\u77ed\u53d8\u91cf\uff0c\u8fd9\u91cc bf \u6307\u4ee3 t.balanceFactor\n    bf := t.balanceFactor(node)\n    // \u5de6\u504f\u6811\n    if bf &gt; 1 {\n        if t.balanceFactor(node.Left) &gt;= 0 {\n            // \u53f3\u65cb\n            return t.rightRotate(node)\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.Left = t.leftRotate(node.Left)\n            return t.rightRotate(node)\n        }\n    }\n    // \u53f3\u504f\u6811\n    if bf &lt; -1 {\n        if t.balanceFactor(node.Right) &lt;= 0 {\n            // \u5de6\u65cb\n            return t.leftRotate(node)\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.Right = t.rightRotate(node.Right)\n            return t.leftRotate(node)\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nfunc rotate(node: TreeNode?) -&gt; TreeNode? {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    let balanceFactor = balanceFactor(node: node)\n    // \u5de6\u504f\u6811\n    if balanceFactor &gt; 1 {\n        if self.balanceFactor(node: node?.left) &gt;= 0 {\n            // \u53f3\u65cb\n            return rightRotate(node: node)\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node?.left = leftRotate(node: node?.left)\n            return rightRotate(node: node)\n        }\n    }\n    // \u53f3\u504f\u6811\n    if balanceFactor &lt; -1 {\n        if self.balanceFactor(node: node?.right) &lt;= 0 {\n            // \u5de6\u65cb\n            return leftRotate(node: node)\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node?.right = rightRotate(node: node?.right)\n            return leftRotate(node: node)\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n#rotate(node) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    const balanceFactor = this.balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (balanceFactor &gt; 1) {\n        if (this.balanceFactor(node.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return this.#rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.left = this.#leftRotate(node.left);\n            return this.#rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balanceFactor &lt; -1) {\n        if (this.balanceFactor(node.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return this.#leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.right = this.#rightRotate(node.right);\n            return this.#leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nrotate(node: TreeNode): TreeNode {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    const balanceFactor = this.balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (balanceFactor &gt; 1) {\n        if (this.balanceFactor(node.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return this.rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.left = this.leftRotate(node.left);\n            return this.rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balanceFactor &lt; -1) {\n        if (this.balanceFactor(node.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return this.leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.right = this.rightRotate(node.right);\n            return this.leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nTreeNode? rotate(TreeNode? node) {\n  // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n  int factor = balanceFactor(node);\n  // \u5de6\u504f\u6811\n  if (factor &gt; 1) {\n    if (balanceFactor(node!.left) &gt;= 0) {\n      // \u53f3\u65cb\n      return rightRotate(node);\n    } else {\n      // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n      node.left = leftRotate(node.left);\n      return rightRotate(node);\n    }\n  }\n  // \u53f3\u504f\u6811\n  if (factor &lt; -1) {\n    if (balanceFactor(node!.right) &lt;= 0) {\n      // \u5de6\u65cb\n      return leftRotate(node);\n    } else {\n      // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n      node.right = rightRotate(node.right);\n      return leftRotate(node);\n    }\n  }\n  // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nfn rotate(node: OptionTreeNodeRc) -&gt; OptionTreeNodeRc {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    let balance_factor = Self::balance_factor(node.clone());\n    // \u5de6\u504f\u6811\n    if balance_factor &gt; 1 {\n        let node = node.unwrap();\n        if Self::balance_factor(node.borrow().left.clone()) &gt;= 0 {\n            // \u53f3\u65cb\n            Self::right_rotate(Some(node))\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            let left = node.borrow().left.clone();\n            node.borrow_mut().left = Self::left_rotate(left);\n            Self::right_rotate(Some(node))\n        }\n    }\n    // \u53f3\u504f\u6811\n    else if balance_factor &lt; -1 {\n        let node = node.unwrap();\n        if Self::balance_factor(node.borrow().right.clone()) &lt;= 0 {\n            // \u5de6\u65cb\n            Self::left_rotate(Some(node))\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            let right = node.borrow().right.clone();\n            node.borrow_mut().right = Self::right_rotate(right);\n            Self::left_rotate(Some(node))\n        }\n    } else {\n        // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n        node\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nTreeNode *rotate(TreeNode *node) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    int bf = balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (bf &gt; 1) {\n        if (balanceFactor(node-&gt;left) &gt;= 0) {\n            // \u53f3\u65cb\n            return rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node-&gt;left = leftRotate(node-&gt;left);\n            return rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (bf &lt; -1) {\n        if (balanceFactor(node-&gt;right) &lt;= 0) {\n            // \u5de6\u65cb\n            return leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node-&gt;right = rightRotate(node-&gt;right);\n            return leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\nfun rotate(node: TreeNode): TreeNode {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    val balanceFactor = balanceFactor(node)\n    // \u5de6\u504f\u6811\n    if (balanceFactor &gt; 1) {\n        if (balanceFactor(node.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return rightRotate(node)\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.left = leftRotate(node.left)\n            return rightRotate(node)\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balanceFactor &lt; -1) {\n        if (balanceFactor(node.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return leftRotate(node)\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.right = rightRotate(node.right)\n            return leftRotate(node)\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 ###\ndef rotate(node)\n  # \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n  balance_factor = balance_factor(node)\n  # \u5de6\u904d\u6811\n  if balance_factor &gt; 1\n    if balance_factor(node.left) &gt;= 0\n      # \u53f3\u65cb\n      return right_rotate(node)\n    else\n      # \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n      node.left = left_rotate(node.left)\n      return right_rotate(node)\n    end\n  # \u53f3\u904d\u6811\n  elsif balance_factor &lt; -1\n    if balance_factor(node.right) &lt;= 0\n      # \u5de6\u65cb\n      return left_rotate(node)\n    else\n      # \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n      node.right = right_rotate(node.right)\n      return left_rotate(node)\n    end\n  end\n  # \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n  node\nend\n</code></pre> avl_tree.zig<pre><code>// \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\nfn rotate(self: *Self, node: ?*inc.TreeNode(T)) ?*inc.TreeNode(T) {\n    // \u83b7\u53d6\u8282\u70b9 node \u7684\u5e73\u8861\u56e0\u5b50\n    var balance_factor = self.balanceFactor(node);\n    // \u5de6\u504f\u6811\n    if (balance_factor &gt; 1) {\n        if (self.balanceFactor(node.?.left) &gt;= 0) {\n            // \u53f3\u65cb\n            return self.rightRotate(node);\n        } else {\n            // \u5148\u5de6\u65cb\u540e\u53f3\u65cb\n            node.?.left = self.leftRotate(node.?.left);\n            return self.rightRotate(node);\n        }\n    }\n    // \u53f3\u504f\u6811\n    if (balance_factor &lt; -1) {\n        if (self.balanceFactor(node.?.right) &lt;= 0) {\n            // \u5de6\u65cb\n            return self.leftRotate(node);\n        } else {\n            // \u5148\u53f3\u65cb\u540e\u5de6\u65cb\n            node.?.right = self.rightRotate(node.?.right);\n            return self.leftRotate(node);\n        }\n    }\n    // \u5e73\u8861\u6811\uff0c\u65e0\u987b\u65cb\u8f6c\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#753-common-operations-in-avl-trees","title":"7.5.3 \u00a0 Common operations in AVL trees","text":""},{"location":"chapter_tree/avl_tree/#1-node-insertion","title":"1. \u00a0 Node insertion","text":"<p>The node insertion operation in AVL trees is similar to that in binary search trees. The only difference is that after inserting a node in an AVL tree, a series of unbalanced nodes may appear along the path from that node to the root node. Therefore, we need to start from this node and perform rotation operations upwards to restore balance to all unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def insert(self, val):\n    \"\"\"\u63d2\u5165\u8282\u70b9\"\"\"\n    self._root = self.insert_helper(self._root, val)\n\ndef insert_helper(self, node: TreeNode | None, val: int) -&gt; TreeNode:\n    \"\"\"\u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09\"\"\"\n    if node is None:\n        return TreeNode(val)\n    # 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9\n    if val &lt; node.val:\n        node.left = self.insert_helper(node.left, val)\n    elif val &gt; node.val:\n        node.right = self.insert_helper(node.right, val)\n    else:\n        # \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n        return node\n    # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.update_height(node)\n    # 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n    return self.rotate(node)\n</code></pre> avl_tree.cpp<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int val) {\n    root = insertHelper(root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode *insertHelper(TreeNode *node, int val) {\n    if (node == nullptr)\n        return new TreeNode(val);\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node-&gt;val)\n        node-&gt;left = insertHelper(node-&gt;left, val);\n    else if (val &gt; node-&gt;val)\n        node-&gt;right = insertHelper(node-&gt;right, val);\n    else\n        return node;    // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int val) {\n    root = insertHelper(root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode insertHelper(TreeNode node, int val) {\n    if (node == null)\n        return new TreeNode(val);\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node.val)\n        node.left = insertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = insertHelper(node.right, val);\n    else\n        return node; // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid Insert(int val) {\n    root = InsertHelper(root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode? InsertHelper(TreeNode? node, int val) {\n    if (node == null) return new TreeNode(val);\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node.val)\n        node.left = InsertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = InsertHelper(node.right, val);\n    else\n        return node;     // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    UpdateHeight(node);  // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = Rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfunc (t *aVLTree) insert(val int) {\n    t.root = t.insertHelper(t.root, val)\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u51fd\u6570\uff09 */\nfunc (t *aVLTree) insertHelper(node *TreeNode, val int) *TreeNode {\n    if node == nil {\n        return NewTreeNode(val)\n    }\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if val &lt; node.Val.(int) {\n        node.Left = t.insertHelper(node.Left, val)\n    } else if val &gt; node.Val.(int) {\n        node.Right = t.insertHelper(node.Right, val)\n    } else {\n        // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n        return node\n    }\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    t.updateHeight(node)\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = t.rotate(node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfunc insert(val: Int) {\n    root = insertHelper(node: root, val: val)\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfunc insertHelper(node: TreeNode?, val: Int) -&gt; TreeNode? {\n    var node = node\n    if node == nil {\n        return TreeNode(x: val)\n    }\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if val &lt; node!.val {\n        node?.left = insertHelper(node: node?.left, val: val)\n    } else if val &gt; node!.val {\n        node?.right = insertHelper(node: node?.right, val: val)\n    } else {\n        return node // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    }\n    updateHeight(node: node) // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node: node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* \u63d2\u5165\u8282\u70b9 */\ninsert(val) {\n    this.root = this.#insertHelper(this.root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\n#insertHelper(node, val) {\n    if (node === null) return new TreeNode(val);\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node.val) node.left = this.#insertHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = this.#insertHelper(node.right, val);\n    else return node; // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    this.#updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = this.#rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u63d2\u5165\u8282\u70b9 */\ninsert(val: number): void {\n    this.root = this.insertHelper(this.root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\ninsertHelper(node: TreeNode, val: number): TreeNode {\n    if (node === null) return new TreeNode(val);\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node.val) {\n        node.left = this.insertHelper(node.left, val);\n    } else if (val &gt; node.val) {\n        node.right = this.insertHelper(node.right, val);\n    } else {\n        return node; // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    }\n    this.updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = this.rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int val) {\n  root = insertHelper(root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode? insertHelper(TreeNode? node, int val) {\n  if (node == null) return TreeNode(val);\n  /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n  if (val &lt; node.val)\n    node.left = insertHelper(node.left, val);\n  else if (val &gt; node.val)\n    node.right = insertHelper(node.right, val);\n  else\n    return node; // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n  updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n  node = rotate(node);\n  // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfn insert(&amp;mut self, val: i32) {\n    self.root = Self::insert_helper(self.root.clone(), val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfn insert_helper(node: OptionTreeNodeRc, val: i32) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(mut node) =&gt; {\n            /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n            match {\n                let node_val = node.borrow().val;\n                node_val\n            }\n            .cmp(&amp;val)\n            {\n                Ordering::Greater =&gt; {\n                    let left = node.borrow().left.clone();\n                    node.borrow_mut().left = Self::insert_helper(left, val);\n                }\n                Ordering::Less =&gt; {\n                    let right = node.borrow().right.clone();\n                    node.borrow_mut().right = Self::insert_helper(right, val);\n                }\n                Ordering::Equal =&gt; {\n                    return Some(node); // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n                }\n            }\n            Self::update_height(Some(node.clone())); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n\n            /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n            node = Self::rotate(Some(node)).unwrap();\n            // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n            Some(node)\n        }\n        None =&gt; Some(TreeNode::new(val)),\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(AVLTree *tree, int val) {\n    tree-&gt;root = insertHelper(tree-&gt;root, val);\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u51fd\u6570\uff09 */\nTreeNode *insertHelper(TreeNode *node, int val) {\n    if (node == NULL) {\n        return newTreeNode(val);\n    }\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (val &lt; node-&gt;val) {\n        node-&gt;left = insertHelper(node-&gt;left, val);\n    } else if (val &gt; node-&gt;val) {\n        node-&gt;right = insertHelper(node-&gt;right, val);\n    } else {\n        // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n        return node;\n    }\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfun insert(_val: Int) {\n    root = insertHelper(root, _val)\n}\n\n/* \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfun insertHelper(n: TreeNode?, _val: Int): TreeNode {\n    if (n == null)\n        return TreeNode(_val)\n    var node = n\n    /* 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9 */\n    if (_val &lt; node._val)\n        node.left = insertHelper(node.left, _val)\n    else if (_val &gt; node._val)\n        node.right = insertHelper(node.right, _val)\n    else\n        return node // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    updateHeight(node) // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### \u63d2\u5165\u8282\u70b9 ###\ndef insert(val)\n  @root = insert_helper(@root, val)\nend\n\n### \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09###\ndef insert_helper(node, val)\n  return TreeNode.new(val) if node.nil?\n  # 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9\n  if val &lt; node.val\n    node.left = insert_helper(node.left, val)\n  elsif val &gt; node.val\n    node.right = insert_helper(node.right, val)\n  else\n    # \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    return node\n  end\n  # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  update_height(node)\n  # 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n  rotate(node)\nend\n</code></pre> avl_tree.zig<pre><code>// \u63d2\u5165\u8282\u70b9\nfn insert(self: *Self, val: T) !void {\n    self.root = (try self.insertHelper(self.root, val)).?;\n}\n\n// \u9012\u5f52\u63d2\u5165\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09\nfn insertHelper(self: *Self, node_: ?*inc.TreeNode(T), val: T) !?*inc.TreeNode(T) {\n    var node = node_;\n    if (node == null) {\n        var tmp_node = try self.mem_allocator.create(inc.TreeNode(T));\n        tmp_node.init(val);\n        return tmp_node;\n    }\n    // 1. \u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u5e76\u63d2\u5165\u8282\u70b9\n    if (val &lt; node.?.val) {\n        node.?.left = try self.insertHelper(node.?.left, val);\n    } else if (val &gt; node.?.val) {\n        node.?.right = try self.insertHelper(node.?.right, val);\n    } else {\n        return node;            // \u91cd\u590d\u8282\u70b9\u4e0d\u63d2\u5165\uff0c\u76f4\u63a5\u8fd4\u56de\n    }\n    self.updateHeight(node);    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    // 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n    node = self.rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#2-node-removal","title":"2. \u00a0 Node removal","text":"<p>Similarly, based on the method of removing nodes in binary search trees, rotation operations need to be performed from the bottom up to restore balance to all unbalanced nodes. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig avl_tree.py<pre><code>def remove(self, val: int):\n    \"\"\"\u5220\u9664\u8282\u70b9\"\"\"\n    self._root = self.remove_helper(self._root, val)\n\ndef remove_helper(self, node: TreeNode | None, val: int) -&gt; TreeNode | None:\n    \"\"\"\u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09\"\"\"\n    if node is None:\n        return None\n    # 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664\n    if val &lt; node.val:\n        node.left = self.remove_helper(node.left, val)\n    elif val &gt; node.val:\n        node.right = self.remove_helper(node.right, val)\n    else:\n        if node.left is None or node.right is None:\n            child = node.left or node.right\n            # \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if child is None:\n                return None\n            # \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else:\n                node = child\n        else:\n            # \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            temp = node.right\n            while temp.left is not None:\n                temp = temp.left\n            node.right = self.remove_helper(node.right, temp.val)\n            node.val = temp.val\n    # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    self.update_height(node)\n    # 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n    return self.rotate(node)\n</code></pre> avl_tree.cpp<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int val) {\n    root = removeHelper(root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode *removeHelper(TreeNode *node, int val) {\n    if (node == nullptr)\n        return nullptr;\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node-&gt;val)\n        node-&gt;left = removeHelper(node-&gt;left, val);\n    else if (val &gt; node-&gt;val)\n        node-&gt;right = removeHelper(node-&gt;right, val);\n    else {\n        if (node-&gt;left == nullptr || node-&gt;right == nullptr) {\n            TreeNode *child = node-&gt;left != nullptr ? node-&gt;left : node-&gt;right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == nullptr) {\n                delete node;\n                return nullptr;\n            }\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else {\n                delete node;\n                node = child;\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            TreeNode *temp = node-&gt;right;\n            while (temp-&gt;left != nullptr) {\n                temp = temp-&gt;left;\n            }\n            int tempVal = temp-&gt;val;\n            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);\n            node-&gt;val = tempVal;\n        }\n    }\n    updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.java<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int val) {\n    root = removeHelper(root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode removeHelper(TreeNode node, int val) {\n    if (node == null)\n        return null;\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node.val)\n        node.left = removeHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = removeHelper(node.right, val);\n    else {\n        if (node.left == null || node.right == null) {\n            TreeNode child = node.left != null ? node.left : node.right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == null)\n                return null;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else\n                node = child;\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            TreeNode temp = node.right;\n            while (temp.left != null) {\n                temp = temp.left;\n            }\n            node.right = removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.cs<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid Remove(int val) {\n    root = RemoveHelper(root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode? RemoveHelper(TreeNode? node, int val) {\n    if (node == null) return null;\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node.val)\n        node.left = RemoveHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = RemoveHelper(node.right, val);\n    else {\n        if (node.left == null || node.right == null) {\n            TreeNode? child = node.left ?? node.right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == null)\n                return null;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else\n                node = child;\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            TreeNode? temp = node.right;\n            while (temp.left != null) {\n                temp = temp.left;\n            }\n            node.right = RemoveHelper(node.right, temp.val!.Value);\n            node.val = temp.val;\n        }\n    }\n    UpdateHeight(node);  // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = Rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.go<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfunc (t *aVLTree) remove(val int) {\n    t.root = t.removeHelper(t.root, val)\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u51fd\u6570\uff09 */\nfunc (t *aVLTree) removeHelper(node *TreeNode, val int) *TreeNode {\n    if node == nil {\n        return nil\n    }\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if val &lt; node.Val.(int) {\n        node.Left = t.removeHelper(node.Left, val)\n    } else if val &gt; node.Val.(int) {\n        node.Right = t.removeHelper(node.Right, val)\n    } else {\n        if node.Left == nil || node.Right == nil {\n            child := node.Left\n            if node.Right != nil {\n                child = node.Right\n            }\n            if child == nil {\n                // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n                return nil\n            } else {\n                // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n                node = child\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            temp := node.Right\n            for temp.Left != nil {\n                temp = temp.Left\n            }\n            node.Right = t.removeHelper(node.Right, temp.Val.(int))\n            node.Val = temp.Val\n        }\n    }\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    t.updateHeight(node)\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = t.rotate(node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.swift<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfunc remove(val: Int) {\n    root = removeHelper(node: root, val: val)\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfunc removeHelper(node: TreeNode?, val: Int) -&gt; TreeNode? {\n    var node = node\n    if node == nil {\n        return nil\n    }\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if val &lt; node!.val {\n        node?.left = removeHelper(node: node?.left, val: val)\n    } else if val &gt; node!.val {\n        node?.right = removeHelper(node: node?.right, val: val)\n    } else {\n        if node?.left == nil || node?.right == nil {\n            let child = node?.left ?? node?.right\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if child == nil {\n                return nil\n            }\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else {\n                node = child\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            var temp = node?.right\n            while temp?.left != nil {\n                temp = temp?.left\n            }\n            node?.right = removeHelper(node: node?.right, val: temp!.val)\n            node?.val = temp!.val\n        }\n    }\n    updateHeight(node: node) // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node: node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.js<pre><code>/* \u5220\u9664\u8282\u70b9 */\nremove(val) {\n    this.root = this.#removeHelper(this.root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\n#removeHelper(node, val) {\n    if (node === null) return null;\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node.val) node.left = this.#removeHelper(node.left, val);\n    else if (val &gt; node.val)\n        node.right = this.#removeHelper(node.right, val);\n    else {\n        if (node.left === null || node.right === null) {\n            const child = node.left !== null ? node.left : node.right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child === null) return null;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else node = child;\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            let temp = node.right;\n            while (temp.left !== null) {\n                temp = temp.left;\n            }\n            node.right = this.#removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    this.#updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = this.#rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.ts<pre><code>/* \u5220\u9664\u8282\u70b9 */\nremove(val: number): void {\n    this.root = this.removeHelper(this.root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nremoveHelper(node: TreeNode, val: number): TreeNode {\n    if (node === null) return null;\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node.val) {\n        node.left = this.removeHelper(node.left, val);\n    } else if (val &gt; node.val) {\n        node.right = this.removeHelper(node.right, val);\n    } else {\n        if (node.left === null || node.right === null) {\n            const child = node.left !== null ? node.left : node.right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child === null) {\n                return null;\n            } else {\n                // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n                node = child;\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            let temp = node.right;\n            while (temp.left !== null) {\n                temp = temp.left;\n            }\n            node.right = this.removeHelper(node.right, temp.val);\n            node.val = temp.val;\n        }\n    }\n    this.updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = this.rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.dart<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int val) {\n  root = removeHelper(root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nTreeNode? removeHelper(TreeNode? node, int val) {\n  if (node == null) return null;\n  /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n  if (val &lt; node.val)\n    node.left = removeHelper(node.left, val);\n  else if (val &gt; node.val)\n    node.right = removeHelper(node.right, val);\n  else {\n    if (node.left == null || node.right == null) {\n      TreeNode? child = node.left ?? node.right;\n      // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n      if (child == null)\n        return null;\n      // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n      else\n        node = child;\n    } else {\n      // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n      TreeNode? temp = node.right;\n      while (temp!.left != null) {\n        temp = temp.left;\n      }\n      node.right = removeHelper(node.right, temp.val);\n      node.val = temp.val;\n    }\n  }\n  updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n  node = rotate(node);\n  // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n  return node;\n}\n</code></pre> avl_tree.rs<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfn remove(&amp;self, val: i32) {\n    Self::remove_helper(self.root.clone(), val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfn remove_helper(node: OptionTreeNodeRc, val: i32) -&gt; OptionTreeNodeRc {\n    match node {\n        Some(mut node) =&gt; {\n            /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n            if val &lt; node.borrow().val {\n                let left = node.borrow().left.clone();\n                node.borrow_mut().left = Self::remove_helper(left, val);\n            } else if val &gt; node.borrow().val {\n                let right = node.borrow().right.clone();\n                node.borrow_mut().right = Self::remove_helper(right, val);\n            } else if node.borrow().left.is_none() || node.borrow().right.is_none() {\n                let child = if node.borrow().left.is_some() {\n                    node.borrow().left.clone()\n                } else {\n                    node.borrow().right.clone()\n                };\n                match child {\n                    // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n                    None =&gt; {\n                        return None;\n                    }\n                    // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n                    Some(child) =&gt; node = child,\n                }\n            } else {\n                // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n                let mut temp = node.borrow().right.clone().unwrap();\n                loop {\n                    let temp_left = temp.borrow().left.clone();\n                    if temp_left.is_none() {\n                        break;\n                    }\n                    temp = temp_left.unwrap();\n                }\n                let right = node.borrow().right.clone();\n                node.borrow_mut().right = Self::remove_helper(right, temp.borrow().val);\n                node.borrow_mut().val = temp.borrow().val;\n            }\n            Self::update_height(Some(node.clone())); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n\n            /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n            node = Self::rotate(Some(node)).unwrap();\n            // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n            Some(node)\n        }\n        None =&gt; None,\n    }\n}\n</code></pre> avl_tree.c<pre><code>/* \u5220\u9664\u8282\u70b9 */\n// \u7531\u4e8e\u5f15\u5165\u4e86 stdio.h \uff0c\u6b64\u5904\u65e0\u6cd5\u4f7f\u7528 remove \u5173\u952e\u8bcd\nvoid removeItem(AVLTree *tree, int val) {\n    TreeNode *root = removeHelper(tree-&gt;root, val);\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u51fd\u6570\uff09 */\nTreeNode *removeHelper(TreeNode *node, int val) {\n    TreeNode *child, *grandChild;\n    if (node == NULL) {\n        return NULL;\n    }\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (val &lt; node-&gt;val) {\n        node-&gt;left = removeHelper(node-&gt;left, val);\n    } else if (val &gt; node-&gt;val) {\n        node-&gt;right = removeHelper(node-&gt;right, val);\n    } else {\n        if (node-&gt;left == NULL || node-&gt;right == NULL) {\n            child = node-&gt;left;\n            if (node-&gt;right != NULL) {\n                child = node-&gt;right;\n            }\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == NULL) {\n                return NULL;\n            } else {\n                // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n                node = child;\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            TreeNode *temp = node-&gt;right;\n            while (temp-&gt;left != NULL) {\n                temp = temp-&gt;left;\n            }\n            int tempVal = temp-&gt;val;\n            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);\n            node-&gt;val = tempVal;\n        }\n    }\n    // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    updateHeight(node);\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre> avl_tree.kt<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfun remove(_val: Int) {\n    root = removeHelper(root, _val)\n}\n\n/* \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09 */\nfun removeHelper(n: TreeNode?, _val: Int): TreeNode? {\n    var node = n ?: return null\n    /* 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664 */\n    if (_val &lt; node._val)\n        node.left = removeHelper(node.left, _val)\n    else if (_val &gt; node._val)\n        node.right = removeHelper(node.right, _val)\n    else {\n        if (node.left == null || node.right == null) {\n            val child = if (node.left != null)\n                node.left\n            else\n                node.right\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == null)\n                return null\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            else\n                node = child\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            var temp = node.right\n            while (temp!!.left != null) {\n                temp = temp.left\n            }\n            node.right = removeHelper(node.right, temp._val)\n            node._val = temp._val\n        }\n    }\n    updateHeight(node) // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    /* 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861 */\n    node = rotate(node)\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node\n}\n</code></pre> avl_tree.rb<pre><code>### \u5220\u9664\u8282\u70b9 ###\ndef remove(val)\n  @root = remove_helper(@root, val)\nend\n\n### \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09###\ndef remove_helper(node, val)\n  return if node.nil?\n  # 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664\n  if val &lt; node.val\n    node.left = remove_helper(node.left, val)\n  elsif val &gt; node.val\n    node.right = remove_helper(node.right, val)\n  else\n    if node.left.nil? || node.right.nil?\n      child = node.left || node.right\n      # \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n      return if child.nil?\n      # \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n      node = child\n    else\n      # \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n      temp = node.right\n      while !temp.left.nil?\n        temp = temp.left\n      end\n      node.right = remove_helper(node.right, temp.val)\n      node.val = temp.val\n    end\n  end\n  # \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n  update_height(node)\n  # 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n  rotate(node)\nend\n</code></pre> avl_tree.zig<pre><code>// \u5220\u9664\u8282\u70b9\nfn remove(self: *Self, val: T) void {\n   self.root = self.removeHelper(self.root, val).?;\n}\n\n// \u9012\u5f52\u5220\u9664\u8282\u70b9\uff08\u8f85\u52a9\u65b9\u6cd5\uff09\nfn removeHelper(self: *Self, node_: ?*inc.TreeNode(T), val: T) ?*inc.TreeNode(T) {\n    var node = node_;\n    if (node == null) return null;\n    // 1. \u67e5\u627e\u8282\u70b9\u5e76\u5220\u9664\n    if (val &lt; node.?.val) {\n        node.?.left = self.removeHelper(node.?.left, val);\n    } else if (val &gt; node.?.val) {\n        node.?.right = self.removeHelper(node.?.right, val);\n    } else {\n        if (node.?.left == null or node.?.right == null) {\n            var child = if (node.?.left != null) node.?.left else node.?.right;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 0 \uff0c\u76f4\u63a5\u5220\u9664 node \u5e76\u8fd4\u56de\n            if (child == null) {\n                return null;\n            // \u5b50\u8282\u70b9\u6570\u91cf = 1 \uff0c\u76f4\u63a5\u5220\u9664 node\n            } else {\n                node = child;\n            }\n        } else {\n            // \u5b50\u8282\u70b9\u6570\u91cf = 2 \uff0c\u5219\u5c06\u4e2d\u5e8f\u904d\u5386\u7684\u4e0b\u4e2a\u8282\u70b9\u5220\u9664\uff0c\u5e76\u7528\u8be5\u8282\u70b9\u66ff\u6362\u5f53\u524d\u8282\u70b9\n            var temp = node.?.right;\n            while (temp.?.left != null) {\n                temp = temp.?.left;\n            }\n            node.?.right = self.removeHelper(node.?.right, temp.?.val);\n            node.?.val = temp.?.val;\n        }\n    }\n    self.updateHeight(node); // \u66f4\u65b0\u8282\u70b9\u9ad8\u5ea6\n    // 2. \u6267\u884c\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4f7f\u8be5\u5b50\u6811\u91cd\u65b0\u6062\u590d\u5e73\u8861\n    node = self.rotate(node);\n    // \u8fd4\u56de\u5b50\u6811\u7684\u6839\u8282\u70b9\n    return node;\n}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#3-node-search","title":"3. \u00a0 Node search","text":"<p>The node search operation in AVL trees is consistent with that in binary search trees and will not be detailed here.</p>"},{"location":"chapter_tree/avl_tree/#754-typical-applications-of-avl-trees","title":"7.5.4 \u00a0 Typical applications of AVL trees","text":"<ul> <li>Organizing and storing large amounts of data, suitable for scenarios with high-frequency searches and low-frequency intertions and removals.</li> <li>Used to build index systems in databases.</li> <li>Red-black trees are also a common type of balanced binary search tree. Compared to AVL trees, red-black trees have more relaxed balancing conditions, require fewer rotations for node insertion and removal, and have a higher average efficiency for node addition and removal operations.</li> </ul>"},{"location":"chapter_tree/binary_search_tree/","title":"7.4 \u00a0 Binary search tree","text":"<p>As shown in Figure 7-16, a binary search tree satisfies the following conditions.</p> <ol> <li>For the root node, the value of all nodes in the left subtree \\(&lt;\\) the value of the root node \\(&lt;\\) the value of all nodes in the right subtree.</li> <li>The left and right subtrees of any node are also binary search trees, i.e., they satisfy condition <code>1.</code> as well.</li> </ol> <p></p> <p> Figure 7-16 \u00a0 Binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#741-operations-on-a-binary-search-tree","title":"7.4.1 \u00a0 Operations on a binary search tree","text":"<p>We encapsulate the binary search tree as a class <code>BinarySearchTree</code> and declare a member variable <code>root</code>, pointing to the tree's root node.</p>"},{"location":"chapter_tree/binary_search_tree/#1-searching-for-a-node","title":"1. \u00a0 Searching for a node","text":"<p>Given a target node value <code>num</code>, one can search according to the properties of the binary search tree. As shown in Figure 7-17, we declare a node <code>cur</code> and start from the binary tree's root node <code>root</code>, looping to compare the size relationship between the node value <code>cur.val</code> and <code>num</code>.</p> <ul> <li>If <code>cur.val &lt; num</code>, it means the target node is in <code>cur</code>'s right subtree, thus execute <code>cur = cur.right</code>.</li> <li>If <code>cur.val &gt; num</code>, it means the target node is in <code>cur</code>'s left subtree, thus execute <code>cur = cur.left</code>.</li> <li>If <code>cur.val = num</code>, it means the target node is found, exit the loop and return the node.</li> </ul> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-17 \u00a0 Example of searching for a node in a binary search tree </p> <p>The search operation in a binary search tree works on the same principle as the binary search algorithm, eliminating half of the possibilities in each round. The number of loops is at most the height of the binary tree. When the binary tree is balanced, it uses \\(O(\\log n)\\) time. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_tree.py<pre><code>def search(self, num: int) -&gt; TreeNode | None:\n    \"\"\"\u67e5\u627e\u8282\u70b9\"\"\"\n    cur = self._root\n    # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while cur is not None:\n        # \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur.val &lt; num:\n            cur = cur.right\n        # \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        elif cur.val &gt; num:\n            cur = cur.left\n        # \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else:\n            break\n    return cur\n</code></pre> binary_search_tree.cpp<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nTreeNode *search(int num) {\n    TreeNode *cur = root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != nullptr) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur-&gt;val &gt; num)\n            cur = cur-&gt;left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else\n            break;\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.java<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nTreeNode search(int num) {\n    TreeNode cur = root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur.val &gt; num)\n            cur = cur.left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else\n            break;\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.cs<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nTreeNode? Search(int num) {\n    TreeNode? cur = root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur =\n            cur.right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur.val &gt; num)\n            cur = cur.left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else\n            break;\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.go<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nfunc (bst *binarySearchTree) search(num int) *TreeNode {\n    node := bst.root\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    for node != nil {\n        if node.Val.(int) &lt; num {\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            node = node.Right\n        } else if node.Val.(int) &gt; num {\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            node = node.Left\n        } else {\n            // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n            break\n        }\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return node\n}\n</code></pre> binary_search_tree.swift<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nfunc search(num: Int) -&gt; TreeNode? {\n    var cur = root\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while cur != nil {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if cur!.val &gt; num {\n            cur = cur?.left\n        }\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else {\n            break\n        }\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur\n}\n</code></pre> binary_search_tree.js<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nsearch(num) {\n    let cur = this.root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur.val &gt; num) cur = cur.left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else break;\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.ts<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nsearch(num: number): TreeNode | null {\n    let cur = this.root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur.val &gt; num) cur = cur.left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else break;\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.dart<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nTreeNode? search(int _num) {\n  TreeNode? cur = _root;\n  // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  while (cur != null) {\n    // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    else if (cur.val &gt; _num)\n      cur = cur.left;\n    // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n    else\n      break;\n  }\n  // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n  return cur;\n}\n</code></pre> binary_search_tree.rs<pre><code>/* \u67e5\u627e\u8282\u70b9 */\npub fn search(&amp;self, num: i32) -&gt; OptionTreeNodeRc {\n    let mut cur = self.root.clone();\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            Ordering::Greater =&gt; cur = node.borrow().right.clone(),\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            Ordering::Less =&gt; cur = node.borrow().left.clone(),\n            // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n            Ordering::Equal =&gt; break,\n        }\n    }\n\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    cur\n}\n</code></pre> binary_search_tree.c<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nTreeNode *search(BinarySearchTree *bst, int num) {\n    TreeNode *cur = bst-&gt;root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != NULL) {\n        if (cur-&gt;val &lt; num) {\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            cur = cur-&gt;right;\n        } else if (cur-&gt;val &gt; num) {\n            // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            cur = cur-&gt;left;\n        } else {\n            // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n            break;\n        }\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> binary_search_tree.kt<pre><code>/* \u67e5\u627e\u8282\u70b9 */\nfun search(num: Int): TreeNode? {\n    var cur = root\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        cur = if (cur._val &lt; num)\n            cur.right\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else if (cur._val &gt; num)\n            cur.left\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        else\n            break\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur\n}\n</code></pre> binary_search_tree.rb<pre><code>### \u67e5\u627e\u8282\u70b9 ###\ndef search(num)\n  cur = @root\n\n  # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  while !cur.nil?\n    # \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if cur.val &lt; num\n      cur = cur.right\n    # \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    elsif cur.val &gt; num\n      cur = cur.left\n    # \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n    else\n      break\n    end\n  end\n\n  cur\nend\n</code></pre> binary_search_tree.zig<pre><code>// \u67e5\u627e\u8282\u70b9\nfn search(self: *Self, num: T) ?*inc.TreeNode(T) {\n    var cur = self.root;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.?.val &lt; num) {\n            cur = cur.?.right;\n        // \u76ee\u6807\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        } else if (cur.?.val &gt; num) {\n            cur = cur.?.left;\n        // \u627e\u5230\u76ee\u6807\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        } else {\n            break;\n        }\n    }\n    // \u8fd4\u56de\u76ee\u6807\u8282\u70b9\n    return cur;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_tree/binary_search_tree/#2-inserting-a-node","title":"2. \u00a0 Inserting a node","text":"<p>Given an element <code>num</code> to be inserted, to maintain the property of the binary search tree \"left subtree &lt; root node &lt; right subtree,\" the insertion operation proceeds as shown in Figure 7-18.</p> <ol> <li>Finding the insertion position: Similar to the search operation, start from the root node and loop downwards according to the size relationship between the current node value and <code>num</code> until passing through the leaf node (traversing to <code>None</code>) then exit the loop.</li> <li>Insert the node at that position: Initialize the node <code>num</code> and place it where <code>None</code> was.</li> </ol> <p></p> <p> Figure 7-18 \u00a0 Inserting a node into a binary search tree </p> <p>In the code implementation, note the following two points.</p> <ul> <li>The binary search tree does not allow duplicate nodes; otherwise, it will violate its definition. Therefore, if the node to be inserted already exists in the tree, the insertion is not performed, and it directly returns.</li> <li>To perform the insertion operation, we need to use the node <code>pre</code> to save the node from the last loop. This way, when traversing to <code>None</code>, we can get its parent node, thus completing the node insertion operation.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_tree.py<pre><code>def insert(self, num: int):\n    \"\"\"\u63d2\u5165\u8282\u70b9\"\"\"\n    # \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if self._root is None:\n        self._root = TreeNode(num)\n        return\n    # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    cur, pre = self._root, None\n    while cur is not None:\n        # \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if cur.val == num:\n            return\n        pre = cur\n        # \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur.val &lt; num:\n            cur = cur.right\n        # \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else:\n            cur = cur.left\n    # \u63d2\u5165\u8282\u70b9\n    node = TreeNode(num)\n    if pre.val &lt; num:\n        pre.right = node\n    else:\n        pre.left = node\n</code></pre> binary_search_tree.cpp<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (root == nullptr) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode *cur = root, *pre = nullptr;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != nullptr) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur-&gt;val == num)\n            return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur-&gt;left;\n    }\n    // \u63d2\u5165\u8282\u70b9\n    TreeNode *node = new TreeNode(num);\n    if (pre-&gt;val &lt; num)\n        pre-&gt;right = node;\n    else\n        pre-&gt;left = node;\n}\n</code></pre> binary_search_tree.java<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (root == null) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode cur = root, pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur.val == num)\n            return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur.left;\n    }\n    // \u63d2\u5165\u8282\u70b9\n    TreeNode node = new TreeNode(num);\n    if (pre.val &lt; num)\n        pre.right = node;\n    else\n        pre.left = node;\n}\n</code></pre> binary_search_tree.cs<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid Insert(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (root == null) {\n        root = new TreeNode(num);\n        return;\n    }\n    TreeNode? cur = root, pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur.val == num)\n            return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur.left;\n    }\n\n    // \u63d2\u5165\u8282\u70b9\n    TreeNode node = new(num);\n    if (pre != null) {\n        if (pre.val &lt; num)\n            pre.right = node;\n        else\n            pre.left = node;\n    }\n}\n</code></pre> binary_search_tree.go<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfunc (bst *binarySearchTree) insert(num int) {\n    cur := bst.root\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if cur == nil {\n        bst.root = NewTreeNode(num)\n        return\n    }\n    // \u5f85\u63d2\u5165\u8282\u70b9\u4e4b\u524d\u7684\u8282\u70b9\u4f4d\u7f6e\n    var pre *TreeNode = nil\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    for cur != nil {\n        if cur.Val == num {\n            return\n        }\n        pre = cur\n        if cur.Val.(int) &lt; num {\n            cur = cur.Right\n        } else {\n            cur = cur.Left\n        }\n    }\n    // \u63d2\u5165\u8282\u70b9\n    node := NewTreeNode(num)\n    if pre.Val.(int) &lt; num {\n        pre.Right = node\n    } else {\n        pre.Left = node\n    }\n}\n</code></pre> binary_search_tree.swift<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfunc insert(num: Int) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if root == nil {\n        root = TreeNode(x: num)\n        return\n    }\n    var cur = root\n    var pre: TreeNode?\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while cur != nil {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if cur!.val == num {\n            return\n        }\n        pre = cur\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else {\n            cur = cur?.left\n        }\n    }\n    // \u63d2\u5165\u8282\u70b9\n    let node = TreeNode(x: num)\n    if pre!.val &lt; num {\n        pre?.right = node\n    } else {\n        pre?.left = node\n    }\n}\n</code></pre> binary_search_tree.js<pre><code>/* \u63d2\u5165\u8282\u70b9 */\ninsert(num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (this.root === null) {\n        this.root = new TreeNode(num);\n        return;\n    }\n    let cur = this.root,\n        pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur.val === num) return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else cur = cur.left;\n    }\n    // \u63d2\u5165\u8282\u70b9\n    const node = new TreeNode(num);\n    if (pre.val &lt; num) pre.right = node;\n    else pre.left = node;\n}\n</code></pre> binary_search_tree.ts<pre><code>/* \u63d2\u5165\u8282\u70b9 */\ninsert(num: number): void {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (this.root === null) {\n        this.root = new TreeNode(num);\n        return;\n    }\n    let cur: TreeNode | null = this.root,\n        pre: TreeNode | null = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur.val === num) return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else cur = cur.left;\n    }\n    // \u63d2\u5165\u8282\u70b9\n    const node = new TreeNode(num);\n    if (pre!.val &lt; num) pre!.right = node;\n    else pre!.left = node;\n}\n</code></pre> binary_search_tree.dart<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(int _num) {\n  // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n  if (_root == null) {\n    _root = TreeNode(_num);\n    return;\n  }\n  TreeNode? cur = _root;\n  TreeNode? pre = null;\n  // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  while (cur != null) {\n    // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n    if (cur.val == _num) return;\n    pre = cur;\n    // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    else\n      cur = cur.left;\n  }\n  // \u63d2\u5165\u8282\u70b9\n  TreeNode? node = TreeNode(_num);\n  if (pre!.val &lt; _num)\n    pre.right = node;\n  else\n    pre.left = node;\n}\n</code></pre> binary_search_tree.rs<pre><code>/* \u63d2\u5165\u8282\u70b9 */\npub fn insert(&amp;mut self, num: i32) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if self.root.is_none() {\n        self.root = Some(TreeNode::new(num));\n        return;\n    }\n    let mut cur = self.root.clone();\n    let mut pre = None;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n            Ordering::Equal =&gt; return,\n            // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            Ordering::Greater =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().right.clone();\n            }\n            // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            Ordering::Less =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().left.clone();\n            }\n        }\n    }\n    // \u63d2\u5165\u8282\u70b9\n    let pre = pre.unwrap();\n    let node = Some(TreeNode::new(num));\n    if num &gt; pre.borrow().val {\n        pre.borrow_mut().right = node;\n    } else {\n        pre.borrow_mut().left = node;\n    }\n}\n</code></pre> binary_search_tree.c<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nvoid insert(BinarySearchTree *bst, int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (bst-&gt;root == NULL) {\n        bst-&gt;root = newTreeNode(num);\n        return;\n    }\n    TreeNode *cur = bst-&gt;root, *pre = NULL;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != NULL) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur-&gt;val == num) {\n            return;\n        }\n        pre = cur;\n        if (cur-&gt;val &lt; num) {\n            // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            cur = cur-&gt;right;\n        } else {\n            // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            cur = cur-&gt;left;\n        }\n    }\n    // \u63d2\u5165\u8282\u70b9\n    TreeNode *node = newTreeNode(num);\n    if (pre-&gt;val &lt; num) {\n        pre-&gt;right = node;\n    } else {\n        pre-&gt;left = node;\n    }\n}\n</code></pre> binary_search_tree.kt<pre><code>/* \u63d2\u5165\u8282\u70b9 */\nfun insert(num: Int) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (root == null) {\n        root = TreeNode(num)\n        return\n    }\n    var cur = root\n    var pre: TreeNode? = null\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur._val == num)\n            return\n        pre = cur\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        cur = if (cur._val &lt; num)\n            cur.right\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur.left\n    }\n    // \u63d2\u5165\u8282\u70b9\n    val node = TreeNode(num)\n    if (pre?._val!! &lt; num)\n        pre.right = node\n    else\n        pre.left = node\n}\n</code></pre> binary_search_tree.rb<pre><code>### \u63d2\u5165\u8282\u70b9 ###\ndef insert(num)\n  # \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n  if @root.nil?\n    @root = TreeNode.new(num)\n    return\n  end\n\n  # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  cur, pre = @root, nil\n  while !cur.nil?\n    # \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n    return if cur.val == num\n\n    pre = cur\n    # \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if cur.val &lt; num\n      cur = cur.right\n    # \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    else\n      cur = cur.left\n    end\n  end\n\n  # \u63d2\u5165\u8282\u70b9\n  node = TreeNode.new(num)\n  if pre.val &lt; num\n    pre.right = node\n  else\n    pre.left = node\n  end\nend\n</code></pre> binary_search_tree.zig<pre><code>// \u63d2\u5165\u8282\u70b9\nfn insert(self: *Self, num: T) !void {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u5219\u521d\u59cb\u5316\u6839\u8282\u70b9\n    if (self.root == null) {\n        self.root = try self.mem_allocator.create(inc.TreeNode(T));\n        return;\n    }\n    var cur = self.root;\n    var pre: ?*inc.TreeNode(T) = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u91cd\u590d\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n        if (cur.?.val == num) return;\n        pre = cur;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.?.val &lt; num) {\n            cur = cur.?.right;\n        // \u63d2\u5165\u4f4d\u7f6e\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        } else {\n            cur = cur.?.left;\n        }\n    }\n    // \u63d2\u5165\u8282\u70b9\n    var node = try self.mem_allocator.create(inc.TreeNode(T));\n    node.init(num);\n    if (pre.?.val &lt; num) {\n        pre.?.right = node;\n    } else {\n        pre.?.left = node;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Similar to searching for a node, inserting a node uses \\(O(\\log n)\\) time.</p>"},{"location":"chapter_tree/binary_search_tree/#3-removing-a-node","title":"3. \u00a0 Removing a node","text":"<p>First, find the target node in the binary tree, then remove it. Similar to inserting a node, we need to ensure that after the removal operation is completed, the property of the binary search tree \"left subtree &lt; root node &lt; right subtree\" is still satisfied. Therefore, based on the number of child nodes of the target node, we divide it into 0, 1, and 2 cases, performing the corresponding node removal operations.</p> <p>As shown in Figure 7-19, when the degree of the node to be removed is \\(0\\), it means the node is a leaf node, and it can be directly removed.</p> <p></p> <p> Figure 7-19 \u00a0 Removing a node in a binary search tree (degree 0) </p> <p>As shown in Figure 7-20, when the degree of the node to be removed is \\(1\\), replacing the node to be removed with its child node is sufficient.</p> <p></p> <p> Figure 7-20 \u00a0 Removing a node in a binary search tree (degree 1) </p> <p>When the degree of the node to be removed is \\(2\\), we cannot remove it directly, but need to use a node to replace it. To maintain the property of the binary search tree \"left subtree \\(&lt;\\) root node \\(&lt;\\) right subtree,\" this node can be either the smallest node of the right subtree or the largest node of the left subtree.</p> <p>Assuming we choose the smallest node of the right subtree (the next node in in-order traversal), then the removal operation proceeds as shown in Figure 7-21.</p> <ol> <li>Find the next node in the \"in-order traversal sequence\" of the node to be removed, denoted as <code>tmp</code>.</li> <li>Replace the value of the node to be removed with <code>tmp</code>'s value, and recursively remove the node <code>tmp</code> in the tree.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p> Figure 7-21 \u00a0 Removing a node in a binary search tree (degree 2) </p> <p>The operation of removing a node also uses \\(O(\\log n)\\) time, where finding the node to be removed requires \\(O(\\log n)\\) time, and obtaining the in-order traversal successor node requires \\(O(\\log n)\\) time. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_search_tree.py<pre><code>def remove(self, num: int):\n    \"\"\"\u5220\u9664\u8282\u70b9\"\"\"\n    # \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if self._root is None:\n        return\n    # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    cur, pre = self._root, None\n    while cur is not None:\n        # \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if cur.val == num:\n            break\n        pre = cur\n        # \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur.val &lt; num:\n            cur = cur.right\n        # \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else:\n            cur = cur.left\n    # \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if cur is None:\n        return\n\n    # \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if cur.left is None or cur.right is None:\n        # \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        child = cur.left or cur.right\n        # \u5220\u9664\u8282\u70b9 cur\n        if cur != self._root:\n            if pre.left == cur:\n                pre.left = child\n            else:\n                pre.right = child\n        else:\n            # \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            self._root = child\n    # \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else:\n        # \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        tmp: TreeNode = cur.right\n        while tmp.left is not None:\n            tmp = tmp.left\n        # \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        self.remove(tmp.val)\n        # \u7528 tmp \u8986\u76d6 cur\n        cur.val = tmp.val\n</code></pre> binary_search_tree.cpp<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (root == nullptr)\n        return;\n    TreeNode *cur = root, *pre = nullptr;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != nullptr) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur-&gt;val == num)\n            break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur-&gt;val &lt; num)\n            cur = cur-&gt;right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur-&gt;left;\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == nullptr)\n        return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur-&gt;left == nullptr || cur-&gt;right == nullptr) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = nullptr / \u8be5\u5b50\u8282\u70b9\n        TreeNode *child = cur-&gt;left != nullptr ? cur-&gt;left : cur-&gt;right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur != root) {\n            if (pre-&gt;left == cur)\n                pre-&gt;left = child;\n            else\n                pre-&gt;right = child;\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            root = child;\n        }\n        // \u91ca\u653e\u5185\u5b58\n        delete cur;\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        TreeNode *tmp = cur-&gt;right;\n        while (tmp-&gt;left != nullptr) {\n            tmp = tmp-&gt;left;\n        }\n        int tmpVal = tmp-&gt;val;\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        remove(tmp-&gt;val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur-&gt;val = tmpVal;\n    }\n}\n</code></pre> binary_search_tree.java<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (root == null)\n        return;\n    TreeNode cur = root, pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur.val == num)\n            break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur.left;\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == null)\n        return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        TreeNode child = cur.left != null ? cur.left : cur.right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur != root) {\n            if (pre.left == cur)\n                pre.left = child;\n            else\n                pre.right = child;\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            root = child;\n        }\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        TreeNode tmp = cur.right;\n        while (tmp.left != null) {\n            tmp = tmp.left;\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        remove(tmp.val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.cs<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid Remove(int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (root == null)\n        return;\n    TreeNode? cur = root, pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur.val == num)\n            break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num)\n            cur = cur.right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur = cur.left;\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == null)\n        return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        TreeNode? child = cur.left ?? cur.right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur != root) {\n            if (pre!.left == cur)\n                pre.left = child;\n            else\n                pre.right = child;\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            root = child;\n        }\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        TreeNode? tmp = cur.right;\n        while (tmp.left != null) {\n            tmp = tmp.left;\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        Remove(tmp.val!.Value);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.go<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfunc (bst *binarySearchTree) remove(num int) {\n    cur := bst.root\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if cur == nil {\n        return\n    }\n    // \u5f85\u5220\u9664\u8282\u70b9\u4e4b\u524d\u7684\u8282\u70b9\u4f4d\u7f6e\n    var pre *TreeNode = nil\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    for cur != nil {\n        if cur.Val == num {\n            break\n        }\n        pre = cur\n        if cur.Val.(int) &lt; num {\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728\u53f3\u5b50\u6811\u4e2d\n            cur = cur.Right\n        } else {\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728\u5de6\u5b50\u6811\u4e2d\n            cur = cur.Left\n        }\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if cur == nil {\n        return\n    }\n    // \u5b50\u8282\u70b9\u6570\u4e3a 0 \u6216 1\n    if cur.Left == nil || cur.Right == nil {\n        var child *TreeNode = nil\n        // \u53d6\u51fa\u5f85\u5220\u9664\u8282\u70b9\u7684\u5b50\u8282\u70b9\n        if cur.Left != nil {\n            child = cur.Left\n        } else {\n            child = cur.Right\n        }\n        // \u5220\u9664\u8282\u70b9 cur\n        if cur != bst.root {\n            if pre.Left == cur {\n                pre.Left = child\n            } else {\n                pre.Right = child\n            }\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            bst.root = child\n        }\n        // \u5b50\u8282\u70b9\u6570\u4e3a 2\n    } else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d\u5f85\u5220\u9664\u8282\u70b9 cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        tmp := cur.Right\n        for tmp.Left != nil {\n            tmp = tmp.Left\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        bst.remove(tmp.Val.(int))\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.Val = tmp.Val\n    }\n}\n</code></pre> binary_search_tree.swift<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfunc remove(num: Int) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if root == nil {\n        return\n    }\n    var cur = root\n    var pre: TreeNode?\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while cur != nil {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if cur!.val == num {\n            break\n        }\n        pre = cur\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if cur!.val &lt; num {\n            cur = cur?.right\n        }\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else {\n            cur = cur?.left\n        }\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if cur == nil {\n        return\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if cur?.left == nil || cur?.right == nil {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        let child = cur?.left ?? cur?.right\n        // \u5220\u9664\u8282\u70b9 cur\n        if cur !== root {\n            if pre?.left === cur {\n                pre?.left = child\n            } else {\n                pre?.right = child\n            }\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            root = child\n        }\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        var tmp = cur?.right\n        while tmp?.left != nil {\n            tmp = tmp?.left\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        remove(num: tmp!.val)\n        // \u7528 tmp \u8986\u76d6 cur\n        cur?.val = tmp!.val\n    }\n}\n</code></pre> binary_search_tree.js<pre><code>/* \u5220\u9664\u8282\u70b9 */\nremove(num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (this.root === null) return;\n    let cur = this.root,\n        pre = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur.val === num) break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else cur = cur.left;\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur === null) return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.left === null || cur.right === null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        const child = cur.left !== null ? cur.left : cur.right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur !== this.root) {\n            if (pre.left === cur) pre.left = child;\n            else pre.right = child;\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            this.root = child;\n        }\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        let tmp = cur.right;\n        while (tmp.left !== null) {\n            tmp = tmp.left;\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        this.remove(tmp.val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.val = tmp.val;\n    }\n}\n</code></pre> binary_search_tree.ts<pre><code>/* \u5220\u9664\u8282\u70b9 */\nremove(num: number): void {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (this.root === null) return;\n    let cur: TreeNode | null = this.root,\n        pre: TreeNode | null = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur !== null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur.val === num) break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.val &lt; num) cur = cur.right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else cur = cur.left;\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur === null) return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.left === null || cur.right === null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        const child: TreeNode | null =\n            cur.left !== null ? cur.left : cur.right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur !== this.root) {\n            if (pre!.left === cur) pre!.left = child;\n            else pre!.right = child;\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            this.root = child;\n        }\n    }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        let tmp: TreeNode | null = cur.right;\n        while (tmp!.left !== null) {\n            tmp = tmp!.left;\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        this.remove(tmp!.val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.val = tmp!.val;\n    }\n}\n</code></pre> binary_search_tree.dart<pre><code>/* \u5220\u9664\u8282\u70b9 */\nvoid remove(int _num) {\n  // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n  if (_root == null) return;\n  TreeNode? cur = _root;\n  TreeNode? pre = null;\n  // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  while (cur != null) {\n    // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n    if (cur.val == _num) break;\n    pre = cur;\n    // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if (cur.val &lt; _num)\n      cur = cur.right;\n    // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    else\n      cur = cur.left;\n  }\n  // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\n  if (cur == null) return;\n  // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n  if (cur.left == null || cur.right == null) {\n    // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n    TreeNode? child = cur.left ?? cur.right;\n    // \u5220\u9664\u8282\u70b9 cur\n    if (cur != _root) {\n      if (pre!.left == cur)\n        pre.left = child;\n      else\n        pre.right = child;\n    } else {\n      // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n      _root = child;\n    }\n  } else {\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n    TreeNode? tmp = cur.right;\n    while (tmp!.left != null) {\n      tmp = tmp.left;\n    }\n    // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n    remove(tmp.val);\n    // \u7528 tmp \u8986\u76d6 cur\n    cur.val = tmp.val;\n  }\n}\n</code></pre> binary_search_tree.rs<pre><code>/* \u5220\u9664\u8282\u70b9 */\npub fn remove(&amp;mut self, num: i32) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if self.root.is_none() {\n        return;\n    }\n    let mut cur = self.root.clone();\n    let mut pre = None;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while let Some(node) = cur.clone() {\n        match num.cmp(&amp;node.borrow().val) {\n            // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n            Ordering::Equal =&gt; break,\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n            Ordering::Greater =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().right.clone();\n            }\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n            Ordering::Less =&gt; {\n                pre = cur.clone();\n                cur = node.borrow().left.clone();\n            }\n        }\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if cur.is_none() {\n        return;\n    }\n    let cur = cur.unwrap();\n    let (left_child, right_child) = (cur.borrow().left.clone(), cur.borrow().right.clone());\n    match (left_child.clone(), right_child.clone()) {\n        // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n        (None, None) | (Some(_), None) | (None, Some(_)) =&gt; {\n            // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = nullptr / \u8be5\u5b50\u8282\u70b9\n            let child = left_child.or(right_child);\n            let pre = pre.unwrap();\n            // \u5220\u9664\u8282\u70b9 cur\n            if !Rc::ptr_eq(&amp;cur, self.root.as_ref().unwrap()) {\n                let left = pre.borrow().left.clone();\n                if left.is_some() &amp;&amp; Rc::ptr_eq(&amp;left.as_ref().unwrap(), &amp;cur) {\n                    pre.borrow_mut().left = child;\n                } else {\n                    pre.borrow_mut().right = child;\n                }\n            } else {\n                // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n                self.root = child;\n            }\n        }\n        // \u5b50\u8282\u70b9\u6570\u91cf = 2\n        (Some(_), Some(_)) =&gt; {\n            // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n            let mut tmp = cur.borrow().right.clone();\n            while let Some(node) = tmp.clone() {\n                if node.borrow().left.is_some() {\n                    tmp = node.borrow().left.clone();\n                } else {\n                    break;\n                }\n            }\n            let tmpval = tmp.unwrap().borrow().val;\n            // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n            self.remove(tmpval);\n            // \u7528 tmp \u8986\u76d6 cur\n            cur.borrow_mut().val = tmpval;\n        }\n    }\n}\n</code></pre> binary_search_tree.c<pre><code>/* \u5220\u9664\u8282\u70b9 */\n// \u7531\u4e8e\u5f15\u5165\u4e86 stdio.h \uff0c\u6b64\u5904\u65e0\u6cd5\u4f7f\u7528 remove \u5173\u952e\u8bcd\nvoid removeItem(BinarySearchTree *bst, int num) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (bst-&gt;root == NULL)\n        return;\n    TreeNode *cur = bst-&gt;root, *pre = NULL;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != NULL) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur-&gt;val == num)\n            break;\n        pre = cur;\n        if (cur-&gt;val &lt; num) {\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728 root \u7684\u53f3\u5b50\u6811\u4e2d\n            cur = cur-&gt;right;\n        } else {\n            // \u5f85\u5220\u9664\u8282\u70b9\u5728 root \u7684\u5de6\u5b50\u6811\u4e2d\n            cur = cur-&gt;left;\n        }\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == NULL)\n        return;\n    // \u5224\u65ad\u5f85\u5220\u9664\u8282\u70b9\u662f\u5426\u5b58\u5728\u5b50\u8282\u70b9\n    if (cur-&gt;left == NULL || cur-&gt;right == NULL) {\n        /* \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1 */\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = nullptr / \u8be5\u5b50\u8282\u70b9\n        TreeNode *child = cur-&gt;left != NULL ? cur-&gt;left : cur-&gt;right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (pre-&gt;left == cur) {\n            pre-&gt;left = child;\n        } else {\n            pre-&gt;right = child;\n        }\n        // \u91ca\u653e\u5185\u5b58\n        free(cur);\n    } else {\n        /* \u5b50\u8282\u70b9\u6570\u91cf = 2 */\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        TreeNode *tmp = cur-&gt;right;\n        while (tmp-&gt;left != NULL) {\n            tmp = tmp-&gt;left;\n        }\n        int tmpVal = tmp-&gt;val;\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        removeItem(bst, tmp-&gt;val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur-&gt;val = tmpVal;\n    }\n}\n</code></pre> binary_search_tree.kt<pre><code>/* \u5220\u9664\u8282\u70b9 */\nfun remove(num: Int) {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (root == null)\n        return\n    var cur = root\n    var pre: TreeNode? = null\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur._val == num)\n            break\n        pre = cur\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        cur = if (cur._val &lt; num)\n            cur.right\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        else\n            cur.left\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == null)\n        return\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.left == null || cur.right == null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        val child = if (cur.left != null)\n            cur.left\n        else\n            cur.right\n        // \u5220\u9664\u8282\u70b9 cur\n        if (cur != root) {\n            if (pre!!.left == cur)\n                pre.left = child\n            else\n                pre.right = child\n        } else {\n            // \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n            root = child\n        }\n        // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    } else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        var tmp = cur.right\n        while (tmp!!.left != null) {\n            tmp = tmp.left\n        }\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        remove(tmp._val)\n        // \u7528 tmp \u8986\u76d6 cur\n        cur._val = tmp._val\n    }\n}\n</code></pre> binary_search_tree.rb<pre><code>### \u5220\u9664\u8282\u70b9 ###\ndef remove(num)\n  # \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n  return if @root.nil?\n\n  # \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n  cur, pre = @root, nil\n  while !cur.nil?\n    # \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n    break if cur.val == num\n\n    pre = cur\n    # \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n    if cur.val &lt; num\n      cur = cur.right\n    # \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n    else\n      cur = cur.left\n    end\n  end\n  # \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n  return if cur.nil?\n\n  # \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n  if cur.left.nil? || cur.right.nil?\n    # \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n    child = cur.left || cur.right\n    # \u5220\u9664\u8282\u70b9 cur\n    if cur != @root\n      if pre.left == cur\n        pre.left = child\n      else\n        pre.right = child\n      end\n    else\n      # \u82e5\u5220\u9664\u8282\u70b9\u4e3a\u6839\u8282\u70b9\uff0c\u5219\u91cd\u65b0\u6307\u5b9a\u6839\u8282\u70b9\n      @root = child\n    end\n  # \u5b50\u8282\u70b9\u6570\u91cf = 2\n  else\n    # \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n    tmp = cur.right\n    while !tmp.left.nil?\n      tmp = tmp.left\n    end\n    # \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n    remove(tmp.val)\n    # \u7528 tmp \u8986\u76d6 cur\n    cur.val = tmp.val\n  end\nend\n</code></pre> binary_search_tree.zig<pre><code>// \u5220\u9664\u8282\u70b9\nfn remove(self: *Self, num: T) void {\n    // \u82e5\u6811\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63d0\u524d\u8fd4\u56de\n    if (self.root == null) return;\n    var cur = self.root;\n    var pre: ?*inc.TreeNode(T) = null;\n    // \u5faa\u73af\u67e5\u627e\uff0c\u8d8a\u8fc7\u53f6\u8282\u70b9\u540e\u8df3\u51fa\n    while (cur != null) {\n        // \u627e\u5230\u5f85\u5220\u9664\u8282\u70b9\uff0c\u8df3\u51fa\u5faa\u73af\n        if (cur.?.val == num) break;\n        pre = cur;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u53f3\u5b50\u6811\u4e2d\n        if (cur.?.val &lt; num) {\n            cur = cur.?.right;\n        // \u5f85\u5220\u9664\u8282\u70b9\u5728 cur \u7684\u5de6\u5b50\u6811\u4e2d\n        } else {\n            cur = cur.?.left;\n        }\n    }\n    // \u82e5\u65e0\u5f85\u5220\u9664\u8282\u70b9\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n    if (cur == null) return;\n    // \u5b50\u8282\u70b9\u6570\u91cf = 0 or 1\n    if (cur.?.left == null or cur.?.right == null) {\n        // \u5f53\u5b50\u8282\u70b9\u6570\u91cf = 0 / 1 \u65f6\uff0c child = null / \u8be5\u5b50\u8282\u70b9\n        var child = if (cur.?.left != null) cur.?.left else cur.?.right;\n        // \u5220\u9664\u8282\u70b9 cur\n        if (pre.?.left == cur) {\n            pre.?.left = child;\n        } else {\n            pre.?.right = child;\n        }\n    // \u5b50\u8282\u70b9\u6570\u91cf = 2\n    } else {\n        // \u83b7\u53d6\u4e2d\u5e8f\u904d\u5386\u4e2d cur \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\n        var tmp = cur.?.right;\n        while (tmp.?.left != null) {\n            tmp = tmp.?.left;\n        }\n        var tmp_val = tmp.?.val;\n        // \u9012\u5f52\u5220\u9664\u8282\u70b9 tmp\n        self.remove(tmp.?.val);\n        // \u7528 tmp \u8986\u76d6 cur\n        cur.?.val = tmp_val;\n    }\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_tree/binary_search_tree/#4-in-order-traversal-is-ordered","title":"4. \u00a0 In-order traversal is ordered","text":"<p>As shown in Figure 7-22, the in-order traversal of a binary tree follows the \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\" traversal order, and a binary search tree satisfies the size relationship \"left child node \\(&lt;\\) root node \\(&lt;\\) right child node\".</p> <p>This means that in-order traversal in a binary search tree always traverses the next smallest node first, thus deriving an important property: The in-order traversal sequence of a binary search tree is ascending.</p> <p>Using the ascending property of in-order traversal, obtaining ordered data in a binary search tree requires only \\(O(n)\\) time, without the need for additional sorting operations, which is very efficient.</p> <p></p> <p> Figure 7-22 \u00a0 In-order traversal sequence of a binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#742-efficiency-of-binary-search-trees","title":"7.4.2 \u00a0 Efficiency of binary search trees","text":"<p>Given a set of data, we consider using an array or a binary search tree for storage. Observing Table 7-2, the operations on a binary search tree all have logarithmic time complexity, which is stable and efficient. Only in scenarios of high-frequency addition and low-frequency search and removal, arrays are more efficient than binary search trees.</p> <p> Table 7-2 \u00a0 Efficiency comparison between arrays and search trees </p> Unsorted array Binary search tree Search element \\(O(n)\\) \\(O(\\log n)\\) Insert element \\(O(1)\\) \\(O(\\log n)\\) Remove element \\(O(n)\\) \\(O(\\log n)\\) <p>In ideal conditions, the binary search tree is \"balanced,\" thus any node can be found within \\(\\log n\\) loops.</p> <p>However, continuously inserting and removing nodes in a binary search tree may lead to the binary tree degenerating into a chain list as shown in Figure 7-23, at which point the time complexity of various operations also degrades to \\(O(n)\\).</p> <p></p> <p> Figure 7-23 \u00a0 Degradation of a binary search tree </p>"},{"location":"chapter_tree/binary_search_tree/#743-common-applications-of-binary-search-trees","title":"7.4.3 \u00a0 Common applications of binary search trees","text":"<ul> <li>Used as multi-level indexes in systems to implement efficient search, insertion, and removal operations.</li> <li>Serves as the underlying data structure for certain search algorithms.</li> <li>Used to store data streams to maintain their ordered state.</li> </ul>"},{"location":"chapter_tree/binary_tree/","title":"7.1 \u00a0 Binary tree","text":"<p>A binary tree is a non-linear data structure that represents the ancestral and descendent relationships, embodying the \"divide and conquer\" logic. Similar to a linked list, the basic unit of a binary tree is a node, each containing a value, a reference to the left child node, and a reference to the right child node.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>class TreeNode:\n    \"\"\"Binary tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.left: TreeNode | None = None  # Reference to left child node\n        self.right: TreeNode | None = None # Reference to right child node\n</code></pre> <pre><code>/* Binary tree node */\nstruct TreeNode {\n    int val;          // Node value\n    TreeNode *left;   // Pointer to left child node\n    TreeNode *right;  // Pointer to right child node\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    int val;         // Node value\n    TreeNode left;   // Reference to left child node\n    TreeNode right;  // Reference to right child node\n    TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public TreeNode? left;  // Reference to left child node\n    public TreeNode? right; // Reference to right child node\n}\n</code></pre> <pre><code>/* Binary tree node */\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n/* \u6784\u9020\u65b9\u6cd5 */\nfunc NewTreeNode(v int) *TreeNode {\n    return &amp;TreeNode{\n        Left:  nil, // Pointer to left child node\n        Right: nil, // Pointer to right child node\n        Val:   v,   // Node value\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var left: TreeNode? // Reference to left child node\n    var right: TreeNode? // Reference to right child node\n\n    init(x: Int) {\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val; // Node value\n    left; // Pointer to left child node\n    right; // Pointer to right child node\n    constructor(val, left, right) {\n        this.val = val === undefined ? 0 : val;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val; // Node value\n        this.left = left === undefined ? null : left; // Reference to left child node\n        this.right = right === undefined ? null : right; // Reference to right child node\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n  int val;         // Node value\n  TreeNode? left;  // Reference to left child node\n  TreeNode? right; // Reference to right child node\n  TreeNode(this.val, [this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Binary tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Reference to left child node\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Reference to right child node\n}\n\nimpl TreeNode {\n    /* \u6784\u9020\u65b9\u6cd5 */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\ntypedef struct TreeNode {\n    int val;                // Node value\n    int height;             // \u8282\u70b9\u9ad8\u5ea6\n    struct TreeNode *left;  // Pointer to left child node\n    struct TreeNode *right; // Pointer to right child node\n} TreeNode;\n\n/* \u6784\u9020\u51fd\u6570 */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val left: TreeNode? = null   // Reference to left child node\n    val right: TreeNode? = null  // Reference to right child node\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Each node has two references (pointers), pointing to the left-child node and right-child node, respectively. This node is called the parent node of these two child nodes. When given a node of a binary tree, we call the tree formed by this node's left child and all nodes under it the left subtree of this node. Similarly, the right subtree can be defined.</p> <p>In a binary tree, except for leaf nodes, all other nodes contain child nodes and non-empty subtrees. As shown in Figure 7-1, if \"Node 2\" is considered as the parent node, then its left and right child nodes are \"Node 4\" and \"Node 5,\" respectively. The left subtree is \"the tree formed by Node 4 and all nodes under it,\" and the right subtree is \"the tree formed by Node 5 and all nodes under it.\"</p> <p></p> <p> Figure 7-1 \u00a0 Parent Node, child Node, subtree </p>"},{"location":"chapter_tree/binary_tree/#711-common-terminology-of-binary-trees","title":"7.1.1 \u00a0 Common terminology of binary trees","text":"<p>The commonly used terminology of binary trees is shown in Figure 7-2.</p> <ul> <li>Root node: The node at the top level of the binary tree, which has no parent node.</li> <li>Leaf node: A node with no children, both of its pointers point to <code>None</code>.</li> <li>Edge: The line segment connecting two nodes, i.e., node reference (pointer).</li> <li>The level of a node: Incrementing from top to bottom, with the root node's level being 1.</li> <li>The degree of a node: The number of a node's children. In a binary tree, the degree can be 0, 1, or 2.</li> <li>The height of a binary tree: The number of edges passed from the root node to the farthest leaf node.</li> <li>The depth of a node: The number of edges passed from the root node to the node.</li> <li>The height of a node: The number of edges from the farthest leaf node to the node.</li> </ul> <p></p> <p> Figure 7-2 \u00a0 Common Terminology of Binary Trees </p> <p>Tip</p> <p>Please note that we usually define \"height\" and \"depth\" as \"the number of edges passed,\" but some problems or textbooks may define them as \"the number of nodes passed.\" In this case, both height and depth need to be incremented by 1.</p>"},{"location":"chapter_tree/binary_tree/#712-basic-operations-of-binary-trees","title":"7.1.2 \u00a0 Basic operations of binary trees","text":""},{"location":"chapter_tree/binary_tree/#1-initializing-a-binary-tree","title":"1. \u00a0 Initializing a binary tree","text":"<p>Similar to a linked list, initialize nodes first, then construct references (pointers).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree.py<pre><code># Initializing a binary tree\n# Initializing nodes\nn1 = TreeNode(val=1)\nn2 = TreeNode(val=2)\nn3 = TreeNode(val=3)\nn4 = TreeNode(val=4)\nn5 = TreeNode(val=5)\n# Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.cpp<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode* n1 = new TreeNode(1);\nTreeNode* n2 = new TreeNode(2);\nTreeNode* n3 = new TreeNode(3);\nTreeNode* n4 = new TreeNode(4);\nTreeNode* n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.java<pre><code>// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.cs<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new(1);\nTreeNode n2 = new(2);\nTreeNode n3 = new(3);\nTreeNode n4 = new(4);\nTreeNode n5 = new(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.go<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nn1 := NewTreeNode(1)\nn2 := NewTreeNode(2)\nn3 := NewTreeNode(3)\nn4 := NewTreeNode(4)\nn5 := NewTreeNode(5)\n// Linking references (pointers) between nodes\nn1.Left = n2\nn1.Right = n3\nn2.Left = n4\nn2.Right = n5\n</code></pre> binary_tree.swift<pre><code>// Initializing nodes\nlet n1 = TreeNode(x: 1)\nlet n2 = TreeNode(x: 2)\nlet n3 = TreeNode(x: 3)\nlet n4 = TreeNode(x: 4)\nlet n5 = TreeNode(x: 5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.js<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.ts<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.dart<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.rs<pre><code>// Initializing nodes\nlet n1 = TreeNode::new(1);\nlet n2 = TreeNode::new(2);\nlet n3 = TreeNode::new(3);\nlet n4 = TreeNode::new(4);\nlet n5 = TreeNode::new(5);\n// Linking references (pointers) between nodes\nn1.borrow_mut().left = Some(n2.clone());\nn1.borrow_mut().right = Some(n3);\nn2.borrow_mut().left = Some(n4);\nn2.borrow_mut().right = Some(n5);\n</code></pre> binary_tree.c<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode *n1 = newTreeNode(1);\nTreeNode *n2 = newTreeNode(2);\nTreeNode *n3 = newTreeNode(3);\nTreeNode *n4 = newTreeNode(4);\nTreeNode *n5 = newTreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.kt<pre><code>// Initializing nodes\nval n1 = TreeNode(1)\nval n2 = TreeNode(2)\nval n3 = TreeNode(3)\nval n4 = TreeNode(4)\nval n5 = TreeNode(5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.rb<pre><code>\n</code></pre> binary_tree.zig<pre><code>\n</code></pre> Code visualization <p>https://pythontutor.com/render.html#code=class%20TreeNode%3A%0A%20%20%20%20%22%22%22%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.left%3A%20TreeNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%20%20%20%20%20%20%20%20self.right%3A%20TreeNode%20%7C%20None%20%3D%20None%20%23%20%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%0A%20%20%20%20n1%20%3D%20TreeNode%28val%3D1%29%0A%20%20%20%20n2%20%3D%20TreeNode%28val%3D2%29%0A%20%20%20%20n3%20%3D%20TreeNode%28val%3D3%29%0A%20%20%20%20n4%20%3D%20TreeNode%28val%3D4%29%0A%20%20%20%20n5%20%3D%20TreeNode%28val%3D5%29%0A%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E6%8C%87%E9%92%88%EF%BC%89%0A%20%20%20%20n1.left%20%3D%20n2%0A%20%20%20%20n1.right%20%3D%20n3%0A%20%20%20%20n2.left%20%3D%20n4%0A%20%20%20%20n2.right%20%3D%20n5&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_tree/binary_tree/#2-inserting-and-removing-nodes","title":"2. \u00a0 Inserting and removing nodes","text":"<p>Similar to a linked list, inserting and removing nodes in a binary tree can be achieved by modifying pointers. Figure 7-3 provides an example.</p> <p></p> <p> Figure 7-3 \u00a0 Inserting and removing nodes in a binary tree </p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree.py<pre><code># Inserting and removing nodes\np = TreeNode(0)\n# Inserting node P between n1 -&gt; n2\nn1.left = p\np.left = n2\n# Removing node P\nn1.left = n2\n</code></pre> binary_tree.cpp<pre><code>/* Inserting and removing nodes */\nTreeNode* P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.java<pre><code>TreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.cs<pre><code>/* Inserting and removing nodes */\nTreeNode P = new(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.go<pre><code>/* Inserting and removing nodes */\n// Inserting node P between n1 and n2\np := NewTreeNode(0)\nn1.Left = p\np.Left = n2\n// Removing node P\nn1.Left = n2\n</code></pre> binary_tree.swift<pre><code>let P = TreeNode(x: 0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.js<pre><code>/* Inserting and removing nodes */\nlet P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.ts<pre><code>/* Inserting and removing nodes */\nconst P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.dart<pre><code>/* Inserting and removing nodes */\nTreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.rs<pre><code>let p = TreeNode::new(0);\n// Inserting node P between n1 and n2\nn1.borrow_mut().left = Some(p.clone());\np.borrow_mut().left = Some(n2.clone());\n// Removing node P\nn1.borrow_mut().left = Some(n2);\n</code></pre> binary_tree.c<pre><code>/* Inserting and removing nodes */\nTreeNode *P = newTreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.kt<pre><code>val P = TreeNode(0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.rb<pre><code>\n</code></pre> binary_tree.zig<pre><code>\n</code></pre> Code visualization <p>https://pythontutor.com/render.html#code=class%20TreeNode%3A%0A%20%20%20%20%22%22%22%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.left%3A%20TreeNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%20%20%20%20%20%20%20%20self.right%3A%20TreeNode%20%7C%20None%20%3D%20None%20%23%20%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%0A%20%20%20%20n1%20%3D%20TreeNode%28val%3D1%29%0A%20%20%20%20n2%20%3D%20TreeNode%28val%3D2%29%0A%20%20%20%20n3%20%3D%20TreeNode%28val%3D3%29%0A%20%20%20%20n4%20%3D%20TreeNode%28val%3D4%29%0A%20%20%20%20n5%20%3D%20TreeNode%28val%3D5%29%0A%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E6%8C%87%E9%92%88%EF%BC%89%0A%20%20%20%20n1.left%20%3D%20n2%0A%20%20%20%20n1.right%20%3D%20n3%0A%20%20%20%20n2.left%20%3D%20n4%0A%20%20%20%20n2.right%20%3D%20n5%0A%0A%20%20%20%20%23%20%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%0A%20%20%20%20p%20%3D%20TreeNode%280%29%0A%20%20%20%20%23%20%E5%9C%A8%20n1%20-%3E%20n2%20%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%20P%0A%20%20%20%20n1.left%20%3D%20p%0A%20%20%20%20p.left%20%3D%20n2%0A%20%20%20%20%23%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%20P%0A%20%20%20%20n1.left%20%3D%20n2&amp;cumulative=false&amp;curInstr=37&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>Tip</p> <p>It's important to note that inserting nodes may change the original logical structure of the binary tree, while removing nodes usually means removing the node and all its subtrees. Therefore, in a binary tree, insertion and removal are usually performed through a set of operations to achieve meaningful actions.</p>"},{"location":"chapter_tree/binary_tree/#713-common-types-of-binary-trees","title":"7.1.3 \u00a0 Common types of binary trees","text":""},{"location":"chapter_tree/binary_tree/#1-perfect-binary-tree","title":"1. \u00a0 Perfect binary tree","text":"<p>As shown in Figure 7-4, in a perfect binary tree, all levels of nodes are fully filled. In a perfect binary tree, the degree of leaf nodes is \\(0\\), and the degree of all other nodes is \\(2\\); if the tree's height is \\(h\\), then the total number of nodes is \\(2^{h+1} - 1\\), showing a standard exponential relationship, reflecting the common phenomenon of cell division in nature.</p> <p>Tip</p> <p>Please note that in the Chinese community, a perfect binary tree is often referred to as a full binary tree.</p> <p></p> <p> Figure 7-4 \u00a0 Perfect binary tree </p>"},{"location":"chapter_tree/binary_tree/#2-complete-binary-tree","title":"2. \u00a0 Complete binary tree","text":"<p>As shown in Figure 7-5, a complete binary tree has only the bottom level nodes not fully filled, and the bottom level nodes are filled as far left as possible.</p> <p></p> <p> Figure 7-5 \u00a0 Complete binary tree </p>"},{"location":"chapter_tree/binary_tree/#3-full-binary-tree","title":"3. \u00a0 Full binary tree","text":"<p>As shown in Figure 7-6, a full binary tree has all nodes except leaf nodes having two children.</p> <p></p> <p> Figure 7-6 \u00a0 Full binary tree </p>"},{"location":"chapter_tree/binary_tree/#4-balanced-binary-tree","title":"4. \u00a0 Balanced binary tree","text":"<p>As shown in Figure 7-7, in a balanced binary tree, the absolute difference in height between the left and right subtrees of any node does not exceed 1.</p> <p></p> <p> Figure 7-7 \u00a0 Balanced binary tree </p>"},{"location":"chapter_tree/binary_tree/#714-degeneration-of-binary-trees","title":"7.1.4 \u00a0 Degeneration of binary trees","text":"<p>Figure 7-8 shows the ideal and degenerate structures of binary trees. When every level of a binary tree is filled, it reaches the \"perfect binary tree\"; when all nodes are biased towards one side, the binary tree degenerates into a \"linked list\".</p> <ul> <li>The perfect binary tree is the ideal situation, fully leveraging the \"divide and conquer\" advantage of binary trees.</li> <li>A linked list is another extreme, where operations become linear, degrading the time complexity to \\(O(n)\\).</li> </ul> <p></p> <p> Figure 7-8 \u00a0 The Best and Worst Structures of Binary Trees </p> <p>As shown in Table 7-1, in the best and worst structures, the number of leaf nodes, total number of nodes, and height of the binary tree reach their maximum or minimum values.</p> <p> Table 7-1 \u00a0 The Best and Worst Structures of Binary Trees </p> Perfect binary tree Linked list Number of nodes at level \\(i\\) \\(2^{i-1}\\) \\(1\\) Number of leaf nodes in a tree with height \\(h\\) \\(2^h\\) \\(1\\) Total number of nodes in a tree with height \\(h\\) \\(2^{h+1} - 1\\) \\(h + 1\\) Height of a tree with \\(n\\) total nodes \\(\\log_2 (n+1) - 1\\) \\(n - 1\\)"},{"location":"chapter_tree/binary_tree_traversal/","title":"7.2 \u00a0 Binary tree traversal","text":"<p>From the perspective of physical structure, a tree is a data structure based on linked lists, hence its traversal method involves accessing nodes one by one through pointers. However, a tree is a non-linear data structure, which makes traversing a tree more complex than traversing a linked list, requiring the assistance of search algorithms to achieve.</p> <p>Common traversal methods for binary trees include level-order traversal, preorder traversal, inorder traversal, and postorder traversal, among others.</p>"},{"location":"chapter_tree/binary_tree_traversal/#721-level-order-traversal","title":"7.2.1 \u00a0 Level-order traversal","text":"<p>As shown in Figure 7-9, level-order traversal traverses the binary tree from top to bottom, layer by layer, and accesses nodes in each layer in a left-to-right order.</p> <p>Level-order traversal essentially belongs to breadth-first traversal, also known as breadth-first search (BFS), which embodies a \"circumferentially outward expanding\" layer-by-layer traversal method.</p> <p></p> <p> Figure 7-9 \u00a0 Level-order traversal of a binary tree </p>"},{"location":"chapter_tree/binary_tree_traversal/#1-code-implementation","title":"1. \u00a0 Code implementation","text":"<p>Breadth-first traversal is usually implemented with the help of a \"queue\". The queue follows the \"first in, first out\" rule, while breadth-first traversal follows the \"layer-by-layer progression\" rule, the underlying ideas of the two are consistent. The implementation code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree_bfs.py<pre><code>def level_order(root: TreeNode | None) -&gt; list[int]:\n    \"\"\"\u5c42\u5e8f\u904d\u5386\"\"\"\n    # \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    queue: deque[TreeNode] = deque()\n    queue.append(root)\n    # \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    res = []\n    while queue:\n        node: TreeNode = queue.popleft()  # \u961f\u5217\u51fa\u961f\n        res.append(node.val)  # \u4fdd\u5b58\u8282\u70b9\u503c\n        if node.left is not None:\n            queue.append(node.left)  # \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if node.right is not None:\n            queue.append(node.right)  # \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    return res\n</code></pre> binary_tree_bfs.cpp<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nvector&lt;int&gt; levelOrder(TreeNode *root) {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    queue&lt;TreeNode *&gt; queue;\n    queue.push(root);\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    vector&lt;int&gt; vec;\n    while (!queue.empty()) {\n        TreeNode *node = queue.front();\n        queue.pop();              // \u961f\u5217\u51fa\u961f\n        vec.push_back(node-&gt;val); // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node-&gt;left != nullptr)\n            queue.push(node-&gt;left); // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if (node-&gt;right != nullptr)\n            queue.push(node-&gt;right); // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    }\n    return vec;\n}\n</code></pre> binary_tree_bfs.java<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nList&lt;Integer&gt; levelOrder(TreeNode root) {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n    queue.add(root);\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll(); // \u961f\u5217\u51fa\u961f\n        list.add(node.val);           // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left != null)\n            queue.offer(node.left);   // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if (node.right != null)\n            queue.offer(node.right);  // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.cs<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nList&lt;int&gt; LevelOrder(TreeNode root) {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    Queue&lt;TreeNode&gt; queue = new();\n    queue.Enqueue(root);\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    List&lt;int&gt; list = [];\n    while (queue.Count != 0) {\n        TreeNode node = queue.Dequeue(); // \u961f\u5217\u51fa\u961f\n        list.Add(node.val!.Value);       // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left != null)\n            queue.Enqueue(node.left);    // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if (node.right != null)\n            queue.Enqueue(node.right);   // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.go<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfunc levelOrder(root *TreeNode) []any {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    queue := list.New()\n    queue.PushBack(root)\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5207\u7247\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    nums := make([]any, 0)\n    for queue.Len() &gt; 0 {\n        // \u961f\u5217\u51fa\u961f\n        node := queue.Remove(queue.Front()).(*TreeNode)\n        // \u4fdd\u5b58\u8282\u70b9\u503c\n        nums = append(nums, node.Val)\n        if node.Left != nil {\n            // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n            queue.PushBack(node.Left)\n        }\n        if node.Right != nil {\n            // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n            queue.PushBack(node.Right)\n        }\n    }\n    return nums\n}\n</code></pre> binary_tree_bfs.swift<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfunc levelOrder(root: TreeNode) -&gt; [Int] {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    var queue: [TreeNode] = [root]\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    var list: [Int] = []\n    while !queue.isEmpty {\n        let node = queue.removeFirst() // \u961f\u5217\u51fa\u961f\n        list.append(node.val) // \u4fdd\u5b58\u8282\u70b9\u503c\n        if let left = node.left {\n            queue.append(left) // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        }\n        if let right = node.right {\n            queue.append(right) // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n        }\n    }\n    return list\n}\n</code></pre> binary_tree_bfs.js<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfunction levelOrder(root) {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    const queue = [root];\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    const list = [];\n    while (queue.length) {\n        let node = queue.shift(); // \u961f\u5217\u51fa\u961f\n        list.push(node.val); // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left) queue.push(node.left); // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if (node.right) queue.push(node.right); // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.ts<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfunction levelOrder(root: TreeNode | null): number[] {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    const queue = [root];\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    const list: number[] = [];\n    while (queue.length) {\n        let node = queue.shift() as TreeNode; // \u961f\u5217\u51fa\u961f\n        list.push(node.val); // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left) {\n            queue.push(node.left); // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        }\n        if (node.right) {\n            queue.push(node.right); // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n        }\n    }\n    return list;\n}\n</code></pre> binary_tree_bfs.dart<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nList&lt;int&gt; levelOrder(TreeNode? root) {\n  // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n  Queue&lt;TreeNode?&gt; queue = Queue();\n  queue.add(root);\n  // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n  List&lt;int&gt; res = [];\n  while (queue.isNotEmpty) {\n    TreeNode? node = queue.removeFirst(); // \u961f\u5217\u51fa\u961f\n    res.add(node!.val); // \u4fdd\u5b58\u8282\u70b9\u503c\n    if (node.left != null) queue.add(node.left); // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n    if (node.right != null) queue.add(node.right); // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n  }\n  return res;\n}\n</code></pre> binary_tree_bfs.rs<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfn level_order(root: &amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    let mut que = VecDeque::new();\n    que.push_back(root.clone());\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    let mut vec = Vec::new();\n\n    while let Some(node) = que.pop_front() {\n        // \u961f\u5217\u51fa\u961f\n        vec.push(node.borrow().val); // \u4fdd\u5b58\u8282\u70b9\u503c\n        if let Some(left) = node.borrow().left.as_ref() {\n            que.push_back(left.clone()); // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        }\n        if let Some(right) = node.borrow().right.as_ref() {\n            que.push_back(right.clone()); // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n        };\n    }\n    vec\n}\n</code></pre> binary_tree_bfs.c<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nint *levelOrder(TreeNode *root, int *size) {\n    /* \u8f85\u52a9\u961f\u5217 */\n    int front, rear;\n    int index, *arr;\n    TreeNode *node;\n    TreeNode **queue;\n\n    /* \u8f85\u52a9\u961f\u5217 */\n    queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE);\n    // \u961f\u5217\u6307\u9488\n    front = 0, rear = 0;\n    // \u52a0\u5165\u6839\u8282\u70b9\n    queue[rear++] = root;\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    /* \u8f85\u52a9\u6570\u7ec4 */\n    arr = (int *)malloc(sizeof(int) * MAX_SIZE);\n    // \u6570\u7ec4\u6307\u9488\n    index = 0;\n    while (front &lt; rear) {\n        // \u961f\u5217\u51fa\u961f\n        node = queue[front++];\n        // \u4fdd\u5b58\u8282\u70b9\u503c\n        arr[index++] = node-&gt;val;\n        if (node-&gt;left != NULL) {\n            // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n            queue[rear++] = node-&gt;left;\n        }\n        if (node-&gt;right != NULL) {\n            // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n            queue[rear++] = node-&gt;right;\n        }\n    }\n    // \u66f4\u65b0\u6570\u7ec4\u957f\u5ea6\u7684\u503c\n    *size = index;\n    arr = realloc(arr, sizeof(int) * (*size));\n\n    // \u91ca\u653e\u8f85\u52a9\u6570\u7ec4\u7a7a\u95f4\n    free(queue);\n    return arr;\n}\n</code></pre> binary_tree_bfs.kt<pre><code>/* \u5c42\u5e8f\u904d\u5386 */\nfun levelOrder(root: TreeNode?): MutableList&lt;Int&gt; {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    val queue = LinkedList&lt;TreeNode?&gt;()\n    queue.add(root)\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    val list = mutableListOf&lt;Int&gt;()\n    while (queue.isNotEmpty()) {\n        val node = queue.poll()      // \u961f\u5217\u51fa\u961f\n        list.add(node?._val!!)       // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left != null)\n            queue.offer(node.left)   // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        if (node.right != null)\n            queue.offer(node.right)  // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n    }\n    return list\n}\n</code></pre> binary_tree_bfs.rb<pre><code>### \u5c42\u5e8f\u904d\u5386 ###\ndef level_order(root)\n  # \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n  queue = [root]\n  # \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n  res = []\n  while !queue.empty?\n    node = queue.shift # \u961f\u5217\u51fa\u961f\n    res &lt;&lt; node.val # \u4fdd\u5b58\u8282\u70b9\u503c\n    queue &lt;&lt; node.left unless node.left.nil? # \u5de6\u5b50\u8282\u70b9\u5165\u961f\n    queue &lt;&lt; node.right unless node.right.nil? # \u53f3\u5b50\u8282\u70b9\u5165\u961f\n  end\n  res\nend\n</code></pre> binary_tree_bfs.zig<pre><code>// \u5c42\u5e8f\u904d\u5386\nfn levelOrder(comptime T: type, mem_allocator: std.mem.Allocator, root: *inc.TreeNode(T)) !std.ArrayList(T) {\n    // \u521d\u59cb\u5316\u961f\u5217\uff0c\u52a0\u5165\u6839\u8282\u70b9\n    const L = std.TailQueue(*inc.TreeNode(T));\n    var queue = L{};\n    var root_node = try mem_allocator.create(L.Node);\n    root_node.data = root;\n    queue.append(root_node); \n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u904d\u5386\u5e8f\u5217\n    var list = std.ArrayList(T).init(std.heap.page_allocator);\n    while (queue.len &gt; 0) {\n        var queue_node = queue.popFirst().?;    // \u961f\u5217\u51fa\u961f\n        var node = queue_node.data;\n        try list.append(node.val);              // \u4fdd\u5b58\u8282\u70b9\u503c\n        if (node.left != null) {\n            var tmp_node = try mem_allocator.create(L.Node);\n            tmp_node.data = node.left.?;\n            queue.append(tmp_node);             // \u5de6\u5b50\u8282\u70b9\u5165\u961f\n        }\n        if (node.right != null) {\n            var tmp_node = try mem_allocator.create(L.Node);\n            tmp_node.data = node.right.?;\n            queue.append(tmp_node);             // \u53f3\u5b50\u8282\u70b9\u5165\u961f\n        }        \n    }\n    return list;\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p>"},{"location":"chapter_tree/binary_tree_traversal/#2-complexity-analysis","title":"2. \u00a0 Complexity analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, using \\(O(n)\\) time, where \\(n\\) is the number of nodes.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., a full binary tree, before traversing to the lowest level, the queue can contain at most \\((n + 1) / 2\\) nodes at the same time, occupying \\(O(n)\\) space.</li> </ul>"},{"location":"chapter_tree/binary_tree_traversal/#722-preorder-inorder-and-postorder-traversal","title":"7.2.2 \u00a0 Preorder, inorder, and postorder traversal","text":"<p>Correspondingly, preorder, inorder, and postorder traversal all belong to depth-first traversal, also known as depth-first search (DFS), which embodies a \"proceed to the end first, then backtrack and continue\" traversal method.</p> <p>Figure 7-10 shows the working principle of performing a depth-first traversal on a binary tree. Depth-first traversal is like walking around the perimeter of the entire binary tree, encountering three positions at each node, corresponding to preorder traversal, inorder traversal, and postorder traversal.</p> <p></p> <p> Figure 7-10 \u00a0 Preorder, inorder, and postorder traversal of a binary search tree </p>"},{"location":"chapter_tree/binary_tree_traversal/#1-code-implementation_1","title":"1. \u00a0 Code implementation","text":"<p>Depth-first search is usually implemented based on recursion:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree_dfs.py<pre><code>def pre_order(root: TreeNode | None):\n    \"\"\"\u524d\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    res.append(root.val)\n    pre_order(root=root.left)\n    pre_order(root=root.right)\n\ndef in_order(root: TreeNode | None):\n    \"\"\"\u4e2d\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    in_order(root=root.left)\n    res.append(root.val)\n    in_order(root=root.right)\n\ndef post_order(root: TreeNode | None):\n    \"\"\"\u540e\u5e8f\u904d\u5386\"\"\"\n    if root is None:\n        return\n    # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    post_order(root=root.left)\n    post_order(root=root.right)\n    res.append(root.val)\n</code></pre> binary_tree_dfs.cpp<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nvoid preOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    vec.push_back(root-&gt;val);\n    preOrder(root-&gt;left);\n    preOrder(root-&gt;right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nvoid inOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root-&gt;left);\n    vec.push_back(root-&gt;val);\n    inOrder(root-&gt;right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nvoid postOrder(TreeNode *root) {\n    if (root == nullptr)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    vec.push_back(root-&gt;val);\n}\n</code></pre> binary_tree_dfs.java<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nvoid preOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.add(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nvoid inOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root.left);\n    list.add(root.val);\n    inOrder(root.right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nvoid postOrder(TreeNode root) {\n    if (root == null)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root.left);\n    postOrder(root.right);\n    list.add(root.val);\n}\n</code></pre> binary_tree_dfs.cs<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nvoid PreOrder(TreeNode? root) {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.Add(root.val!.Value);\n    PreOrder(root.left);\n    PreOrder(root.right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nvoid InOrder(TreeNode? root) {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    InOrder(root.left);\n    list.Add(root.val!.Value);\n    InOrder(root.right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nvoid PostOrder(TreeNode? root) {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    PostOrder(root.left);\n    PostOrder(root.right);\n    list.Add(root.val!.Value);\n}\n</code></pre> binary_tree_dfs.go<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfunc preOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    nums = append(nums, node.Val)\n    preOrder(node.Left)\n    preOrder(node.Right)\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfunc inOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(node.Left)\n    nums = append(nums, node.Val)\n    inOrder(node.Right)\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfunc postOrder(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(node.Left)\n    postOrder(node.Right)\n    nums = append(nums, node.Val)\n}\n</code></pre> binary_tree_dfs.swift<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfunc preOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.append(root.val)\n    preOrder(root: root.left)\n    preOrder(root: root.right)\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfunc inOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root: root.left)\n    list.append(root.val)\n    inOrder(root: root.right)\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfunc postOrder(root: TreeNode?) {\n    guard let root = root else {\n        return\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root: root.left)\n    postOrder(root: root.right)\n    list.append(root.val)\n}\n</code></pre> binary_tree_dfs.js<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfunction preOrder(root) {\n    if (root === null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.push(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfunction inOrder(root) {\n    if (root === null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root.left);\n    list.push(root.val);\n    inOrder(root.right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfunction postOrder(root) {\n    if (root === null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root.left);\n    postOrder(root.right);\n    list.push(root.val);\n}\n</code></pre> binary_tree_dfs.ts<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfunction preOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.push(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfunction inOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root.left);\n    list.push(root.val);\n    inOrder(root.right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfunction postOrder(root: TreeNode | null): void {\n    if (root === null) {\n        return;\n    }\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root.left);\n    postOrder(root.right);\n    list.push(root.val);\n}\n</code></pre> binary_tree_dfs.dart<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nvoid preOrder(TreeNode? node) {\n  if (node == null) return;\n  // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n  list.add(node.val);\n  preOrder(node.left);\n  preOrder(node.right);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nvoid inOrder(TreeNode? node) {\n  if (node == null) return;\n  // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n  inOrder(node.left);\n  list.add(node.val);\n  inOrder(node.right);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nvoid postOrder(TreeNode? node) {\n  if (node == null) return;\n  // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n  postOrder(node.left);\n  postOrder(node.right);\n  list.add(node.val);\n}\n</code></pre> binary_tree_dfs.rs<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfn pre_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    if let Some(node) = root {\n        // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n        result.push(node.borrow().val);\n        result.extend(pre_order(node.borrow().left.as_ref()));\n        result.extend(pre_order(node.borrow().right.as_ref()));\n    }\n    result\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfn in_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    if let Some(node) = root {\n        // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n        result.extend(in_order(node.borrow().left.as_ref()));\n        result.push(node.borrow().val);\n        result.extend(in_order(node.borrow().right.as_ref()));\n    }\n    result\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfn post_order(root: Option&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut result = vec![];\n\n    if let Some(node) = root {\n        // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n        result.extend(post_order(node.borrow().left.as_ref()));\n        result.extend(post_order(node.borrow().right.as_ref()));\n        result.push(node.borrow().val);\n    }\n    result\n}\n</code></pre> binary_tree_dfs.c<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nvoid preOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    arr[(*size)++] = root-&gt;val;\n    preOrder(root-&gt;left, size);\n    preOrder(root-&gt;right, size);\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nvoid inOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root-&gt;left, size);\n    arr[(*size)++] = root-&gt;val;\n    inOrder(root-&gt;right, size);\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nvoid postOrder(TreeNode *root, int *size) {\n    if (root == NULL)\n        return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root-&gt;left, size);\n    postOrder(root-&gt;right, size);\n    arr[(*size)++] = root-&gt;val;\n}\n</code></pre> binary_tree_dfs.kt<pre><code>/* \u524d\u5e8f\u904d\u5386 */\nfun preOrder(root: TreeNode?) {\n    if (root == null) return\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    list.add(root._val)\n    preOrder(root.left)\n    preOrder(root.right)\n}\n\n/* \u4e2d\u5e8f\u904d\u5386 */\nfun inOrder(root: TreeNode?) {\n    if (root == null) return\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    inOrder(root.left)\n    list.add(root._val)\n    inOrder(root.right)\n}\n\n/* \u540e\u5e8f\u904d\u5386 */\nfun postOrder(root: TreeNode?) {\n    if (root == null) return\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    postOrder(root.left)\n    postOrder(root.right)\n    list.add(root._val)\n}\n</code></pre> binary_tree_dfs.rb<pre><code>### \u524d\u5e8f\u904d\u5386 ###\ndef pre_order(root)\n  return if root.nil?\n\n  # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n  $res &lt;&lt; root.val\n  pre_order(root.left)\n  pre_order(root.right)\nend\n\n### \u4e2d\u5e8f\u904d\u5386 ###\ndef in_order(root)\n  return if root.nil?\n\n  # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n  in_order(root.left)\n  $res &lt;&lt; root.val\n  in_order(root.right)\nend\n\n### \u540e\u5e8f\u904d\u5386 ###\ndef post_order(root)\n  return if root.nil?\n\n  # \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n  post_order(root.left)\n  post_order(root.right)\n  $res &lt;&lt; root.val\nend\n</code></pre> binary_tree_dfs.zig<pre><code>// \u524d\u5e8f\u904d\u5386\nfn preOrder(comptime T: type, root: ?*inc.TreeNode(T)) !void {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u6839\u8282\u70b9 -&gt; \u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811\n    try list.append(root.?.val);\n    try preOrder(T, root.?.left);\n    try preOrder(T, root.?.right);\n}\n\n// \u4e2d\u5e8f\u904d\u5386\nfn inOrder(comptime T: type, root: ?*inc.TreeNode(T)) !void {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u6839\u8282\u70b9 -&gt; \u53f3\u5b50\u6811\n    try inOrder(T, root.?.left);\n    try list.append(root.?.val);\n    try inOrder(T, root.?.right);\n}\n\n// \u540e\u5e8f\u904d\u5386\nfn postOrder(comptime T: type, root: ?*inc.TreeNode(T)) !void {\n    if (root == null) return;\n    // \u8bbf\u95ee\u4f18\u5148\u7ea7\uff1a\u5de6\u5b50\u6811 -&gt; \u53f3\u5b50\u6811 -&gt; \u6839\u8282\u70b9\n    try postOrder(T, root.?.left);\n    try postOrder(T, root.?.right);\n    try list.append(root.?.val);\n}\n</code></pre> Code Visualization <p> Full Screen &gt;</p> <p>Tip</p> <p>Depth-first search can also be implemented based on iteration, interested readers can study this on their own.</p> <p>Figure 7-11 shows the recursive process of preorder traversal of a binary tree, which can be divided into two opposite parts: \"recursion\" and \"return\".</p> <ol> <li>\"Recursion\" means starting a new method, the program accesses the next node in this process.</li> <li>\"Return\" means the function returns, indicating the current node has been fully accessed.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p> Figure 7-11 \u00a0 The recursive process of preorder traversal </p>"},{"location":"chapter_tree/binary_tree_traversal/#2-complexity-analysis_1","title":"2. \u00a0 Complexity analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, using \\(O(n)\\) time.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., the tree degrades into a linked list, the recursion depth reaches \\(n\\), the system occupies \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_tree/summary/","title":"7.6 \u00a0 Summary","text":""},{"location":"chapter_tree/summary/#1-key-review","title":"1. \u00a0 Key review","text":"<ul> <li>A binary tree is a non-linear data structure that reflects the \"divide and conquer\" logic of splitting one into two. Each binary tree node contains a value and two pointers, which point to its left and right child nodes, respectively.</li> <li>For a node in a binary tree, the tree formed by its left (right) child node and all nodes under it is called the node's left (right) subtree.</li> <li>Related terminology of binary trees includes root node, leaf node, level, degree, edge, height, and depth, among others.</li> <li>The operations of initializing a binary tree, inserting nodes, and removing nodes are similar to those of linked list operations.</li> <li>Common types of binary trees include perfect binary trees, complete binary trees, full binary trees, and balanced binary trees. The perfect binary tree represents the ideal state, while the linked list is the worst state after degradation.</li> <li>A binary tree can be represented using an array by arranging the node values and empty slots in a level-order traversal sequence and implementing pointers based on the index mapping relationship between parent nodes and child nodes.</li> <li>The level-order traversal of a binary tree is a breadth-first search method, which reflects a layer-by-layer traversal manner of \"expanding circle by circle.\" It is usually implemented using a queue.</li> <li>Pre-order, in-order, and post-order traversals are all depth-first search methods, reflecting the traversal manner of \"going to the end first, then backtracking to continue.\" They are usually implemented using recursion.</li> <li>A binary search tree is an efficient data structure for element searching, with the time complexity of search, insert, and remove operations all being \\(O(\\log n)\\). When a binary search tree degrades into a linked list, these time complexities deteriorate to \\(O(n)\\).</li> <li>An AVL tree, also known as a balanced binary search tree, ensures that the tree remains balanced after continuous node insertions and removals through rotation operations.</li> <li>Rotation operations in an AVL tree include right rotation, left rotation, right-then-left rotation, and left-then-right rotation. After inserting or removing nodes, an AVL tree performs rotation operations from bottom to top to rebalance the tree.</li> </ul>"},{"location":"chapter_tree/summary/#2-q-a","title":"2. \u00a0 Q &amp; A","text":"<p>Q: For a binary tree with only one node, are both the height of the tree and the depth of the root node \\(0\\)?</p> <p>Yes, because height and depth are typically defined as \"the number of edges passed.\"</p> <p>Q: The insertion and removal in a binary tree are generally completed by a set of operations. What does \"a set of operations\" refer to here? Can it be understood as the release of resources of the child nodes?</p> <p>Taking the binary search tree as an example, the operation of removing a node needs to be handled in three different scenarios, each requiring multiple steps of node operations.</p> <p>Q: Why are there three sequences: pre-order, in-order, and post-order for DFS traversal of a binary tree, and what are their uses?</p> <p>Similar to sequential and reverse traversal of arrays, pre-order, in-order, and post-order traversals are three methods of traversing a binary tree, allowing us to obtain a traversal result in a specific order. For example, in a binary search tree, since the node sizes satisfy <code>left child node value &lt; root node value &lt; right child node value</code>, we can obtain an ordered node sequence by traversing the tree in the \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\" priority.</p> <p>Q: In a right rotation operation that deals with the relationship between the imbalance nodes <code>node</code>, <code>child</code>, <code>grand_child</code>, isn't the connection between <code>node</code> and its parent node and the original link of <code>node</code> lost after the right rotation?</p> <p>We need to view this problem from a recursive perspective. The <code>right_rotate(root)</code> operation passes the root node of the subtree and eventually returns the root node of the rotated subtree with <code>return child</code>. The connection between the subtree's root node and its parent node is established after this function returns, which is outside the scope of the right rotation operation's maintenance.</p> <p>Q: In C++, functions are divided into <code>private</code> and <code>public</code> sections. What considerations are there for this? Why are the <code>height()</code> function and the <code>updateHeight()</code> function placed in <code>public</code> and <code>private</code>, respectively?</p> <p>It depends on the scope of the method's use. If a method is only used within the class, then it is designed to be <code>private</code>. For example, it makes no sense for users to call <code>updateHeight()</code> on their own, as it is just a step in the insertion or removal operations. However, <code>height()</code> is for accessing node height, similar to <code>vector.size()</code>, thus it is set to <code>public</code> for use.</p> <p>Q: How do you build a binary search tree from a set of input data? Is the choice of root node very important?</p> <p>Yes, the method for building the tree is provided in the <code>build_tree()</code> method in the binary search tree code. As for the choice of the root node, we usually sort the input data and then select the middle element as the root node, recursively building the left and right subtrees. This approach maximizes the balance of the tree.</p> <p>Q: In Java, do you always have to use the <code>equals()</code> method for string comparison?</p> <p>In Java, for primitive data types, <code>==</code> is used to compare whether the values of two variables are equal. For reference types, the working principles of the two symbols are different.</p> <ul> <li><code>==</code>: Used to compare whether two variables point to the same object, i.e., whether their positions in memory are the same.</li> <li><code>equals()</code>: Used to compare whether the values of two objects are equal.</li> </ul> <p>Therefore, to compare values, we should use <code>equals()</code>. However, strings initialized with <code>String a = \"hi\"; String b = \"hi\";</code> are stored in the string constant pool and point to the same object, so <code>a == b</code> can also be used to compare the contents of two strings.</p> <p>Q: Before reaching the bottom level, is the number of nodes in the queue \\(2^h\\) in breadth-first traversal?</p> <p>Yes, for example, a full binary tree with height \\(h = 2\\) has a total of \\(n = 7\\) nodes, then the bottom level has \\(4 = 2^h = (n + 1) / 2\\) nodes.</p>"}]}